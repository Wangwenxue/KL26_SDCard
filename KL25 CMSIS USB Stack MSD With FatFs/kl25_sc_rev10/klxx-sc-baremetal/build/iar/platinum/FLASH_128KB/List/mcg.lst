###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        30/Nov/2015  21:44:53
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\mcg\mcg.c
#    Command line =  
#        "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\mcg\mcg.c" -D IAR -D
#        FREEDOM -lCN "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD
#        With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\"
#        -lB "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\"
#        -o "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\Obj\"
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\projects\platinum\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\common\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\cpu\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\platforms\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\" -Oh
#    List file    =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\mcg.lst
#    Object file  =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\Obj\mcg.o
#
###############################################################################

D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\mcg\mcg.c
      1          /*
      2           * File:    mcg.c
      3           *
      4           * MCG drivers for Freescale Kinetis L - series devices
      5           * Notes:
      6           * Assumes the MCG mode is in the default FEI mode out of reset
      7           */
      8          
      9          #include "common.h"
     10          #include "mcg.h"
     11          
     12          
     13          // global variables
     14          extern int core_clk_khz;
     15          
     16          

   \                                 In section .bss, align 1
     17          char drs_val, dmx32_val;
   \                     drs_val:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     dmx32_val:
   \   00000000                      DS8 1
     18          
     19          
     20          
     21          
     22          
     23          /*********************************************************************************************/
     24          /* Functon name : pll_init
     25           *
     26           * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
     27           *
     28           * This function initializess PLL0. Either OSC0 is selected for the
     29           * reference clock source. The oscillators can be configured to use a crystal or take in an
     30           * external square wave clock.
     31           * Using the function parameter names the PLL frequency is calculated as follows:
     32           * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
     33           * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
     34           * All parameters must be provided, for example crystal_val must be provided even if the
     35           * oscillator associated with that parameter is already initialized.
     36           * The various passed parameters are checked to ensure they are within the allowed range. If any
     37           * of these checks fail the driver will exit and return a fail/error code. An error code will
     38           * also be returned if any error occurs during the PLL initialization sequence. Refer to the
     39           * readme file in the mcg driver directory for a list of all these codes.
     40           *
     41           * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
     42           *                           wave clock source
     43           *             hgo_val     - selects whether low power or high gain mode is selected
     44           *                           for the crystal oscillator. This has no meaning if an
     45           *                           external clock is used.
     46           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
     47           *             prdiv_val   - value to divide the external clock source by to create the desired
     48           *                           PLL reference clock frequency
     49           *             vdiv_val    - value to multiply the PLL reference clock frequency by
     50           *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
     51           *                              to provide the MCGOUT clock for the system.
     52           *
     53           * Return value : PLL frequency (Hz) or error code
     54           */
     55          

   \                                 In section .text, align 2, keep-with-next
     56          int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val, signed char vdiv_val, unsigned char mcgout_select)
     57          {
   \                     pll_init: (+1)
   \   00000000   0xB5FD             PUSH     {R0,R2-R7,LR}
   \   00000002   0x000F             MOVS     R7,R1
     58            unsigned char frdiv_val;
     59            unsigned char temp_reg;
     60            unsigned char prdiv, vdiv;
     61            short i;
     62            int ref_freq;
     63            int pll_freq;
     64          
     65            // check if in FEI mode
     66            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
     67                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
     68                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000004   0x....             LDR      R5,??DataTable0  ;; 0x40064000
   \   00000006   0x2603             MOVS     R6,#+3
   \   00000008   0x79A8             LDRB     R0,[R5, #+6]
   \   0000000A   0x0880             LSRS     R0,R0,#+2
   \   0000000C   0x4030             ANDS     R0,R0,R6
   \   0000000E   0xD105             BNE      ??pll_init_0
   \   00000010   0x79A8             LDRB     R0,[R5, #+6]
   \   00000012   0x06C0             LSLS     R0,R0,#+27
   \   00000014   0xD502             BPL      ??pll_init_0
   \   00000016   0x79A8             LDRB     R0,[R5, #+6]
   \   00000018   0x0680             LSLS     R0,R0,#+26
   \   0000001A   0xD501             BPL      ??pll_init_1
     69            {
     70              return 0x1;                                                     // return error code
   \                     ??pll_init_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE0E3             B        ??pll_init_2
     71            }
     72          
     73            // check external frequency is less than the maximum frequency
     74            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??pll_init_1: (+1)
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x....             LDR      R1,??DataTable0_1  ;; 0x2faf081
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xDB01             BLT      ??pll_init_3
   \   00000028   0x2021             MOVS     R0,#+33
   \   0000002A   0xE0DD             B        ??pll_init_2
     75          
     76            // check crystal frequency is within spec. if crystal osc is being used as PLL ref
     77            if (erefs_val)
   \                     ??pll_init_3: (+1)
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD006             BEQ      ??pll_init_4
     78            {
     79              if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of the available crystal options is not available
   \   00000030   0x....             LDR      R1,??DataTable0_2  ;; 0xffd23940
   \   00000032   0x1840             ADDS     R0,R0,R1
   \   00000034   0x....             LDR      R1,??DataTable0_3  ;; 0x1ba8141
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD301             BCC      ??pll_init_4
   \   0000003A   0x2022             MOVS     R0,#+34
   \   0000003C   0xE0D4             B        ??pll_init_2
     80            }
     81          
     82            // make sure HGO will never be greater than 1. Could return an error instead if desired.
     83            if (hgo_val > 0)
   \                     ??pll_init_4: (+1)
   \   0000003E   0x2F00             CMP      R7,#+0
   \   00000040   0xD000             BEQ      ??pll_init_5
     84            {
     85              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000042   0x2701             MOVS     R7,#+1
     86            }
     87          
     88            // Check PLL divider settings are within spec.
     89            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??pll_init_5: (+1)
   \   00000044   0x4669             MOV      R1,SP
   \   00000046   0x1E58             SUBS     R0,R3,#+1
   \   00000048   0x2819             CMP      R0,#+25
   \   0000004A   0xD301             BCC      ??pll_init_6
   \   0000004C   0x2041             MOVS     R0,#+65
   \   0000004E   0xE0CB             B        ??pll_init_2
   \                     ??pll_init_6: (+1)
   \   00000050   0x2020             MOVS     R0,#+32
   \   00000052   0x560C             LDRSB    R4,[R1, R0]
     90            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x3818             SUBS     R0,R0,#+24
   \   00000058   0x281B             CMP      R0,#+27
   \   0000005A   0xD301             BCC      ??pll_init_7
   \   0000005C   0x2042             MOVS     R0,#+66
   \   0000005E   0xE0C3             B        ??pll_init_2
     91          
     92            // Check PLL reference clock frequency is within spec.
     93            ref_freq = crystal_val / prdiv_val;
     94            if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
   \                     ??pll_init_7: (+1)
   \   00000060   0x9800             LDR      R0,[SP, #+0]
   \   00000062   0x4619             MOV      R1,R3
   \   00000064   0x.... 0x....      BL       __aeabi_idiv
   \   00000068   0x....             LDR      R1,??DataTable0_4  ;; 0xffe17b80
   \   0000006A   0x1841             ADDS     R1,R0,R1
   \   0000006C   0x....             LDR      R2,??DataTable0_5  ;; 0x1e8481
   \   0000006E   0x4291             CMP      R1,R2
   \   00000070   0xD301             BCC      ??pll_init_8
   \   00000072   0x2043             MOVS     R0,#+67
   \   00000074   0xE0B8             B        ??pll_init_2
     95          
     96            // Check PLL output frequency is within spec.
     97            pll_freq = (crystal_val / prdiv_val) * vdiv_val;
     98            if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
   \                     ??pll_init_8: (+1)
   \   00000076   0x4360             MULS     R0,R4,R0
   \   00000078   0x....             LDR      R1,??DataTable1  ;; 0xfd239400
   \   0000007A   0x1840             ADDS     R0,R0,R1
   \   0000007C   0x....             LDR      R1,??DataTable1_1  ;; 0x3197501
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD301             BCC      ??pll_init_9
   \   00000082   0x2045             MOVS     R0,#+69
   \   00000084   0xE0B0             B        ??pll_init_2
     99          
    100            // configure the MCG_C2 register
    101            // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
    102            // it still needs to be set correctly even if the oscillator is not being used
    103                
    104            temp_reg = MCG_C2;
   \                     ??pll_init_9: (+1)
   \   00000086   0x7869             LDRB     R1,[R5, #+1]
    105            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   00000088   0x20C3             MOVS     R0,#+195
   \   0000008A   0x4008             ANDS     R0,R0,R1
    106              
    107            if (crystal_val <= 8000000)
   \   0000008C   0x4669             MOV      R1,SP
   \   0000008E   0x7909             LDRB     R1,[R1, #+4]
   \   00000090   0x0089             LSLS     R1,R1,#+2
   \   00000092   0x00FA             LSLS     R2,R7,#+3
   \   00000094   0x9B00             LDR      R3,[SP, #+0]
   \   00000096   0x....             LDR      R7,??DataTable1_2  ;; 0x7a1201
   \   00000098   0x42BB             CMP      R3,R7
   \   0000009A   0xDA02             BGE      ??pll_init_10
    108            {
    109              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   0000009C   0x4311             ORRS     R1,R1,R2
   \   0000009E   0x2210             MOVS     R2,#+16
   \   000000A0   0xE001             B        ??pll_init_11
    110            }
    111            else
    112            {
    113              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??pll_init_10: (+1)
   \   000000A2   0x4311             ORRS     R1,R1,R2
   \   000000A4   0x2220             MOVS     R2,#+32
   \                     ??pll_init_11: (+1)
   \   000000A6   0x430A             ORRS     R2,R2,R1
   \   000000A8   0x4302             ORRS     R2,R2,R0
    114            }
    115            MCG_C2 = temp_reg;
   \   000000AA   0x706A             STRB     R2,[R5, #+1]
    116            
    117            // determine FRDIV based on reference clock frequency
    118            // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
    119            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x....             LDR      R1,??DataTable1_3  ;; 0x1312d1
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xDA01             BGE      ??pll_init_12
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xE014             B        ??pll_init_13
    120            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??pll_init_12: (+1)
   \   000000B8   0x....             LDR      R1,??DataTable1_4  ;; 0x2625a1
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xDA01             BGE      ??pll_init_14
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE00F             B        ??pll_init_13
    121            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??pll_init_14: (+1)
   \   000000C2   0x....             LDR      R1,??DataTable2  ;; 0x4c4b41
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xDA01             BGE      ??pll_init_15
   \   000000C8   0x2002             MOVS     R0,#+2
   \   000000CA   0xE00A             B        ??pll_init_13
    122            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??pll_init_15: (+1)
   \   000000CC   0x....             LDR      R1,??DataTable2_1  ;; 0x989681
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xDA01             BGE      ??pll_init_16
   \   000000D2   0x2003             MOVS     R0,#+3
   \   000000D4   0xE005             B        ??pll_init_13
    123            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??pll_init_16: (+1)
   \   000000D6   0x....             LDR      R1,??DataTable2_2  ;; 0x1312d01
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xDA01             BGE      ??pll_init_17
   \   000000DC   0x2004             MOVS     R0,#+4
   \   000000DE   0xE000             B        ??pll_init_13
    124            else {frdiv_val = 5;}
   \                     ??pll_init_17: (+1)
   \   000000E0   0x2005             MOVS     R0,#+5
    125          
    126            // Select external oscillator and Reference Divider and clear IREFS to start ext osc
    127            // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
    128            // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
    129            temp_reg = MCG_C1;
   \                     ??pll_init_13: (+1)
   \   000000E2   0x7829             LDRB     R1,[R5, #+0]
    130            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
    131            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
    132            MCG_C1 = temp_reg;
   \   000000E4   0x2203             MOVS     R2,#+3
   \   000000E6   0x400A             ANDS     R2,R2,R1
   \   000000E8   0x00C0             LSLS     R0,R0,#+3
   \   000000EA   0x4310             ORRS     R0,R0,R2
   \   000000EC   0x2180             MOVS     R1,#+128
   \   000000EE   0x4301             ORRS     R1,R1,R0
   \   000000F0   0x7029             STRB     R1,[R5, #+0]
    133          
    134            // if the external oscillator is used need to wait for OSCINIT to set
    135            if (erefs_val)
   \   000000F2   0x4668             MOV      R0,SP
   \   000000F4   0x7900             LDRB     R0,[R0, #+4]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD00C             BEQ      ??pll_init_18
    136            {
    137              for (i = 0 ; i < 20000 ; i++)
   \   000000FA   0x....             LDR      R1,??DataTable2_3  ;; 0x4e20
   \   000000FC   0x2002             MOVS     R0,#+2
   \   000000FE   0x2302             MOVS     R3,#+2
    138              {
    139                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \                     ??pll_init_19: (+1)
   \   00000100   0x79AA             LDRB     R2,[R5, #+6]
   \   00000102   0x421A             TST      R2,R3
   \   00000104   0xD101             BNE      ??pll_init_20
    140              }
   \   00000106   0x1E49             SUBS     R1,R1,#+1
   \   00000108   0xD1FA             BNE      ??pll_init_19
    141            if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??pll_init_20: (+1)
   \   0000010A   0x79A9             LDRB     R1,[R5, #+6]
   \   0000010C   0x4201             TST      R1,R0
   \   0000010E   0xD101             BNE      ??pll_init_18
   \   00000110   0x2023             MOVS     R0,#+35
   \   00000112   0xE069             B        ??pll_init_2
    142            }
    143          
    144            // wait for Reference clock Status bit to clear
    145            for (i = 0 ; i < 2000 ; i++)
   \                     ??pll_init_18: (+1)
   \   00000114   0x20FA             MOVS     R0,#+250
   \   00000116   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000118   0x0001             MOVS     R1,R0
    146            {
    147              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \                     ??pll_init_21: (+1)
   \   0000011A   0x79AA             LDRB     R2,[R5, #+6]
   \   0000011C   0x06D2             LSLS     R2,R2,#+27
   \   0000011E   0xD501             BPL      ??pll_init_22
    148            }
   \   00000120   0x1E49             SUBS     R1,R1,#+1
   \   00000122   0xD1FA             BNE      ??pll_init_21
    149            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??pll_init_22: (+1)
   \   00000124   0x79A9             LDRB     R1,[R5, #+6]
   \   00000126   0x06C9             LSLS     R1,R1,#+27
   \   00000128   0xD501             BPL      ??pll_init_23
   \   0000012A   0x2011             MOVS     R0,#+17
   \   0000012C   0xE05C             B        ??pll_init_2
    150          
    151            // Wait for clock status bits to show clock source is ext ref clk
    152            for (i = 0 ; i < 2000 ; i++)
   \                     ??pll_init_23: (+1)
   \   0000012E   0x0001             MOVS     R1,R0
    153            {
    154              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \                     ??pll_init_24: (+1)
   \   00000130   0x79AA             LDRB     R2,[R5, #+6]
   \   00000132   0x0892             LSRS     R2,R2,#+2
   \   00000134   0x4032             ANDS     R2,R2,R6
   \   00000136   0x2A02             CMP      R2,#+2
   \   00000138   0xD001             BEQ      ??pll_init_25
    155            }
   \   0000013A   0x1E49             SUBS     R1,R1,#+1
   \   0000013C   0xD1F8             BNE      ??pll_init_24
    156            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??pll_init_25: (+1)
   \   0000013E   0x79A9             LDRB     R1,[R5, #+6]
   \   00000140   0x0889             LSRS     R1,R1,#+2
   \   00000142   0x4031             ANDS     R1,R1,R6
   \   00000144   0x2902             CMP      R1,#+2
   \   00000146   0xD001             BEQ      ??pll_init_26
   \   00000148   0x201A             MOVS     R0,#+26
   \   0000014A   0xE04D             B        ??pll_init_2
    157          
    158            // Now in FBE
    159            // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
    160            // It is enabled here but can be removed if this is not required.
    161            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??pll_init_26: (+1)
   \   0000014C   0x7969             LDRB     R1,[R5, #+5]
   \   0000014E   0x2220             MOVS     R2,#+32
   \   00000150   0x430A             ORRS     R2,R2,R1
   \   00000152   0x716A             STRB     R2,[R5, #+5]
    162            
    163            // Configure PLL
    164            // Configure MCG_C5
    165            // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.
    166            temp_reg = MCG_C5;
   \   00000154   0x792F             LDRB     R7,[R5, #+4]
    167            temp_reg &= ~MCG_C5_PRDIV0_MASK;
    168            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
    169            MCG_C5 = temp_reg;
   \   00000156   0x211F             MOVS     R1,#+31
   \   00000158   0x22E0             MOVS     R2,#+224
   \   0000015A   0x4017             ANDS     R7,R7,R2
   \   0000015C   0x46BC             MOV      R12,R7
   \   0000015E   0x466F             MOV      R7,SP
   \   00000160   0x2308             MOVS     R3,#+8
   \   00000162   0x56FB             LDRSB    R3,[R7, R3]
   \   00000164   0x1E5B             SUBS     R3,R3,#+1
   \   00000166   0x400B             ANDS     R3,R3,R1
   \   00000168   0x4667             MOV      R7,R12
   \   0000016A   0x433B             ORRS     R3,R3,R7
   \   0000016C   0x712B             STRB     R3,[R5, #+4]
    170          
    171            // Configure MCG_C6
    172            // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
    173            // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    174            temp_reg = MCG_C6; // store present C6 value
   \   0000016E   0x796F             LDRB     R7,[R5, #+5]
    175            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
    176            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
    177            MCG_C6 = temp_reg; // update MCG_C6
   \   00000170   0x2340             MOVS     R3,#+64
   \   00000172   0x403A             ANDS     R2,R2,R7
   \   00000174   0x3C18             SUBS     R4,R4,#+24
   \   00000176   0x400C             ANDS     R4,R4,R1
   \   00000178   0x4314             ORRS     R4,R4,R2
   \   0000017A   0x431C             ORRS     R4,R4,R3
   \   0000017C   0x716C             STRB     R4,[R5, #+5]
    178          
    179            // wait for PLLST status bit to set
    180            for (i = 0 ; i < 2000 ; i++)
   \   0000017E   0x0002             MOVS     R2,R0
    181            {
    182              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \                     ??pll_init_27: (+1)
   \   00000180   0x79AC             LDRB     R4,[R5, #+6]
   \   00000182   0x06A4             LSLS     R4,R4,#+26
   \   00000184   0xD401             BMI      ??pll_init_28
    183            }
   \   00000186   0x1E52             SUBS     R2,R2,#+1
   \   00000188   0xD1FA             BNE      ??pll_init_27
    184            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??pll_init_28: (+1)
   \   0000018A   0x79AA             LDRB     R2,[R5, #+6]
   \   0000018C   0x0692             LSLS     R2,R2,#+26
   \   0000018E   0xD401             BMI      ??pll_init_29
   \   00000190   0x2016             MOVS     R0,#+22
   \   00000192   0xE029             B        ??pll_init_2
    185          
    186            // Wait for LOCK bit to set
    187            for (i = 0 ; i < 4000 ; i++)
   \                     ??pll_init_29: (+1)
   \   00000194   0x0042             LSLS     R2,R0,#+1
    188            {
    189              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \                     ??pll_init_30: (+1)
   \   00000196   0x79AC             LDRB     R4,[R5, #+6]
   \   00000198   0x421C             TST      R4,R3
   \   0000019A   0xD101             BNE      ??pll_init_31
    190            }
   \   0000019C   0x1E52             SUBS     R2,R2,#+1
   \   0000019E   0xD1FA             BNE      ??pll_init_30
    191            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??pll_init_31: (+1)
   \   000001A0   0x79AA             LDRB     R2,[R5, #+6]
   \   000001A2   0x421A             TST      R2,R3
   \   000001A4   0xD101             BNE      ??pll_init_32
   \   000001A6   0x2044             MOVS     R0,#+68
   \   000001A8   0xE01E             B        ??pll_init_2
    192          
    193            // Use actual PLL settings to calculate PLL frequency
    194            prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
   \                     ??pll_init_32: (+1)
   \   000001AA   0x792A             LDRB     R2,[R5, #+4]
   \   000001AC   0x400A             ANDS     R2,R2,R1
   \   000001AE   0x1C52             ADDS     R2,R2,#+1
    195            vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
   \   000001B0   0x796B             LDRB     R3,[R5, #+5]
   \   000001B2   0x4019             ANDS     R1,R1,R3
   \   000001B4   0x3118             ADDS     R1,R1,#+24
   \   000001B6   0x000C             MOVS     R4,R1
    196          
    197            // now in PBE
    198          
    199            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
   \   000001B8   0x7829             LDRB     R1,[R5, #+0]
   \   000001BA   0x0689             LSLS     R1,R1,#+26
   \   000001BC   0x0E89             LSRS     R1,R1,#+26
   \   000001BE   0x7029             STRB     R1,[R5, #+0]
    200          
    201            // Wait for clock status bits to update
    202            for (i = 0 ; i < 2000 ; i++)
    203            {
    204              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
   \                     ??pll_init_33: (+1)
   \   000001C0   0x79A9             LDRB     R1,[R5, #+6]
   \   000001C2   0x0889             LSRS     R1,R1,#+2
   \   000001C4   0x4031             ANDS     R1,R1,R6
   \   000001C6   0x2903             CMP      R1,#+3
   \   000001C8   0xD001             BEQ      ??pll_init_34
    205            }
   \   000001CA   0x1E40             SUBS     R0,R0,#+1
   \   000001CC   0xD1F8             BNE      ??pll_init_33
    206            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not
   \                     ??pll_init_34: (+1)
   \   000001CE   0x79A8             LDRB     R0,[R5, #+6]
   \   000001D0   0x0880             LSRS     R0,R0,#+2
   \   000001D2   0x4006             ANDS     R6,R6,R0
   \   000001D4   0x2E03             CMP      R6,#+3
   \   000001D6   0xD001             BEQ      ??pll_init_35
   \   000001D8   0x201B             MOVS     R0,#+27
   \   000001DA   0xE005             B        ??pll_init_2
    207          
    208            // Now in PEE
    209            
    210            return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
   \                     ??pll_init_35: (+1)
   \   000001DC   0x9800             LDR      R0,[SP, #+0]
   \   000001DE   0xB2D1             UXTB     R1,R2
   \   000001E0   0x.... 0x....      BL       __aeabi_idiv
   \   000001E4   0xB2E4             UXTB     R4,R4
   \   000001E6   0x4360             MULS     R0,R4,R0
   \                     ??pll_init_2: (+1)
   \   000001E8   0xB003             ADD      SP,SP,#+12
   \   000001EA   0xBDF0             POP      {R4-R7,PC}       ;; return
    211          } // pll_init
    212          
    213          
    214          /*********************************************************************************************/
    215          /* Functon name : new_pll_freq
    216           *
    217           * Mode transition: Moves from PEE to PBE mode before changing PLL settings and moves back to PEE mode
    218           *
    219           * This function provides a safe means of updating the PLL configurations to ensure the system
    220           * does not lose the clock source or is over-clocked as the PLL frequency changes.
    221           * Using the function parameter names the PLL frequency is calculated as follows:
    222           * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
    223           * The various passed parameters are checked to ensure they are within the allowed range. If any
    224           * of these checks fail the driver will exit and return a fail/error code. An error code will
    225           * also be returned if any error occurs during the PLL initialization sequence. Refer to the
    226           * readme file in the mcg driver directory for a list of all these codes.
    227           * This function first moves the MCG to PBE mode to use the external reference clock to provide the
    228           * system clock. The PLL settings are then updated. Once the PLL has re-locked the MCG is moved back
    229           * to PEE to use the PLL as the system clock.
    230           * Only the PLL PRDIV0 and VDIV0 fields are changed.
    231           * 
    232           * Prerequisistes : The MCG must be in PEE mode before calling this routine. It is the responsibility
    233           * of the calling routine to ensure the SIM_CLKDIV1 system clock dividers and any peripheral clock
    234           * dividers are set correctly before or after calling this function to ensure the appropriate clocks
    235           * are kept within specification. You would typically change the divider values before calling this
    236           * routine.
    237           * 
    238           * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
    239           *                           wave clock source
    240           *             prdiv_val   - value to divide the external clock source by to create the desired
    241           *                           PLL reference clock frequency
    242           *             vdiv_val    - value to multiply the PLL reference clock frequency by
    243           *
    244           * Return value : PLL frequency (Hz) or error code
    245           */

   \                                 In section .text, align 2, keep-with-next
    246          int new_pll_freq(int crystal_val, signed char prdiv_val, signed char vdiv_val)
    247          {
   \                     new_pll_freq: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0x0014             MOVS     R4,R2
    248            unsigned char temp_reg;
    249            unsigned char prdiv, vdiv;
    250            short i;
    251            int ref_freq;
    252            int pll_freq;
    253          
    254            
    255            // Check MCG is in PEE mode
    256            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted PLL output
    257                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    258                (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selected PLL 
   \   00000004   0x....             LDR      R5,??DataTable4  ;; 0x40064000
   \   00000006   0x2603             MOVS     R6,#+3
   \   00000008   0x79A8             LDRB     R0,[R5, #+6]
   \   0000000A   0x0880             LSRS     R0,R0,#+2
   \   0000000C   0x4030             ANDS     R0,R0,R6
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD105             BNE      ??new_pll_freq_0
   \   00000012   0x79A8             LDRB     R0,[R5, #+6]
   \   00000014   0x06C0             LSLS     R0,R0,#+27
   \   00000016   0xD402             BMI      ??new_pll_freq_0
   \   00000018   0x79A8             LDRB     R0,[R5, #+6]
   \   0000001A   0x0680             LSLS     R0,R0,#+26
   \   0000001C   0xD401             BMI      ??new_pll_freq_1
    259            {
    260              return 0x8;                                                       // return error code
   \                     ??new_pll_freq_0: (+1)
   \   0000001E   0x2008             MOVS     R0,#+8
   \   00000020   0xBDF6             POP      {R1,R2,R4-R7,PC}
    261            } 
    262            
    263            // Check PLL divider settings are within spec.
    264            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??new_pll_freq_1: (+1)
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x5608             LDRSB    R0,[R1, R0]
   \   00000028   0x1E40             SUBS     R0,R0,#+1
   \   0000002A   0x2819             CMP      R0,#+25
   \   0000002C   0xD301             BCC      ??new_pll_freq_2
   \   0000002E   0x2041             MOVS     R0,#+65
   \   00000030   0xBDF6             POP      {R1,R2,R4-R7,PC}
    265            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
   \                     ??new_pll_freq_2: (+1)
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x3818             SUBS     R0,R0,#+24
   \   00000036   0x281B             CMP      R0,#+27
   \   00000038   0xD301             BCC      ??new_pll_freq_3
   \   0000003A   0x2042             MOVS     R0,#+66
   \   0000003C   0xBDF6             POP      {R1,R2,R4-R7,PC}
    266          
    267            // Check PLL reference clock frequency is within spec.
    268            ref_freq = crystal_val / prdiv_val;
    269            if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
   \                     ??new_pll_freq_3: (+1)
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x466A             MOV      R2,SP
   \   00000042   0x2104             MOVS     R1,#+4
   \   00000044   0x5651             LDRSB    R1,[R2, R1]
   \   00000046   0x.... 0x....      BL       __aeabi_idiv
   \   0000004A   0x....             LDR      R1,??DataTable4_1  ;; 0xffe17b80
   \   0000004C   0x1841             ADDS     R1,R0,R1
   \   0000004E   0x....             LDR      R2,??DataTable4_2  ;; 0x1e8481
   \   00000050   0x4291             CMP      R1,R2
   \   00000052   0xD301             BCC      ??new_pll_freq_4
   \   00000054   0x2043             MOVS     R0,#+67
   \   00000056   0xBDF6             POP      {R1,R2,R4-R7,PC}
    270          
    271            // Check PLL output frequency is within spec.
    272            pll_freq = (crystal_val / prdiv_val) * vdiv_val;
    273            if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
   \                     ??new_pll_freq_4: (+1)
   \   00000058   0x4360             MULS     R0,R4,R0
   \   0000005A   0x....             LDR      R1,??DataTable1  ;; 0xfd239400
   \   0000005C   0x1840             ADDS     R0,R0,R1
   \   0000005E   0x....             LDR      R1,??DataTable1_1  ;; 0x3197501
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD301             BCC      ??new_pll_freq_5
   \   00000064   0x2045             MOVS     R0,#+69
   \   00000066   0xBDF6             POP      {R1,R2,R4-R7,PC}
    274            
    275            // First move to PBE mode so that the PLL frequency can be safely changed.
    276            // As we are running from the PLL by default the PLL and external clock settings are valid
    277            // To move to PBE from PEE SIMply requires the switching of the CLKS mux to select the ext clock 
    278            // As CLKS is already 0 the CLKS value can SIMply be OR'ed into the register 
    279            MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
   \                     ??new_pll_freq_5: (+1)
   \   00000068   0x7828             LDRB     R0,[R5, #+0]
   \   0000006A   0x2180             MOVS     R1,#+128
   \   0000006C   0x4301             ORRS     R1,R1,R0
   \   0000006E   0x7029             STRB     R1,[R5, #+0]
    280            
    281            // Wait for clock status bits to update 
    282            for (i = 0 ; i < 2000 ; i++)
   \   00000070   0x20FA             MOVS     R0,#+250
   \   00000072   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000074   0x0001             MOVS     R1,R0
    283            {
    284              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \                     ??new_pll_freq_6: (+1)
   \   00000076   0x79AA             LDRB     R2,[R5, #+6]
   \   00000078   0x0892             LSRS     R2,R2,#+2
   \   0000007A   0x4032             ANDS     R2,R2,R6
   \   0000007C   0x2A02             CMP      R2,#+2
   \   0000007E   0xD001             BEQ      ??new_pll_freq_7
    285            }
   \   00000080   0x1E49             SUBS     R1,R1,#+1
   \   00000082   0xD1F8             BNE      ??new_pll_freq_6
    286            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??new_pll_freq_7: (+1)
   \   00000084   0x79A9             LDRB     R1,[R5, #+6]
   \   00000086   0x0889             LSRS     R1,R1,#+2
   \   00000088   0x4031             ANDS     R1,R1,R6
   \   0000008A   0x2902             CMP      R1,#+2
   \   0000008C   0xD001             BEQ      ??new_pll_freq_8
   \   0000008E   0x201A             MOVS     R0,#+26
   \   00000090   0xBDF6             POP      {R1,R2,R4-R7,PC}
    287          
    288            // Now in PBE mode 
    289            // System is clocked off the external clock. 
    290            // Now update the PLL settings and wait for the PLL to re-lock
    291            // Configure MCG_C5
    292            temp_reg = MCG_C5;
   \                     ??new_pll_freq_8: (+1)
   \   00000092   0x792B             LDRB     R3,[R5, #+4]
    293            temp_reg &= ~MCG_C5_PRDIV0_MASK;
    294            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
    295            MCG_C5 = temp_reg;
   \   00000094   0x271F             MOVS     R7,#+31
   \   00000096   0x21E0             MOVS     R1,#+224
   \   00000098   0x400B             ANDS     R3,R3,R1
   \   0000009A   0x469C             MOV      R12,R3
   \   0000009C   0x466B             MOV      R3,SP
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0x569A             LDRSB    R2,[R3, R2]
   \   000000A2   0x1E52             SUBS     R2,R2,#+1
   \   000000A4   0x403A             ANDS     R2,R2,R7
   \   000000A6   0x4663             MOV      R3,R12
   \   000000A8   0x431A             ORRS     R2,R2,R3
   \   000000AA   0x712A             STRB     R2,[R5, #+4]
    296          
    297            // Configure MCG_C6
    298            // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
    299            // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    300            temp_reg = MCG_C6; // store present C6 value
   \   000000AC   0x796B             LDRB     R3,[R5, #+5]
    301            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
    302            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
    303            MCG_C6 = temp_reg; // update MCG_C6
   \   000000AE   0x2240             MOVS     R2,#+64
   \   000000B0   0x4019             ANDS     R1,R1,R3
   \   000000B2   0x3C18             SUBS     R4,R4,#+24
   \   000000B4   0x403C             ANDS     R4,R4,R7
   \   000000B6   0x430C             ORRS     R4,R4,R1
   \   000000B8   0x4314             ORRS     R4,R4,R2
   \   000000BA   0x716C             STRB     R4,[R5, #+5]
    304          
    305            // wait for PLLST status bit to set
    306            for (i = 0 ; i < 2000 ; i++)
   \   000000BC   0x0001             MOVS     R1,R0
    307            {
    308              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \                     ??new_pll_freq_9: (+1)
   \   000000BE   0x79AB             LDRB     R3,[R5, #+6]
   \   000000C0   0x069B             LSLS     R3,R3,#+26
   \   000000C2   0xD401             BMI      ??new_pll_freq_10
    309            }
   \   000000C4   0x1E49             SUBS     R1,R1,#+1
   \   000000C6   0xD1FA             BNE      ??new_pll_freq_9
    310            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??new_pll_freq_10: (+1)
   \   000000C8   0x79A9             LDRB     R1,[R5, #+6]
   \   000000CA   0x0689             LSLS     R1,R1,#+26
   \   000000CC   0xD401             BMI      ??new_pll_freq_11
   \   000000CE   0x2016             MOVS     R0,#+22
   \   000000D0   0xBDF6             POP      {R1,R2,R4-R7,PC}
    311          
    312            // Wait for LOCK bit to set
    313            for (i = 0 ; i < 4000 ; i++)
   \                     ??new_pll_freq_11: (+1)
   \   000000D2   0x0041             LSLS     R1,R0,#+1
    314            {
    315              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \                     ??new_pll_freq_12: (+1)
   \   000000D4   0x79AB             LDRB     R3,[R5, #+6]
   \   000000D6   0x4213             TST      R3,R2
   \   000000D8   0xD101             BNE      ??new_pll_freq_13
    316            }
   \   000000DA   0x1E49             SUBS     R1,R1,#+1
   \   000000DC   0xD1FA             BNE      ??new_pll_freq_12
    317            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??new_pll_freq_13: (+1)
   \   000000DE   0x79A9             LDRB     R1,[R5, #+6]
   \   000000E0   0x4211             TST      R1,R2
   \   000000E2   0xD101             BNE      ??new_pll_freq_14
   \   000000E4   0x2044             MOVS     R0,#+68
   \   000000E6   0xBDF6             POP      {R1,R2,R4-R7,PC}
    318          
    319            // Change CLKS mux to now select the PLL output
    320            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
   \                     ??new_pll_freq_14: (+1)
   \   000000E8   0x7829             LDRB     R1,[R5, #+0]
   \   000000EA   0x0689             LSLS     R1,R1,#+26
   \   000000EC   0x0E89             LSRS     R1,R1,#+26
   \   000000EE   0x7029             STRB     R1,[R5, #+0]
    321          
    322            // Wait for clock status bits to update
    323            for (i = 0 ; i < 2000 ; i++)
    324            {
    325              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
   \                     ??new_pll_freq_15: (+1)
   \   000000F0   0x79A9             LDRB     R1,[R5, #+6]
   \   000000F2   0x0889             LSRS     R1,R1,#+2
   \   000000F4   0x4031             ANDS     R1,R1,R6
   \   000000F6   0x2903             CMP      R1,#+3
   \   000000F8   0xD001             BEQ      ??new_pll_freq_16
    326            }
   \   000000FA   0x1E40             SUBS     R0,R0,#+1
   \   000000FC   0xD1F8             BNE      ??new_pll_freq_15
    327            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not
   \                     ??new_pll_freq_16: (+1)
   \   000000FE   0x79A8             LDRB     R0,[R5, #+6]
   \   00000100   0x0880             LSRS     R0,R0,#+2
   \   00000102   0x4006             ANDS     R6,R6,R0
   \   00000104   0x2E03             CMP      R6,#+3
   \   00000106   0xD001             BEQ      ??new_pll_freq_17
   \   00000108   0x201B             MOVS     R0,#+27
   \   0000010A   0xBDF6             POP      {R1,R2,R4-R7,PC}
    328          
    329            // Now in PEE
    330            // Use actual PLL settings to calculate PLL frequency
    331            prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
   \                     ??new_pll_freq_17: (+1)
   \   0000010C   0x7929             LDRB     R1,[R5, #+4]
    332            vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
   \   0000010E   0x796C             LDRB     R4,[R5, #+5]
    333            
    334            return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
   \   00000110   0x9800             LDR      R0,[SP, #+0]
   \   00000112   0x4039             ANDS     R1,R1,R7
   \   00000114   0x1C49             ADDS     R1,R1,#+1
   \   00000116   0xB2C9             UXTB     R1,R1
   \   00000118   0x.... 0x....      BL       __aeabi_idiv
   \   0000011C   0x4027             ANDS     R7,R7,R4
   \   0000011E   0x3718             ADDS     R7,R7,#+24
   \   00000120   0xB2FF             UXTB     R7,R7
   \   00000122   0x4378             MULS     R0,R7,R0
   \   00000124   0xBDF6             POP      {R1,R2,R4-R7,PC}  ;; return
    335          } // new_pll_freq
    336          
    337          
    338          /********************************************************************/
    339          

   \                                 In section .text, align 2, keep-with-next
    340          int pee_pbe(int crystal_val)
    341          {
   \                     pee_pbe: (+1)
   \   00000000   0xB410             PUSH     {R4}
    342            short i;
    343            
    344          // Check MCG is in PEE mode
    345            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted PLL output
    346                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    347                (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selected PLL 
   \   00000002   0x....             LDR      R1,??DataTable4  ;; 0x40064000
   \   00000004   0x2203             MOVS     R2,#+3
   \   00000006   0x798B             LDRB     R3,[R1, #+6]
   \   00000008   0x089B             LSRS     R3,R3,#+2
   \   0000000A   0x4013             ANDS     R3,R3,R2
   \   0000000C   0x2B03             CMP      R3,#+3
   \   0000000E   0xD105             BNE      ??pee_pbe_0
   \   00000010   0x798B             LDRB     R3,[R1, #+6]
   \   00000012   0x06DB             LSLS     R3,R3,#+27
   \   00000014   0xD402             BMI      ??pee_pbe_0
   \   00000016   0x798B             LDRB     R3,[R1, #+6]
   \   00000018   0x069B             LSLS     R3,R3,#+26
   \   0000001A   0xD401             BMI      ??pee_pbe_1
    348            {
    349              return 0x8;                                                       // return error code
   \                     ??pee_pbe_0: (+1)
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0xE012             B        ??pee_pbe_2
    350            } 
    351            
    352          // As we are running from the PLL by default the PLL and external clock settings are valid
    353          // To move to PBE from PEE SIMply requires the switching of the CLKS mux to select the ext clock 
    354          // As CLKS is already 0 the CLKS value can SIMply be OR'ed into the register 
    355            MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
   \                     ??pee_pbe_1: (+1)
   \   00000020   0x780B             LDRB     R3,[R1, #+0]
   \   00000022   0x2480             MOVS     R4,#+128
   \   00000024   0x431C             ORRS     R4,R4,R3
   \   00000026   0x700C             STRB     R4,[R1, #+0]
    356            
    357          // Wait for clock status bits to update 
    358            for (i = 0 ; i < 2000 ; i++)
   \   00000028   0x23FA             MOVS     R3,#+250
   \   0000002A   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
    359            {
    360              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \                     ??pee_pbe_3: (+1)
   \   0000002C   0x798C             LDRB     R4,[R1, #+6]
   \   0000002E   0x08A4             LSRS     R4,R4,#+2
   \   00000030   0x4014             ANDS     R4,R4,R2
   \   00000032   0x2C02             CMP      R4,#+2
   \   00000034   0xD001             BEQ      ??pee_pbe_4
    361            }
   \   00000036   0x1E5B             SUBS     R3,R3,#+1
   \   00000038   0xD1F8             BNE      ??pee_pbe_3
    362            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??pee_pbe_4: (+1)
   \   0000003A   0x7989             LDRB     R1,[R1, #+6]
   \   0000003C   0x0889             LSRS     R1,R1,#+2
   \   0000003E   0x400A             ANDS     R2,R2,R1
   \   00000040   0x2A02             CMP      R2,#+2
   \   00000042   0xD000             BEQ      ??pee_pbe_2
   \   00000044   0x201A             MOVS     R0,#+26
    363          
    364          // Now in PBE mode  
    365            return crystal_val; // MCGOUT frequency equals external clock frequency
   \                     ??pee_pbe_2: (+1)
   \   00000046   0xBC10             POP      {R4}
   \   00000048   0x4770             BX       LR               ;; return
    366          } // pee_pbe
    367          
    368          

   \                                 In section .text, align 2, keep-with-next
    369          int pbe_pee(int crystal_val)
    370          {
   \                     pbe_pee: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    371            unsigned char prdiv, vdiv;
    372            short i;
    373          
    374            // Check MCG is in PBE mode
    375            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    376                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    377                (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selected PLL
    378                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set
   \   00000002   0x....             LDR      R2,??DataTable4  ;; 0x40064000
   \   00000004   0x2303             MOVS     R3,#+3
   \   00000006   0x7991             LDRB     R1,[R2, #+6]
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x4019             ANDS     R1,R1,R3
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD108             BNE      ??pbe_pee_0
   \   00000010   0x7991             LDRB     R1,[R2, #+6]
   \   00000012   0x06C9             LSLS     R1,R1,#+27
   \   00000014   0xD405             BMI      ??pbe_pee_0
   \   00000016   0x7991             LDRB     R1,[R2, #+6]
   \   00000018   0x0689             LSLS     R1,R1,#+26
   \   0000001A   0xD502             BPL      ??pbe_pee_0
   \   0000001C   0x7851             LDRB     R1,[R2, #+1]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD501             BPL      ??pbe_pee_1
    379            {
    380              return 0x7;                                                       // return error code
   \                     ??pbe_pee_0: (+1)
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0xBD70             POP      {R4-R6,PC}
    381            }
    382          
    383            // As the PLL settings have already been checked when PBE mode was enterred they are not checked here
    384          
    385            // Check the PLL state before transitioning to PEE mode
    386            
    387            // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but good practice
    388            // to re-check before switch to use PLL)
    389            for (i = 0 ; i < 2000 ; i++)
   \                     ??pbe_pee_1: (+1)
   \   00000026   0x25FA             MOVS     R5,#+250
   \   00000028   0x00ED             LSLS     R5,R5,#+3        ;; #+2000
   \   0000002A   0x002C             MOVS     R4,R5
   \   0000002C   0x2140             MOVS     R1,#+64
    390            {
    391              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \                     ??pbe_pee_2: (+1)
   \   0000002E   0x7996             LDRB     R6,[R2, #+6]
   \   00000030   0x420E             TST      R6,R1
   \   00000032   0xD101             BNE      ??pbe_pee_3
    392            }
   \   00000034   0x1E64             SUBS     R4,R4,#+1
   \   00000036   0xD1FA             BNE      ??pbe_pee_2
    393            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??pbe_pee_3: (+1)
   \   00000038   0x7994             LDRB     R4,[R2, #+6]
   \   0000003A   0x420C             TST      R4,R1
   \   0000003C   0xD101             BNE      ??pbe_pee_4
   \   0000003E   0x2044             MOVS     R0,#+68
   \   00000040   0xBD70             POP      {R4-R6,PC}
    394            // Use actual PLL settings to calculate PLL frequency
    395            prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
   \                     ??pbe_pee_4: (+1)
   \   00000042   0x241F             MOVS     R4,#+31
   \   00000044   0x7911             LDRB     R1,[R2, #+4]
   \   00000046   0x4021             ANDS     R1,R1,R4
   \   00000048   0x1C49             ADDS     R1,R1,#+1
    396            vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
   \   0000004A   0x7956             LDRB     R6,[R2, #+5]
   \   0000004C   0x4034             ANDS     R4,R4,R6
   \   0000004E   0x3418             ADDS     R4,R4,#+24
    397            
    398            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
   \   00000050   0x7816             LDRB     R6,[R2, #+0]
   \   00000052   0x06B6             LSLS     R6,R6,#+26
   \   00000054   0x0EB6             LSRS     R6,R6,#+26
   \   00000056   0x7016             STRB     R6,[R2, #+0]
    399          
    400            // Wait for clock status bits to update
    401            for (i = 0 ; i < 2000 ; i++)
    402            {
    403              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
   \                     ??pbe_pee_5: (+1)
   \   00000058   0x7996             LDRB     R6,[R2, #+6]
   \   0000005A   0x08B6             LSRS     R6,R6,#+2
   \   0000005C   0x401E             ANDS     R6,R6,R3
   \   0000005E   0x2E03             CMP      R6,#+3
   \   00000060   0xD001             BEQ      ??pbe_pee_6
    404            }
   \   00000062   0x1E6D             SUBS     R5,R5,#+1
   \   00000064   0xD1F8             BNE      ??pbe_pee_5
    405            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not
   \                     ??pbe_pee_6: (+1)
   \   00000066   0x7992             LDRB     R2,[R2, #+6]
   \   00000068   0x0892             LSRS     R2,R2,#+2
   \   0000006A   0x4013             ANDS     R3,R3,R2
   \   0000006C   0x2B03             CMP      R3,#+3
   \   0000006E   0xD001             BEQ      ??pbe_pee_7
   \   00000070   0x201B             MOVS     R0,#+27
   \   00000072   0xBD70             POP      {R4-R6,PC}
    406          
    407            // Now in PEE
    408            return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
   \                     ??pbe_pee_7: (+1)
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x.... 0x....      BL       __aeabi_idiv
   \   0000007A   0xB2E4             UXTB     R4,R4
   \   0000007C   0x4360             MULS     R0,R4,R0
   \   0000007E   0xBD70             POP      {R4-R6,PC}       ;; return
    409            
    410          }  // pbe_pee
    411          
    412          

   \                                 In section .text, align 2, keep-with-next
    413          int pbe_fbe(int crystal_val)
    414          {
   \                     pbe_fbe: (+1)
   \   00000000   0xB410             PUSH     {R4}
    415            short i;
    416            
    417          // Check MCG is in PBE mode
    418            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    419                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    420                (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selected PLL
    421                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable9  ;; 0x40064001
   \   00000004   0x794A             LDRB     R2,[R1, #+5]
   \   00000006   0x0712             LSLS     R2,R2,#+28
   \   00000008   0x0F92             LSRS     R2,R2,#+30
   \   0000000A   0x2A02             CMP      R2,#+2
   \   0000000C   0xD109             BNE      ??pbe_fbe_0
   \   0000000E   0x794A             LDRB     R2,[R1, #+5]
   \   00000010   0x06D2             LSLS     R2,R2,#+27
   \   00000012   0xD406             BMI      ??pbe_fbe_0
   \   00000014   0x2220             MOVS     R2,#+32
   \   00000016   0x794B             LDRB     R3,[R1, #+5]
   \   00000018   0x4213             TST      R3,R2
   \   0000001A   0xD002             BEQ      ??pbe_fbe_0
   \   0000001C   0x780B             LDRB     R3,[R1, #+0]
   \   0000001E   0x079B             LSLS     R3,R3,#+30
   \   00000020   0xD501             BPL      ??pbe_fbe_1
    422            {
    423              return 0x7;                                                       // return error code
   \                     ??pbe_fbe_0: (+1)
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0xE00E             B        ??pbe_fbe_2
    424            }
    425          
    426          // As we are running from the ext clock, by default the external clock settings are valid
    427          // To move to FBE from PBE SIMply requires the switching of the PLLS mux to disable the PLL 
    428            
    429            MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
   \                     ??pbe_fbe_1: (+1)
   \   00000026   0x790B             LDRB     R3,[R1, #+4]
   \   00000028   0x24BF             MOVS     R4,#+191
   \   0000002A   0x401C             ANDS     R4,R4,R3
   \   0000002C   0x710C             STRB     R4,[R1, #+4]
    430            
    431          // wait for PLLST status bit to set
    432            for (i = 0 ; i < 2000 ; i++)
   \   0000002E   0x23FA             MOVS     R3,#+250
   \   00000030   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
    433            {
    434              if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
   \                     ??pbe_fbe_3: (+1)
   \   00000032   0x794C             LDRB     R4,[R1, #+5]
   \   00000034   0x4214             TST      R4,R2
   \   00000036   0xD001             BEQ      ??pbe_fbe_4
    435            }
   \   00000038   0x1E5B             SUBS     R3,R3,#+1
   \   0000003A   0xD1FA             BNE      ??pbe_fbe_3
    436            if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if not clear  
   \                     ??pbe_fbe_4: (+1)
   \   0000003C   0x7949             LDRB     R1,[R1, #+5]
   \   0000003E   0x4211             TST      R1,R2
   \   00000040   0xD000             BEQ      ??pbe_fbe_2
   \   00000042   0x2015             MOVS     R0,#+21
    437          
    438          // Now in FBE mode  
    439            return crystal_val; // MCGOUT frequency equals external clock frequency 
   \                     ??pbe_fbe_2: (+1)
   \   00000044   0xBC10             POP      {R4}
   \   00000046   0x4770             BX       LR               ;; return
    440          } // pbe_fbe
    441          
    442          
    443          /********************************************************************/
    444          /* Functon name : fbe_pbe
    445           *
    446           * Mode transition: FBE to PBE mode
    447           *
    448           * This function transitions the MCG from FBE mode to PBE mode. 
    449           * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soon 
    450           * The function requires the desired OSC and PLL be passed in to it for compatibility with the
    451           * future support of OSC/PLL selection
    452           *
    453           * Parameters: crystal_val - external clock frequency in Hz
    454           *             prdiv_val   - value to divide the external clock source by to create the desired
    455           *                           PLL reference clock frequency
    456           *             vdiv_val    - value to multiply the PLL reference clock frequency by
    457           *
    458           * Return value : MCGCLKOUT frequency (Hz) or error code
    459           */

   \                                 In section .text, align 2, keep-with-next
    460          int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
    461          {
   \                     fbe_pbe: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0x000C             MOVS     R4,R1
   \   00000004   0x0015             MOVS     R5,R2
    462            unsigned char temp_reg;
    463            short i;
    464            int pll_freq;
    465            
    466          // Check MCG is in FBE mode
    467            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    468                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    469                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    470                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000006   0x....             LDR      R6,??DataTable9  ;; 0x40064001
   \   00000008   0x7970             LDRB     R0,[R6, #+5]
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0x0F80             LSRS     R0,R0,#+30
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD109             BNE      ??fbe_pbe_0
   \   00000012   0x7970             LDRB     R0,[R6, #+5]
   \   00000014   0x06C0             LSLS     R0,R0,#+27
   \   00000016   0xD406             BMI      ??fbe_pbe_0
   \   00000018   0x2720             MOVS     R7,#+32
   \   0000001A   0x7970             LDRB     R0,[R6, #+5]
   \   0000001C   0x4238             TST      R0,R7
   \   0000001E   0xD102             BNE      ??fbe_pbe_0
   \   00000020   0x7830             LDRB     R0,[R6, #+0]
   \   00000022   0x0780             LSLS     R0,R0,#+30
   \   00000024   0xD501             BPL      ??fbe_pbe_1
    471            {
    472              return 0x4;                                                       // return error code
   \                     ??fbe_pbe_0: (+1)
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
    473            }
    474            
    475          // As the external frequency has already been checked when FBE mode was enterred it is not checked here
    476          
    477          // Check PLL divider settings are within spec.
    478            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??fbe_pbe_1: (+1)
   \   0000002A   0x1E60             SUBS     R0,R4,#+1
   \   0000002C   0x2819             CMP      R0,#+25
   \   0000002E   0xD301             BCC      ??fbe_pbe_2
   \   00000030   0x2041             MOVS     R0,#+65
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}
    479            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
   \                     ??fbe_pbe_2: (+1)
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x3818             SUBS     R0,R0,#+24
   \   00000038   0x281B             CMP      R0,#+27
   \   0000003A   0xD301             BCC      ??fbe_pbe_3
   \   0000003C   0x2042             MOVS     R0,#+66
   \   0000003E   0xBDF2             POP      {R1,R4-R7,PC}
    480            
    481          // Check PLL reference clock frequency is within spec.
    482            if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;}
   \                     ??fbe_pbe_3: (+1)
   \   00000040   0x9800             LDR      R0,[SP, #+0]
   \   00000042   0x.... 0x....      BL       __aeabi_idiv
   \   00000046   0x....             LDR      R1,??DataTable10  ;; 0xffe17b80
   \   00000048   0x1841             ADDS     R1,R0,R1
   \   0000004A   0x....             LDR      R2,??DataTable10_1  ;; 0x1e8481
   \   0000004C   0x4291             CMP      R1,R2
   \   0000004E   0xD301             BCC      ??fbe_pbe_4
   \   00000050   0x2043             MOVS     R0,#+67
   \   00000052   0xBDF2             POP      {R1,R4-R7,PC}
    483                 
    484          // Check PLL output frequency is within spec.
    485            pll_freq = (crystal_val / prdiv_val) * vdiv_val;
    486            if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
   \                     ??fbe_pbe_4: (+1)
   \   00000054   0x4368             MULS     R0,R5,R0
   \   00000056   0x....             LDR      R1,??DataTable10_2  ;; 0xfd239400
   \   00000058   0x1840             ADDS     R0,R0,R1
   \   0000005A   0x....             LDR      R1,??DataTable10_3  ;; 0x3197501
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD301             BCC      ??fbe_pbe_5
   \   00000060   0x2045             MOVS     R0,#+69
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}
    487          
    488            // Configure MCG_C5
    489            // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.       
    490            temp_reg = MCG_C5;
   \                     ??fbe_pbe_5: (+1)
   \   00000064   0x78F2             LDRB     R2,[R6, #+3]
    491            temp_reg &= ~MCG_C5_PRDIV0_MASK;
    492            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
    493            MCG_C5 = temp_reg;
   \   00000066   0x201F             MOVS     R0,#+31
   \   00000068   0x21E0             MOVS     R1,#+224
   \   0000006A   0x400A             ANDS     R2,R2,R1
   \   0000006C   0x1E63             SUBS     R3,R4,#+1
   \   0000006E   0x4003             ANDS     R3,R3,R0
   \   00000070   0x4313             ORRS     R3,R3,R2
   \   00000072   0x70F3             STRB     R3,[R6, #+3]
    494          
    495            // Configure MCG_C6
    496            // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
    497            // The clock monitor is not enabled here as it has likely been enabled previously and so the value of CME
    498            // is not altered here.
    499            // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    500            temp_reg = MCG_C6; // store present C6 value
   \   00000074   0x7933             LDRB     R3,[R6, #+4]
    501            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
    502            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
    503            MCG_C6 = temp_reg; // update MCG_C6
   \   00000076   0x2240             MOVS     R2,#+64
   \   00000078   0x4019             ANDS     R1,R1,R3
   \   0000007A   0x3D18             SUBS     R5,R5,#+24
   \   0000007C   0x4028             ANDS     R0,R0,R5
   \   0000007E   0x4308             ORRS     R0,R0,R1
   \   00000080   0x4310             ORRS     R0,R0,R2
   \   00000082   0x7130             STRB     R0,[R6, #+4]
    504            
    505            // wait for PLLST status bit to set
    506            for (i = 0 ; i < 2000 ; i++)
   \   00000084   0x20FA             MOVS     R0,#+250
   \   00000086   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000088   0x0001             MOVS     R1,R0
    507            {
    508              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \                     ??fbe_pbe_6: (+1)
   \   0000008A   0x7973             LDRB     R3,[R6, #+5]
   \   0000008C   0x423B             TST      R3,R7
   \   0000008E   0xD101             BNE      ??fbe_pbe_7
    509            }
   \   00000090   0x1E49             SUBS     R1,R1,#+1
   \   00000092   0xD1FA             BNE      ??fbe_pbe_6
    510            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??fbe_pbe_7: (+1)
   \   00000094   0x7971             LDRB     R1,[R6, #+5]
   \   00000096   0x4239             TST      R1,R7
   \   00000098   0xD101             BNE      ??fbe_pbe_8
   \   0000009A   0x2016             MOVS     R0,#+22
   \   0000009C   0xBDF2             POP      {R1,R4-R7,PC}
    511          
    512            // Wait for LOCK bit to set
    513            for (i = 0 ; i < 2000 ; i++)
    514            {
    515              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \                     ??fbe_pbe_8: (+1)
   \   0000009E   0x7971             LDRB     R1,[R6, #+5]
   \   000000A0   0x4211             TST      R1,R2
   \   000000A2   0xD101             BNE      ??fbe_pbe_9
    516            }
   \   000000A4   0x1E40             SUBS     R0,R0,#+1
   \   000000A6   0xD1FA             BNE      ??fbe_pbe_8
    517            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??fbe_pbe_9: (+1)
   \   000000A8   0x7970             LDRB     R0,[R6, #+5]
   \   000000AA   0x4210             TST      R0,R2
   \   000000AC   0xD101             BNE      ??fbe_pbe_10
   \   000000AE   0x2044             MOVS     R0,#+68
   \   000000B0   0xBDF2             POP      {R1,R4-R7,PC}
    518              
    519          // now in PBE 
    520            return crystal_val; // MCGOUT frequency equals external clock frequency
   \                     ??fbe_pbe_10: (+1)
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    521          } // fbe_pbe
    522          
    523          

   \                                 In section .text, align 2, keep-with-next
    524          int pbe_blpe(int crystal_val)
    525          {
    526          // Check MCG is in PBE mode
    527            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    528                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    529                (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selected PLL
    530                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \                     pbe_blpe: (+1)
   \   00000000   0x....             LDR      R1,??DataTable10_4  ;; 0x40064001
   \   00000002   0x794A             LDRB     R2,[R1, #+5]
   \   00000004   0x0712             LSLS     R2,R2,#+28
   \   00000006   0x0F92             LSRS     R2,R2,#+30
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD109             BNE      ??pbe_blpe_0
   \   0000000C   0x794A             LDRB     R2,[R1, #+5]
   \   0000000E   0x06D2             LSLS     R2,R2,#+27
   \   00000010   0xD406             BMI      ??pbe_blpe_0
   \   00000012   0x794A             LDRB     R2,[R1, #+5]
   \   00000014   0x0692             LSLS     R2,R2,#+26
   \   00000016   0xD503             BPL      ??pbe_blpe_0
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x780B             LDRB     R3,[R1, #+0]
   \   0000001C   0x4213             TST      R3,R2
   \   0000001E   0xD001             BEQ      ??pbe_blpe_1
    531            {
    532              return 0x7;                                                       // return error code
   \                     ??pbe_blpe_0: (+1)
   \   00000020   0x2007             MOVS     R0,#+7
   \   00000022   0x4770             BX       LR
    533            }
    534            
    535          // To enter BLPE mode the LP bit must be set, disabling the PLL  
    536            MCG_C2 |= MCG_C2_LP_MASK;
   \                     ??pbe_blpe_1: (+1)
   \   00000024   0x780B             LDRB     R3,[R1, #+0]
   \   00000026   0x431A             ORRS     R2,R2,R3
   \   00000028   0x700A             STRB     R2,[R1, #+0]
    537            
    538          // Now in BLPE mode
    539            return crystal_val;  
   \   0000002A   0x4770             BX       LR               ;; return
    540          } // pbe_blpe
    541          
    542          
    543          // ************************************************************************************************
    544          // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been 
    545          // previously configured correctly. That is why this general purpose driver has the PLL settings as
    546          // passed parameters.
    547          // ************************************************************************************************

   \                                 In section .text, align 2, keep-with-next
    548          int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
    549          {
   \                     blpe_pbe: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    550            unsigned char temp_reg;
    551            short i;
    552            
    553          // Check MCG is in BLPE mode
    554            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    555                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    556                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is set   
   \   00000008   0x....             LDR      R7,??DataTable9  ;; 0x40064001
   \   0000000A   0x7978             LDRB     R0,[R7, #+5]
   \   0000000C   0x0700             LSLS     R0,R0,#+28
   \   0000000E   0x0F80             LSRS     R0,R0,#+30
   \   00000010   0x2802             CMP      R0,#+2
   \   00000012   0xD105             BNE      ??blpe_pbe_0
   \   00000014   0x7978             LDRB     R0,[R7, #+5]
   \   00000016   0x06C0             LSLS     R0,R0,#+27
   \   00000018   0xD402             BMI      ??blpe_pbe_0
   \   0000001A   0x7838             LDRB     R0,[R7, #+0]
   \   0000001C   0x0780             LSLS     R0,R0,#+30
   \   0000001E   0xD401             BMI      ??blpe_pbe_1
    557            {
    558              return 0x6;                                                       // return error code
   \                     ??blpe_pbe_0: (+1)
   \   00000020   0x2006             MOVS     R0,#+6
   \   00000022   0xBDF0             POP      {R4-R7,PC}
    559            }
    560            
    561          // As the external frequency has already been checked when FBE mode was enterred it is not checked here
    562          
    563          // Check PLL divider settings are within spec.
    564            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??blpe_pbe_1: (+1)
   \   00000024   0x1E68             SUBS     R0,R5,#+1
   \   00000026   0x2819             CMP      R0,#+25
   \   00000028   0xD301             BCC      ??blpe_pbe_2
   \   0000002A   0x2041             MOVS     R0,#+65
   \   0000002C   0xBDF0             POP      {R4-R7,PC}
    565            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
   \                     ??blpe_pbe_2: (+1)
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x3818             SUBS     R0,R0,#+24
   \   00000032   0x281B             CMP      R0,#+27
   \   00000034   0xD301             BCC      ??blpe_pbe_3
   \   00000036   0x2042             MOVS     R0,#+66
   \   00000038   0xBDF0             POP      {R4-R7,PC}
    566            
    567          // Check PLL reference clock frequency is within spec.
    568            if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;}
   \                     ??blpe_pbe_3: (+1)
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       __aeabi_idiv
   \   00000040   0x....             LDR      R1,??DataTable10  ;; 0xffe17b80
   \   00000042   0x1840             ADDS     R0,R0,R1
   \   00000044   0x....             LDR      R1,??DataTable10_1  ;; 0x1e8481
   \   00000046   0x4288             CMP      R0,R1
   \   00000048   0xD301             BCC      ??blpe_pbe_4
   \   0000004A   0x2043             MOVS     R0,#+67
   \   0000004C   0xBDF0             POP      {R4-R7,PC}
    569                 
    570          // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
    571          
    572          // Configure MCG_C5
    573          // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.       
    574            temp_reg = MCG_C5;
   \                     ??blpe_pbe_4: (+1)
   \   0000004E   0x78FA             LDRB     R2,[R7, #+3]
    575            temp_reg &= ~MCG_C5_PRDIV0_MASK;
    576            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
    577            MCG_C5 = temp_reg;
   \   00000050   0x201F             MOVS     R0,#+31
   \   00000052   0x21E0             MOVS     R1,#+224
   \   00000054   0x400A             ANDS     R2,R2,R1
   \   00000056   0x1E6B             SUBS     R3,R5,#+1
   \   00000058   0x4003             ANDS     R3,R3,R0
   \   0000005A   0x4313             ORRS     R3,R3,R2
   \   0000005C   0x70FB             STRB     R3,[R7, #+3]
    578          
    579          // Configure MCG_C6
    580          // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
    581          // The clock monitor is not enabled here as it has likely been enabled previously and so the value of CME
    582          // is not altered here.
    583          // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    584            temp_reg = MCG_C6; // store present C6 value
   \   0000005E   0x793B             LDRB     R3,[R7, #+4]
    585            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
    586            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
    587            MCG_C6 = temp_reg; // update MCG_C6
   \   00000060   0x2240             MOVS     R2,#+64
   \   00000062   0x4019             ANDS     R1,R1,R3
   \   00000064   0x3E18             SUBS     R6,R6,#+24
   \   00000066   0x4030             ANDS     R0,R0,R6
   \   00000068   0x4308             ORRS     R0,R0,R1
   \   0000006A   0x4310             ORRS     R0,R0,R2
   \   0000006C   0x7138             STRB     R0,[R7, #+4]
    588            
    589          // Now that PLL is configured, LP is cleared to enable the PLL
    590            MCG_C2 &= ~MCG_C2_LP_MASK;
   \   0000006E   0x7838             LDRB     R0,[R7, #+0]
   \   00000070   0x21FD             MOVS     R1,#+253
   \   00000072   0x4001             ANDS     R1,R1,R0
   \   00000074   0x7039             STRB     R1,[R7, #+0]
    591            
    592          // wait for PLLST status bit to set
    593            for (i = 0 ; i < 2000 ; i++)
   \   00000076   0x20FA             MOVS     R0,#+250
   \   00000078   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   0000007A   0x0003             MOVS     R3,R0
   \   0000007C   0x2120             MOVS     R1,#+32
    594            {
    595              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \                     ??blpe_pbe_5: (+1)
   \   0000007E   0x797D             LDRB     R5,[R7, #+5]
   \   00000080   0x420D             TST      R5,R1
   \   00000082   0xD101             BNE      ??blpe_pbe_6
    596            }
   \   00000084   0x1E5B             SUBS     R3,R3,#+1
   \   00000086   0xD1FA             BNE      ??blpe_pbe_5
    597            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??blpe_pbe_6: (+1)
   \   00000088   0x797B             LDRB     R3,[R7, #+5]
   \   0000008A   0x420B             TST      R3,R1
   \   0000008C   0xD101             BNE      ??blpe_pbe_7
   \   0000008E   0x2016             MOVS     R0,#+22
   \   00000090   0xBDF0             POP      {R4-R7,PC}
    598          
    599          // Wait for LOCK bit to set
    600            for (i = 0 ; i < 2000 ; i++)
    601            {
    602              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \                     ??blpe_pbe_7: (+1)
   \   00000092   0x7979             LDRB     R1,[R7, #+5]
   \   00000094   0x4211             TST      R1,R2
   \   00000096   0xD101             BNE      ??blpe_pbe_8
    603            }
   \   00000098   0x1E40             SUBS     R0,R0,#+1
   \   0000009A   0xD1FA             BNE      ??blpe_pbe_7
    604            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??blpe_pbe_8: (+1)
   \   0000009C   0x7978             LDRB     R0,[R7, #+5]
   \   0000009E   0x4210             TST      R0,R2
   \   000000A0   0xD101             BNE      ??blpe_pbe_9
   \   000000A2   0x2044             MOVS     R0,#+68
   \   000000A4   0xBDF0             POP      {R4-R7,PC}
    605          
    606          // now in PBE 
    607            return crystal_val; // MCGOUT frequency equals external clock frequency  
   \                     ??blpe_pbe_9: (+1)
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0xBDF0             POP      {R4-R7,PC}       ;; return
    608          } // blpe_pbe
    609          
    610          

   \                                 In section .text, align 2, keep-with-next
    611          int blpe_fbe(int crystal_val)
    612          {
   \                     blpe_fbe: (+1)
   \   00000000   0xB410             PUSH     {R4}
    613            short i;
    614            
    615          // Check MCG is in BLPE mode
    616            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    617                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    618                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is set   
   \   00000002   0x....             LDR      R1,??DataTable10_4  ;; 0x40064001
   \   00000004   0x794A             LDRB     R2,[R1, #+5]
   \   00000006   0x0712             LSLS     R2,R2,#+28
   \   00000008   0x0F92             LSRS     R2,R2,#+30
   \   0000000A   0x2A02             CMP      R2,#+2
   \   0000000C   0xD105             BNE      ??blpe_fbe_0
   \   0000000E   0x794A             LDRB     R2,[R1, #+5]
   \   00000010   0x06D2             LSLS     R2,R2,#+27
   \   00000012   0xD402             BMI      ??blpe_fbe_0
   \   00000014   0x780A             LDRB     R2,[R1, #+0]
   \   00000016   0x0792             LSLS     R2,R2,#+30
   \   00000018   0xD401             BMI      ??blpe_fbe_1
    619            {
    620              return 0x6;                                                       // return error code
   \                     ??blpe_fbe_0: (+1)
   \   0000001A   0x2006             MOVS     R0,#+6
   \   0000001C   0xE013             B        ??blpe_fbe_2
    621            }
    622           
    623          // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be cleared
    624            MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
   \                     ??blpe_fbe_1: (+1)
   \   0000001E   0x790A             LDRB     R2,[R1, #+4]
   \   00000020   0x23BF             MOVS     R3,#+191
   \   00000022   0x4013             ANDS     R3,R3,R2
   \   00000024   0x710B             STRB     R3,[R1, #+4]
    625            MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
   \   00000026   0x780A             LDRB     R2,[R1, #+0]
   \   00000028   0x23FD             MOVS     R3,#+253
   \   0000002A   0x4013             ANDS     R3,R3,R2
   \   0000002C   0x700B             STRB     R3,[R1, #+0]
    626          
    627          // wait for PLLST status bit to clear
    628            for (i = 0 ; i < 2000 ; i++)
   \   0000002E   0x22FA             MOVS     R2,#+250
   \   00000030   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000032   0x2320             MOVS     R3,#+32
    629            {
    630              if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
   \                     ??blpe_fbe_3: (+1)
   \   00000034   0x794C             LDRB     R4,[R1, #+5]
   \   00000036   0x421C             TST      R4,R3
   \   00000038   0xD001             BEQ      ??blpe_fbe_4
    631            }
   \   0000003A   0x1E52             SUBS     R2,R2,#+1
   \   0000003C   0xD1FA             BNE      ??blpe_fbe_3
    632            if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if not clear  
   \                     ??blpe_fbe_4: (+1)
   \   0000003E   0x7949             LDRB     R1,[R1, #+5]
   \   00000040   0x4219             TST      R1,R3
   \   00000042   0xD000             BEQ      ??blpe_fbe_2
   \   00000044   0x2015             MOVS     R0,#+21
    633            
    634          // now in FBE mode
    635            return crystal_val; // MCGOUT frequency equals external clock frequency     
   \                     ??blpe_fbe_2: (+1)
   \   00000046   0xBC10             POP      {R4}
   \   00000048   0x4770             BX       LR               ;; return
    636          } // blpe_fbe
    637          
    638          

   \                                 In section .text, align 2, keep-with-next
    639          int fbe_blpe(int crystal_val)
    640          {
    641          // Check MCG is in FBE mode
    642            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    643                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    644                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    645                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \                     fbe_blpe: (+1)
   \   00000000   0x....             LDR      R1,??DataTable10_4  ;; 0x40064001
   \   00000002   0x794A             LDRB     R2,[R1, #+5]
   \   00000004   0x0712             LSLS     R2,R2,#+28
   \   00000006   0x0F92             LSRS     R2,R2,#+30
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD109             BNE      ??fbe_blpe_0
   \   0000000C   0x794A             LDRB     R2,[R1, #+5]
   \   0000000E   0x06D2             LSLS     R2,R2,#+27
   \   00000010   0xD406             BMI      ??fbe_blpe_0
   \   00000012   0x794A             LDRB     R2,[R1, #+5]
   \   00000014   0x0692             LSLS     R2,R2,#+26
   \   00000016   0xD403             BMI      ??fbe_blpe_0
   \   00000018   0x2202             MOVS     R2,#+2
   \   0000001A   0x780B             LDRB     R3,[R1, #+0]
   \   0000001C   0x4213             TST      R3,R2
   \   0000001E   0xD001             BEQ      ??fbe_blpe_1
    646            {
    647              return 0x4;                                                       // return error code
   \                     ??fbe_blpe_0: (+1)
   \   00000020   0x2004             MOVS     R0,#+4
   \   00000022   0x4770             BX       LR
    648            }
    649           
    650          // To move from FBE to BLPE the LP bit must be set
    651            MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
   \                     ??fbe_blpe_1: (+1)
   \   00000024   0x780B             LDRB     R3,[R1, #+0]
   \   00000026   0x431A             ORRS     R2,R2,R3
   \   00000028   0x700A             STRB     R2,[R1, #+0]
    652           
    653          // now in FBE mode
    654            return crystal_val; // MCGOUT frequency equals external clock frequency     
   \   0000002A   0x4770             BX       LR               ;; return
    655          } // fbe_blpe
    656          
    657          

   \                                 In section .text, align 2, keep-with-next
    658          int fbe_fei(int slow_irc_freq)
    659          {
   \                     fbe_fei: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    660            unsigned char temp_reg;
    661            short i;
    662            int mcg_out;
    663            
    664          // Check MCG is in FBE mode
    665            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    666                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    667                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    668                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R4,??DataTable12  ;; 0x40064000
   \   00000004   0x2503             MOVS     R5,#+3
   \   00000006   0x79A1             LDRB     R1,[R4, #+6]
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x4029             ANDS     R1,R1,R5
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD109             BNE      ??fbe_fei_0
   \   00000010   0x2610             MOVS     R6,#+16
   \   00000012   0x79A1             LDRB     R1,[R4, #+6]
   \   00000014   0x4231             TST      R1,R6
   \   00000016   0xD105             BNE      ??fbe_fei_0
   \   00000018   0x79A1             LDRB     R1,[R4, #+6]
   \   0000001A   0x0689             LSLS     R1,R1,#+26
   \   0000001C   0xD402             BMI      ??fbe_fei_0
   \   0000001E   0x7861             LDRB     R1,[R4, #+1]
   \   00000020   0x0789             LSLS     R1,R1,#+30
   \   00000022   0xD501             BPL      ??fbe_fei_1
    669            {
    670              return 0x4;                                                       // return error code
   \                     ??fbe_fei_0: (+1)
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xBD70             POP      {R4-R6,PC}
    671            }
    672          
    673          // Check IRC frequency is within spec.
    674            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fbe_fei_1: (+1)
   \   00000028   0x....             LDR      R1,??DataTable13  ;; 0xffff85ee
   \   0000002A   0x1841             ADDS     R1,R0,R1
   \   0000002C   0x....             LDR      R2,??DataTable13_1  ;; 0x1e86
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD301             BCC      ??fbe_fei_2
    675            {
    676              return 0x31;
   \   00000032   0x2031             MOVS     R0,#+49
   \   00000034   0xBD70             POP      {R4-R6,PC}
    677            }
    678            
    679          // Check resulting FLL frequency 
    680            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fbe_fei_2: (+1)
   \   00000036   0x.... 0x....      BL       fll_freq
    681            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   0000003A   0x283C             CMP      R0,#+60
   \   0000003C   0xDB21             BLT      ??fbe_fei_3
    682          
    683          // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
    684            MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
   \   0000003E   0x7961             LDRB     R1,[R4, #+5]
   \   00000040   0x22DF             MOVS     R2,#+223
   \   00000042   0x400A             ANDS     R2,R2,R1
   \   00000044   0x7162             STRB     R2,[R4, #+5]
    685            
    686          // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
    687            temp_reg = MCG_C1;
   \   00000046   0x7821             LDRB     R1,[R4, #+0]
    688            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
    689            temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
    690            MCG_C1 = temp_reg; // update MCG_C1 
   \   00000048   0x0689             LSLS     R1,R1,#+26
   \   0000004A   0x0E89             LSRS     R1,R1,#+26
   \   0000004C   0x2204             MOVS     R2,#+4
   \   0000004E   0x430A             ORRS     R2,R2,R1
   \   00000050   0x7022             STRB     R2,[R4, #+0]
    691            
    692          // wait for Reference clock Status bit to set
    693            for (i = 0 ; i < 2000 ; i++)
   \   00000052   0x21FA             MOVS     R1,#+250
   \   00000054   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000056   0x000A             MOVS     R2,R1
    694            {
    695              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \                     ??fbe_fei_4: (+1)
   \   00000058   0x79A3             LDRB     R3,[R4, #+6]
   \   0000005A   0x4233             TST      R3,R6
   \   0000005C   0xD101             BNE      ??fbe_fei_5
    696            }
   \   0000005E   0x1E52             SUBS     R2,R2,#+1
   \   00000060   0xD1FA             BNE      ??fbe_fei_4
    697            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbe_fei_5: (+1)
   \   00000062   0x79A2             LDRB     R2,[R4, #+6]
   \   00000064   0x4232             TST      R2,R6
   \   00000066   0xD101             BNE      ??fbe_fei_6
   \   00000068   0x2012             MOVS     R0,#+18
   \   0000006A   0xBD70             POP      {R4-R6,PC}
    698            
    699          // Wait for clock status bits to show clock source is ext ref clk
    700            for (i = 0 ; i < 2000 ; i++)
    701            {
    702              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \                     ??fbe_fei_6: (+1)
   \   0000006C   0x79A2             LDRB     R2,[R4, #+6]
   \   0000006E   0x0892             LSRS     R2,R2,#+2
   \   00000070   0x402A             ANDS     R2,R2,R5
   \   00000072   0xD001             BEQ      ??fbe_fei_7
    703            }
   \   00000074   0x1E49             SUBS     R1,R1,#+1
   \   00000076   0xD1F9             BNE      ??fbe_fei_6
    704            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is really selected and return with error if not
   \                     ??fbe_fei_7: (+1)
   \   00000078   0x79A1             LDRB     R1,[R4, #+6]
   \   0000007A   0x0889             LSRS     R1,R1,#+2
   \   0000007C   0x400D             ANDS     R5,R5,R1
   \   0000007E   0xD000             BEQ      ??fbe_fei_3
   \   00000080   0x2018             MOVS     R0,#+24
    705          
    706          // Now in FEI mode
    707            return mcg_out;
   \                     ??fbe_fei_3: (+1)
   \   00000082   0xBD70             POP      {R4-R6,PC}       ;; return
    708          } // fbe_fei
    709          
    710          
    711          /********************************************************************/
    712          /* Functon name : fei_fbe
    713           *
    714           * Mode transition: FEI to FBE mode
    715           *
    716           * This function transitions the MCG from FEI mode to FBE mode. This is
    717           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
    718           * check so 0 is always returned if the function was called with the MCG
    719           * in FBI mode. The MCGCLKOUT frequency does not change
    720           *
    721           * Parameters: crystal_val - external clock frequency in Hz
    722           *             hgo_val     - selects whether low power or high gain mode is selected
    723           *                           for the crystal oscillator. This has no meaning if an 
    724           *                           external clock is used.
    725           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
    726           *
    727           * Return value : MCGCLKOUT frequency (Hz) or error code
    728           */

   \                                 In section .text, align 2, keep-with-next
    729          int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
    730          {
   \                     fei_fbe: (+1)
   \   00000000   0xB4F5             PUSH     {R0,R2,R4-R7}
    731            unsigned char frdiv_val;
    732            unsigned char temp_reg;
    733            short i;
    734            
    735          // check if in FEI mode
    736            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    737                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    738                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R2,??DataTable12  ;; 0x40064000
   \   00000004   0x2303             MOVS     R3,#+3
   \   00000006   0x7990             LDRB     R0,[R2, #+6]
   \   00000008   0x0880             LSRS     R0,R0,#+2
   \   0000000A   0x4018             ANDS     R0,R0,R3
   \   0000000C   0xD107             BNE      ??fei_fbe_0
   \   0000000E   0x2510             MOVS     R5,#+16
   \   00000010   0x7990             LDRB     R0,[R2, #+6]
   \   00000012   0x4228             TST      R0,R5
   \   00000014   0xD003             BEQ      ??fei_fbe_0
   \   00000016   0x2420             MOVS     R4,#+32
   \   00000018   0x7990             LDRB     R0,[R2, #+6]
   \   0000001A   0x4220             TST      R0,R4
   \   0000001C   0xD001             BEQ      ??fei_fbe_1
    739            {
    740              return 0x1;                                                     // return error code
   \                     ??fei_fbe_0: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE081             B        ??fei_fbe_2
    741            }
    742          
    743          // check external frequency is less than the maximum frequency
    744            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fei_fbe_1: (+1)
   \   00000022   0x9800             LDR      R0,[SP, #+0]
   \   00000024   0x....             LDR      R6,??DataTable13_2  ;; 0x2faf081
   \   00000026   0x42B0             CMP      R0,R6
   \   00000028   0xDB01             BLT      ??fei_fbe_3
   \   0000002A   0x2021             MOVS     R0,#+33
   \   0000002C   0xE07B             B        ??fei_fbe_2
    745            
    746          // check crystal frequency is within spec. if crystal osc is being used
    747            if (erefs_val)
   \                     ??fei_fbe_3: (+1)
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x7900             LDRB     R0,[R0, #+4]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD00E             BEQ      ??fei_fbe_4
    748            {
    749              if ((crystal_val < 30000) ||
    750                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
    751                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000036   0x9800             LDR      R0,[SP, #+0]
   \   00000038   0x....             LDR      R6,??DataTable13_3  ;; 0x7530
   \   0000003A   0x42B0             CMP      R0,R6
   \   0000003C   0xDB08             BLT      ??fei_fbe_5
   \   0000003E   0x....             LDR      R6,??DataTable13_4  ;; 0xffff63bf
   \   00000040   0x1980             ADDS     R0,R0,R6
   \   00000042   0x....             LDR      R6,??DataTable13_5  ;; 0x2d2a7f
   \   00000044   0x42B0             CMP      R0,R6
   \   00000046   0xD303             BCC      ??fei_fbe_5
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x....             LDR      R6,??DataTable13_6  ;; 0x1e84801
   \   0000004C   0x42B0             CMP      R0,R6
   \   0000004E   0xDB01             BLT      ??fei_fbe_4
   \                     ??fei_fbe_5: (+1)
   \   00000050   0x2022             MOVS     R0,#+34
   \   00000052   0xE068             B        ??fei_fbe_2
    752            }
    753          
    754          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
    755            if (hgo_val > 0)
   \                     ??fei_fbe_4: (+1)
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD000             BEQ      ??fei_fbe_6
    756            {
    757              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000058   0x2101             MOVS     R1,#+1
    758            }
    759          
    760          // configure the MCG_C2 register
    761          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
    762          // it still needs to be set correctly even if the oscillator is not being used
    763            temp_reg = MCG_C2;
   \                     ??fei_fbe_6: (+1)
   \   0000005A   0x7850             LDRB     R0,[R2, #+1]
    764            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   0000005C   0x26C3             MOVS     R6,#+195
   \   0000005E   0x4006             ANDS     R6,R6,R0
    765            if (crystal_val <= 40000)
   \   00000060   0x00C9             LSLS     R1,R1,#+3
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x7900             LDRB     R0,[R0, #+4]
   \   00000066   0x0080             LSLS     R0,R0,#+2
   \   00000068   0x4308             ORRS     R0,R0,R1
   \   0000006A   0x9900             LDR      R1,[SP, #+0]
   \   0000006C   0x....             LDR      R7,??DataTable14  ;; 0x9c41
   \   0000006E   0x42B9             CMP      R1,R7
   \   00000070   0xDB05             BLT      ??fei_fbe_7
    766            {
    767              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
    768            }
    769            else if (crystal_val <= 8000000)
   \   00000072   0x....             LDR      R7,??DataTable14_1  ;; 0x7a1201
   \   00000074   0x42B9             CMP      R1,R7
   \   00000076   0xDA01             BGE      ??fei_fbe_8
    770            {
    771              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000078   0x4328             ORRS     R0,R0,R5
   \   0000007A   0xE000             B        ??fei_fbe_7
    772            }
    773            else
    774            {
    775              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fei_fbe_8: (+1)
   \   0000007C   0x4320             ORRS     R0,R0,R4
   \                     ??fei_fbe_7: (+1)
   \   0000007E   0x4330             ORRS     R0,R0,R6
    776            }
    777            MCG_C2 = temp_reg;
   \   00000080   0x7050             STRB     R0,[R2, #+1]
    778          // determine FRDIV based on reference clock frequency
    779          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
    780            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   00000082   0x9800             LDR      R0,[SP, #+0]
   \   00000084   0x....             LDR      R1,??DataTable14_2  ;; 0x1312d1
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xDA01             BGE      ??fei_fbe_9
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0xE014             B        ??fei_fbe_10
    781            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fei_fbe_9: (+1)
   \   0000008E   0x....             LDR      R1,??DataTable14_3  ;; 0x2625a1
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xDA01             BGE      ??fei_fbe_11
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0xE00F             B        ??fei_fbe_10
    782            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fei_fbe_11: (+1)
   \   00000098   0x....             LDR      R1,??DataTable14_4  ;; 0x4c4b41
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xDA01             BGE      ??fei_fbe_12
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0xE00A             B        ??fei_fbe_10
    783            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fei_fbe_12: (+1)
   \   000000A2   0x....             LDR      R1,??DataTable14_5  ;; 0x989681
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xDA01             BGE      ??fei_fbe_13
   \   000000A8   0x2003             MOVS     R0,#+3
   \   000000AA   0xE005             B        ??fei_fbe_10
    784            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fei_fbe_13: (+1)
   \   000000AC   0x....             LDR      R1,??DataTable14_6  ;; 0x1312d01
   \   000000AE   0x4288             CMP      R0,R1
   \   000000B0   0xDA01             BGE      ??fei_fbe_14
   \   000000B2   0x2004             MOVS     R0,#+4
   \   000000B4   0xE000             B        ??fei_fbe_10
    785            else {frdiv_val = 5;}
   \                     ??fei_fbe_14: (+1)
   \   000000B6   0x2005             MOVS     R0,#+5
    786            
    787          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    788          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
    789          // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
    790            temp_reg = MCG_C1;
   \                     ??fei_fbe_10: (+1)
   \   000000B8   0x7811             LDRB     R1,[R2, #+0]
    791            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
    792            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
    793            MCG_C1 = temp_reg;
   \   000000BA   0x2603             MOVS     R6,#+3
   \   000000BC   0x400E             ANDS     R6,R6,R1
   \   000000BE   0x00C0             LSLS     R0,R0,#+3
   \   000000C0   0x4330             ORRS     R0,R0,R6
   \   000000C2   0x2180             MOVS     R1,#+128
   \   000000C4   0x4301             ORRS     R1,R1,R0
   \   000000C6   0x7011             STRB     R1,[R2, #+0]
    794          
    795          // if the external oscillator is used need to wait for OSCINIT to set
    796            if (erefs_val)
   \   000000C8   0x4668             MOV      R0,SP
   \   000000CA   0x7900             LDRB     R0,[R0, #+4]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD00B             BEQ      ??fei_fbe_15
    797            {
    798              for (i = 0 ; i < 10000 ; i++)
   \   000000D0   0x....             LDR      R0,??DataTable14_7  ;; 0x2710
   \   000000D2   0x2102             MOVS     R1,#+2
    799              {
    800                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \                     ??fei_fbe_16: (+1)
   \   000000D4   0x7997             LDRB     R7,[R2, #+6]
   \   000000D6   0x420F             TST      R7,R1
   \   000000D8   0xD101             BNE      ??fei_fbe_17
    801              }
   \   000000DA   0x1E40             SUBS     R0,R0,#+1
   \   000000DC   0xD1FA             BNE      ??fei_fbe_16
    802              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fei_fbe_17: (+1)
   \   000000DE   0x7990             LDRB     R0,[R2, #+6]
   \   000000E0   0x4208             TST      R0,R1
   \   000000E2   0xD101             BNE      ??fei_fbe_15
   \   000000E4   0x2023             MOVS     R0,#+35
   \   000000E6   0xE01E             B        ??fei_fbe_2
    803            }
    804          
    805          // wait for Reference clock Status bit to clear
    806            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbe_15: (+1)
   \   000000E8   0x20FA             MOVS     R0,#+250
   \   000000EA   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   000000EC   0x0001             MOVS     R1,R0
    807            {
    808              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \                     ??fei_fbe_18: (+1)
   \   000000EE   0x7997             LDRB     R7,[R2, #+6]
   \   000000F0   0x422F             TST      R7,R5
   \   000000F2   0xD001             BEQ      ??fei_fbe_19
    809            }
   \   000000F4   0x1E49             SUBS     R1,R1,#+1
   \   000000F6   0xD1FA             BNE      ??fei_fbe_18
    810            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fei_fbe_19: (+1)
   \   000000F8   0x7991             LDRB     R1,[R2, #+6]
   \   000000FA   0x4229             TST      R1,R5
   \   000000FC   0xD001             BEQ      ??fei_fbe_20
   \   000000FE   0x2011             MOVS     R0,#+17
   \   00000100   0xE011             B        ??fei_fbe_2
    811            
    812          // Wait for clock status bits to show clock source is ext ref clk
    813            for (i = 0 ; i < 2000 ; i++)
    814            {
    815              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \                     ??fei_fbe_20: (+1)
   \   00000102   0x7991             LDRB     R1,[R2, #+6]
   \   00000104   0x0889             LSRS     R1,R1,#+2
   \   00000106   0x4019             ANDS     R1,R1,R3
   \   00000108   0x2902             CMP      R1,#+2
   \   0000010A   0xD001             BEQ      ??fei_fbe_21
    816            }
   \   0000010C   0x1E40             SUBS     R0,R0,#+1
   \   0000010E   0xD1F8             BNE      ??fei_fbe_20
    817            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fei_fbe_21: (+1)
   \   00000110   0x7990             LDRB     R0,[R2, #+6]
   \   00000112   0x0880             LSRS     R0,R0,#+2
   \   00000114   0x4003             ANDS     R3,R3,R0
   \   00000116   0x2B02             CMP      R3,#+2
   \   00000118   0xD001             BEQ      ??fei_fbe_22
   \   0000011A   0x201A             MOVS     R0,#+26
   \   0000011C   0xE003             B        ??fei_fbe_2
    818           
    819          // Now in FBE  
    820          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
    821          // It is enabled here but can be removed if this is not required.
    822            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fei_fbe_22: (+1)
   \   0000011E   0x7950             LDRB     R0,[R2, #+5]
   \   00000120   0x4304             ORRS     R4,R4,R0
   \   00000122   0x7154             STRB     R4,[R2, #+5]
    823            
    824            return crystal_val; // MCGOUT frequency equals external clock frequency
   \   00000124   0x9800             LDR      R0,[SP, #+0]
   \                     ??fei_fbe_2: (+1)
   \   00000126   0xBCF6             POP      {R1,R2,R4-R7}
   \   00000128   0x4770             BX       LR               ;; return
    825          } // fei_fbe
    826          
    827          

   \                                 In section .text, align 2, keep-with-next
    828          int fbe_fee(int crystal_val)
    829          {
   \                     fbe_fee: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    830            short i, fll_ref_freq;
    831            int mcg_out;
    832          
    833          // Check MCG is in FBE mode
    834            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    835                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    836                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    837                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R4,??DataTable12  ;; 0x40064000
   \   00000004   0x2503             MOVS     R5,#+3
   \   00000006   0x79A1             LDRB     R1,[R4, #+6]
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x4029             ANDS     R1,R1,R5
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD109             BNE      ??fbe_fee_0
   \   00000010   0x79A1             LDRB     R1,[R4, #+6]
   \   00000012   0x06C9             LSLS     R1,R1,#+27
   \   00000014   0xD406             BMI      ??fbe_fee_0
   \   00000016   0x2120             MOVS     R1,#+32
   \   00000018   0x79A2             LDRB     R2,[R4, #+6]
   \   0000001A   0x420A             TST      R2,R1
   \   0000001C   0xD102             BNE      ??fbe_fee_0
   \   0000001E   0x7862             LDRB     R2,[R4, #+1]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD501             BPL      ??fbe_fee_1
    838            {
    839              return 0x4;                                                       // return error code
   \                     ??fbe_fee_0: (+1)
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}
    840            }
    841            
    842            // The FLL ref clk divide value depends on FRDIV and the RANGE value
    843            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fbe_fee_1: (+1)
   \   00000028   0x7862             LDRB     R2,[R4, #+1]
   \   0000002A   0x0912             LSRS     R2,R2,#+4
   \   0000002C   0x402A             ANDS     R2,R2,R5
   \   0000002E   0xD004             BEQ      ??fbe_fee_2
    844            {
    845              fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
   \   00000030   0x7822             LDRB     R2,[R4, #+0]
   \   00000032   0x0692             LSLS     R2,R2,#+26
   \   00000034   0x0F52             LSRS     R2,R2,#+29
   \   00000036   0x4091             LSLS     R1,R1,R2
   \   00000038   0xE005             B        ??fbe_fee_3
    846            }
    847            else
    848            {
    849              fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT))));
   \                     ??fbe_fee_2: (+1)
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x7862             LDRB     R2,[R4, #+1]
   \   0000003E   0x0912             LSRS     R2,R2,#+4
   \   00000040   0x2303             MOVS     R3,#+3
   \   00000042   0x4013             ANDS     R3,R3,R2
   \   00000044   0x4099             LSLS     R1,R1,R3
   \                     ??fbe_fee_3: (+1)
   \   00000046   0x.... 0x....      BL       __aeabi_idiv
    850            }
    851            
    852          // Check resulting FLL frequency 
    853            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \   0000004A   0xB200             SXTH     R0,R0
   \   0000004C   0x.... 0x....      BL       fll_freq
    854            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000050   0x283C             CMP      R0,#+60
   \   00000052   0xDB10             BLT      ??fbe_fee_4
    855            
    856          // Clear CLKS field to switch CLKS mux to select FLL output
    857            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
   \   00000054   0x7821             LDRB     R1,[R4, #+0]
   \   00000056   0x0689             LSLS     R1,R1,#+26
   \   00000058   0x0E89             LSRS     R1,R1,#+26
   \   0000005A   0x7021             STRB     R1,[R4, #+0]
    858          
    859          // Wait for clock status bits to show clock source is FLL
    860            for (i = 0 ; i < 2000 ; i++)
   \   0000005C   0x21FA             MOVS     R1,#+250
   \   0000005E   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
    861            {
    862              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL selected before loop finishes
   \                     ??fbe_fee_5: (+1)
   \   00000060   0x79A2             LDRB     R2,[R4, #+6]
   \   00000062   0x0892             LSRS     R2,R2,#+2
   \   00000064   0x402A             ANDS     R2,R2,R5
   \   00000066   0xD001             BEQ      ??fbe_fee_6
    863            }
   \   00000068   0x1E49             SUBS     R1,R1,#+1
   \   0000006A   0xD1F9             BNE      ??fbe_fee_5
    864            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really selected and return with error if not
   \                     ??fbe_fee_6: (+1)
   \   0000006C   0x79A1             LDRB     R1,[R4, #+6]
   \   0000006E   0x0889             LSRS     R1,R1,#+2
   \   00000070   0x400D             ANDS     R5,R5,R1
   \   00000072   0xD000             BEQ      ??fbe_fee_4
   \   00000074   0x2018             MOVS     R0,#+24
    865            
    866          // Now in FEE mode
    867            return mcg_out;
   \                     ??fbe_fee_4: (+1)
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    868          } // fbe_fee
    869          
    870          

   \                                 In section .text, align 2, keep-with-next
    871          int fee_fbe(int crystal_val)
    872          { 
   \                     fee_fbe: (+1)
   \   00000000   0xB410             PUSH     {R4}
    873            short i;
    874            
    875          // Check MCG is in FEE mode
    876            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
    877                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    878                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R1,??DataTable15  ;; 0x40064000
   \   00000004   0x2203             MOVS     R2,#+3
   \   00000006   0x798B             LDRB     R3,[R1, #+6]
   \   00000008   0x089B             LSRS     R3,R3,#+2
   \   0000000A   0x4013             ANDS     R3,R3,R2
   \   0000000C   0xD105             BNE      ??fee_fbe_0
   \   0000000E   0x798B             LDRB     R3,[R1, #+6]
   \   00000010   0x06DB             LSLS     R3,R3,#+27
   \   00000012   0xD402             BMI      ??fee_fbe_0
   \   00000014   0x798B             LDRB     R3,[R1, #+6]
   \   00000016   0x069B             LSLS     R3,R3,#+26
   \   00000018   0xD501             BPL      ??fee_fbe_1
    879            {
    880              return 0x2;                                                       // return error code
   \                     ??fee_fbe_0: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE012             B        ??fee_fbe_2
    881            }
    882            
    883          // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
    884          // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
    885            MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
   \                     ??fee_fbe_1: (+1)
   \   0000001E   0x780B             LDRB     R3,[R1, #+0]
   \   00000020   0x2480             MOVS     R4,#+128
   \   00000022   0x431C             ORRS     R4,R4,R3
   \   00000024   0x700C             STRB     R4,[R1, #+0]
    886          
    887          /// Wait for clock status bits to show clock source is ext ref clk
    888            for (i = 0 ; i < 2000 ; i++)
   \   00000026   0x23FA             MOVS     R3,#+250
   \   00000028   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
    889            {
    890              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \                     ??fee_fbe_3: (+1)
   \   0000002A   0x798C             LDRB     R4,[R1, #+6]
   \   0000002C   0x08A4             LSRS     R4,R4,#+2
   \   0000002E   0x4014             ANDS     R4,R4,R2
   \   00000030   0x2C02             CMP      R4,#+2
   \   00000032   0xD001             BEQ      ??fee_fbe_4
    891            }
   \   00000034   0x1E5B             SUBS     R3,R3,#+1
   \   00000036   0xD1F8             BNE      ??fee_fbe_3
    892            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fee_fbe_4: (+1)
   \   00000038   0x7989             LDRB     R1,[R1, #+6]
   \   0000003A   0x0889             LSRS     R1,R1,#+2
   \   0000003C   0x400A             ANDS     R2,R2,R1
   \   0000003E   0x2A02             CMP      R2,#+2
   \   00000040   0xD000             BEQ      ??fee_fbe_2
   \   00000042   0x201A             MOVS     R0,#+26
    893            
    894          // Now in FBE mode
    895            return crystal_val;
   \                     ??fee_fbe_2: (+1)
   \   00000044   0xBC10             POP      {R4}
   \   00000046   0x4770             BX       LR               ;; return
    896          } // fee_fbe
    897          
    898          

   \                                 In section .text, align 2, keep-with-next
    899          int fbe_fbi(int irc_freq, unsigned char irc_select)
    900          {
   \                     fbe_fbi: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    901            unsigned char temp_reg;
    902            unsigned char fcrdiv_val;
    903            short i;
    904            
    905          // Check MCG is in FBE mode
    906            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    907                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    908                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    909                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R3,??DataTable15  ;; 0x40064000
   \   00000004   0x2503             MOVS     R5,#+3
   \   00000006   0x799A             LDRB     R2,[R3, #+6]
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x402A             ANDS     R2,R2,R5
   \   0000000C   0x2A02             CMP      R2,#+2
   \   0000000E   0xD109             BNE      ??fbe_fbi_0
   \   00000010   0x2410             MOVS     R4,#+16
   \   00000012   0x799A             LDRB     R2,[R3, #+6]
   \   00000014   0x4222             TST      R2,R4
   \   00000016   0xD105             BNE      ??fbe_fbi_0
   \   00000018   0x799A             LDRB     R2,[R3, #+6]
   \   0000001A   0x0692             LSLS     R2,R2,#+26
   \   0000001C   0xD402             BMI      ??fbe_fbi_0
   \   0000001E   0x785A             LDRB     R2,[R3, #+1]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD501             BPL      ??fbe_fbi_1
    910            {
    911              return 0x4;                                                       // return error code
   \                     ??fbe_fbi_0: (+1)
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0xBDF0             POP      {R4-R7,PC}
    912            }
    913          
    914          // Check that the irc frequency matches the selected IRC 
    915            if (!(irc_select))
   \                     ??fbe_fbi_1: (+1)
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD106             BNE      ??fbe_fbi_2
    916            {    
    917              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   0000002C   0x....             LDR      R2,??DataTable16  ;; 0xffff85ee
   \   0000002E   0x1882             ADDS     R2,R0,R2
   \   00000030   0x....             LDR      R6,??DataTable16_1  ;; 0x1e86
   \   00000032   0x42B2             CMP      R2,R6
   \   00000034   0xD30C             BCC      ??fbe_fbi_3
   \   00000036   0x2031             MOVS     R0,#+49
   \   00000038   0xBDF0             POP      {R4-R7,PC}
    918            }
    919            else
    920            {
    921              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fbe_fbi_2: (+1)
   \   0000003A   0x....             LDR      R2,??DataTable16_2  ;; 0xffd23940
   \   0000003C   0x1882             ADDS     R2,R0,R2
   \   0000003E   0x....             LDR      R6,??DataTable16_3  ;; 0x1e8481
   \   00000040   0x42B2             CMP      R2,R6
   \   00000042   0xD301             BCC      ??fbe_fbi_4
   \   00000044   0x2032             MOVS     R0,#+50
   \   00000046   0xBDF0             POP      {R4-R7,PC}
    922            }
    923            
    924          // Select the required IRC
    925            if (irc_select)
    926            {
    927              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
   \                     ??fbe_fbi_4: (+1)
   \   00000048   0x785A             LDRB     R2,[R3, #+1]
   \   0000004A   0x2601             MOVS     R6,#+1
   \   0000004C   0x4316             ORRS     R6,R6,R2
   \   0000004E   0xE002             B        ??fbe_fbi_5
    928            }
    929            else
    930            {
    931              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
   \                     ??fbe_fbi_3: (+1)
   \   00000050   0x785A             LDRB     R2,[R3, #+1]
   \   00000052   0x26FE             MOVS     R6,#+254
   \   00000054   0x4016             ANDS     R6,R6,R2
   \                     ??fbe_fbi_5: (+1)
   \   00000056   0x705E             STRB     R6,[R3, #+1]
    932            }
    933            
    934          // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
    935            MCG_C6 &= ~MCG_C6_CME0_MASK;
   \   00000058   0x795A             LDRB     R2,[R3, #+5]
   \   0000005A   0x26DF             MOVS     R6,#+223
   \   0000005C   0x4016             ANDS     R6,R6,R2
   \   0000005E   0x715E             STRB     R6,[R3, #+5]
    936            
    937          // Select the IRC as the CLKS mux selection
    938            temp_reg = MCG_C1;
   \   00000060   0x781A             LDRB     R2,[R3, #+0]
    939            temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
    940            temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
    941            MCG_C1 = temp_reg; // update MCG_C1
   \   00000062   0x0692             LSLS     R2,R2,#+26
   \   00000064   0x0E92             LSRS     R2,R2,#+26
   \   00000066   0x2644             MOVS     R6,#+68
   \   00000068   0x4316             ORRS     R6,R6,R2
   \   0000006A   0x701E             STRB     R6,[R3, #+0]
    942            
    943          // wait until internal reference switches to requested irc.
    944            if (!(irc_select))
   \   0000006C   0x22FA             MOVS     R2,#+250
   \   0000006E   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000070   0x2900             CMP      R1,#+0
   \   00000072   0xD10A             BNE      ??fbe_fbi_6
    945            {
    946              for (i = 0 ; i < 2000 ; i++)
   \   00000074   0x0016             MOVS     R6,R2
    947              {
    948                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \                     ??fbe_fbi_7: (+1)
   \   00000076   0x799F             LDRB     R7,[R3, #+6]
   \   00000078   0x07FF             LSLS     R7,R7,#+31
   \   0000007A   0xD501             BPL      ??fbe_fbi_8
    949              }
   \   0000007C   0x1E76             SUBS     R6,R6,#+1
   \   0000007E   0xD1FA             BNE      ??fbe_fbi_7
    950              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fbe_fbi_8: (+1)
   \   00000080   0x799E             LDRB     R6,[R3, #+6]
   \   00000082   0x07F6             LSLS     R6,R6,#+31
   \   00000084   0xD50C             BPL      ??fbe_fbi_9
   \   00000086   0x2013             MOVS     R0,#+19
   \   00000088   0xBDF0             POP      {R4-R7,PC}
    951            }
    952            else
    953            {
    954              for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_6: (+1)
   \   0000008A   0x0016             MOVS     R6,R2
    955              {
    956                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \                     ??fbe_fbi_10: (+1)
   \   0000008C   0x799F             LDRB     R7,[R3, #+6]
   \   0000008E   0x07FF             LSLS     R7,R7,#+31
   \   00000090   0xD401             BMI      ??fbe_fbi_11
    957              }
   \   00000092   0x1E76             SUBS     R6,R6,#+1
   \   00000094   0xD1FA             BNE      ??fbe_fbi_10
    958              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fbe_fbi_11: (+1)
   \   00000096   0x799E             LDRB     R6,[R3, #+6]
   \   00000098   0x07F6             LSLS     R6,R6,#+31
   \   0000009A   0xD401             BMI      ??fbe_fbi_9
   \   0000009C   0x2014             MOVS     R0,#+20
   \   0000009E   0xBDF0             POP      {R4-R7,PC}
    959            }
    960           
    961          // Wait for clock status bits to update
    962            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_9: (+1)
   \   000000A0   0x0016             MOVS     R6,R2
    963            {
    964              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \                     ??fbe_fbi_12: (+1)
   \   000000A2   0x799F             LDRB     R7,[R3, #+6]
   \   000000A4   0x08BF             LSRS     R7,R7,#+2
   \   000000A6   0x402F             ANDS     R7,R7,R5
   \   000000A8   0x2F01             CMP      R7,#+1
   \   000000AA   0xD001             BEQ      ??fbe_fbi_13
    965            }
   \   000000AC   0x1E76             SUBS     R6,R6,#+1
   \   000000AE   0xD1F8             BNE      ??fbe_fbi_12
    966            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fbe_fbi_13: (+1)
   \   000000B0   0x799E             LDRB     R6,[R3, #+6]
   \   000000B2   0x08B6             LSRS     R6,R6,#+2
   \   000000B4   0x4035             ANDS     R5,R5,R6
   \   000000B6   0x2D01             CMP      R5,#+1
   \   000000B8   0xD001             BEQ      ??fbe_fbi_14
   \   000000BA   0x2019             MOVS     R0,#+25
   \   000000BC   0xBDF0             POP      {R4-R7,PC}
    967            
    968            // wait for Reference clock Status bit to set
    969            for (i = 0 ; i < 2000 ; i++)
    970            {
    971              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \                     ??fbe_fbi_14: (+1)
   \   000000BE   0x799D             LDRB     R5,[R3, #+6]
   \   000000C0   0x4225             TST      R5,R4
   \   000000C2   0xD101             BNE      ??fbe_fbi_15
    972            }
   \   000000C4   0x1E52             SUBS     R2,R2,#+1
   \   000000C6   0xD1FA             BNE      ??fbe_fbi_14
    973            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbe_fbi_15: (+1)
   \   000000C8   0x799A             LDRB     R2,[R3, #+6]
   \   000000CA   0x4222             TST      R2,R4
   \   000000CC   0xD101             BNE      ??fbe_fbi_16
   \   000000CE   0x2012             MOVS     R0,#+18
   \   000000D0   0xBDF0             POP      {R4-R7,PC}
    974            
    975          // Now in FBI mode
    976            
    977            if (irc_select)
   \                     ??fbe_fbi_16: (+1)
   \   000000D2   0x....             B.N      ?Subroutine0
    978            {
    979              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
    980              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV factor
    981            }
    982            else
    983            {
    984              return irc_freq; // MCGOUT frequency equals slow IRC frequency
    985            }
    986          } //fbe_fbi

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD007             BEQ      ??Subroutine0_0
   \   00000004   0x7A1A             LDRB     R2,[R3, #+8]
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0712             LSLS     R2,R2,#+28
   \   0000000A   0x0F52             LSRS     R2,R2,#+29
   \   0000000C   0x4091             LSLS     R1,R1,R2
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x.... 0x....      BL       __aeabi_idiv
   \                     ??Subroutine0_0: (+1)
   \   00000014   0xBDF0             POP      {R4-R7,PC}       ;; return
    987          
    988          

   \                                 In section .text, align 2, keep-with-next
    989          int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
    990          {
   \                     fbi_fbe: (+1)
   \   00000000   0xB4F5             PUSH     {R0,R2,R4-R7}
    991            unsigned char temp_reg;
    992            unsigned char frdiv_val;
    993            short i;
    994            
    995          // check if in FBI mode
    996            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
    997                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    998                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    999                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x2203             MOVS     R2,#+3
   \   00000004   0x....             LDR      R3,??DataTable15  ;; 0x40064000
   \   00000006   0x7998             LDRB     R0,[R3, #+6]
   \   00000008   0x0880             LSRS     R0,R0,#+2
   \   0000000A   0x4010             ANDS     R0,R0,R2
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD10A             BNE      ??fbi_fbe_0
   \   00000010   0x2410             MOVS     R4,#+16
   \   00000012   0x7998             LDRB     R0,[R3, #+6]
   \   00000014   0x4220             TST      R0,R4
   \   00000016   0xD006             BEQ      ??fbi_fbe_0
   \   00000018   0x7998             LDRB     R0,[R3, #+6]
   \   0000001A   0x0680             LSLS     R0,R0,#+26
   \   0000001C   0xD403             BMI      ??fbi_fbe_0
   \   0000001E   0x2502             MOVS     R5,#+2
   \   00000020   0x7858             LDRB     R0,[R3, #+1]
   \   00000022   0x4228             TST      R0,R5
   \   00000024   0xD001             BEQ      ??fbi_fbe_1
   1000            {  
   1001              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fbe_0: (+1)
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE083             B        ??fbi_fbe_2
   1002            }
   1003           
   1004          // check external frequency is less than the maximum frequency
   1005            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fbi_fbe_1: (+1)
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x....             LDR      R6,??DataTable16_4  ;; 0x2faf081
   \   0000002E   0x42B0             CMP      R0,R6
   \   00000030   0xDB01             BLT      ??fbi_fbe_3
   \   00000032   0x2021             MOVS     R0,#+33
   \   00000034   0xE07D             B        ??fbi_fbe_2
   1006            
   1007          // check crystal frequency is within spec. if crystal osc is being used
   1008            if (erefs_val)
   \                     ??fbi_fbe_3: (+1)
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x7900             LDRB     R0,[R0, #+4]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD00E             BEQ      ??fbi_fbe_4
   1009            {
   1010              if ((crystal_val < 30000) ||
   1011                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1012                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x....             LDR      R6,??DataTable16_5  ;; 0x7530
   \   00000042   0x42B0             CMP      R0,R6
   \   00000044   0xDB08             BLT      ??fbi_fbe_5
   \   00000046   0x....             LDR      R6,??DataTable16_6  ;; 0xffff63bf
   \   00000048   0x1980             ADDS     R0,R0,R6
   \   0000004A   0x....             LDR      R6,??DataTable16_7  ;; 0x2d2a7f
   \   0000004C   0x42B0             CMP      R0,R6
   \   0000004E   0xD303             BCC      ??fbi_fbe_5
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x....             LDR      R6,??DataTable16_8  ;; 0x1e84801
   \   00000054   0x42B0             CMP      R0,R6
   \   00000056   0xDB01             BLT      ??fbi_fbe_4
   \                     ??fbi_fbe_5: (+1)
   \   00000058   0x2022             MOVS     R0,#+34
   \   0000005A   0xE06A             B        ??fbi_fbe_2
   1013            }
   1014          
   1015          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1016            if (hgo_val > 0)
   \                     ??fbi_fbe_4: (+1)
   \   0000005C   0x2900             CMP      R1,#+0
   \   0000005E   0xD000             BEQ      ??fbi_fbe_6
   1017            {
   1018              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000060   0x2101             MOVS     R1,#+1
   1019            }
   1020          
   1021          // configure the MCG_C2 register
   1022          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1023          // it still needs to be set correctly even if the oscillator is not being used
   1024            temp_reg = MCG_C2;
   \                     ??fbi_fbe_6: (+1)
   \   00000062   0x7858             LDRB     R0,[R3, #+1]
   1025            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   00000064   0x26C3             MOVS     R6,#+195
   \   00000066   0x4006             ANDS     R6,R6,R0
   1026            if (crystal_val <= 40000)
   \   00000068   0x00C9             LSLS     R1,R1,#+3
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x7900             LDRB     R0,[R0, #+4]
   \   0000006E   0x0080             LSLS     R0,R0,#+2
   \   00000070   0x4308             ORRS     R0,R0,R1
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x....             LDR      R7,??DataTable16_9  ;; 0x9c41
   \   00000076   0x42B9             CMP      R1,R7
   \   00000078   0xDB07             BLT      ??fbi_fbe_7
   1027            {
   1028              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   1029            }
   1030            else if (crystal_val <= 8000000)
   \   0000007A   0x....             LDR      R7,??DataTable16_10  ;; 0x7a1201
   \   0000007C   0x42B9             CMP      R1,R7
   \   0000007E   0xDA01             BGE      ??fbi_fbe_8
   1031            {
   1032              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000080   0x4320             ORRS     R0,R0,R4
   \   00000082   0xE002             B        ??fbi_fbe_7
   1033            }
   1034            else
   1035            {
   1036              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fbi_fbe_8: (+1)
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x2020             MOVS     R0,#+32
   \   00000088   0x4308             ORRS     R0,R0,R1
   \                     ??fbi_fbe_7: (+1)
   \   0000008A   0x4330             ORRS     R0,R0,R6
   1037            }
   1038            MCG_C2 = temp_reg;
   \   0000008C   0x7058             STRB     R0,[R3, #+1]
   1039          
   1040          // determine FRDIV based on reference clock frequency
   1041          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1042            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   0000008E   0x9800             LDR      R0,[SP, #+0]
   \   00000090   0x....             LDR      R1,??DataTable16_11  ;; 0x1312d1
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xDA01             BGE      ??fbi_fbe_9
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE014             B        ??fbi_fbe_10
   1043            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fbi_fbe_9: (+1)
   \   0000009A   0x....             LDR      R1,??DataTable16_12  ;; 0x2625a1
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xDA01             BGE      ??fbi_fbe_11
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE00F             B        ??fbi_fbe_10
   1044            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fbi_fbe_11: (+1)
   \   000000A4   0x....             LDR      R1,??DataTable16_13  ;; 0x4c4b41
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xDA01             BGE      ??fbi_fbe_12
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0xE00A             B        ??fbi_fbe_10
   1045            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fbi_fbe_12: (+1)
   \   000000AE   0x....             LDR      R1,??DataTable17  ;; 0x989681
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xDA01             BGE      ??fbi_fbe_13
   \   000000B4   0x2003             MOVS     R0,#+3
   \   000000B6   0xE005             B        ??fbi_fbe_10
   1046            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fbi_fbe_13: (+1)
   \   000000B8   0x....             LDR      R1,??DataTable17_1  ;; 0x1312d01
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xDA01             BGE      ??fbi_fbe_14
   \   000000BE   0x2004             MOVS     R0,#+4
   \   000000C0   0xE000             B        ??fbi_fbe_10
   1047            else {frdiv_val = 5;}
   \                     ??fbi_fbe_14: (+1)
   \   000000C2   0x2005             MOVS     R0,#+5
   1048            
   1049          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1050          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1051          // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
   1052            temp_reg = MCG_C1;
   \                     ??fbi_fbe_10: (+1)
   \   000000C4   0x7819             LDRB     R1,[R3, #+0]
   1053            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   1054            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   1055            MCG_C1 = temp_reg;
   \   000000C6   0x2603             MOVS     R6,#+3
   \   000000C8   0x400E             ANDS     R6,R6,R1
   \   000000CA   0x00C0             LSLS     R0,R0,#+3
   \   000000CC   0x4330             ORRS     R0,R0,R6
   \   000000CE   0x2180             MOVS     R1,#+128
   \   000000D0   0x4301             ORRS     R1,R1,R0
   \   000000D2   0x7019             STRB     R1,[R3, #+0]
   1056          
   1057          // if the external oscillator is used need to wait for OSCINIT to set
   1058            if (erefs_val)
   \   000000D4   0x4668             MOV      R0,SP
   \   000000D6   0x7900             LDRB     R0,[R0, #+4]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD00A             BEQ      ??fbi_fbe_15
   1059            {
   1060              for (i = 0 ; i < 10000 ; i++)
   \   000000DC   0x....             LDR      R0,??DataTable17_2  ;; 0x2710
   1061              {
   1062                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \                     ??fbi_fbe_16: (+1)
   \   000000DE   0x7999             LDRB     R1,[R3, #+6]
   \   000000E0   0x4229             TST      R1,R5
   \   000000E2   0xD101             BNE      ??fbi_fbe_17
   1063              }
   \   000000E4   0x1E40             SUBS     R0,R0,#+1
   \   000000E6   0xD1FA             BNE      ??fbi_fbe_16
   1064              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fbi_fbe_17: (+1)
   \   000000E8   0x7998             LDRB     R0,[R3, #+6]
   \   000000EA   0x4228             TST      R0,R5
   \   000000EC   0xD101             BNE      ??fbi_fbe_15
   \   000000EE   0x2023             MOVS     R0,#+35
   \   000000F0   0xE01F             B        ??fbi_fbe_2
   1065            }
   1066          
   1067          // wait for Reference clock Status bit to clear
   1068            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fbe_15: (+1)
   \   000000F2   0x20FA             MOVS     R0,#+250
   \   000000F4   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   000000F6   0x0001             MOVS     R1,R0
   1069            {
   1070              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \                     ??fbi_fbe_18: (+1)
   \   000000F8   0x799D             LDRB     R5,[R3, #+6]
   \   000000FA   0x4225             TST      R5,R4
   \   000000FC   0xD001             BEQ      ??fbi_fbe_19
   1071            }
   \   000000FE   0x1E49             SUBS     R1,R1,#+1
   \   00000100   0xD1FA             BNE      ??fbi_fbe_18
   1072            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fbi_fbe_19: (+1)
   \   00000102   0x7999             LDRB     R1,[R3, #+6]
   \   00000104   0x4221             TST      R1,R4
   \   00000106   0xD001             BEQ      ??fbi_fbe_20
   \   00000108   0x2011             MOVS     R0,#+17
   \   0000010A   0xE012             B        ??fbi_fbe_2
   1073            
   1074          // Wait for clock status bits to show clock source is ext ref clk
   1075            for (i = 0 ; i < 2000 ; i++)
   1076            {
   1077              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \                     ??fbi_fbe_20: (+1)
   \   0000010C   0x7999             LDRB     R1,[R3, #+6]
   \   0000010E   0x0889             LSRS     R1,R1,#+2
   \   00000110   0x4011             ANDS     R1,R1,R2
   \   00000112   0x2902             CMP      R1,#+2
   \   00000114   0xD001             BEQ      ??fbi_fbe_21
   1078            }
   \   00000116   0x1E40             SUBS     R0,R0,#+1
   \   00000118   0xD1F8             BNE      ??fbi_fbe_20
   1079            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fbi_fbe_21: (+1)
   \   0000011A   0x7998             LDRB     R0,[R3, #+6]
   \   0000011C   0x0880             LSRS     R0,R0,#+2
   \   0000011E   0x4002             ANDS     R2,R2,R0
   \   00000120   0x2A02             CMP      R2,#+2
   \   00000122   0xD001             BEQ      ??fbi_fbe_22
   \   00000124   0x201A             MOVS     R0,#+26
   \   00000126   0xE004             B        ??fbi_fbe_2
   1080           
   1081          // Now in FBE  
   1082          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1083          // It is enabled here but can be removed if this is not required.
   1084            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fbi_fbe_22: (+1)
   \   00000128   0x7958             LDRB     R0,[R3, #+5]
   \   0000012A   0x2120             MOVS     R1,#+32
   \   0000012C   0x4301             ORRS     R1,R1,R0
   \   0000012E   0x7159             STRB     R1,[R3, #+5]
   1085            
   1086            return crystal_val; // MCGOUT frequency equals external clock frequency  
   \   00000130   0x9800             LDR      R0,[SP, #+0]
   \                     ??fbi_fbe_2: (+1)
   \   00000132   0xBCF6             POP      {R1,R2,R4-R7}
   \   00000134   0x4770             BX       LR               ;; return
   1087          } // fbi_fbe
   1088          
   1089          
   1090          /********************************************************************/
   1091          /* Functon name : fbi_blpi
   1092           *
   1093           * Mode transition: FBI to BLPI mode
   1094           *
   1095           * This function transitions the MCG from FBI mode to BLPI mode. This is
   1096           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
   1097           * check so 0 is always returned if the function was called with the MCG
   1098           * in FBI mode. 
   1099           *
   1100           * Parameters: irc_freq - internal reference clock frequency
   1101           *             ircs_select - 0 if slow irc, 1 if fast irc
   1102           *
   1103           * Return value : MCGOUT frequency or error code 0x13
   1104           */

   \                                 In section .text, align 2, keep-with-next
   1105          int fbi_blpi(int irc_freq, unsigned char irc_select)
   1106          {
   \                     fbi_blpi: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1107            unsigned char fcrdiv_val;
   1108            
   1109          // check if in FBI mode
   1110            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1111                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1112                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1113                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x....             LDR      R2,??DataTable17_3  ;; 0x40064001
   \   00000004   0x7953             LDRB     R3,[R2, #+5]
   \   00000006   0x071B             LSLS     R3,R3,#+28
   \   00000008   0x0F9B             LSRS     R3,R3,#+30
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD109             BNE      ??fbi_blpi_0
   \   0000000E   0x7953             LDRB     R3,[R2, #+5]
   \   00000010   0x06DB             LSLS     R3,R3,#+27
   \   00000012   0xD506             BPL      ??fbi_blpi_0
   \   00000014   0x7953             LDRB     R3,[R2, #+5]
   \   00000016   0x069B             LSLS     R3,R3,#+26
   \   00000018   0xD403             BMI      ??fbi_blpi_0
   \   0000001A   0x2302             MOVS     R3,#+2
   \   0000001C   0x7814             LDRB     R4,[R2, #+0]
   \   0000001E   0x421C             TST      R4,R3
   \   00000020   0xD001             BEQ      ??fbi_blpi_1
   1114            {  
   1115              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_blpi_0: (+1)
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xBD10             POP      {R4,PC}
   1116            }
   1117          
   1118          // Set LP bit to disable the FLL and enter BLPI
   1119            MCG_C2 |= MCG_C2_LP_MASK;
   \                     ??fbi_blpi_1: (+1)
   \   00000026   0x7814             LDRB     R4,[R2, #+0]
   \   00000028   0x4323             ORRS     R3,R3,R4
   \   0000002A   0x7013             STRB     R3,[R2, #+0]
   1120            
   1121          // Now in BLPI
   1122            if (irc_select)
   \   0000002C   0x....             B.N      ?Subroutine1
   1123            {
   1124              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   1125              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   1126            }
   1127            else
   1128            {
   1129              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   1130            }   
   1131          } // fbi_blpi

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD007             BEQ      ??Subroutine1_0
   \   00000004   0x79D2             LDRB     R2,[R2, #+7]
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x0712             LSLS     R2,R2,#+28
   \   0000000A   0x0F52             LSRS     R2,R2,#+29
   \   0000000C   0x4091             LSLS     R1,R1,R2
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x.... 0x....      BL       __aeabi_idiv
   \                     ??Subroutine1_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1132          
   1133          
   1134          
   1135          /********************************************************************/
   1136          /* Functon name : blpi_fbi
   1137           *
   1138           * Mode transition: BLPI to FBI mode
   1139           *
   1140           * This function transitions the MCG from BLPI mode to FBI mode. This is
   1141           * achieved by clearing the MCG_C2[LP] bit. There is no status bit to 
   1142           * check so 0 is always returned if the function was called with the MCG
   1143           * in BLPI mode. 
   1144           *
   1145           * Parameters: irc_freq - internal reference clock frequency
   1146           *             ircs_select - 0 if slow irc, 1 if fast irc
   1147           *
   1148           * Return value : MCGOUT frequency or error code 0x15
   1149           */

   \                                 In section .text, align 2, keep-with-next
   1150          int blpi_fbi(int irc_freq, unsigned char irc_select)
   1151          {
   \                     blpi_fbi: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1152            unsigned char fcrdiv_val;
   1153            // check if in BLPI mode
   1154            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1155                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1156                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1157                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
   \   00000002   0x....             LDR      R2,??DataTable17_3  ;; 0x40064001
   \   00000004   0x7953             LDRB     R3,[R2, #+5]
   \   00000006   0x071B             LSLS     R3,R3,#+28
   \   00000008   0x0F9B             LSRS     R3,R3,#+30
   \   0000000A   0x2B01             CMP      R3,#+1
   \   0000000C   0xD108             BNE      ??blpi_fbi_0
   \   0000000E   0x7953             LDRB     R3,[R2, #+5]
   \   00000010   0x06DB             LSLS     R3,R3,#+27
   \   00000012   0xD505             BPL      ??blpi_fbi_0
   \   00000014   0x7953             LDRB     R3,[R2, #+5]
   \   00000016   0x069B             LSLS     R3,R3,#+26
   \   00000018   0xD402             BMI      ??blpi_fbi_0
   \   0000001A   0x7813             LDRB     R3,[R2, #+0]
   \   0000001C   0x079B             LSLS     R3,R3,#+30
   \   0000001E   0xD401             BMI      ??blpi_fbi_1
   1158            {
   1159              return 0x5;                                                       // MCG not in correct mode return fail code
   \                     ??blpi_fbi_0: (+1)
   \   00000020   0x2005             MOVS     R0,#+5
   \   00000022   0xBD10             POP      {R4,PC}
   1160            }
   1161          
   1162          // Clear LP bit to enable the FLL and enter FBI mode   
   1163            MCG_C2 &= ~MCG_C2_LP_MASK;
   \                     ??blpi_fbi_1: (+1)
   \   00000024   0x7813             LDRB     R3,[R2, #+0]
   \   00000026   0x24FD             MOVS     R4,#+253
   \   00000028   0x401C             ANDS     R4,R4,R3
   \   0000002A   0x7014             STRB     R4,[R2, #+0]
   1164            
   1165          // Now in FBI mode
   1166            if (irc_select)
   \   0000002C                      REQUIRE ?Subroutine1
   \   0000002C                      ;; // Fall through to label ?Subroutine1
   1167            {
   1168              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   1169              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   1170            }
   1171            else
   1172            {
   1173              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   1174            }
   1175          } // blpi_fbi
   1176          
   1177          

   \                                 In section .text, align 2, keep-with-next
   1178          int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
   1179          {
   \                     fbi_fee: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   1180            unsigned char temp_reg;
   1181            unsigned char frdiv_val;
   1182            short i;
   1183            int mcg_out, fll_ref_freq;
   1184          
   1185          // check if in FBI mode
   1186            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1187                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1188                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1189                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x2603             MOVS     R6,#+3
   \   00000004   0x....             LDR      R5,??DataTable17_4  ;; 0x40064000
   \   00000006   0x79AA             LDRB     R2,[R5, #+6]
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x4032             ANDS     R2,R2,R6
   \   0000000C   0x2A01             CMP      R2,#+1
   \   0000000E   0xD109             BNE      ??fbi_fee_0
   \   00000010   0x79AA             LDRB     R2,[R5, #+6]
   \   00000012   0x06D2             LSLS     R2,R2,#+27
   \   00000014   0xD506             BPL      ??fbi_fee_0
   \   00000016   0x79AA             LDRB     R2,[R5, #+6]
   \   00000018   0x0692             LSLS     R2,R2,#+26
   \   0000001A   0xD403             BMI      ??fbi_fee_0
   \   0000001C   0x2702             MOVS     R7,#+2
   \   0000001E   0x786A             LDRB     R2,[R5, #+1]
   \   00000020   0x423A             TST      R2,R7
   \   00000022   0xD001             BEQ      ??fbi_fee_1
   1190            {  
   1191              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fee_0: (+1)
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xBDF2             POP      {R1,R4-R7,PC}
   1192            }
   1193            
   1194          // check external frequency is less than the maximum frequency
   1195            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fbi_fee_1: (+1)
   \   00000028   0x....             LDR      R2,??DataTable17_5  ;; 0x2faf081
   \   0000002A   0x4290             CMP      R0,R2
   \   0000002C   0xDB01             BLT      ??fbi_fee_2
   \   0000002E   0x2021             MOVS     R0,#+33
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}
   1196            
   1197          // check crystal frequency is within spec. if crystal osc is being used
   1198            if (erefs_val)
   \                     ??fbi_fee_2: (+1)
   \   00000032   0x466A             MOV      R2,SP
   \   00000034   0x7812             LDRB     R2,[R2, #+0]
   \   00000036   0x2A00             CMP      R2,#+0
   \   00000038   0xD00C             BEQ      ??fbi_fee_3
   1199            {
   1200              if ((crystal_val < 30000) ||
   1201                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1202                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   0000003A   0x....             LDR      R2,??DataTable17_6  ;; 0x7530
   \   0000003C   0x4290             CMP      R0,R2
   \   0000003E   0xDB07             BLT      ??fbi_fee_4
   \   00000040   0x....             LDR      R2,??DataTable17_7  ;; 0xffff63bf
   \   00000042   0x1882             ADDS     R2,R0,R2
   \   00000044   0x....             LDR      R3,??DataTable18  ;; 0x2d2a7f
   \   00000046   0x429A             CMP      R2,R3
   \   00000048   0xD302             BCC      ??fbi_fee_4
   \   0000004A   0x....             LDR      R2,??DataTable18_1  ;; 0x1e84801
   \   0000004C   0x4290             CMP      R0,R2
   \   0000004E   0xDB01             BLT      ??fbi_fee_3
   \                     ??fbi_fee_4: (+1)
   \   00000050   0x2022             MOVS     R0,#+34
   \   00000052   0xBDF2             POP      {R1,R4-R7,PC}
   1203            }
   1204          
   1205          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1206            if (hgo_val > 0)
   \                     ??fbi_fee_3: (+1)
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD000             BEQ      ??fbi_fee_5
   1207            {
   1208              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000058   0x2101             MOVS     R1,#+1
   1209            }
   1210          
   1211          // configure the MCG_C2 register
   1212          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1213          // it still needs to be set correctly even if the oscillator is not being used
   1214            temp_reg = MCG_C2;
   \                     ??fbi_fee_5: (+1)
   \   0000005A   0x786B             LDRB     R3,[R5, #+1]
   1215            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   0000005C   0x22C3             MOVS     R2,#+195
   \   0000005E   0x401A             ANDS     R2,R2,R3
   1216            if (crystal_val <= 40000)
   \   00000060   0x00C9             LSLS     R1,R1,#+3
   \   00000062   0x466B             MOV      R3,SP
   \   00000064   0x781B             LDRB     R3,[R3, #+0]
   \   00000066   0x009B             LSLS     R3,R3,#+2
   \   00000068   0x430B             ORRS     R3,R3,R1
   \   0000006A   0x....             LDR      R1,??DataTable18_2  ;; 0x9c41
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xDA01             BGE      ??fbi_fee_6
   1217            {
   1218              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000070   0x4313             ORRS     R3,R3,R2
   \   00000072   0xE008             B        ??fbi_fee_7
   1219            }
   1220            else if (crystal_val <= 8000000)
   \                     ??fbi_fee_6: (+1)
   \   00000074   0x....             LDR      R1,??DataTable18_3  ;; 0x7a1201
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xDA01             BGE      ??fbi_fee_8
   1221            {
   1222              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   0000007A   0x2110             MOVS     R1,#+16
   \   0000007C   0xE000             B        ??fbi_fee_9
   1223            }
   1224            else
   1225            {
   1226              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fbi_fee_8: (+1)
   \   0000007E   0x2120             MOVS     R1,#+32
   \                     ??fbi_fee_9: (+1)
   \   00000080   0x4319             ORRS     R1,R1,R3
   \   00000082   0x4311             ORRS     R1,R1,R2
   \   00000084   0x000B             MOVS     R3,R1
   1227            }
   1228            MCG_C2 = temp_reg;
   \                     ??fbi_fee_7: (+1)
   \   00000086   0x706B             STRB     R3,[R5, #+1]
   1229          
   1230          // determine FRDIV based on reference clock frequency
   1231          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1232            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   00000088   0x....             LDR      R1,??DataTable18_4  ;; 0x1312d1
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xDA01             BGE      ??fbi_fee_10
   \   0000008E   0x2400             MOVS     R4,#+0
   \   00000090   0xE014             B        ??fbi_fee_11
   1233            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fbi_fee_10: (+1)
   \   00000092   0x....             LDR      R1,??DataTable18_5  ;; 0x2625a1
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xDA01             BGE      ??fbi_fee_12
   \   00000098   0x2401             MOVS     R4,#+1
   \   0000009A   0xE00F             B        ??fbi_fee_11
   1234            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fbi_fee_12: (+1)
   \   0000009C   0x....             LDR      R1,??DataTable18_6  ;; 0x4c4b41
   \   0000009E   0x4288             CMP      R0,R1
   \   000000A0   0xDA01             BGE      ??fbi_fee_13
   \   000000A2   0x2402             MOVS     R4,#+2
   \   000000A4   0xE00A             B        ??fbi_fee_11
   1235            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fbi_fee_13: (+1)
   \   000000A6   0x....             LDR      R1,??DataTable17  ;; 0x989681
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xDA01             BGE      ??fbi_fee_14
   \   000000AC   0x2403             MOVS     R4,#+3
   \   000000AE   0xE005             B        ??fbi_fee_11
   1236            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fbi_fee_14: (+1)
   \   000000B0   0x....             LDR      R1,??DataTable17_1  ;; 0x1312d01
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xDA01             BGE      ??fbi_fee_15
   \   000000B6   0x2404             MOVS     R4,#+4
   \   000000B8   0xE000             B        ??fbi_fee_11
   1237            else {frdiv_val = 5;}
   \                     ??fbi_fee_15: (+1)
   \   000000BA   0x2405             MOVS     R4,#+5
   1238          // The FLL ref clk divide value depends on FRDIV and the RANGE value
   1239            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fbi_fee_11: (+1)
   \   000000BC   0x7869             LDRB     R1,[R5, #+1]
   \   000000BE   0x0909             LSRS     R1,R1,#+4
   \   000000C0   0x4031             ANDS     R1,R1,R6
   \   000000C2   0xD001             BEQ      ??fbi_fee_16
   1240            {
   1241              fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
   \   000000C4   0x2120             MOVS     R1,#+32
   \   000000C6   0xE000             B        ??fbi_fee_17
   1242            }
   1243            else
   1244            {
   1245              fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
   \                     ??fbi_fee_16: (+1)
   \   000000C8   0x2101             MOVS     R1,#+1
   \                     ??fbi_fee_17: (+1)
   \   000000CA   0x40A1             LSLS     R1,R1,R4
   \   000000CC   0x.... 0x....      BL       __aeabi_idiv
   1246            }
   1247            
   1248          // Check resulting FLL frequency 
   1249            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \   000000D0   0x.... 0x....      BL       fll_freq
   1250            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   000000D4   0x283C             CMP      R0,#+60
   \   000000D6   0xDB31             BLT      ??fbi_fee_18
   1251            
   1252          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1253          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1254          // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
   1255            temp_reg = MCG_C1;
   \   000000D8   0x7829             LDRB     R1,[R5, #+0]
   1256            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and IREFS fields
   1257            temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   1258            MCG_C1 = temp_reg;
   \   000000DA   0x2203             MOVS     R2,#+3
   \   000000DC   0x400A             ANDS     R2,R2,R1
   \   000000DE   0x00E1             LSLS     R1,R4,#+3
   \   000000E0   0x4311             ORRS     R1,R1,R2
   \   000000E2   0x7029             STRB     R1,[R5, #+0]
   1259          
   1260          // if the external oscillator is used need to wait for OSCINIT to set
   1261            if (erefs_val)
   \   000000E4   0x4669             MOV      R1,SP
   \   000000E6   0x7809             LDRB     R1,[R1, #+0]
   \   000000E8   0x2900             CMP      R1,#+0
   \   000000EA   0xD00A             BEQ      ??fbi_fee_19
   1262            {
   1263              for (i = 0 ; i < 10000 ; i++)
   \   000000EC   0x....             LDR      R1,??DataTable17_2  ;; 0x2710
   1264              {
   1265                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \                     ??fbi_fee_20: (+1)
   \   000000EE   0x79AA             LDRB     R2,[R5, #+6]
   \   000000F0   0x423A             TST      R2,R7
   \   000000F2   0xD101             BNE      ??fbi_fee_21
   1266              }
   \   000000F4   0x1E49             SUBS     R1,R1,#+1
   \   000000F6   0xD1FA             BNE      ??fbi_fee_20
   1267              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fbi_fee_21: (+1)
   \   000000F8   0x79A9             LDRB     R1,[R5, #+6]
   \   000000FA   0x4239             TST      R1,R7
   \   000000FC   0xD101             BNE      ??fbi_fee_19
   \   000000FE   0x2023             MOVS     R0,#+35
   \   00000100   0xBDF2             POP      {R1,R4-R7,PC}
   1268            }
   1269          
   1270          // wait for Reference clock Status bit to clear
   1271            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fee_19: (+1)
   \   00000102   0x21FA             MOVS     R1,#+250
   \   00000104   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000106   0x000A             MOVS     R2,R1
   1272            {
   1273              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \                     ??fbi_fee_22: (+1)
   \   00000108   0x79AB             LDRB     R3,[R5, #+6]
   \   0000010A   0x06DB             LSLS     R3,R3,#+27
   \   0000010C   0xD501             BPL      ??fbi_fee_23
   1274            }
   \   0000010E   0x1E52             SUBS     R2,R2,#+1
   \   00000110   0xD1FA             BNE      ??fbi_fee_22
   1275            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fbi_fee_23: (+1)
   \   00000112   0x79AA             LDRB     R2,[R5, #+6]
   \   00000114   0x06D2             LSLS     R2,R2,#+27
   \   00000116   0xD501             BPL      ??fbi_fee_24
   \   00000118   0x2011             MOVS     R0,#+17
   \   0000011A   0xBDF2             POP      {R1,R4-R7,PC}
   1276            
   1277          // Wait for clock status bits to show clock source is ext ref clk
   1278            for (i = 0 ; i < 2000 ; i++)
   1279            {
   1280              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL selected before loop finishes
   \                     ??fbi_fee_24: (+1)
   \   0000011C   0x79AA             LDRB     R2,[R5, #+6]
   \   0000011E   0x0892             LSRS     R2,R2,#+2
   \   00000120   0x4032             ANDS     R2,R2,R6
   \   00000122   0xD001             BEQ      ??fbi_fee_25
   1281            }
   \   00000124   0x1E49             SUBS     R1,R1,#+1
   \   00000126   0xD1F9             BNE      ??fbi_fee_24
   1282            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is really selected and return with error if not
   \                     ??fbi_fee_25: (+1)
   \   00000128   0x79A9             LDRB     R1,[R5, #+6]
   \   0000012A   0x0889             LSRS     R1,R1,#+2
   \   0000012C   0x400E             ANDS     R6,R6,R1
   \   0000012E   0xD001             BEQ      ??fbi_fee_26
   \   00000130   0x2018             MOVS     R0,#+24
   \   00000132   0xBDF2             POP      {R1,R4-R7,PC}
   1283           
   1284          // Now in FEE  
   1285          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1286          // It is enabled here but can be removed if this is not required.
   1287          // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and BLPI)
   1288            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fbi_fee_26: (+1)
   \   00000134   0x7969             LDRB     R1,[R5, #+5]
   \   00000136   0x2220             MOVS     R2,#+32
   \   00000138   0x430A             ORRS     R2,R2,R1
   \   0000013A   0x716A             STRB     R2,[R5, #+5]
   1289            
   1290            return mcg_out; // MCGOUT frequency equals FLL frequency
   \                     ??fbi_fee_18: (+1)
   \   0000013C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1291          } //fbi_fee
   1292          
   1293          

   \                                 In section .text, align 2, keep-with-next
   1294          int fee_fbi(int irc_freq, unsigned char irc_select)
   1295          { 
   \                     fee_fbi: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   1296            unsigned char fcrdiv_val;
   1297            short i;
   1298            
   1299          // Check MCG is in FEE mode
   1300            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1301                (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external ref clk
   1302                (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R3,??DataTable19  ;; 0x40064000
   \   00000004   0x2503             MOVS     R5,#+3
   \   00000006   0x799A             LDRB     R2,[R3, #+6]
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x402A             ANDS     R2,R2,R5
   \   0000000C   0xD106             BNE      ??fee_fbi_0
   \   0000000E   0x2410             MOVS     R4,#+16
   \   00000010   0x799A             LDRB     R2,[R3, #+6]
   \   00000012   0x4222             TST      R2,R4
   \   00000014   0xD102             BNE      ??fee_fbi_0
   \   00000016   0x799A             LDRB     R2,[R3, #+6]
   \   00000018   0x0692             LSLS     R2,R2,#+26
   \   0000001A   0xD501             BPL      ??fee_fbi_1
   1303            {
   1304              return 0x2;                                                     // return error code
   \                     ??fee_fbi_0: (+1)
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xBDF0             POP      {R4-R7,PC}
   1305            }
   1306            
   1307            // Check that the irc frequency matches the selected IRC 
   1308            if (!(irc_select))
   \                     ??fee_fbi_1: (+1)
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD106             BNE      ??fee_fbi_2
   1309            {    
   1310              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   00000024   0x....             LDR      R2,??DataTable19_1  ;; 0xffff85ee
   \   00000026   0x1882             ADDS     R2,R0,R2
   \   00000028   0x....             LDR      R6,??DataTable19_2  ;; 0x1e86
   \   0000002A   0x42B2             CMP      R2,R6
   \   0000002C   0xD30C             BCC      ??fee_fbi_3
   \   0000002E   0x2031             MOVS     R0,#+49
   \   00000030   0xBDF0             POP      {R4-R7,PC}
   1311            }
   1312            else
   1313            {
   1314              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fee_fbi_2: (+1)
   \   00000032   0x....             LDR      R2,??DataTable19_3  ;; 0xffd23940
   \   00000034   0x1882             ADDS     R2,R0,R2
   \   00000036   0x....             LDR      R6,??DataTable19_4  ;; 0x1e8481
   \   00000038   0x42B2             CMP      R2,R6
   \   0000003A   0xD301             BCC      ??fee_fbi_4
   \   0000003C   0x2032             MOVS     R0,#+50
   \   0000003E   0xBDF0             POP      {R4-R7,PC}
   1315            }
   1316            
   1317          // Select the required IRC
   1318            if (irc_select)
   1319            {
   1320              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
   \                     ??fee_fbi_4: (+1)
   \   00000040   0x785A             LDRB     R2,[R3, #+1]
   \   00000042   0x2601             MOVS     R6,#+1
   \   00000044   0x4316             ORRS     R6,R6,R2
   \   00000046   0xE002             B        ??fee_fbi_5
   1321            }
   1322            else
   1323            {
   1324              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
   \                     ??fee_fbi_3: (+1)
   \   00000048   0x785A             LDRB     R2,[R3, #+1]
   \   0000004A   0x26FE             MOVS     R6,#+254
   \   0000004C   0x4016             ANDS     R6,R6,R2
   \                     ??fee_fbi_5: (+1)
   \   0000004E   0x705E             STRB     R6,[R3, #+1]
   1325            }
   1326            
   1327          // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
   1328            MCG_C6 &= ~MCG_C6_CME0_MASK;
   \   00000050   0x795A             LDRB     R2,[R3, #+5]
   \   00000052   0x26DF             MOVS     R6,#+223
   \   00000054   0x4016             ANDS     R6,R6,R2
   \   00000056   0x715E             STRB     R6,[R3, #+5]
   1329            
   1330          // Select the IRC as the CLKS mux selection
   1331            MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
   \   00000058   0x781A             LDRB     R2,[R3, #+0]
   \   0000005A   0x2644             MOVS     R6,#+68
   \   0000005C   0x4316             ORRS     R6,R6,R2
   \   0000005E   0x701E             STRB     R6,[R3, #+0]
   1332           
   1333          // wait until internal reference switches to requested irc.
   1334            if (!(irc_select))
   \   00000060   0x22FA             MOVS     R2,#+250
   \   00000062   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000064   0x2900             CMP      R1,#+0
   \   00000066   0xD10A             BNE      ??fee_fbi_6
   1335            {
   1336              for (i = 0 ; i < 2000 ; i++)
   \   00000068   0x0016             MOVS     R6,R2
   1337              {
   1338                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \                     ??fee_fbi_7: (+1)
   \   0000006A   0x799F             LDRB     R7,[R3, #+6]
   \   0000006C   0x07FF             LSLS     R7,R7,#+31
   \   0000006E   0xD501             BPL      ??fee_fbi_8
   1339              }
   \   00000070   0x1E76             SUBS     R6,R6,#+1
   \   00000072   0xD1FA             BNE      ??fee_fbi_7
   1340              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fee_fbi_8: (+1)
   \   00000074   0x799E             LDRB     R6,[R3, #+6]
   \   00000076   0x07F6             LSLS     R6,R6,#+31
   \   00000078   0xD50C             BPL      ??fee_fbi_9
   \   0000007A   0x2013             MOVS     R0,#+19
   \   0000007C   0xBDF0             POP      {R4-R7,PC}
   1341            }
   1342            else
   1343            {
   1344              for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_6: (+1)
   \   0000007E   0x0016             MOVS     R6,R2
   1345              {
   1346                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \                     ??fee_fbi_10: (+1)
   \   00000080   0x799F             LDRB     R7,[R3, #+6]
   \   00000082   0x07FF             LSLS     R7,R7,#+31
   \   00000084   0xD401             BMI      ??fee_fbi_11
   1347              }
   \   00000086   0x1E76             SUBS     R6,R6,#+1
   \   00000088   0xD1FA             BNE      ??fee_fbi_10
   1348              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fee_fbi_11: (+1)
   \   0000008A   0x799E             LDRB     R6,[R3, #+6]
   \   0000008C   0x07F6             LSLS     R6,R6,#+31
   \   0000008E   0xD401             BMI      ??fee_fbi_9
   \   00000090   0x2014             MOVS     R0,#+20
   \   00000092   0xBDF0             POP      {R4-R7,PC}
   1349            }
   1350            
   1351          // Wait for clock status bits to update
   1352            for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_9: (+1)
   \   00000094   0x0016             MOVS     R6,R2
   1353            {
   1354              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \                     ??fee_fbi_12: (+1)
   \   00000096   0x799F             LDRB     R7,[R3, #+6]
   \   00000098   0x08BF             LSRS     R7,R7,#+2
   \   0000009A   0x402F             ANDS     R7,R7,R5
   \   0000009C   0x2F01             CMP      R7,#+1
   \   0000009E   0xD001             BEQ      ??fee_fbi_13
   1355            }
   \   000000A0   0x1E76             SUBS     R6,R6,#+1
   \   000000A2   0xD1F8             BNE      ??fee_fbi_12
   1356            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fee_fbi_13: (+1)
   \   000000A4   0x799E             LDRB     R6,[R3, #+6]
   \   000000A6   0x08B6             LSRS     R6,R6,#+2
   \   000000A8   0x4035             ANDS     R5,R5,R6
   \   000000AA   0x2D01             CMP      R5,#+1
   \   000000AC   0xD001             BEQ      ??fee_fbi_14
   \   000000AE   0x2019             MOVS     R0,#+25
   \   000000B0   0xBDF0             POP      {R4-R7,PC}
   1357            
   1358          // wait for Reference clock Status bit to set
   1359            for (i = 0 ; i < 2000 ; i++)
   1360            {
   1361              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \                     ??fee_fbi_14: (+1)
   \   000000B2   0x799D             LDRB     R5,[R3, #+6]
   \   000000B4   0x4225             TST      R5,R4
   \   000000B6   0xD101             BNE      ??fee_fbi_15
   1362            }
   \   000000B8   0x1E52             SUBS     R2,R2,#+1
   \   000000BA   0xD1FA             BNE      ??fee_fbi_14
   1363            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set  
   \                     ??fee_fbi_15: (+1)
   \   000000BC   0x799A             LDRB     R2,[R3, #+6]
   \   000000BE   0x4222             TST      R2,R4
   \   000000C0   0xD101             BNE      ??fee_fbi_16
   \   000000C2   0x2012             MOVS     R0,#+18
   \   000000C4   0xBDF0             POP      {R4-R7,PC}
   1364            
   1365          // Now in FBI mode
   1366            if (irc_select)
   \                     ??fee_fbi_16: (+1)
   \   000000C6                      REQUIRE ?Subroutine0
   \   000000C6                      ;; // Fall through to label ?Subroutine0
   1367            {
   1368              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   1369              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   1370            }
   1371            else
   1372            {
   1373              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   1374            }
   1375          } // fee_fbi 
   1376          
   1377          

   \                                 In section .text, align 2, keep-with-next
   1378          int fbi_fei(int slow_irc_freq)
   1379          {
   \                     fbi_fei: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1380            unsigned char temp_reg;
   1381            short i;
   1382            int mcg_out;
   1383          
   1384          // check if in FBI mode
   1385            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1386                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1387                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1388                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x2403             MOVS     R4,#+3
   \   00000004   0x....             LDR      R5,??DataTable19  ;; 0x40064000
   \   00000006   0x79A9             LDRB     R1,[R5, #+6]
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x4021             ANDS     R1,R1,R4
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD109             BNE      ??fbi_fei_0
   \   00000010   0x2610             MOVS     R6,#+16
   \   00000012   0x79A9             LDRB     R1,[R5, #+6]
   \   00000014   0x4231             TST      R1,R6
   \   00000016   0xD005             BEQ      ??fbi_fei_0
   \   00000018   0x79A9             LDRB     R1,[R5, #+6]
   \   0000001A   0x0689             LSLS     R1,R1,#+26
   \   0000001C   0xD402             BMI      ??fbi_fei_0
   \   0000001E   0x7869             LDRB     R1,[R5, #+1]
   \   00000020   0x0789             LSLS     R1,R1,#+30
   \   00000022   0xD501             BPL      ??fbi_fei_1
   1389            {  
   1390              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fei_0: (+1)
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xBD70             POP      {R4-R6,PC}
   1391            }
   1392          
   1393          // Check IRC frequency is within spec.
   1394            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fbi_fei_1: (+1)
   \   00000028   0x....             LDR      R1,??DataTable19_1  ;; 0xffff85ee
   \   0000002A   0x1841             ADDS     R1,R0,R1
   \   0000002C   0x....             LDR      R2,??DataTable19_2  ;; 0x1e86
   \   0000002E   0x4291             CMP      R1,R2
   \   00000030   0xD301             BCC      ??fbi_fei_2
   1395            {
   1396              return 0x31;
   \   00000032   0x2031             MOVS     R0,#+49
   \   00000034   0xBD70             POP      {R4-R6,PC}
   1397            }
   1398          
   1399          // Check resulting FLL frequency 
   1400            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fbi_fei_2: (+1)
   \   00000036   0x.... 0x....      BL       fll_freq
   1401            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   0000003A   0x283C             CMP      R0,#+60
   \   0000003C   0xDB1D             BLT      ??fbi_fei_3
   1402            
   1403          // Change the CLKS mux to select the FLL output as MCGOUT  
   1404            temp_reg = MCG_C1;
   \   0000003E   0x7829             LDRB     R1,[R5, #+0]
   1405            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
   1406            temp_reg |= MCG_C1_CLKS(0); // select FLL as MCGOUT
   1407            temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
   1408            MCG_C1 = temp_reg; // update MCG_C1
   \   00000040   0x0689             LSLS     R1,R1,#+26
   \   00000042   0x0E89             LSRS     R1,R1,#+26
   \   00000044   0x2204             MOVS     R2,#+4
   \   00000046   0x430A             ORRS     R2,R2,R1
   \   00000048   0x702A             STRB     R2,[R5, #+0]
   1409            
   1410          // wait for Reference clock Status bit to clear
   1411            for (i = 0 ; i < 2000 ; i++)
   \   0000004A   0x21FA             MOVS     R1,#+250
   \   0000004C   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   0000004E   0x000A             MOVS     R2,R1
   1412            {
   1413              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
   \                     ??fbi_fei_4: (+1)
   \   00000050   0x79AB             LDRB     R3,[R5, #+6]
   \   00000052   0x4233             TST      R3,R6
   \   00000054   0xD101             BNE      ??fbi_fei_5
   1414            }
   \   00000056   0x1E52             SUBS     R2,R2,#+1
   \   00000058   0xD1FA             BNE      ??fbi_fei_4
   1415            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbi_fei_5: (+1)
   \   0000005A   0x79AA             LDRB     R2,[R5, #+6]
   \   0000005C   0x4232             TST      R2,R6
   \   0000005E   0xD101             BNE      ??fbi_fei_6
   \   00000060   0x2012             MOVS     R0,#+18
   \   00000062   0xBD70             POP      {R4-R6,PC}
   1416            
   1417          // Wait for clock status bits to show clock source is ext ref clk
   1418            for (i = 0 ; i < 2000 ; i++)
   1419            {
   1420              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL slected before loop finishes
   \                     ??fbi_fei_6: (+1)
   \   00000064   0x79AA             LDRB     R2,[R5, #+6]
   \   00000066   0x0892             LSRS     R2,R2,#+2
   \   00000068   0x4022             ANDS     R2,R2,R4
   \   0000006A   0xD001             BEQ      ??fbi_fei_7
   1421            }
   \   0000006C   0x1E49             SUBS     R1,R1,#+1
   \   0000006E   0xD1F9             BNE      ??fbi_fei_6
   1422            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really selected and return with error if not
   \                     ??fbi_fei_7: (+1)
   \   00000070   0x79A9             LDRB     R1,[R5, #+6]
   \   00000072   0x0889             LSRS     R1,R1,#+2
   \   00000074   0x400C             ANDS     R4,R4,R1
   \   00000076   0xD000             BEQ      ??fbi_fei_3
   \   00000078   0x2018             MOVS     R0,#+24
   1423          
   1424          // Now in FEI mode
   1425            return mcg_out;  
   \                     ??fbi_fei_3: (+1)
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
   1426          } // fbi_fei
   1427          
   1428          

   \                                 In section .text, align 2, keep-with-next
   1429          int fei_fbi(int irc_freq, unsigned char irc_select)
   1430          {
   \                     fei_fbi: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1431            unsigned char temp_reg;
   1432            unsigned char fcrdiv_val;
   1433            short i;
   1434            
   1435          // Check MCG is in FEI mode
   1436            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1437                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1438                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R2,??DataTable19  ;; 0x40064000
   \   00000004   0x2303             MOVS     R3,#+3
   \   00000006   0x7994             LDRB     R4,[R2, #+6]
   \   00000008   0x08A4             LSRS     R4,R4,#+2
   \   0000000A   0x401C             ANDS     R4,R4,R3
   \   0000000C   0xD105             BNE      ??fei_fbi_0
   \   0000000E   0x7994             LDRB     R4,[R2, #+6]
   \   00000010   0x06E4             LSLS     R4,R4,#+27
   \   00000012   0xD502             BPL      ??fei_fbi_0
   \   00000014   0x7994             LDRB     R4,[R2, #+6]
   \   00000016   0x06A4             LSLS     R4,R4,#+26
   \   00000018   0xD501             BPL      ??fei_fbi_1
   1439            {
   1440              return 0x1;                                                       // return error code
   \                     ??fei_fbi_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD70             POP      {R4-R6,PC}
   1441            } 
   1442          
   1443          // Check that the irc frequency matches the selected IRC 
   1444            if (!(irc_select))
   \                     ??fei_fbi_1: (+1)
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD106             BNE      ??fei_fbi_2
   1445            {    
   1446              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   00000022   0x....             LDR      R4,??DataTable19_1  ;; 0xffff85ee
   \   00000024   0x1904             ADDS     R4,R0,R4
   \   00000026   0x....             LDR      R5,??DataTable19_2  ;; 0x1e86
   \   00000028   0x42AC             CMP      R4,R5
   \   0000002A   0xD30C             BCC      ??fei_fbi_3
   \   0000002C   0x2031             MOVS     R0,#+49
   \   0000002E   0xBD70             POP      {R4-R6,PC}
   1447            }
   1448            else
   1449            {
   1450              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fei_fbi_2: (+1)
   \   00000030   0x....             LDR      R4,??DataTable19_3  ;; 0xffd23940
   \   00000032   0x1904             ADDS     R4,R0,R4
   \   00000034   0x....             LDR      R5,??DataTable19_4  ;; 0x1e8481
   \   00000036   0x42AC             CMP      R4,R5
   \   00000038   0xD301             BCC      ??fei_fbi_4
   \   0000003A   0x2032             MOVS     R0,#+50
   \   0000003C   0xBD70             POP      {R4-R6,PC}
   1451            }
   1452            
   1453          // Select the desired IRC
   1454            if (irc_select)
   1455            {
   1456              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
   \                     ??fei_fbi_4: (+1)
   \   0000003E   0x7854             LDRB     R4,[R2, #+1]
   \   00000040   0x2501             MOVS     R5,#+1
   \   00000042   0x4325             ORRS     R5,R5,R4
   \   00000044   0xE002             B        ??fei_fbi_5
   1457            }
   1458            else
   1459            {
   1460              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
   \                     ??fei_fbi_3: (+1)
   \   00000046   0x7854             LDRB     R4,[R2, #+1]
   \   00000048   0x25FE             MOVS     R5,#+254
   \   0000004A   0x4025             ANDS     R5,R5,R4
   \                     ??fei_fbi_5: (+1)
   \   0000004C   0x7055             STRB     R5,[R2, #+1]
   1461            }
   1462            
   1463          // Change the CLKS mux to select the IRC as the MCGOUT
   1464            temp_reg = MCG_C1;
   \   0000004E   0x7814             LDRB     R4,[R2, #+0]
   1465            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
   1466            temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
   1467            MCG_C1 = temp_reg;
   \   00000050   0x06A4             LSLS     R4,R4,#+26
   \   00000052   0x0EA4             LSRS     R4,R4,#+26
   \   00000054   0x2540             MOVS     R5,#+64
   \   00000056   0x4325             ORRS     R5,R5,R4
   \   00000058   0x7015             STRB     R5,[R2, #+0]
   1468          
   1469          // wait until internal reference switches to requested irc.
   1470            if (!(irc_select))
   \   0000005A   0x24FA             MOVS     R4,#+250
   \   0000005C   0x00E4             LSLS     R4,R4,#+3        ;; #+2000
   \   0000005E   0x2900             CMP      R1,#+0
   \   00000060   0xD10A             BNE      ??fei_fbi_6
   1471            {
   1472              for (i = 0 ; i < 2000 ; i++)
   \   00000062   0x0025             MOVS     R5,R4
   1473              {
   1474                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \                     ??fei_fbi_7: (+1)
   \   00000064   0x7996             LDRB     R6,[R2, #+6]
   \   00000066   0x07F6             LSLS     R6,R6,#+31
   \   00000068   0xD501             BPL      ??fei_fbi_8
   1475              }
   \   0000006A   0x1E6D             SUBS     R5,R5,#+1
   \   0000006C   0xD1FA             BNE      ??fei_fbi_7
   1476              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fei_fbi_8: (+1)
   \   0000006E   0x7995             LDRB     R5,[R2, #+6]
   \   00000070   0x07ED             LSLS     R5,R5,#+31
   \   00000072   0xD50C             BPL      ??fei_fbi_9
   \   00000074   0x2013             MOVS     R0,#+19
   \   00000076   0xBD70             POP      {R4-R6,PC}
   1477            }
   1478            else
   1479            {
   1480              for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbi_6: (+1)
   \   00000078   0x0025             MOVS     R5,R4
   1481              {
   1482                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \                     ??fei_fbi_10: (+1)
   \   0000007A   0x7996             LDRB     R6,[R2, #+6]
   \   0000007C   0x07F6             LSLS     R6,R6,#+31
   \   0000007E   0xD401             BMI      ??fei_fbi_11
   1483              }
   \   00000080   0x1E6D             SUBS     R5,R5,#+1
   \   00000082   0xD1FA             BNE      ??fei_fbi_10
   1484              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fei_fbi_11: (+1)
   \   00000084   0x7995             LDRB     R5,[R2, #+6]
   \   00000086   0x07ED             LSLS     R5,R5,#+31
   \   00000088   0xD401             BMI      ??fei_fbi_9
   \   0000008A   0x2014             MOVS     R0,#+20
   \   0000008C   0xBD70             POP      {R4-R6,PC}
   1485            }
   1486            
   1487          // Wait for clock status bits to update
   1488            for (i = 0 ; i < 2000 ; i++)
   1489            {
   1490              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \                     ??fei_fbi_9: (+1)
   \   0000008E   0x7995             LDRB     R5,[R2, #+6]
   \   00000090   0x08AD             LSRS     R5,R5,#+2
   \   00000092   0x401D             ANDS     R5,R5,R3
   \   00000094   0x2D01             CMP      R5,#+1
   \   00000096   0xD001             BEQ      ??fei_fbi_12
   1491            }
   \   00000098   0x1E64             SUBS     R4,R4,#+1
   \   0000009A   0xD1F8             BNE      ??fei_fbi_9
   1492            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fei_fbi_12: (+1)
   \   0000009C   0x7994             LDRB     R4,[R2, #+6]
   \   0000009E   0x08A4             LSRS     R4,R4,#+2
   \   000000A0   0x4023             ANDS     R3,R3,R4
   \   000000A2   0x2B01             CMP      R3,#+1
   \   000000A4   0xD001             BEQ      ??fei_fbi_13
   \   000000A6   0x2019             MOVS     R0,#+25
   \   000000A8   0xBD70             POP      {R4-R6,PC}
   1493            
   1494          // Now in FBI mode
   1495            if (irc_select)
   \                     ??fei_fbi_13: (+1)
   \   000000AA   0x2900             CMP      R1,#+0
   \   000000AC   0xD007             BEQ      ??fei_fbi_14
   1496            {
   1497              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   000000AE   0x7A12             LDRB     R2,[R2, #+8]
   1498              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0x0712             LSLS     R2,R2,#+28
   \   000000B4   0x0F52             LSRS     R2,R2,#+29
   \   000000B6   0x4091             LSLS     R1,R1,R2
   \   000000B8   0xB2C9             UXTB     R1,R1
   \   000000BA   0x.... 0x....      BL       __aeabi_idiv
   1499            }
   1500            else
   1501            {
   1502              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fei_fbi_14: (+1)
   \   000000BE   0xBD70             POP      {R4-R6,PC}       ;; return
   1503            }   
   1504          } // fei_fbi
   1505          
   1506          
   1507          /********************************************************************/
   1508          /* Functon name : fei_fee
   1509           *
   1510           * Mode transition: FEI to FEE mode
   1511           *
   1512           * This function transitions the MCG from FEI mode to FEE mode. This is
   1513           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
   1514           * check so 0 is always returned if the function was called with the MCG
   1515           * in FBI mode. The MCGCLKOUT frequency does not change
   1516           *
   1517           * Parameters: crystal_val - external clock frequency in Hz
   1518           *             hgo_val     - selects whether low power or high gain mode is selected
   1519           *                           for the crystal oscillator. This has no meaning if an 
   1520           *                           external clock is used.
   1521           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
   1522           *
   1523           * Return value : MCGCLKOUT frequency (Hz) or error code
   1524           */

   \                                 In section .text, align 2, keep-with-next
   1525          int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
   1526          {
   \                     fei_fee: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   1527            unsigned char frdiv_val;
   1528            unsigned char temp_reg;
   1529           // short i;
   1530            int mcg_out, fll_ref_freq, i;
   1531            
   1532          // check if in FEI mode
   1533            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1534                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1535                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R5,??DataTable21  ;; 0x40064000
   \   00000004   0x79AA             LDRB     R2,[R5, #+6]
   \   00000006   0x0712             LSLS     R2,R2,#+28
   \   00000008   0x0F92             LSRS     R2,R2,#+30
   \   0000000A   0xD107             BNE      ??fei_fee_0
   \   0000000C   0x2710             MOVS     R7,#+16
   \   0000000E   0x79AA             LDRB     R2,[R5, #+6]
   \   00000010   0x423A             TST      R2,R7
   \   00000012   0xD003             BEQ      ??fei_fee_0
   \   00000014   0x2620             MOVS     R6,#+32
   \   00000016   0x79AA             LDRB     R2,[R5, #+6]
   \   00000018   0x4232             TST      R2,R6
   \   0000001A   0xD001             BEQ      ??fei_fee_1
   1536            {
   1537              return 0x1;                                                     // return error code
   \                     ??fei_fee_0: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBDF2             POP      {R1,R4-R7,PC}
   1538            }
   1539          
   1540          // check external frequency is less than the maximum frequency
   1541            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fei_fee_1: (+1)
   \   00000020   0x....             LDR      R2,??DataTable21_1  ;; 0x2faf081
   \   00000022   0x4290             CMP      R0,R2
   \   00000024   0xDB01             BLT      ??fei_fee_2
   \   00000026   0x2021             MOVS     R0,#+33
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}
   1542            
   1543          // check crystal frequency is within spec. if crystal osc is being used
   1544            if (erefs_val)
   \                     ??fei_fee_2: (+1)
   \   0000002A   0x466A             MOV      R2,SP
   \   0000002C   0x7812             LDRB     R2,[R2, #+0]
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD00C             BEQ      ??fei_fee_3
   1545            {
   1546              if ((crystal_val < 30000) ||
   1547                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1548                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000032   0x....             LDR      R2,??DataTable21_2  ;; 0x7530
   \   00000034   0x4290             CMP      R0,R2
   \   00000036   0xDB07             BLT      ??fei_fee_4
   \   00000038   0x....             LDR      R2,??DataTable21_3  ;; 0xffff63bf
   \   0000003A   0x1882             ADDS     R2,R0,R2
   \   0000003C   0x....             LDR      R3,??DataTable21_4  ;; 0x2d2a7f
   \   0000003E   0x429A             CMP      R2,R3
   \   00000040   0xD302             BCC      ??fei_fee_4
   \   00000042   0x....             LDR      R2,??DataTable21_5  ;; 0x1e84801
   \   00000044   0x4290             CMP      R0,R2
   \   00000046   0xDB01             BLT      ??fei_fee_3
   \                     ??fei_fee_4: (+1)
   \   00000048   0x2022             MOVS     R0,#+34
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
   1549            }
   1550          
   1551          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1552            if (hgo_val > 0)
   \                     ??fei_fee_3: (+1)
   \   0000004C   0x2900             CMP      R1,#+0
   \   0000004E   0xD000             BEQ      ??fei_fee_5
   1553            {
   1554              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000050   0x2101             MOVS     R1,#+1
   1555            }
   1556          
   1557          // configure the MCG_C2 register
   1558          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1559          // it still needs to be set correctly even if the oscillator is not being used
   1560            temp_reg = MCG_C2;
   \                     ??fei_fee_5: (+1)
   \   00000052   0x786B             LDRB     R3,[R5, #+1]
   1561            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   00000054   0x22C3             MOVS     R2,#+195
   \   00000056   0x401A             ANDS     R2,R2,R3
   1562            if (crystal_val <= 40000)
   \   00000058   0x00C9             LSLS     R1,R1,#+3
   \   0000005A   0x466B             MOV      R3,SP
   \   0000005C   0x781B             LDRB     R3,[R3, #+0]
   \   0000005E   0x009B             LSLS     R3,R3,#+2
   \   00000060   0x430B             ORRS     R3,R3,R1
   \   00000062   0x....             LDR      R1,??DataTable22  ;; 0x9c41
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xDB05             BLT      ??fei_fee_6
   1563            {
   1564              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   1565            }
   1566            else if (crystal_val <= 8000000)
   \   00000068   0x....             LDR      R1,??DataTable22_1  ;; 0x7a1201
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xDA01             BGE      ??fei_fee_7
   1567            {
   1568              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   0000006E   0x433B             ORRS     R3,R3,R7
   \   00000070   0xE000             B        ??fei_fee_6
   1569            }
   1570            else
   1571            {
   1572              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fei_fee_7: (+1)
   \   00000072   0x4333             ORRS     R3,R3,R6
   \                     ??fei_fee_6: (+1)
   \   00000074   0x4313             ORRS     R3,R3,R2
   1573            }
   1574            MCG_C2 = temp_reg;
   \   00000076   0x706B             STRB     R3,[R5, #+1]
   1575          
   1576          // determine FRDIV based on reference clock frequency
   1577          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1578            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   00000078   0x....             LDR      R1,??DataTable22_2  ;; 0x1312d1
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xDA01             BGE      ??fei_fee_8
   \   0000007E   0x2400             MOVS     R4,#+0
   \   00000080   0xE014             B        ??fei_fee_9
   1579            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fei_fee_8: (+1)
   \   00000082   0x....             LDR      R1,??DataTable22_3  ;; 0x2625a1
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xDA01             BGE      ??fei_fee_10
   \   00000088   0x2401             MOVS     R4,#+1
   \   0000008A   0xE00F             B        ??fei_fee_9
   1580            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fei_fee_10: (+1)
   \   0000008C   0x....             LDR      R1,??DataTable22_4  ;; 0x4c4b41
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xDA01             BGE      ??fei_fee_11
   \   00000092   0x2402             MOVS     R4,#+2
   \   00000094   0xE00A             B        ??fei_fee_9
   1581            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fei_fee_11: (+1)
   \   00000096   0x....             LDR      R1,??DataTable22_5  ;; 0x989681
   \   00000098   0x4288             CMP      R0,R1
   \   0000009A   0xDA01             BGE      ??fei_fee_12
   \   0000009C   0x2403             MOVS     R4,#+3
   \   0000009E   0xE005             B        ??fei_fee_9
   1582            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fei_fee_12: (+1)
   \   000000A0   0x....             LDR      R1,??DataTable22_6  ;; 0x1312d01
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xDA01             BGE      ??fei_fee_13
   \   000000A6   0x2404             MOVS     R4,#+4
   \   000000A8   0xE000             B        ??fei_fee_9
   1583            else {frdiv_val = 5;}
   \                     ??fei_fee_13: (+1)
   \   000000AA   0x2405             MOVS     R4,#+5
   1584             
   1585            // The FLL ref clk divide value depends on FRDIV and the RANGE value
   1586            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fei_fee_9: (+1)
   \   000000AC   0x7869             LDRB     R1,[R5, #+1]
   \   000000AE   0x0689             LSLS     R1,R1,#+26
   \   000000B0   0x0F89             LSRS     R1,R1,#+30
   \   000000B2   0xD001             BEQ      ??fei_fee_14
   1587            {
   1588              fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
   \   000000B4   0x2120             MOVS     R1,#+32
   \   000000B6   0xE000             B        ??fei_fee_15
   1589            }
   1590            else
   1591            {
   1592              fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
   \                     ??fei_fee_14: (+1)
   \   000000B8   0x2101             MOVS     R1,#+1
   \                     ??fei_fee_15: (+1)
   \   000000BA   0x40A1             LSLS     R1,R1,R4
   \   000000BC   0x.... 0x....      BL       __aeabi_idiv
   1593            }
   1594            
   1595          // Check resulting FLL frequency 
   1596            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \   000000C0   0x.... 0x....      BL       fll_freq
   1597            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   000000C4   0x283C             CMP      R0,#+60
   \   000000C6   0xDB25             BLT      ??fei_fee_16
   1598            
   1599          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1600          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1601          // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
   1602            temp_reg = MCG_C1;
   \   000000C8   0x7829             LDRB     R1,[R5, #+0]
   1603            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   1604            temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   1605            MCG_C1 = temp_reg;
   \   000000CA   0x0789             LSLS     R1,R1,#+30
   \   000000CC   0x0F89             LSRS     R1,R1,#+30
   \   000000CE   0x00E2             LSLS     R2,R4,#+3
   \   000000D0   0x430A             ORRS     R2,R2,R1
   \   000000D2   0x702A             STRB     R2,[R5, #+0]
   1606          
   1607          // if the external oscillator is used need to wait for OSCINIT to set
   1608            if (erefs_val)
   \   000000D4   0x4669             MOV      R1,SP
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x2900             CMP      R1,#+0
   \   000000DA   0xD00C             BEQ      ??fei_fee_17
   1609            {
   1610              for (i = 0 ; i < 20000000 ; i++)
   \   000000DC   0x....             LDR      R1,??DataTable22_7  ;; 0x1312d00
   \   000000DE   0x2202             MOVS     R2,#+2
   \   000000E0   0x2302             MOVS     R3,#+2
   1611              {
   1612                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \                     ??fei_fee_18: (+1)
   \   000000E2   0x79AC             LDRB     R4,[R5, #+6]
   \   000000E4   0x421C             TST      R4,R3
   \   000000E6   0xD101             BNE      ??fei_fee_19
   1613              }
   \   000000E8   0x1E49             SUBS     R1,R1,#+1
   \   000000EA   0xD1FA             BNE      ??fei_fee_18
   1614              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fei_fee_19: (+1)
   \   000000EC   0x79A9             LDRB     R1,[R5, #+6]
   \   000000EE   0x4211             TST      R1,R2
   \   000000F0   0xD101             BNE      ??fei_fee_17
   \   000000F2   0x2023             MOVS     R0,#+35
   \   000000F4   0xBDF2             POP      {R1,R4-R7,PC}
   1615            }
   1616          
   1617          // wait for Reference clock Status bit to clear
   1618            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fee_17: (+1)
   \   000000F6   0x21FA             MOVS     R1,#+250
   \   000000F8   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   1619            {
   1620              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \                     ??fei_fee_20: (+1)
   \   000000FA   0x79AA             LDRB     R2,[R5, #+6]
   \   000000FC   0x423A             TST      R2,R7
   \   000000FE   0xD001             BEQ      ??fei_fee_21
   1621            }
   \   00000100   0x1E49             SUBS     R1,R1,#+1
   \   00000102   0xD1FA             BNE      ??fei_fee_20
   1622            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fei_fee_21: (+1)
   \   00000104   0x79A9             LDRB     R1,[R5, #+6]
   \   00000106   0x4239             TST      R1,R7
   \   00000108   0xD001             BEQ      ??fei_fee_22
   \   0000010A   0x2011             MOVS     R0,#+17
   \   0000010C   0xBDF2             POP      {R1,R4-R7,PC}
   1623            
   1624          // Now in FBE  
   1625          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1626          // It is enabled here but can be removed if this is not required.
   1627            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fei_fee_22: (+1)
   \   0000010E   0x7969             LDRB     R1,[R5, #+5]
   \   00000110   0x430E             ORRS     R6,R6,R1
   \   00000112   0x716E             STRB     R6,[R5, #+5]
   1628            
   1629            return mcg_out; // MCGOUT frequency equals FLL frequency
   \                     ??fei_fee_16: (+1)
   \   00000114   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1630          } // fei_fee
   1631          
   1632          

   \                                 In section .text, align 2, keep-with-next
   1633          int fee_fei(int slow_irc_freq)
   1634          {
   \                     fee_fei: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1635            short i;
   1636            int mcg_out;
   1637          
   1638          // Check MCG is in FEE mode
   1639            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
   1640                (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external ref clk
   1641                (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R4,??DataTable21  ;; 0x40064000
   \   00000004   0x79A1             LDRB     R1,[R4, #+6]
   \   00000006   0x0709             LSLS     R1,R1,#+28
   \   00000008   0x0F89             LSRS     R1,R1,#+30
   \   0000000A   0xD106             BNE      ??fee_fei_0
   \   0000000C   0x2510             MOVS     R5,#+16
   \   0000000E   0x79A1             LDRB     R1,[R4, #+6]
   \   00000010   0x4229             TST      R1,R5
   \   00000012   0xD102             BNE      ??fee_fei_0
   \   00000014   0x79A1             LDRB     R1,[R4, #+6]
   \   00000016   0x0689             LSLS     R1,R1,#+26
   \   00000018   0xD501             BPL      ??fee_fei_1
   1642            {
   1643              return 0x2;                                                     // return error code
   \                     ??fee_fei_0: (+1)
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}
   1644            } 
   1645                
   1646          // Check IRC frequency is within spec.
   1647            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fee_fei_1: (+1)
   \   0000001E   0x....             LDR      R1,??DataTable22_8  ;; 0xffff85ee
   \   00000020   0x1841             ADDS     R1,R0,R1
   \   00000022   0x....             LDR      R2,??DataTable23  ;; 0x1e86
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD301             BCC      ??fee_fei_2
   1648            {
   1649              return 0x31;
   \   00000028   0x2031             MOVS     R0,#+49
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
   1650            }
   1651          
   1652            // Check resulting FLL frequency 
   1653            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fee_fei_2: (+1)
   \   0000002C   0x.... 0x....      BL       fll_freq
   1654            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000030   0x283C             CMP      R0,#+60
   \   00000032   0xDB12             BLT      ??fee_fei_3
   1655            
   1656          // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trigger
   1657            MCG_C6 &= ~MCG_C6_CME0_MASK;
   \   00000034   0x7961             LDRB     R1,[R4, #+5]
   \   00000036   0x22DF             MOVS     R2,#+223
   \   00000038   0x400A             ANDS     R2,R2,R1
   \   0000003A   0x7162             STRB     R2,[R4, #+5]
   1658          
   1659          // Change FLL reference clock from external to internal by setting IREFS bit
   1660            MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
   \   0000003C   0x7821             LDRB     R1,[R4, #+0]
   \   0000003E   0x2204             MOVS     R2,#+4
   \   00000040   0x430A             ORRS     R2,R2,R1
   \   00000042   0x7022             STRB     R2,[R4, #+0]
   1661            
   1662          // wait for Reference clock to switch to internal reference 
   1663            for (i = 0 ; i < 2000 ; i++)
   \   00000044   0x21FA             MOVS     R1,#+250
   \   00000046   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   1664            {
   1665              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \                     ??fee_fei_4: (+1)
   \   00000048   0x79A2             LDRB     R2,[R4, #+6]
   \   0000004A   0x422A             TST      R2,R5
   \   0000004C   0xD101             BNE      ??fee_fei_5
   1666            }
   \   0000004E   0x1E49             SUBS     R1,R1,#+1
   \   00000050   0xD1FA             BNE      ??fee_fei_4
   1667            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set  
   \                     ??fee_fei_5: (+1)
   \   00000052   0x79A1             LDRB     R1,[R4, #+6]
   \   00000054   0x4229             TST      R1,R5
   \   00000056   0xD100             BNE      ??fee_fei_3
   \   00000058   0x2012             MOVS     R0,#+18
   1668            
   1669          // Now in FEI mode  
   1670            return mcg_out;  
   \                     ??fee_fei_3: (+1)
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1671          } // fee_fei
   1672          
   1673          
   1674          

   \                                 In section .text, align 2, keep-with-next
   1675          unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq)
   1676          {
   \                     atc: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1677            unsigned char mcg_mode;
   1678            unsigned short atcv;
   1679            int bus_clock_freq;
   1680            int  bus_clk_div_val;
   1681            int orig_div;
   1682            int temp_reg;
   1683            
   1684            if (irc_select > 0) // force irc to 1 if greater than 0
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD000             BEQ      ??atc_0
   1685            {
   1686              irc_select = 1;
   \   0000000C   0x2401             MOVS     R4,#+1
   1687            }
   1688            
   1689            mcg_mode = what_mcg_mode(); // get present MCG mode
   \                     ??atc_0: (+1)
   \   0000000E   0x.... 0x....      BL       what_mcg_mode
   1690            if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
   \   00000012   0x2808             CMP      R0,#+8
   \   00000014   0xD005             BEQ      ??atc_1
   \   00000016   0x2807             CMP      R0,#+7
   \   00000018   0xD003             BEQ      ??atc_1
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xD001             BEQ      ??atc_1
   1691            {
   1692              return 1; // return error code if not in PEE, PBE or FBE modes
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE085             B        ??atc_2
   1693            }
   1694            
   1695            orig_div = SIM_CLKDIV1; //store present clock divider values
   \                     ??atc_1: (+1)
   \   00000022   0x....             LDR      R6,??DataTable23_1  ;; 0x40048044
   \   00000024   0x6837             LDR      R7,[R6, #+0]
   1696            
   1697            bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest allowed bus clock for autotrim
   1698            temp_reg = SIM_CLKDIV1;
   \   00000026   0x6831             LDR      R1,[R6, #+0]
   1699            temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
   1700            // set all bus and flash dividers to same value to ensure clocking restrictions are met
   1701            temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
   1702            SIM_CLKDIV1 = temp_reg; // set actual dividers
   \   00000028   0x....             LDR      R0,??DataTable23_2  ;; 0xfff8ffff
   \   0000002A   0x4008             ANDS     R0,R0,R1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0x9802             LDR      R0,[SP, #+8]
   \   00000030   0x....             LDR      R1,??DataTable23_3  ;; 0xf42400
   \   00000032   0x.... 0x....      BL       __aeabi_idiv
   \   00000036   0x0400             LSLS     R0,R0,#+16
   \   00000038   0x21E0             MOVS     R1,#+224
   \   0000003A   0x02C9             LSLS     R1,R1,#+11       ;; #+458752
   \   0000003C   0x4001             ANDS     R1,R1,R0
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x4301             ORRS     R1,R1,R0
   \   00000042   0x6031             STR      R1,[R6, #+0]
   1703            
   1704            bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same bus div
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0x6831             LDR      R1,[R6, #+0]
   \   00000048   0x0C09             LSRS     R1,R1,#+16
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0x.... 0x....      BL       __aeabi_uidiv
   1705            if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
   \   00000050   0x....             LDR      R1,??DataTable23_4  ;; 0xff85ee00
   \   00000052   0x1841             ADDS     R1,R0,R1
   \   00000054   0x....             LDR      R2,??DataTable22_1  ;; 0x7a1201
   \   00000056   0x4291             CMP      R1,R2
   \   00000058   0xD302             BCC      ??atc_3
   1706            {
   1707              SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   0000005A   0x6037             STR      R7,[R6, #+0]
   1708              return 3; // error, bus clock frequency is not within 8MHz to 16MHz
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0xE066             B        ??atc_2
   1709            }
   1710                          
   1711            if(!irc_select) //determine if slow or fast IRC to be trimmed
   \                     ??atc_3: (+1)
   \   00000060   0x2C00             CMP      R4,#+0
   \   00000062   0xD10B             BNE      ??atc_4
   1712            {
   1713              if (irc_freq < 31250) // check frequency is above min spec.
   \   00000064   0x0A11             LSRS     R1,R2,#+8
   \   00000066   0x428D             CMP      R5,R1
   \   00000068   0xDA02             BGE      ??atc_5
   1714              {
   1715                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   0000006A   0x6037             STR      R7,[R6, #+0]
   1716                return 4;
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0xE05E             B        ??atc_2
   1717              }
   1718              if (irc_freq > 39062) // check frequency is below max spec.
   \                     ??atc_5: (+1)
   \   00000070   0x....             LDR      R1,??DataTable23_5  ;; 0x9897
   \   00000072   0x428D             CMP      R5,R1
   \   00000074   0xDB1A             BLT      ??atc_6
   1719              {
   1720                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000076   0x6037             STR      R7,[R6, #+0]
   1721                return 5;
   \   00000078   0x2005             MOVS     R0,#+5
   \   0000007A   0xE058             B        ??atc_2
   1722              }         
   1723            }
   1724            else
   1725            {
   1726              if (irc_freq < 3000000) // check frequency is above min spec.
   \                     ??atc_4: (+1)
   \   0000007C   0x....             LDR      R1,??DataTable23_6  ;; 0x2dc6c0
   \   0000007E   0x428D             CMP      R5,R1
   \   00000080   0xDA02             BGE      ??atc_7
   1727              {
   1728                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000082   0x6037             STR      R7,[R6, #+0]
   1729                return 6;
   \   00000084   0x2006             MOVS     R0,#+6
   \   00000086   0xE052             B        ??atc_2
   1730              }
   1731              if (irc_freq > 5000000) // check frequency is below max spec.
   \                     ??atc_7: (+1)
   \   00000088   0x....             LDR      R1,??DataTable22_4  ;; 0x4c4b41
   \   0000008A   0x428D             CMP      R5,R1
   \   0000008C   0xDB02             BLT      ??atc_8
   1732              {
   1733                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   0000008E   0x6037             STR      R7,[R6, #+0]
   1734                return 7;
   \   00000090   0x2007             MOVS     R0,#+7
   \   00000092   0xE04C             B        ??atc_2
   1735              }            
   1736            } // if
   1737                  
   1738          // Set up autocal registers, must use floating point calculation
   1739            if (irc_select) 
   1740              atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
   \                     ??atc_8: (+1)
   \   00000094   0x.... 0x....      BL       __aeabi_i2f
   \   00000098   0x9000             STR      R0,[SP, #+0]
   \   0000009A   0x0028             MOVS     R0,R5
   \   0000009C   0x.... 0x....      BL       __aeabi_i2f
   \   000000A0   0x0001             MOVS     R1,R0
   \   000000A2   0x9800             LDR      R0,[SP, #+0]
   \   000000A4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000A8   0x....             LDR      R1,??DataTable23_7  ;; 0x45280000
   \   000000AA   0xE00A             B        ??atc_9
   1741            else
   1742              atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
   \                     ??atc_6: (+1)
   \   000000AC   0x.... 0x....      BL       __aeabi_i2f
   \   000000B0   0x9000             STR      R0,[SP, #+0]
   \   000000B2   0x0028             MOVS     R0,R5
   \   000000B4   0x.... 0x....      BL       __aeabi_i2f
   \   000000B8   0x0001             MOVS     R1,R0
   \   000000BA   0x9800             LDR      R0,[SP, #+0]
   \   000000BC   0x.... 0x....      BL       __aeabi_fdiv
   \   000000C0   0x....             LDR      R1,??DataTable24  ;; 0x41a80000
   \                     ??atc_9: (+1)
   \   000000C2   0x.... 0x....      BL       __aeabi_fmul
   \   000000C6   0x.... 0x....      BL       __aeabi_f2iz
   \   000000CA   0xB280             UXTH     R0,R0
   1743                  
   1744            MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
   \   000000CC   0x....             LDR      R1,??DataTable25  ;; 0x40064002
   \   000000CE   0x7248             STRB     R0,[R1, #+9]
   1745            MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
   \   000000D0   0x0A00             LSRS     R0,R0,#+8
   \   000000D2   0x7208             STRB     R0,[R1, #+8]
   1746          
   1747          // Enable autocal
   1748            MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
   \   000000D4   0x7988             LDRB     R0,[R1, #+6]
   \   000000D6   0x06C0             LSLS     R0,R0,#+27
   \   000000D8   0x0EC0             LSRS     R0,R0,#+27
   \   000000DA   0x7188             STRB     R0,[R1, #+6]
   1749            temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enable trim machine
   1750            MCG_SC |= temp_reg;
   \   000000DC   0x2080             MOVS     R0,#+128
   \   000000DE   0x798A             LDRB     R2,[R1, #+6]
   \   000000E0   0x01A3             LSLS     R3,R4,#+6
   \   000000E2   0x4303             ORRS     R3,R3,R0
   \   000000E4   0x4313             ORRS     R3,R3,R2
   \   000000E6   0x718B             STRB     R3,[R1, #+6]
   1751                  
   1752            while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
   \                     ??atc_10: (+1)
   \   000000E8   0x798A             LDRB     R2,[R1, #+6]
   \   000000EA   0x4202             TST      R2,R0
   \   000000EC   0xD1FC             BNE      ??atc_10
   1753                  
   1754            if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
   \   000000EE   0x7988             LDRB     R0,[R1, #+6]
   \   000000F0   0x0680             LSLS     R0,R0,#+26
   \   000000F2   0xD502             BPL      ??atc_11
   1755            {
   1756              SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   000000F4   0x6037             STR      R7,[R6, #+0]
   1757              return 8;
   \   000000F6   0x2008             MOVS     R0,#+8
   \   000000F8   0xE019             B        ??atc_2
   1758            } 
   1759            else 
   1760            {      
   1761              if (!irc_select)
   \                     ??atc_11: (+1)
   \   000000FA   0x2C00             CMP      R4,#+0
   \   000000FC   0xD108             BNE      ??atc_12
   1762              {
   1763                if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
   \   000000FE   0x7808             LDRB     R0,[R1, #+0]
   \   00000100   0x28FF             CMP      R0,#+255
   \   00000102   0xD002             BEQ      ??atc_13
   \   00000104   0x7808             LDRB     R0,[R1, #+0]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD10F             BNE      ??atc_14
   1764                {
   1765                  SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_13: (+1)
   \   0000010A   0x6037             STR      R7,[R6, #+0]
   1766                  return 9;
   \   0000010C   0x2009             MOVS     R0,#+9
   \   0000010E   0xE00E             B        ??atc_2
   1767                }
   1768              }
   1769              else
   1770              {
   1771                if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
   1772                    (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
   \                     ??atc_12: (+1)
   \   00000110   0x200F             MOVS     R0,#+15
   \   00000112   0x784A             LDRB     R2,[R1, #+1]
   \   00000114   0x0852             LSRS     R2,R2,#+1
   \   00000116   0x4002             ANDS     R2,R2,R0
   \   00000118   0x2A0F             CMP      R2,#+15
   \   0000011A   0xD003             BEQ      ??atc_15
   \   0000011C   0x7849             LDRB     R1,[R1, #+1]
   \   0000011E   0x0849             LSRS     R1,R1,#+1
   \   00000120   0x4008             ANDS     R0,R0,R1
   \   00000122   0xD102             BNE      ??atc_14
   1773                {
   1774                  SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_15: (+1)
   \   00000124   0x6037             STR      R7,[R6, #+0]
   1775                  return 10;
   \   00000126   0x200A             MOVS     R0,#+10
   \   00000128   0xE001             B        ??atc_2
   1776                }
   1777              }
   1778            }
   1779            SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_14: (+1)
   \   0000012A   0x6037             STR      R7,[R6, #+0]
   1780            return 0;
   \   0000012C   0x2000             MOVS     R0,#+0
   \                     ??atc_2: (+1)
   \   0000012E   0xB003             ADD      SP,SP,#+12
   \   00000130   0xBDF0             POP      {R4-R7,PC}       ;; return
   1781          }// atc
   1782          
   1783          
   1784          
   1785          

   \                                 In section .text, align 2, keep-with-next
   1786          int fll_freq(int fll_ref)
   1787          {
   \                     fll_freq: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
   1788            int fll_freq_hz = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   1789            
   1790            // Check that only allowed ranges have been selected
   1791            if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
   \   00000006   0x2203             MOVS     R2,#+3
   \   00000008   0x....             LDR      R3,??DataTable26  ;; 0x40064003
   \   0000000A   0x781C             LDRB     R4,[R3, #+0]
   \   0000000C   0x0964             LSRS     R4,R4,#+5
   \   0000000E   0x4014             ANDS     R4,R4,R2
   \   00000010   0x2C02             CMP      R4,#+2
   \   00000012   0xD301             BCC      ??fll_freq_0
   1792            {
   1793              return 0x3B; // return error code if DRS range 2 or 3 selected
   \   00000014   0x203B             MOVS     R0,#+59
   \   00000016   0xE062             B        ??fll_freq_1
   1794            }
   1795            
   1796            if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
   \                     ??fll_freq_0: (+1)
   \   00000018   0x781C             LDRB     R4,[R3, #+0]
   \   0000001A   0x0624             LSLS     R4,R4,#+24
   \   0000001C   0x781B             LDRB     R3,[R3, #+0]
   \   0000001E   0xD536             BPL      ??fll_freq_2
   1797            {
   1798              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   \   00000020   0x095B             LSRS     R3,R3,#+5
   \   00000022   0x401A             ANDS     R2,R2,R3
   \   00000024   0xD005             BEQ      ??fll_freq_3
   \   00000026   0x2A02             CMP      R2,#+2
   \   00000028   0xD01B             BEQ      ??fll_freq_4
   \   0000002A   0xD30E             BCC      ??fll_freq_5
   \   0000002C   0x2A03             CMP      R2,#+3
   \   0000002E   0xD023             BEQ      ??fll_freq_6
   \   00000030   0xE055             B        ??fll_freq_1
   1799              {
   1800              case 0:
   1801                fll_freq_hz = (fll_ref * 732);
   \                     ??fll_freq_3: (+1)
   \   00000032   0x20B7             MOVS     R0,#+183
   \   00000034   0x0080             LSLS     R0,R0,#+2        ;; #+732
   \   00000036   0x4341             MULS     R1,R0,R1
   \   00000038   0x0008             MOVS     R0,R1
   1802                if (fll_freq_hz < 20000000) {return 0x33;}
   \   0000003A   0x....             LDR      R1,??DataTable26_1  ;; 0x1312d00
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xDB35             BLT      ??fll_freq_7
   1803                else if (fll_freq_hz > 25000000) {return 0x34;}
   1804                break;
   1805              case 1:
   1806                fll_freq_hz = (fll_ref * 1464);
   1807                if (fll_freq_hz < 40000000) {return 0x35;}
   1808                else if (fll_freq_hz > 50000000) {return 0x36;}
   1809                break;
   1810              case 2:
   1811                fll_freq_hz = (fll_ref * 2197);
   1812                if (fll_freq_hz < 60000000) {return 0x37;}
   1813                else if (fll_freq_hz > 75000000) {return 0x38;}
   1814                break;
   1815              case 3:
   1816                fll_freq_hz = (fll_ref * 2929);
   1817                if (fll_freq_hz < 80000000) {return 0x39;}
   1818                else if (fll_freq_hz > 100000000) {return 0x3A;}
   1819                break;
   1820              }
   1821            }
   1822            else // if DMX32 = 0
   1823            {
   1824              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   1825              {
   1826              case 0:
   1827                fll_freq_hz = (fll_ref * 640);
   1828                if (fll_freq_hz < 20000000) {return 0x33;}
   1829                else if (fll_freq_hz > 25000000) {return 0x34;}
   \                     ??fll_freq_8: (+1)
   \   00000040   0x....             LDR      R1,??DataTable26_2  ;; 0x17d7841
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xDB4B             BLT      ??fll_freq_1
   \   00000046   0x2034             MOVS     R0,#+52
   \   00000048   0xE049             B        ??fll_freq_1
   \                     ??fll_freq_5: (+1)
   \   0000004A   0x20B7             MOVS     R0,#+183
   \   0000004C   0x00C0             LSLS     R0,R0,#+3        ;; #+1464
   \   0000004E   0x4341             MULS     R1,R0,R1
   \   00000050   0x0008             MOVS     R0,R1
   \   00000052   0x....             LDR      R1,??DataTable26_3  ;; 0x2625a00
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xDB31             BLT      ??fll_freq_9
   1830                break;
   1831              case 1:
   1832                fll_freq_hz = (fll_ref * 1280);
   1833                if (fll_freq_hz < 40000000) {return 0x35;}
   1834                else if (fll_freq_hz > 50000000) {return 0x36;}
   \                     ??fll_freq_10: (+1)
   \   00000058   0x....             LDR      R1,??DataTable26_4  ;; 0x2faf081
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xDB3F             BLT      ??fll_freq_1
   \   0000005E   0x2036             MOVS     R0,#+54
   \   00000060   0xE03D             B        ??fll_freq_1
   \                     ??fll_freq_4: (+1)
   \   00000062   0x....             LDR      R0,??DataTable26_5  ;; 0x895
   \   00000064   0x4341             MULS     R1,R0,R1
   \   00000066   0x0008             MOVS     R0,R1
   \   00000068   0x....             LDR      R1,??DataTable26_6  ;; 0x3938700
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xDB2E             BLT      ??fll_freq_11
   1835                break;
   1836              case 2:
   1837                fll_freq_hz = (fll_ref * 1920);
   1838                if (fll_freq_hz < 60000000) {return 0x37;}
   1839                else if (fll_freq_hz > 75000000) {return 0x38;}
   \                     ??fll_freq_12: (+1)
   \   0000006E   0x....             LDR      R1,??DataTable26_7  ;; 0x47868c1
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xDB34             BLT      ??fll_freq_1
   \   00000074   0x2038             MOVS     R0,#+56
   \   00000076   0xE032             B        ??fll_freq_1
   \                     ??fll_freq_6: (+1)
   \   00000078   0x....             LDR      R0,??DataTable26_8  ;; 0xb71
   \   0000007A   0x4341             MULS     R1,R0,R1
   \   0000007C   0x0008             MOVS     R0,R1
   \   0000007E   0x....             LDR      R1,??DataTable26_9  ;; 0x4c4b400
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xDB2B             BLT      ??fll_freq_13
   1840                break;
   1841              case 3:
   1842                fll_freq_hz = (fll_ref * 2560);
   1843                if (fll_freq_hz < 80000000) {return 0x39;}
   1844                else if (fll_freq_hz > 100000000) {return 0x3A;}
   \                     ??fll_freq_14: (+1)
   \   00000084   0x....             LDR      R1,??DataTable26_10  ;; 0x5f5e101
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xDB29             BLT      ??fll_freq_1
   \   0000008A   0x203A             MOVS     R0,#+58
   \   0000008C   0xE027             B        ??fll_freq_1
   \                     ??fll_freq_2: (+1)
   \   0000008E   0x095B             LSRS     R3,R3,#+5
   \   00000090   0x401A             ANDS     R2,R2,R3
   \   00000092   0xD005             BEQ      ??fll_freq_15
   \   00000094   0x2A02             CMP      R2,#+2
   \   00000096   0xD013             BEQ      ??fll_freq_16
   \   00000098   0xD30A             BCC      ??fll_freq_17
   \   0000009A   0x2A03             CMP      R2,#+3
   \   0000009C   0xD018             BEQ      ??fll_freq_18
   \   0000009E   0xE01E             B        ??fll_freq_1
   \                     ??fll_freq_15: (+1)
   \   000000A0   0x0088             LSLS     R0,R1,#+2
   \   000000A2   0x1840             ADDS     R0,R0,R1
   \   000000A4   0x01C0             LSLS     R0,R0,#+7
   \   000000A6   0x....             LDR      R1,??DataTable26_1  ;; 0x1312d00
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xDAC9             BGE      ??fll_freq_8
   \                     ??fll_freq_7: (+1)
   \   000000AC   0x2033             MOVS     R0,#+51
   \   000000AE   0xE016             B        ??fll_freq_1
   \                     ??fll_freq_17: (+1)
   \   000000B0   0x0088             LSLS     R0,R1,#+2
   \   000000B2   0x1840             ADDS     R0,R0,R1
   \   000000B4   0x0200             LSLS     R0,R0,#+8
   \   000000B6   0x....             LDR      R1,??DataTable26_3  ;; 0x2625a00
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xDACD             BGE      ??fll_freq_10
   \                     ??fll_freq_9: (+1)
   \   000000BC   0x2035             MOVS     R0,#+53
   \   000000BE   0xE00E             B        ??fll_freq_1
   \                     ??fll_freq_16: (+1)
   \   000000C0   0x0108             LSLS     R0,R1,#+4
   \   000000C2   0x1A40             SUBS     R0,R0,R1
   \   000000C4   0x01C0             LSLS     R0,R0,#+7
   \   000000C6   0x....             LDR      R1,??DataTable26_6  ;; 0x3938700
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xDAD0             BGE      ??fll_freq_12
   \                     ??fll_freq_11: (+1)
   \   000000CC   0x2037             MOVS     R0,#+55
   \   000000CE   0xE006             B        ??fll_freq_1
   \                     ??fll_freq_18: (+1)
   \   000000D0   0x0088             LSLS     R0,R1,#+2
   \   000000D2   0x1840             ADDS     R0,R0,R1
   \   000000D4   0x0240             LSLS     R0,R0,#+9
   \   000000D6   0x....             LDR      R1,??DataTable26_9  ;; 0x4c4b400
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xDAD3             BGE      ??fll_freq_14
   \                     ??fll_freq_13: (+1)
   \   000000DC   0x2039             MOVS     R0,#+57
   1845                break;
   1846              }
   1847            }    
   1848            return fll_freq_hz;
   \                     ??fll_freq_1: (+1)
   \   000000DE   0xBC10             POP      {R4}
   \   000000E0   0x4770             BX       LR               ;; return
   1849          } // fll_freq
   1850          
   1851          

   \                                 In section .text, align 2, keep-with-next
   1852          unsigned char what_mcg_mode(void)
   1853          {
   1854            // check if in FEI mode
   1855            if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selcted FLL output
   1856                (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is internal ref clk
   1857                (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has selected FLL
   \                     what_mcg_mode: (+1)
   \   00000000   0x....             LDR      R0,??DataTable26_11  ;; 0x40064001
   \   00000002   0x2110             MOVS     R1,#+16
   \   00000004   0x2203             MOVS     R2,#+3
   \   00000006   0x7943             LDRB     R3,[R0, #+5]
   \   00000008   0x089B             LSRS     R3,R3,#+2
   \   0000000A   0x4013             ANDS     R3,R3,R2
   \   0000000C   0xD107             BNE      ??what_mcg_mode_0
   \   0000000E   0x7943             LDRB     R3,[R0, #+5]
   \   00000010   0x420B             TST      R3,R1
   \   00000012   0xD004             BEQ      ??what_mcg_mode_0
   \   00000014   0x7943             LDRB     R3,[R0, #+5]
   \   00000016   0x069B             LSLS     R3,R3,#+26
   \   00000018   0xD401             BMI      ??what_mcg_mode_0
   1858            {
   1859              return FEI;                                                          // return FEI code
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0x4770             BX       LR
   1860            }
   1861            // Check MCG is in PEE mode
   1862            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted PLL output
   1863                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1864                    (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has selected PLL 
   \                     ??what_mcg_mode_0: (+1)
   \   0000001E   0x7943             LDRB     R3,[R0, #+5]
   \   00000020   0x089B             LSRS     R3,R3,#+2
   \   00000022   0x4013             ANDS     R3,R3,R2
   \   00000024   0x2B03             CMP      R3,#+3
   \   00000026   0xD107             BNE      ??what_mcg_mode_1
   \   00000028   0x7943             LDRB     R3,[R0, #+5]
   \   0000002A   0x420B             TST      R3,R1
   \   0000002C   0xD104             BNE      ??what_mcg_mode_1
   \   0000002E   0x7943             LDRB     R3,[R0, #+5]
   \   00000030   0x069B             LSLS     R3,R3,#+26
   \   00000032   0xD501             BPL      ??what_mcg_mode_1
   1865            {
   1866              return PEE;                                                          // return PEE code
   \   00000034   0x2008             MOVS     R0,#+8
   \   00000036   0x4770             BX       LR
   1867            }
   1868            // Check MCG is in PBE mode
   1869            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1870                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1871                    (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has selected PLL
   1872                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is not set
   \                     ??what_mcg_mode_1: (+1)
   \   00000038   0x7943             LDRB     R3,[R0, #+5]
   \   0000003A   0x089B             LSRS     R3,R3,#+2
   \   0000003C   0x4013             ANDS     R3,R3,R2
   \   0000003E   0x2B02             CMP      R3,#+2
   \   00000040   0xD10A             BNE      ??what_mcg_mode_2
   \   00000042   0x7943             LDRB     R3,[R0, #+5]
   \   00000044   0x420B             TST      R3,R1
   \   00000046   0xD107             BNE      ??what_mcg_mode_2
   \   00000048   0x7943             LDRB     R3,[R0, #+5]
   \   0000004A   0x069B             LSLS     R3,R3,#+26
   \   0000004C   0xD504             BPL      ??what_mcg_mode_2
   \   0000004E   0x7803             LDRB     R3,[R0, #+0]
   \   00000050   0x079B             LSLS     R3,R3,#+30
   \   00000052   0xD401             BMI      ??what_mcg_mode_2
   1873            {
   1874              return PBE;                                                          // return PBE code
   \   00000054   0x2007             MOVS     R0,#+7
   \   00000056   0x4770             BX       LR
   1875            }
   1876            // Check MCG is in FBE mode
   1877            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1878                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1879                    (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1880                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is not set   
   \                     ??what_mcg_mode_2: (+1)
   \   00000058   0x7943             LDRB     R3,[R0, #+5]
   \   0000005A   0x089B             LSRS     R3,R3,#+2
   \   0000005C   0x4013             ANDS     R3,R3,R2
   \   0000005E   0x2B02             CMP      R3,#+2
   \   00000060   0xD10A             BNE      ??what_mcg_mode_3
   \   00000062   0x7943             LDRB     R3,[R0, #+5]
   \   00000064   0x420B             TST      R3,R1
   \   00000066   0xD107             BNE      ??what_mcg_mode_3
   \   00000068   0x7943             LDRB     R3,[R0, #+5]
   \   0000006A   0x069B             LSLS     R3,R3,#+26
   \   0000006C   0xD404             BMI      ??what_mcg_mode_3
   \   0000006E   0x7803             LDRB     R3,[R0, #+0]
   \   00000070   0x079B             LSLS     R3,R3,#+30
   \   00000072   0xD401             BMI      ??what_mcg_mode_3
   1881            {
   1882              return FBE;                                                          // return FBE code
   \   00000074   0x2005             MOVS     R0,#+5
   \   00000076   0x4770             BX       LR
   1883            }
   1884            // Check MCG is in BLPE mode
   1885            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1886                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1887                    (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is set   
   \                     ??what_mcg_mode_3: (+1)
   \   00000078   0x7943             LDRB     R3,[R0, #+5]
   \   0000007A   0x089B             LSRS     R3,R3,#+2
   \   0000007C   0x4013             ANDS     R3,R3,R2
   \   0000007E   0x2B02             CMP      R3,#+2
   \   00000080   0xD107             BNE      ??what_mcg_mode_4
   \   00000082   0x7943             LDRB     R3,[R0, #+5]
   \   00000084   0x420B             TST      R3,R1
   \   00000086   0xD104             BNE      ??what_mcg_mode_4
   \   00000088   0x7803             LDRB     R3,[R0, #+0]
   \   0000008A   0x079B             LSLS     R3,R3,#+30
   \   0000008C   0xD501             BPL      ??what_mcg_mode_4
   1888            {
   1889              return BLPE;                                                         // return BLPE code
   \   0000008E   0x2006             MOVS     R0,#+6
   \   00000090   0x4770             BX       LR
   1890            }
   1891            // check if in BLPI mode
   1892            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1893                    (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is internal ref clk
   1894                    (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1895                    (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
   \                     ??what_mcg_mode_4: (+1)
   \   00000092   0x7943             LDRB     R3,[R0, #+5]
   \   00000094   0x089B             LSRS     R3,R3,#+2
   \   00000096   0x4013             ANDS     R3,R3,R2
   \   00000098   0x2B01             CMP      R3,#+1
   \   0000009A   0xD10A             BNE      ??what_mcg_mode_5
   \   0000009C   0x7943             LDRB     R3,[R0, #+5]
   \   0000009E   0x420B             TST      R3,R1
   \   000000A0   0xD007             BEQ      ??what_mcg_mode_5
   \   000000A2   0x7943             LDRB     R3,[R0, #+5]
   \   000000A4   0x069B             LSLS     R3,R3,#+26
   \   000000A6   0xD404             BMI      ??what_mcg_mode_5
   \   000000A8   0x7803             LDRB     R3,[R0, #+0]
   \   000000AA   0x079B             LSLS     R3,R3,#+30
   \   000000AC   0xD501             BPL      ??what_mcg_mode_5
   1896            {
   1897              return BLPI;                                                         // return BLPI code
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0x4770             BX       LR
   1898            }
   1899            // check if in FBI mode
   1900            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1901                    (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is internal ref clk
   1902                    (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1903                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
   \                     ??what_mcg_mode_5: (+1)
   \   000000B2   0x7943             LDRB     R3,[R0, #+5]
   \   000000B4   0x089B             LSRS     R3,R3,#+2
   \   000000B6   0x4013             ANDS     R3,R3,R2
   \   000000B8   0x2B01             CMP      R3,#+1
   \   000000BA   0xD10A             BNE      ??what_mcg_mode_6
   \   000000BC   0x7943             LDRB     R3,[R0, #+5]
   \   000000BE   0x420B             TST      R3,R1
   \   000000C0   0xD007             BEQ      ??what_mcg_mode_6
   \   000000C2   0x7943             LDRB     R3,[R0, #+5]
   \   000000C4   0x069B             LSLS     R3,R3,#+26
   \   000000C6   0xD404             BMI      ??what_mcg_mode_6
   \   000000C8   0x7803             LDRB     R3,[R0, #+0]
   \   000000CA   0x079B             LSLS     R3,R3,#+30
   \   000000CC   0xD401             BMI      ??what_mcg_mode_6
   1904            {  
   1905              return FBI;                                                          // return FBI code 
   \   000000CE   0x2002             MOVS     R0,#+2
   \   000000D0   0x4770             BX       LR
   1906            }
   1907            // Check MCG is in FEE mode
   1908            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
   1909                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1910                    (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has selected FLL
   \                     ??what_mcg_mode_6: (+1)
   \   000000D2   0x7943             LDRB     R3,[R0, #+5]
   \   000000D4   0x089B             LSRS     R3,R3,#+2
   \   000000D6   0x401A             ANDS     R2,R2,R3
   \   000000D8   0xD107             BNE      ??what_mcg_mode_7
   \   000000DA   0x7942             LDRB     R2,[R0, #+5]
   \   000000DC   0x420A             TST      R2,R1
   \   000000DE   0xD104             BNE      ??what_mcg_mode_7
   \   000000E0   0x7940             LDRB     R0,[R0, #+5]
   \   000000E2   0x0680             LSLS     R0,R0,#+26
   \   000000E4   0xD401             BMI      ??what_mcg_mode_7
   1911            {
   1912              return FEE;                                                          // return FEE code
   \   000000E6   0x2004             MOVS     R0,#+4
   \   000000E8   0x4770             BX       LR
   1913            }
   1914            else
   1915            {
   1916              return 0;                                                            // error condition
   \                     ??what_mcg_mode_7: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x4770             BX       LR               ;; return
   1917            }
   1918          } // what_mcg_mode
   1919          
   1920          
   1921          /********************************************************************/
   1922          /* Functon name : clk_monitor_0
   1923           *
   1924           * This function SIMply enables or disables the OSC 0 clock monitor. This is
   1925           * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to  
   1926           * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
   1927           * It MUST be disabled in all other modes or a reset may be generated. It must
   1928           * also be disabled if it is desired to enter VLPR from BLPE mode.
   1929           *
   1930           * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
   1931           *
   1932           * Return value : none
   1933           */

   \                                 In section .text, align 2, keep-with-next
   1934          void clk_monitor_0(unsigned char en_dis)
   1935          {         
   1936            if (en_dis)
   \                     clk_monitor_0: (+1)
   \   00000000   0x....             LDR      R1,??DataTable26_12  ;; 0x40064005
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0xD002             BEQ      ??clk_monitor_0_0
   1937            {
   1938              MCG_C6 |= MCG_C6_CME0_MASK;   
   \   00000008   0x2220             MOVS     R2,#+32
   \   0000000A   0x4302             ORRS     R2,R2,R0
   \   0000000C   0xE001             B        ??clk_monitor_0_1
   1939            }
   1940            else
   1941            {
   1942              MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??clk_monitor_0_0: (+1)
   \   0000000E   0x22DF             MOVS     R2,#+223
   \   00000010   0x4002             ANDS     R2,R2,R0
   \                     ??clk_monitor_0_1: (+1)
   \   00000012   0x700A             STRB     R2,[R1, #+0]
   1943            }
   1944          }    // end clk_monitor_0
   \   00000014   0x4770             BX       LR               ;; return
   1945          
   1946          
   1947          /********************************************************************/
   1948          /* Functon name : chk_for_resistor
   1949           *
   1950           * This function is specifically for the Freescale Tower and Freedom boards.
   1951           * It performs a SIMple check to determine if there is an 1M ohm external 
   1952           * feedback resistor connected between extal and xtal. It returns a 1 if the
   1953           * resistor is detected or a 0 if the resistor is not detected. This can be used
   1954           * by the calling routine to compare the test result with the value for HGO that
   1955           * is being used to configure the oscillator. This helps ensure the correct
   1956           * configuration is used.
   1957           *
   1958           * This check is used just to test for the presence of a 1M resistor, it MUST
   1959           * NOT be used in user code to automatically configure the oscillator HGO value.
   1960           *
   1961           * It SIMply configures the crystal pins as GPIO outputs, sets them both low,
   1962           * configures one as high and then configures the other as an input (no pull
   1963           * up). If the resistor is present then the input will be pulled high. This
   1964           * process is repeated for the pin functions reversed. Both conditions have 
   1965           * to result in the input being pulled high for the resistor to be identifiedas
   1966           * being present.
   1967           */

   \                                 In section .text, align 2, keep-with-next
   1968          unsigned char chk_for_resistor(void)
   1969          {
   \                     chk_for_resistor: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   1970            unsigned char extal_high = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2000             MOVS     R0,#+0
   1971            unsigned char xtal_high = 0;
   1972            short i;
   1973            
   1974            // Configure EXTAL (PTA18) and XTAL PTA(19) as GPIO driving Low, no pull enabled
   1975            FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 output data
   \   00000006   0x....             LDR      R2,??DataTable26_13  ;; 0xf80ff004
   \   00000008   0x23C0             MOVS     R3,#+192
   \   0000000A   0x031B             LSLS     R3,R3,#+12       ;; #+786432
   \   0000000C   0x6053             STR      R3,[R2, #+4]
   1976            FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
   \   0000000E   0x6914             LDR      R4,[R2, #+16]
   \   00000010   0x431C             ORRS     R4,R4,R3
   \   00000012   0x6114             STR      R4,[R2, #+16]
   1977            PORTA_GPCHR = (0xC0000 | PORT_PCR_MUX(1)); // configure the pin muxes for GPIO
   \   00000014   0x....             LDR      R4,??DataTable26_14  ;; 0x40049084
   \   00000016   0x....             LDR      R5,??DataTable26_15  ;; 0xc0100
   \   00000018   0x6025             STR      R5,[R4, #+0]
   1978            // Drive EXTAL high
   1979            FGPIOA_PSOR = 0x40000; // set PTA18 data out high
   \   0000001A   0x2580             MOVS     R5,#+128
   \   0000001C   0x02ED             LSLS     R5,R5,#+11       ;; #+262144
   \   0000001E   0x6015             STR      R5,[R2, #+0]
   1980            // Configure XTAL as an Input, no pull up 
   1981            FGPIOA_PDDR &= ~(0x80000); // clear PTA19 data direction to make it an input 
   \   00000020   0x6916             LDR      R6,[R2, #+16]
   \   00000022   0x....             LDR      R7,??DataTable26_16  ;; 0xfff7ffff
   \   00000024   0x4037             ANDS     R7,R7,R6
   \   00000026   0x6117             STR      R7,[R2, #+16]
   1982            // Wait for ~2 time constants
   1983            for (i = 0 ; i < 300 ; i++) {} 
   1984            // Check if XTAL was pulled high
   1985            if (FGPIOA_PDIR & 0x80000)
   \   00000028   0x006E             LSLS     R6,R5,#+1
   \   0000002A   0x68D7             LDR      R7,[R2, #+12]
   \   0000002C   0x4037             ANDS     R7,R7,R6
   \   0000002E   0xD000             BEQ      ??chk_for_resistor_0
   1986            {
   1987              xtal_high = 1;
   \   00000030   0x2101             MOVS     R1,#+1
   1988            }
   1989            // Configure EXTAL and XTAL as GPIO driving low
   1990            FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 data output
   \                     ??chk_for_resistor_0: (+1)
   \   00000032   0x6053             STR      R3,[R2, #+4]
   1991            FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
   \   00000034   0x6917             LDR      R7,[R2, #+16]
   \   00000036   0x431F             ORRS     R7,R7,R3
   \   00000038   0x6117             STR      R7,[R2, #+16]
   1992            // Drive XTAL high
   1993            FGPIOA_PSOR = 0x80000; // set PTA19 data out high
   \   0000003A   0x6016             STR      R6,[R2, #+0]
   1994            // Configure EXTAL as Input, no pull up
   1995            FGPIOA_PDDR &= ~(0x40000); // clear PTA18 data direction to make it an input
   \   0000003C   0x6916             LDR      R6,[R2, #+16]
   \   0000003E   0x....             LDR      R7,??DataTable26_17  ;; 0xfffbffff
   \   00000040   0x4037             ANDS     R7,R7,R6
   \   00000042   0x6117             STR      R7,[R2, #+16]
   1996            // Wait for ~2 time constants
   1997            for (i = 0 ; i < 300 ; i++) {} 
   1998            // Check if EXTAL was pulled high
   1999            if (FGPIOA_PDIR & 0x40000)
   \   00000044   0x68D6             LDR      R6,[R2, #+12]
   \   00000046   0x4035             ANDS     R5,R5,R6
   \   00000048   0xD000             BEQ      ??chk_for_resistor_1
   2000            {
   2001              extal_high = 1;
   \   0000004A   0x2001             MOVS     R0,#+1
   2002            }
   2003          
   2004            // Now configure both pins back to their default state
   2005            PORTA_GPCHR = 0x000C0000; // clear pta18 and 19 mux values to default
   \                     ??chk_for_resistor_1: (+1)
   \   0000004C   0x6023             STR      R3,[R4, #+0]
   2006            FGPIOA_PDDR &= ~(0xC0000);    // set PTA18 and 19 as inputs
   \   0000004E   0x6914             LDR      R4,[R2, #+16]
   \   00000050   0x....             LDR      R5,??DataTable26_18  ;; 0xfff3ffff
   \   00000052   0x4025             ANDS     R5,R5,R4
   \   00000054   0x6115             STR      R5,[R2, #+16]
   2007            FGPIOA_PCOR = 0xC0000;        // clear PTA18 and 19 output data
   \   00000056   0x6053             STR      R3,[R2, #+4]
   2008          
   2009            // If both rising and falling are true return 1, else return 0
   2010            if (extal_high && xtal_high)
   \   00000058   0x4001             ANDS     R1,R1,R0
   \   0000005A   0x1E48             SUBS     R0,R1,#+1
   \   0000005C   0x4180             SBCS     R0,R0,R0
   \   0000005E   0x43C0             MVNS     R0,R0
   \   00000060   0x0FC0             LSRS     R0,R0,#+31
   2011            {
   2012              return 1;
   2013            }
   2014            else
   2015            {
   2016              return 0;
   \   00000062   0xBCF0             POP      {R4-R7}
   \   00000064   0x4770             BX       LR               ;; return
   2017            }       
   2018          } // chk_for_resistor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0xFFD23940         DC32     0xffd23940

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x01BA8141         DC32     0x1ba8141

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0xFFE17B80         DC32     0xffe17b80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0xFD239400         DC32     0xfd239400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x03197501         DC32     0x3197501

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x00004E20         DC32     0x4e20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xFFE17B80         DC32     0xffe17b80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0xFFE17B80         DC32     0xffe17b80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0xFD239400         DC32     0xfd239400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x03197501         DC32     0x3197501

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xFFFF85EE         DC32     0xffff85ee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0xFFFF63BF         DC32     0xffff63bf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xFFFF85EE         DC32     0xffff85ee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0xFFD23940         DC32     0xffd23940

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0xFFFF63BF         DC32     0xffff63bf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0xFFFF63BF         DC32     0xffff63bf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0xFFFF85EE         DC32     0xffff85ee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0xFFD23940         DC32     0xffd23940

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0xFFFF63BF         DC32     0xffff63bf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0x01312D00         DC32     0x1312d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0xFFFF85EE         DC32     0xffff85ee

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0xFFF8FFFF         DC32     0xfff8ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0xFF85EE00         DC32     0xff85ee00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x00009897         DC32     0x9897

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x45280000         DC32     0x45280000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x41A80000         DC32     0x41a80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x40064002         DC32     0x40064002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x40064003         DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x01312D00         DC32     0x1312d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x017D7841         DC32     0x17d7841

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x02625A00         DC32     0x2625a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x00000895         DC32     0x895

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x03938700         DC32     0x3938700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \   00000000   0x047868C1         DC32     0x47868c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \   00000000   0x00000B71         DC32     0xb71

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_9:
   \   00000000   0x04C4B400         DC32     0x4c4b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_10:
   \   00000000   0x05F5E101         DC32     0x5f5e101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_11:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_12:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_13:
   \   00000000   0xF80FF004         DC32     0xf80ff004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_14:
   \   00000000   0x40049084         DC32     0x40049084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_15:
   \   00000000   0x000C0100         DC32     0xc0100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_16:
   \   00000000   0xFFF7FFFF         DC32     0xfff7ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_17:
   \   00000000   0xFFFBFFFF         DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_18:
   \   00000000   0xFFF3FFFF         DC32     0xfff3ffff
   2019          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   atc
        32   -> __aeabi_f2iz
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_i2f
        32   -> what_mcg_mode
        32 __aeabi_idiv
        32 __aeabi_uidiv
       4   blpe_fbe
      20   blpe_pbe
        20 __aeabi_idiv
       8   blpi_fbi
         0 __aeabi_idiv
      16   chk_for_resistor
       0   clk_monitor_0
       0   fbe_blpe
      20   fbe_fbi
         0 __aeabi_idiv
      16   fbe_fee
        16   -> fll_freq
        16 __aeabi_idiv
      16   fbe_fei
        16   -> fll_freq
      24   fbe_pbe
        24 __aeabi_idiv
       8   fbi_blpi
         0 __aeabi_idiv
      24   fbi_fbe
      24   fbi_fee
        24   -> fll_freq
        24 __aeabi_idiv
      16   fbi_fei
        16   -> fll_freq
       4   fee_fbe
      20   fee_fbi
         0 __aeabi_idiv
      16   fee_fei
        16   -> fll_freq
      24   fei_fbe
      16   fei_fbi
        16 __aeabi_idiv
      24   fei_fee
        24   -> fll_freq
        24 __aeabi_idiv
       4   fll_freq
      28   new_pll_freq
        28 __aeabi_idiv
       0   pbe_blpe
       4   pbe_fbe
      16   pbe_pee
        16 __aeabi_idiv
       4   pee_pbe
      32   pll_init
        32 __aeabi_idiv
       0   what_mcg_mode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable2
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_12
       4  ??DataTable26_13
       4  ??DataTable26_14
       4  ??DataTable26_15
       4  ??DataTable26_16
       4  ??DataTable26_17
       4  ??DataTable26_18
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable9
      22  ?Subroutine0
      22  ?Subroutine1
     306  atc
      74  blpe_fbe
     170  blpe_pbe
      44  blpi_fbi
     102  chk_for_resistor
      22  clk_monitor_0
       1  dmx32_val
       1  drs_val
      44  fbe_blpe
     212  fbe_fbi
     120  fbe_fee
     132  fbe_fei
     182  fbe_pbe
      46  fbi_blpi
     310  fbi_fbe
     318  fbi_fee
     124  fbi_fei
      72  fee_fbe
     198  fee_fbi
      92  fee_fei
     298  fei_fbe
     192  fei_fbi
     278  fei_fee
     226  fll_freq
     294  new_pll_freq
      44  pbe_blpe
      72  pbe_fbe
     128  pbe_pee
      74  pee_pbe
     492  pll_init
     238  what_mcg_mode

 
     2 bytes in section .bss
 5 424 bytes in section .text
 
 5 424 bytes of CODE memory
     2 bytes of DATA memory

Errors: none
Warnings: none
