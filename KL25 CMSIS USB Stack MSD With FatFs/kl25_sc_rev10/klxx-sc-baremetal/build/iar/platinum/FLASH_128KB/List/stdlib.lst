###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        30/Nov/2015  21:44:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\stdlib.c
#    Command line =  
#        "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\stdlib.c" -D IAR -D
#        FREEDOM -lCN "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD
#        With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\"
#        -lB "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\"
#        -o "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\Obj\"
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\projects\platinum\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\common\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\cpu\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\platforms\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\" -Oh
#    List file    =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\stdlib.lst
#    Object file  =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\Obj\stdlib.o
#
###############################################################################

D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\stdlib.c
      1          /*
      2           * File:        stdlib.c
      3           * Purpose:     Functions normally found in a standard C lib.
      4           *
      5           * Notes:       This supports ASCII only!!!
      6           *
      7           */
      8          
      9          #include "common.h"
     10          #include "stdlib.h"
     11          
     12          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     13          int
     14          isspace (int ch)
     15          {
     16              if ((ch == ' ') || (ch == '\t'))    /* \n ??? */
   \                     isspace: (+1)
   \   00000000   0x2820             CMP      R0,#+32
   \   00000002   0xD001             BEQ      ??isspace_0
   \   00000004   0x2809             CMP      R0,#+9
   \   00000006   0xD101             BNE      ??isspace_1
     17                  return TRUE;
   \                     ??isspace_0: (+1)
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
     18              else
     19                  return FALSE;
   \                     ??isspace_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     20          }
     21          
     22          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     23          int
     24          isalnum (int ch)
     25          {
     26              /* ASCII only */
     27              if (((ch >= '0') && (ch <= '9')) ||
     28                  ((ch >= 'A') && (ch <= 'Z')) ||
     29                  ((ch >= 'a') && (ch <= 'z')))
   \                     isalnum: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0x3930             SUBS     R1,R1,#+48
   \   00000004   0x290A             CMP      R1,#+10
   \   00000006   0xD306             BCC      ??isalnum_0
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0x3941             SUBS     R1,R1,#+65
   \   0000000C   0x291A             CMP      R1,#+26
   \   0000000E   0xD302             BCC      ??isalnum_0
   \   00000010   0x3861             SUBS     R0,R0,#+97
   \   00000012   0x281A             CMP      R0,#+26
   \   00000014   0xD201             BCS      ??isalnum_1
     30                  return TRUE;
   \                     ??isalnum_0: (+1)
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x4770             BX       LR
     31              else
     32                  return FALSE;
   \                     ??isalnum_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
     33          }
     34          
     35          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     36          int
     37          isdigit (int ch)
     38          {
     39              /* ASCII only */
     40              if ((ch >= '0') && (ch <= '9'))
   \                     isdigit: (+1)
   \   00000000   0x3830             SUBS     R0,R0,#+48
   \   00000002   0x280A             CMP      R0,#+10
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
     41                  return TRUE;
     42              else
     43                  return FALSE;
   \   00000008   0x4770             BX       LR               ;; return
     44          }
     45          
     46          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     47          int
     48          isupper (int ch)
     49          {
     50              /* ASCII only */
     51              if ((ch >= 'A') && (ch <= 'Z'))
   \                     isupper: (+1)
   \   00000000   0x3841             SUBS     R0,R0,#+65
   \   00000002   0x281A             CMP      R0,#+26
   \   00000004   0x4180             SBCS     R0,R0,R0
   \   00000006   0x0FC0             LSRS     R0,R0,#+31
     52                  return TRUE;
     53              else
     54                  return FALSE;
   \   00000008   0x4770             BX       LR               ;; return
     55          }
     56          
     57          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     58          int
     59          strcasecmp (const char *s1, const char *s2)
     60          {
   \                     strcasecmp: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
     61              char    c1, c2;
     62              int     result = 0;
     63          
     64              while (result == 0)
     65              {
     66                  c1 = *s1++;
   \                     ??strcasecmp_0: (+1)
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x1C52             ADDS     R2,R2,#+1
     67                  c2 = *s2++;
   \   00000008   0x780C             LDRB     R4,[R1, #+0]
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
     68                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   0000000C   0x0018             MOVS     R0,R3
   \   0000000E   0x3861             SUBS     R0,R0,#+97
   \   00000010   0x281A             CMP      R0,#+26
   \   00000012   0xD201             BCS      ??strcasecmp_1
     69                      c1 = (char)(c1 - ' ');
   \   00000014   0x3B20             SUBS     R3,R3,#+32
   \   00000016   0xB2DB             UXTB     R3,R3
     70                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strcasecmp_1: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x3861             SUBS     R0,R0,#+97
   \   0000001C   0x281A             CMP      R0,#+26
   \   0000001E   0xD201             BCS      ??strcasecmp_2
     71                      c2 = (char)(c2 - ' ');
   \   00000020   0x3C20             SUBS     R4,R4,#+32
   \   00000022   0xB2E4             UXTB     R4,R4
     72                  if ((result = (c1 - c2)) != 0)
   \                     ??strcasecmp_2: (+1)
   \   00000024   0x1B18             SUBS     R0,R3,R4
   \   00000026   0xD103             BNE      ??strcasecmp_3
     73                      break;
     74                  if ((c1 == 0) || (c2 == 0))
   \   00000028   0x2B00             CMP      R3,#+0
   \   0000002A   0xD001             BEQ      ??strcasecmp_3
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD1E9             BNE      ??strcasecmp_0
     75                      break;
     76              }
     77              return result;
   \                     ??strcasecmp_3: (+1)
   \   00000030   0xBC10             POP      {R4}
   \   00000032   0x4770             BX       LR               ;; return
     78          }
     79          
     80          
     81          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
     82          int
     83          strncasecmp (const char *s1, const char *s2, int n)
     84          {
   \                     strncasecmp: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x000B             MOVS     R3,R1
     85              char    c1, c2;
     86              int     k = 0;
   \   00000004   0x2600             MOVS     R6,#+0
     87              int     result = 0;
   \   00000006   0x2100             MOVS     R1,#+0
     88          
     89              while ( k++ < n )
   \                     ??strncasecmp_0: (+1)
   \   00000008   0x4296             CMP      R6,R2
   \   0000000A   0xDA16             BGE      ??strncasecmp_1
   \   0000000C   0x1C76             ADDS     R6,R6,#+1
     90              {
     91                  c1 = *s1++;
   \   0000000E   0x7804             LDRB     R4,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
     92                  c2 = *s2++;
   \   00000012   0x781D             LDRB     R5,[R3, #+0]
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
     93                  if ((c1 >= 'a') && (c1 <= 'z'))
   \   00000016   0x0021             MOVS     R1,R4
   \   00000018   0x3961             SUBS     R1,R1,#+97
   \   0000001A   0x291A             CMP      R1,#+26
   \   0000001C   0xD201             BCS      ??strncasecmp_2
     94                      c1 = (char)(c1 - ' ');
   \   0000001E   0x3C20             SUBS     R4,R4,#+32
   \   00000020   0xB2E4             UXTB     R4,R4
     95                  if ((c2 >= 'a') && (c2 <= 'z'))
   \                     ??strncasecmp_2: (+1)
   \   00000022   0x0029             MOVS     R1,R5
   \   00000024   0x3961             SUBS     R1,R1,#+97
   \   00000026   0x291A             CMP      R1,#+26
   \   00000028   0xD201             BCS      ??strncasecmp_3
     96                      c2 = (char)(c2 - ' ');
   \   0000002A   0x3D20             SUBS     R5,R5,#+32
   \   0000002C   0xB2ED             UXTB     R5,R5
     97                  if ((result = (c1 - c2)) != 0)
   \                     ??strncasecmp_3: (+1)
   \   0000002E   0x1B61             SUBS     R1,R4,R5
   \   00000030   0xD103             BNE      ??strncasecmp_1
     98                      break;
     99                  if ((c1 == 0) || (c2 == 0))
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD001             BEQ      ??strncasecmp_1
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD1E6             BNE      ??strncasecmp_0
    100                      break;
    101              }
    102              return result;
   \                     ??strncasecmp_1: (+1)
   \   0000003A   0x0008             MOVS     R0,R1
   \   0000003C   0xBC70             POP      {R4-R6}
   \   0000003E   0x4770             BX       LR               ;; return
    103          }
    104          
    105          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          uint32
    107          strtoul (char *str, char **ptr, int base)
    108          {
   \                     strtoul: (+1)
   \   00000000   0xB4F2             PUSH     {R1,R4-R7}
   \   00000002   0x0001             MOVS     R1,R0
    109              unsigned long rvalue;
    110              int c, err, neg;
    111              char *endp;
    112              char *startp;
    113          
    114              rvalue = 0;  err = 0;  neg = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x2300             MOVS     R3,#+0
    115          
    116              /* Check for invalid arguments */
    117              if ((str == NULL) || (base < 0) || (base == 1) || (base > 36))
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD03E             BEQ      ??strtoul_0
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD43C             BMI      ??strtoul_0
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xD03A             BEQ      ??strtoul_0
   \   00000016   0x2A25             CMP      R2,#+37
   \   00000018   0xDA38             BGE      ??strtoul_0
    118              {
    119                  if (ptr != NULL)
    120                  {
    121                      *ptr = str;
    122                  }
    123                  return 0;
    124              }
    125          
    126              /* Skip leading white spaces */
    127              for (startp = str; isspace(*startp); ++startp)
   \   0000001A   0x000C             MOVS     R4,R1
   \   0000001C   0xE000             B        ??strtoul_1
   \                     ??strtoul_2: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??strtoul_1: (+1)
   \   00000020   0x7826             LDRB     R6,[R4, #+0]
   \   00000022   0x2E20             CMP      R6,#+32
   \   00000024   0xD0FB             BEQ      ??strtoul_2
   \   00000026   0x2E09             CMP      R6,#+9
   \   00000028   0xD0F9             BEQ      ??strtoul_2
    128                  ;
    129          
    130              /* Check for notations */
    131              switch (startp[0])
   \   0000002A   0x2E2D             CMP      R6,#+45
   \   0000002C   0xD00D             BEQ      ??strtoul_3
   \   0000002E   0x2E30             CMP      R6,#+48
   \   00000030   0xD10D             BNE      ??strtoul_4
    132              {
    133                  case '0':
    134                      if ((startp[1] == 'x') || (startp[1] == 'X'))
   \   00000032   0x7866             LDRB     R6,[R4, #+1]
   \   00000034   0x2E78             CMP      R6,#+120
   \   00000036   0xD001             BEQ      ??strtoul_5
   \   00000038   0x2E58             CMP      R6,#+88
   \   0000003A   0xD108             BNE      ??strtoul_4
    135                      {
    136                          if ((base == 0) || (base == 16))
   \                     ??strtoul_5: (+1)
   \   0000003C   0x2A00             CMP      R2,#+0
   \   0000003E   0xD001             BEQ      ??strtoul_6
   \   00000040   0x2A10             CMP      R2,#+16
   \   00000042   0xD10A             BNE      ??strtoul_7
    137                          {
    138                              base = 16;
   \                     ??strtoul_6: (+1)
   \   00000044   0x2210             MOVS     R2,#+16
    139                              startp = &startp[2];
   \   00000046   0x1CA4             ADDS     R4,R4,#+2
   \   00000048   0xE007             B        ??strtoul_7
    140                          }
    141                      }
    142                      break;
    143                  case '-':
    144                      neg = 1;
   \                     ??strtoul_3: (+1)
   \   0000004A   0x2301             MOVS     R3,#+1
    145                      startp = &startp[1];
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
    146                      break;
    147                  default:
    148                      break;
    149              }
    150          
    151              if (base == 0)
   \                     ??strtoul_4: (+1)
   \   0000004E   0x2A00             CMP      R2,#+0
   \   00000050   0xD103             BNE      ??strtoul_7
    152                  base = 10;
   \   00000052   0x220A             MOVS     R2,#+10
    153          
    154              /* Check for invalid chars in str */
    155              for ( endp = startp; (c = *endp) != '\0'; ++endp)
   \   00000054   0xE001             B        ??strtoul_7
    156              {
    157                  /* Check for 0..9,Aa-Zz */
    158                  if (!isalnum(c))
    159                  {
    160                      err = 1;
    161                      break;
    162                  }
    163          
    164                  /* Convert char to num in 0..36 */
    165                  if (isdigit(c))
    166                  {
    167                      c = c - '0';
    168                  }
    169                  else
    170                  {
    171                      if (isupper(c))
    172                      {
    173                          c = c - 'A' + 10;
    174                      }
    175                      else
    176                      {
    177                          c = c - 'a' + 10;
    178                      }
    179                  }
    180          
    181                  /* check c against base */
    182                  if (c >= base)
    183                  {
    184                      err = 1;
    185                      break;
    186                  }
    187          
    188                  if (neg)
    189                  {
    190                      rvalue = (rvalue * base) - c;
    191                  }
    192                  else
    193                  {
    194                      rvalue = (rvalue * base) + c;
   \                     ??strtoul_8: (+1)
   \   00000056   0x1980             ADDS     R0,R0,R6
    195                  }
   \                     ??strtoul_9: (+1)
   \   00000058   0x1C64             ADDS     R4,R4,#+1
   \                     ??strtoul_7: (+1)
   \   0000005A   0x7826             LDRB     R6,[R4, #+0]
   \   0000005C   0x2E00             CMP      R6,#+0
   \   0000005E   0xD00F             BEQ      ??strtoul_10
   \   00000060   0x0037             MOVS     R7,R6
   \   00000062   0x3F30             SUBS     R7,R7,#+48
   \   00000064   0x2F0A             CMP      R7,#+10
   \   00000066   0xD317             BCC      ??strtoul_11
   \   00000068   0x0037             MOVS     R7,R6
   \   0000006A   0x3F41             SUBS     R7,R7,#+65
   \   0000006C   0x2F1A             CMP      R7,#+26
   \   0000006E   0xD315             BCC      ??strtoul_12
   \   00000070   0x0037             MOVS     R7,R6
   \   00000072   0x3F61             SUBS     R7,R7,#+97
   \   00000074   0x2F1A             CMP      R7,#+26
   \   00000076   0xD202             BCS      ??strtoul_13
   \   00000078   0x3E57             SUBS     R6,R6,#+87
   \                     ??strtoul_14: (+1)
   \   0000007A   0x4296             CMP      R6,R2
   \   0000007C   0xDB10             BLT      ??strtoul_15
   \                     ??strtoul_13: (+1)
   \   0000007E   0x2501             MOVS     R5,#+1
    196              }
    197          
    198              /* Upon exit, endp points to the character at which valid info */
    199              /* STOPS.  No chars including and beyond endp are used.        */
    200          
    201              if (ptr != NULL)
   \                     ??strtoul_10: (+1)
   \   00000080   0x9A00             LDR      R2,[SP, #+0]
   \   00000082   0x2A00             CMP      R2,#+0
   \   00000084   0xD000             BEQ      ??strtoul_16
    202                  *ptr = endp;
   \   00000086   0x6014             STR      R4,[R2, #+0]
    203          
    204              if (err)
   \                     ??strtoul_16: (+1)
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD00E             BEQ      ??strtoul_17
    205              {
    206                  if (ptr != NULL)
   \                     ??strtoul_0: (+1)
   \   0000008C   0x9800             LDR      R0,[SP, #+0]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD000             BEQ      ??strtoul_18
    207                      *ptr = str;
   \   00000092   0x6001             STR      R1,[R0, #+0]
    208                  
    209                  return 0;
   \                     ??strtoul_18: (+1)
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0xE008             B        ??strtoul_17
    210              }
   \                     ??strtoul_11: (+1)
   \   00000098   0x3E30             SUBS     R6,R6,#+48
   \   0000009A   0xE7EE             B        ??strtoul_14
   \                     ??strtoul_12: (+1)
   \   0000009C   0x3E37             SUBS     R6,R6,#+55
   \   0000009E   0xE7EC             B        ??strtoul_14
   \                     ??strtoul_15: (+1)
   \   000000A0   0x4350             MULS     R0,R2,R0
   \   000000A2   0x2B00             CMP      R3,#+0
   \   000000A4   0xD0D7             BEQ      ??strtoul_8
   \   000000A6   0x1B80             SUBS     R0,R0,R6
   \   000000A8   0xE7D6             B        ??strtoul_9
    211              else
    212              {
    213                  return rvalue;
   \                     ??strtoul_17: (+1)
   \   000000AA   0xBCF2             POP      {R1,R4-R7}
   \   000000AC   0x4770             BX       LR               ;; return
    214              }
    215          }
    216          
    217          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    218          int
    219          strlen (const char *str)
    220          {
   \                     strlen: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    221              char *s = (char *)str;
    222              int len = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    223          
    224              if (s == NULL)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD102             BNE      ??strlen_0
    225                  return 0;
   \   00000008   0x4770             BX       LR
    226          
    227              while (*s++ != '\0')
   \                     ??strlen_1: (+1)
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
    228                  ++len;
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \                     ??strlen_0: (+1)
   \   0000000E   0x780A             LDRB     R2,[R1, #+0]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD1FA             BNE      ??strlen_1
    229          
    230              return len;
   \   00000014   0x4770             BX       LR               ;; return
    231          }
    232          
    233          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          char *
    235          strcat (char *dest, const char *src)
    236          {
    237              char *dp;
    238              char *sp = (char *)src;
   \                     strcat: (+1)
   \   00000000   0x000A             MOVS     R2,R1
    239          
    240              if ((dest != NULL) && (src != NULL))
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD100             BNE      ??strcat_0
   \   00000006   0x4770             BX       LR
   \                     ??strcat_0: (+1)
   \   00000008   0xB430             PUSH     {R4,R5}
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD011             BEQ      ??strcat_1
    241              {
    242                  dp = &dest[strlen(dest)];
   \   0000000E   0x0001             MOVS     R1,R0
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x2400             MOVS     R4,#+0
   \   00000014   0xE001             B        ??strcat_2
   \                     ??strcat_3: (+1)
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x1C64             ADDS     R4,R4,#+1
   \                     ??strcat_2: (+1)
   \   0000001A   0x780D             LDRB     R5,[R1, #+0]
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD1FA             BNE      ??strcat_3
   \   00000020   0x1901             ADDS     R1,R0,R4
   \   00000022   0xE002             B        ??strcat_4
    243          
    244                  while (*sp != '\0')
    245                  {
    246                      *dp++ = *sp++;
   \                     ??strcat_5: (+1)
   \   00000024   0x700C             STRB     R4,[R1, #+0]
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0x1C49             ADDS     R1,R1,#+1
    247                  }
   \                     ??strcat_4: (+1)
   \   0000002A   0x7814             LDRB     R4,[R2, #+0]
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD1F9             BNE      ??strcat_5
    248                  *dp = '\0';
   \   00000030   0x700B             STRB     R3,[R1, #+0]
    249              }
    250              return dest;
   \                     ??strcat_1: (+1)
   \   00000032   0xBC30             POP      {R4,R5}
   \   00000034   0x4770             BX       LR               ;; return
    251          }
    252          
    253          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    254          char *
    255          strncat (char *dest, const char *src, int n)
    256          {
    257              char *dp;
    258              char *sp = (char *)src;
   \                     strncat: (+1)
   \   00000000   0x000B             MOVS     R3,R1
    259          
    260              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD100             BNE      ??strncat_0
   \   00000006   0x4770             BX       LR
   \                     ??strncat_0: (+1)
   \   00000008   0xB470             PUSH     {R4-R6}
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD017             BEQ      ??strncat_1
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xDB15             BLT      ??strncat_1
    261              {
    262                  dp = &dest[strlen(dest)];
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2500             MOVS     R5,#+0
   \   00000018   0xE001             B        ??strncat_2
   \                     ??strncat_3: (+1)
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??strncat_2: (+1)
   \   0000001E   0x7826             LDRB     R6,[R4, #+0]
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD1FA             BNE      ??strncat_3
   \   00000024   0x1944             ADDS     R4,R0,R5
   \   00000026   0xE002             B        ??strncat_4
    263          
    264                  while ((*sp != '\0') && (n-- > 0))
    265                  {
    266                      *dp++ = *sp++;
   \                     ??strncat_5: (+1)
   \   00000028   0x7025             STRB     R5,[R4, #+0]
   \   0000002A   0x1C5B             ADDS     R3,R3,#+1
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
    267                  }
   \                     ??strncat_4: (+1)
   \   0000002E   0x781D             LDRB     R5,[R3, #+0]
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD003             BEQ      ??strncat_6
   \   00000034   0x0016             MOVS     R6,R2
   \   00000036   0x1E72             SUBS     R2,R6,#+1
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xDAF5             BGE      ??strncat_5
    268                  *dp = '\0';
   \                     ??strncat_6: (+1)
   \   0000003C   0x7021             STRB     R1,[R4, #+0]
    269              }
    270              return dest;
   \                     ??strncat_1: (+1)
   \   0000003E   0xBC70             POP      {R4-R6}
   \   00000040   0x4770             BX       LR               ;; return
    271          }
    272          
    273          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    274          char *
    275          strcpy (char *dest, const char *src)
    276          {
    277              char *dp = (char *)dest;
   \                     strcpy: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    278              char *sp = (char *)src;
   \   00000002   0x000B             MOVS     R3,R1
    279          
    280              if ((dest != NULL) && (src != NULL))
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD008             BEQ      ??strcpy_0
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD006             BEQ      ??strcpy_0
   \   0000000C   0xE001             B        ??strcpy_1
    281              {
    282                  while (*sp != '\0')
    283                  {
    284                      *dp++ = *sp++;
   \                     ??strcpy_2: (+1)
   \   0000000E   0x1C5B             ADDS     R3,R3,#+1
   \   00000010   0x1C52             ADDS     R2,R2,#+1
    285                  }
   \                     ??strcpy_1: (+1)
   \   00000012   0x7819             LDRB     R1,[R3, #+0]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0x7011             STRB     R1,[R2, #+0]
   \   00000018   0xD1F9             BNE      ??strcpy_2
    286                  *dp = '\0';
    287              }
    288              return dest;
   \                     ??strcpy_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    289          }
    290          
    291          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    292          char *
    293          strncpy (char *dest, const char *src, int n)
    294          {
   \                     strncpy: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    295              char *dp = (char *)dest;
   \   00000002   0x0003             MOVS     R3,R0
    296              char *sp = (char *)src;
   \   00000004   0x000C             MOVS     R4,R1
    297          
    298              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD010             BEQ      ??strncpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD00E             BEQ      ??strncpy_0
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xDB0C             BLT      ??strncpy_0
   \   00000012   0xE002             B        ??strncpy_1
    299              {
    300                  while ((*sp != '\0') && (n-- > 0))
    301                  {
    302                      *dp++ = *sp++;
   \                     ??strncpy_2: (+1)
   \   00000014   0x7019             STRB     R1,[R3, #+0]
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \   00000018   0x1C5B             ADDS     R3,R3,#+1
    303                  }
   \                     ??strncpy_1: (+1)
   \   0000001A   0x7821             LDRB     R1,[R4, #+0]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD003             BEQ      ??strncpy_3
   \   00000020   0x0015             MOVS     R5,R2
   \   00000022   0x1E6A             SUBS     R2,R5,#+1
   \   00000024   0x2D01             CMP      R5,#+1
   \   00000026   0xDAF5             BGE      ??strncpy_2
    304                  *dp = '\0';
   \                     ??strncpy_3: (+1)
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x7019             STRB     R1,[R3, #+0]
    305              }
    306              return dest;
   \                     ??strncpy_0: (+1)
   \   0000002C   0xBC30             POP      {R4,R5}
   \   0000002E   0x4770             BX       LR               ;; return
    307          }
    308          
    309          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    310          int
    311          strcmp (const char *s1, const char *s2)
    312          {
    313              /* No checks for NULL */
    314              char *s1p = (char *)s1;
    315              char *s2p = (char *)s2;
   \                     strcmp: (+1)
   \   00000000   0xE001             B        ??strcmp_0
    316          
    317              while (*s2p != '\0')
    318              {
    319                  if (*s1p != *s2p)
    320                      break;
    321          
    322                  ++s1p;
   \                     ??strcmp_1: (+1)
   \   00000002   0x1C40             ADDS     R0,R0,#+1
    323                  ++s2p;
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??strcmp_0: (+1)
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x780B             LDRB     R3,[R1, #+0]
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD001             BEQ      ??strcmp_2
   \   0000000E   0x429A             CMP      R2,R3
   \   00000010   0xD0F7             BEQ      ??strcmp_1
    324              }
    325              return (*s1p - *s2p);
   \                     ??strcmp_2: (+1)
   \   00000012   0x1AD0             SUBS     R0,R2,R3
   \   00000014   0x4770             BX       LR               ;; return
    326          }
    327          
    328          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          int
    330          strncmp (const char *s1, const char *s2, int n)
    331          {
   \                     strncmp: (+1)
   \   00000000   0xB410             PUSH     {R4}
    332              /* No checks for NULL */
    333              char *s1p = (char *)s1;
    334              char *s2p = (char *)s2;
    335          
    336              if (n <= 0)
   \   00000002   0x2A01             CMP      R2,#+1
   \   00000004   0xDA03             BGE      ??strncmp_0
    337                  return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE00A             B        ??strncmp_1
    338          
    339              while (*s2p != '\0')
    340              {
    341                  if (*s1p != *s2p)
    342                      break;
    343          
    344                  if (--n == 0)
    345                      break;
    346          
    347                  ++s1p;
   \                     ??strncmp_2: (+1)
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
    348                  ++s2p;
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \                     ??strncmp_0: (+1)
   \   0000000E   0x7803             LDRB     R3,[R0, #+0]
   \   00000010   0x780C             LDRB     R4,[R1, #+0]
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD003             BEQ      ??strncmp_3
   \   00000016   0x42A3             CMP      R3,R4
   \   00000018   0xD101             BNE      ??strncmp_3
   \   0000001A   0x1E52             SUBS     R2,R2,#+1
   \   0000001C   0xD1F5             BNE      ??strncmp_2
    349              }
    350              return (*s1p - *s2p);
   \                     ??strncmp_3: (+1)
   \   0000001E   0x1B18             SUBS     R0,R3,R4
   \                     ??strncmp_1: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    351          }
    352          
    353          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          void *
    355          memcpy (void *dest, const void *src, unsigned n)
    356          {
   \                     memcpy: (+1)
   \   00000000   0xB450             PUSH     {R4,R6}
    357              int longs, bytes;
    358              uint32 *dpl = (uint32 *)dest;
   \   00000002   0x0003             MOVS     R3,R0
    359              uint32 *spl = (uint32 *)src;
   \   00000004   0x000C             MOVS     R4,R1
    360              uint8  *dpb, *spb;
    361          
    362              if ((dest != NULL) && (src != NULL) && (n > 0))
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD016             BEQ      ??memcpy_0
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD014             BEQ      ??memcpy_0
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD012             BEQ      ??memcpy_0
   \   00000012   0x0791             LSLS     R1,R2,#+30
   \   00000014   0x0F89             LSRS     R1,R1,#+30
    363              {
    364                  bytes = (n & 0x3);
    365                  longs = (n - bytes) >> 2;
   \   00000016   0x1A52             SUBS     R2,R2,R1
   \   00000018   0x0892             LSRS     R2,R2,#+2
   \   0000001A   0xD005             BEQ      ??memcpy_1
    366              
    367                  while (longs--)
    368                      *dpl++ = *spl++;
   \                     ??memcpy_2: (+1)
   \   0000001C   0x6826             LDR      R6,[R4, #+0]
   \   0000001E   0x601E             STR      R6,[R3, #+0]
   \   00000020   0x1D24             ADDS     R4,R4,#+4
   \   00000022   0x1D1B             ADDS     R3,R3,#+4
   \   00000024   0x1E52             SUBS     R2,R2,#+1
   \   00000026   0xD1F9             BNE      ??memcpy_2
    369                  
    370                  dpb = (uint8 *)dpl;
    371                  spb = (uint8 *)spl;
   \                     ??memcpy_1: (+1)
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD005             BEQ      ??memcpy_0
    372                  
    373                  while (bytes--)
    374                      *dpb++ = *spb++;
   \                     ??memcpy_3: (+1)
   \   0000002C   0x7822             LDRB     R2,[R4, #+0]
   \   0000002E   0x701A             STRB     R2,[R3, #+0]
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
   \   00000034   0x1E49             SUBS     R1,R1,#+1
   \   00000036   0xD1F9             BNE      ??memcpy_3
    375              }
    376              return dest;
   \                     ??memcpy_0: (+1)
   \   00000038   0xBC50             POP      {R4,R6}
   \   0000003A   0x4770             BX       LR               ;; return
    377          }
    378          
    379          /****************************************************************/

   \                                 In section .text, align 2, keep-with-next
    380          void *
    381          memset (void *s, int c, unsigned n)
    382          {
   \                     memset: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0010             MOVS     R0,R2
    383              /* Not optimized, but very portable */
    384              unsigned char *sp = (unsigned char *)s;
    385          
    386              if ((s != NULL) && (n > 0))
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD006             BEQ      ??memset_0
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ      ??memset_0
    387              {
    388                  while (n--)
    389                  {
    390                      *sp++ = (unsigned char)c;
   \   0000000E   0x000A             MOVS     R2,R1
   \   00000010   0x0001             MOVS     R1,R0
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       __aeabi_memset
    391                  }
    392              }
    393              return s;
   \                     ??memset_0: (+1)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    394          }
    395          
    396          /****************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   isalnum
       0   isdigit
       0   isspace
       0   isupper
       8   memcpy
       8   memset
         8   -> __aeabi_memset
       4   strcasecmp
       8   strcat
       0   strcmp
       0   strcpy
       0   strlen
      12   strncasecmp
      12   strncat
       4   strncmp
       8   strncpy
      20   strtoul


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      30  isalnum
      10  isdigit
      16  isspace
      10  isupper
      60  memcpy
      28  memset
      52  strcasecmp
      54  strcat
      22  strcmp
      28  strcpy
      22  strlen
      64  strncasecmp
      66  strncat
      36  strncmp
      48  strncpy
     174  strtoul

 
 720 bytes in section .text
 
 720 bytes of CODE memory

Errors: none
Warnings: none
