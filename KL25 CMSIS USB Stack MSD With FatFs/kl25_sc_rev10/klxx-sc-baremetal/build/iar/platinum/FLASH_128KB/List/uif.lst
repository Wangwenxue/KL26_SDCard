###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        30/Nov/2015  21:44:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\uif.c
#    Command line =  
#        "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\uif.c" -D IAR -D
#        FREEDOM -lCN "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD
#        With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\"
#        -lB "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\"
#        -o "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\Obj\"
#        --debug --endian=little --cpu=Cortex-M0+ -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\projects\platinum\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\common\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\cpu\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\..\..\src\platforms\"
#        -I "D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\..\" -Oh
#    List file    =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\List\uif.lst
#    Object file  =  
#        D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\platinum\FLASH_128KB\Obj\uif.o
#
###############################################################################

D:\My Project\ZhiyunKangkai\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\uif.c
      1          /*
      2           * File:    uif.c
      3           * Purpose: Provide an interactive user interface
      4           *              
      5           * Notes:   The commands, set/show parameters, and prompt are configured 
      6           *          at the project level
      7           */
      8          
      9          #include "common.h"
     10          #include "uif.h"
     11          /********************************************************************/
     12          /*
     13           * Global messages -- constant strings
     14           */

   \                                 In section .text, align 4, keep-with-next
     15          const char HELPMSG[] =
   \                     HELPMSG:
   \   00000000   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     16              "Enter 'help' for help.\n";
     17          

   \                                 In section .text, align 4, keep-with-next
     18          const char INVARG[] =
   \                     INVARG:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     19              "Error: Invalid argument: %s\n";
     20          

   \                                 In section .rodata, align 4, keep-with-next
     21          const char INVALUE[] = 
   \                     INVALUE:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
     22              "Error: Invalid value: %s\n";
     23          
     24          /*
     25           * Strings used by this file only
     26           */

   \                                 In section .text, align 4, keep-with-next
     27          static const char INVCMD[] =
   \                     INVCMD:
   \   00000000   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     28              "Error: No such command: %s\n";
     29          

   \                                 In section .text, align 4, keep-with-next
     30          static const char HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     31              "%8s  %-25s %s %s\n";
     32          

   \                                 In section .text, align 4, keep-with-next
     33          static const char SYNTAX[] = 
   \                     SYNTAX:
   \   00000000   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
     34              "Error: Invalid syntax for: %s\n";
     35          

   \                                 In section .text, align 4, keep-with-next
     36          static const char INVOPT[] = 
   \                     INVOPT:
   \   00000000   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     37              "Error:  Invalid set/show option: %s\n";
     38          

   \                                 In section .text, align 4, keep-with-next
     39          static const char OPTFMT[] = 
   \                     OPTFMT:
   \   00000000   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
     40              "%12s: ";
     41          

   \                                 In section .bss, align 4
     42          static char cmdline1 [UIF_MAX_LINE];
     43          static char cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
   \   00000050                      DS8 80
     44          
     45          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     46          char *
     47          get_line (char *line)
     48          {
   \                     get_line: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     49              int pos;
     50              int ch;
     51          
     52              pos = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x2600             MOVS     R6,#+0
     53              ch = (int)in_char();
   \   00000008   0xE00A             B        ??get_line_0
     54              while ( (ch != 0x0D /* CR */) &&
     55                      (ch != 0x0A /* LF/NL */) &&
     56                      (pos < UIF_MAX_LINE))
     57              {
     58                  switch (ch)
     59                  {
     60                      case 0x08:      /* Backspace */
     61                      case 0x7F:      /* Delete */
     62                          if (pos > 0)
     63                          {
     64                              pos -= 1;
     65                              out_char(0x08);    /* backspace */
     66                              out_char(' ');
     67                              out_char(0x08);    /* backspace */
     68                          }
     69                          break;
     70                      default:
     71                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_1: (+1)
   \   0000000A   0x1C71             ADDS     R1,R6,#+1
   \   0000000C   0x2950             CMP      R1,#+80
   \   0000000E   0xDA07             BGE      ??get_line_0
     72                          {
     73                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x3A20             SUBS     R2,R2,#+32
   \   00000014   0x2A60             CMP      R2,#+96
   \   00000016   0xD203             BCS      ??get_line_0
     74                              {
     75                                  line[pos++] = (char)ch;
   \   00000018   0x55A0             STRB     R0,[R4, R6]
   \   0000001A   0x000E             MOVS     R6,R1
     76                                  out_char((char)ch);
   \                     ??get_line_2: (+1)
   \   0000001C   0x.... 0x....      BL       out_char
     77                              }
     78                          }
     79                          break;
     80                  }
     81                  ch = (int)in_char();
   \                     ??get_line_0: (+1)
   \   00000020   0x.... 0x....      BL       in_char
   \   00000024   0x280D             CMP      R0,#+13
   \   00000026   0xD012             BEQ      ??get_line_3
   \   00000028   0x280A             CMP      R0,#+10
   \   0000002A   0xD010             BEQ      ??get_line_3
   \   0000002C   0x2E50             CMP      R6,#+80
   \   0000002E   0xDA0E             BGE      ??get_line_3
   \   00000030   0x2808             CMP      R0,#+8
   \   00000032   0xD001             BEQ      ??get_line_4
   \   00000034   0x287F             CMP      R0,#+127
   \   00000036   0xD1E8             BNE      ??get_line_1
   \                     ??get_line_4: (+1)
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xDBF1             BLT      ??get_line_0
   \   0000003C   0x1E76             SUBS     R6,R6,#+1
   \   0000003E   0x2008             MOVS     R0,#+8
   \   00000040   0x.... 0x....      BL       out_char
   \   00000044   0x2020             MOVS     R0,#+32
   \   00000046   0x.... 0x....      BL       out_char
   \   0000004A   0x2008             MOVS     R0,#+8
   \   0000004C   0xE7E6             B        ??get_line_2
     82              }
     83              line[pos] = '\0';
   \                     ??get_line_3: (+1)
   \   0000004E   0x55A5             STRB     R5,[R4, R6]
     84              out_char(0x0D);    /* CR */
   \   00000050   0x200D             MOVS     R0,#+13
   \   00000052   0x.... 0x....      BL       out_char
     85              out_char(0x0A);    /* LF */
   \   00000056   0x200A             MOVS     R0,#+10
   \   00000058   0x.... 0x....      BL       out_char
     86          
     87              return line;
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
     88          }
     89          
     90          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     91          int
     92          make_argv (char *cmdline, char *argv[])
     93          {
   \                     make_argv: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x0002             MOVS     R2,R0
     94              int argc, i, in_text;
     95          
     96              /* 
     97               * Break cmdline into strings and argv
     98               * It is permissible for argv to be NULL, in which case
     99               * the purpose of this routine becomes to count args
    100               */
    101              argc = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2000             MOVS     R0,#+0
    102              i = 0;
    103              in_text = FALSE;
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0xE005             B        ??make_argv_0
    104              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    105              {
    106                  if (((cmdline[i] == ' ')   ||
    107                       (cmdline[i] == '\t')) )
    108                  {
    109                      if (in_text)
    110                      {
    111                          /* end of command line argument */
    112                          cmdline[i] = '\0';
    113                          in_text = FALSE;
    114                      }
    115                      else
    116                      {
    117                          /* still looking for next argument */
    118                          
    119                      }
    120                  }
    121                  else
    122                  {
    123                      /* got non-whitespace character */
    124                      if (in_text)
    125                      {
    126                      }
    127                      else
    128                      {
    129                          /* start of an argument */
    130                          in_text = TRUE;
    131                          if (argc < UIF_MAX_ARGS)
    132                          {
    133                              if (argv != NULL)
   \                     ??make_argv_1: (+1)
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ      ??make_argv_2
    134                                  argv[argc] = &cmdline[i];
   \   00000010   0x0086             LSLS     R6,R0,#+2
   \   00000012   0x518A             STR      R2,[R1, R6]
    135                              argc++;
   \                     ??make_argv_2: (+1)
   \   00000014   0x1C40             ADDS     R0,R0,#+1
    136                          }
    137                          else
    138                              /*return argc;*/
    139                              break;
    140                      }
    141          
    142                  }
    143                  i++;    /* proceed to next character */
   \                     ??make_argv_3: (+1)
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \                     ??make_argv_0: (+1)
   \   00000018   0x7816             LDRB     R6,[R2, #+0]
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD00D             BEQ      ??make_argv_4
   \   0000001E   0x2E20             CMP      R6,#+32
   \   00000020   0xD001             BEQ      ??make_argv_5
   \   00000022   0x2E09             CMP      R6,#+9
   \   00000024   0xD104             BNE      ??make_argv_6
   \                     ??make_argv_5: (+1)
   \   00000026   0x2D00             CMP      R5,#+0
   \   00000028   0xD0F5             BEQ      ??make_argv_3
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0x7015             STRB     R5,[R2, #+0]
   \   0000002E   0xE7F2             B        ??make_argv_3
   \                     ??make_argv_6: (+1)
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD1F0             BNE      ??make_argv_3
   \   00000034   0x2501             MOVS     R5,#+1
   \   00000036   0x280A             CMP      R0,#+10
   \   00000038   0xDBE8             BLT      ??make_argv_1
    144              }
    145              if (argv != NULL)
   \                     ??make_argv_4: (+1)
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD001             BEQ      ??make_argv_7
    146                  argv[argc] = NULL;
   \   0000003E   0x0082             LSLS     R2,R0,#+2
   \   00000040   0x508C             STR      R4,[R1, R2]
    147              return argc;
   \                     ??make_argv_7: (+1)
   \   00000042   0xBC70             POP      {R4-R6}
   \   00000044   0x4770             BX       LR               ;; return
    148          }
    149          
    150          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    151          void
    152          run_cmd (void)
    153          {
   \                     run_cmd: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
    154              /*
    155               * Global array of pointers to emulate C argc,argv interface
    156               */
    157              int argc;
    158              char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    159          
    160              get_line(cmdline1);
   \   00000004   0x....             LDR      R4,??DataTable16
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x3050             ADDS     R0,R0,#+80
   \   0000000A   0x.... 0x....      BL       get_line
    161          
    162          	  argc = make_argv(cmdline1,argv);
   \   0000000E   0xA901             ADD      R1,SP,#+4
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x3050             ADDS     R0,R0,#+80
   \   00000014   0x.... 0x....      BL       make_argv
   \   00000018   0x0007             MOVS     R7,R0
    163          	
    164              if (!(argc))
   \   0000001A   0xD10A             BNE      ??run_cmd_0
    165              {
    166                  /* no command entered, just a blank line */
    167                  strcpy(cmdline1,cmdline2);
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x3050             ADDS     R0,R0,#+80
   \   00000022   0x.... 0x....      BL       strcpy
    168                  argc = make_argv(cmdline1,argv);
   \   00000026   0xA901             ADD      R1,SP,#+4
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x3050             ADDS     R0,R0,#+80
   \   0000002C   0x.... 0x....      BL       make_argv
   \   00000030   0x0007             MOVS     R7,R0
    169              }
    170              cmdline2[0] = '\0';
   \                     ??run_cmd_0: (+1)
   \   00000032   0x2500             MOVS     R5,#+0
   \   00000034   0x7025             STRB     R5,[R4, #+0]
    171          
    172              if (argc)
   \   00000036   0x2F00             CMP      R7,#+0
   \   00000038   0xD033             BEQ      ??run_cmd_1
    173              {
    174                  int i;
    175                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   0000003A   0x....             LDR      R6,??DataTable16_1
   \   0000003C   0x....             LDR      R0,??DataTable16_2
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0xE001             B        ??run_cmd_2
   \                     ??run_cmd_3: (+1)
   \   00000044   0x1C6D             ADDS     R5,R5,#+1
   \   00000046   0x361C             ADDS     R6,R6,#+28
   \                     ??run_cmd_2: (+1)
   \   00000048   0x9800             LDR      R0,[SP, #+0]
   \   0000004A   0x4285             CMP      R5,R0
   \   0000004C   0x9901             LDR      R1,[SP, #+4]
   \   0000004E   0xDA21             BGE      ??run_cmd_4
    176                  {
    177                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000050   0x6830             LDR      R0,[R6, #+0]
   \   00000052   0x.... 0x....      BL       strcasecmp
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD1F4             BNE      ??run_cmd_3
    178                      {
    179                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    180                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   0000005A   0x....             LDR      R0,??DataTable16_1
   \   0000005C   0x00E9             LSLS     R1,R5,#+3
   \   0000005E   0x1B49             SUBS     R1,R1,R5
   \   00000060   0x0089             LSLS     R1,R1,#+2
   \   00000062   0x1845             ADDS     R5,R0,R1
   \   00000064   0x1E78             SUBS     R0,R7,#+1
   \   00000066   0x6869             LDR      R1,[R5, #+4]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xDB0E             BLT      ??run_cmd_5
   \   0000006C   0x68A9             LDR      R1,[R5, #+8]
   \   0000006E   0x4281             CMP      R1,R0
   \   00000070   0xDB0B             BLT      ??run_cmd_5
    181                          {
    182                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   00000072   0x7B28             LDRB     R0,[R5, #+12]
   \   00000074   0x07C0             LSLS     R0,R0,#+31
   \   00000076   0xD503             BPL      ??run_cmd_6
    183                              {
    184                                  strcpy(cmdline2,argv[0]);
   \   00000078   0x9901             LDR      R1,[SP, #+4]
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       strcpy
    185                              }
    186                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6: (+1)
   \   00000080   0xA901             ADD      R1,SP,#+4
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0x692A             LDR      R2,[R5, #+16]
   \   00000086   0x4790             BLX      R2
    187                              return;
   \   00000088   0xE00B             B        ??run_cmd_1
    188                          }
    189                          else
    190                          {
    191                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5: (+1)
   \   0000008A   0x9901             LDR      R1,[SP, #+4]
   \   0000008C   0x....             ADR.N    R0,SYNTAX
   \   0000008E   0x.... 0x....      BL       printf
    192                              return;
   \   00000092   0xE006             B        ??run_cmd_1
    193                          }
    194                      }
    195                  }
    196                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4: (+1)
   \   00000094   0x....             ADR.N    R0,INVCMD
   \   00000096   0x.... 0x....      BL       printf
    197                  printf(HELPMSG);
   \   0000009A   0xBF00             Nop      
   \   0000009C   0x....             ADR.N    R0,HELPMSG
   \   0000009E   0x.... 0x....      BL       printf
    198              }
    199          }
   \                     ??run_cmd_1: (+1)
   \   000000A2   0xB00D             ADD      SP,SP,#+52
   \   000000A4   0xBDF0             POP      {R4-R7,PC}       ;; return
    200          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    201          uint32
    202          get_value (char *s, int *success, int base)
    203          {
   \                     get_value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    204              uint32 value;
    205              char *p;
    206          
    207              value = strtoul(s,&p,base);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x.... 0x....      BL       strtoul
    208              if ((value == 0) && (p == s))
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD104             BNE      ??get_value_0
   \   00000010   0x9900             LDR      R1,[SP, #+0]
   \   00000012   0x42A9             CMP      R1,R5
   \   00000014   0xD101             BNE      ??get_value_0
    209              {
    210                  *success = FALSE;
   \   00000016   0x6020             STR      R0,[R4, #+0]
    211                  return 0;
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
    212              }
    213              else
    214              {
    215                  *success = TRUE;
   \                     ??get_value_0: (+1)
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x6021             STR      R1,[R4, #+0]
    216                  return value;
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    217              }
    218          }
    219          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    220          void
    221          uif_cmd_help (int argc, char **argv)
    222          {
   \                     uif_cmd_help: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    223              int index;
    224              
    225              (void)argc;
    226              (void)argv;
    227              
    228              printf("\n");
   \   00000002   0x....             ADR      R6,??DataTable16_3  ;; "\n"
   \   00000004   0x0030             MOVS     R0,R6
   \   00000006   0x.... 0x....      BL       printf
    229              for (index = 0; index < UIF_NUM_CMD; index++)
   \   0000000A   0x....             LDR      R0,??DataTable16_2
   \   0000000C   0x6805             LDR      R5,[R0, #+0]
   \   0000000E   0x2D01             CMP      R5,#+1
   \   00000010   0xDB0C             BLT      ??uif_cmd_help_0
   \   00000012   0x....             LDR      R4,??DataTable16_1
   \   00000014   0x....             ADR.N    R7,HELPFORMAT
    230              {
    231                  printf(HELPFORMAT,
    232                      UIF_CMDTAB[index].cmd,
    233                      UIF_CMDTAB[index].description,
    234                      UIF_CMDTAB[index].cmd,
    235                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1: (+1)
   \   00000016   0x6823             LDR      R3,[R4, #+0]
   \   00000018   0x69A0             LDR      R0,[R4, #+24]
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x6962             LDR      R2,[R4, #+20]
   \   0000001E   0x0019             MOVS     R1,R3
   \   00000020   0x0038             MOVS     R0,R7
   \   00000022   0x.... 0x....      BL       printf
    236              }
   \   00000026   0x341C             ADDS     R4,R4,#+28
   \   00000028   0x1E6D             SUBS     R5,R5,#+1
   \   0000002A   0xD1F4             BNE      ??uif_cmd_help_1
    237              printf("\n");
   \                     ??uif_cmd_help_0: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      BL       printf
    238          }
   \   00000032   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    239          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    240          void
    241          uif_cmd_set (int argc, char **argv)
    242          {
   \                     uif_cmd_set: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x....             ADR      R0,??DataTable16_3  ;; "\n"
    243              int index;
    244          
    245              printf("\n");
   \   00000008   0x.... 0x....      BL       printf
    246              if (argc == 1)
   \   0000000C   0x2C01             CMP      R4,#+1
   \   0000000E   0xD117             BNE      ??uif_cmd_set_0
    247              {
    248                  printf("Valid 'set' options:\n");
   \   00000010   0x....             ADR.N    R0,?_1
   \   00000012   0x.... 0x....      BL       printf
    249                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   00000016   0x....             LDR      R0,??DataTable16_4
   \   00000018   0x6806             LDR      R6,[R0, #+0]
   \   0000001A   0x2E01             CMP      R6,#+1
   \   0000001C   0xDB0E             BLT      ??uif_cmd_set_1
   \   0000001E   0x....             LDR      R4,??DataTable16_5
   \   00000020   0x....             ADR      R7,??DataTable16_6  ;; "%s\n"
   \   00000022   0xBF00             Nop      
   \   00000024   0x....             ADR.N    R5,OPTFMT
    250                  {
    251                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2: (+1)
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x.... 0x....      BL       printf
    252                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   0000002E   0x6921             LDR      R1,[R4, #+16]
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0x.... 0x....      BL       printf
    253                  }
   \   00000036   0x3414             ADDS     R4,R4,#+20
   \   00000038   0x1E76             SUBS     R6,R6,#+1
   \   0000003A   0xD1F4             BNE      ??uif_cmd_set_2
    254                  printf("\n");
   \                     ??uif_cmd_set_1: (+1)
   \   0000003C   0x....             ADR      R0,??DataTable16_3  ;; "\n"
   \   0000003E   0xE002             B.N      ??uif_cmd_set_3
    255                  return;
    256              }
    257          
    258              if (argc != 3)
   \                     ??uif_cmd_set_0: (+1)
   \   00000040   0x2C03             CMP      R4,#+3
   \   00000042   0xD003             BEQ      ??uif_cmd_set_4
    259              {
    260                  printf("Error: Invalid argument list\n");
   \   00000044   0x....             ADR.N    R0,?_3
   \                     ??uif_cmd_set_3: (+1)
   \   00000046   0x.... 0x....      BL       printf
    261                  return;
   \   0000004A   0xBDF1             POP      {R0,R4-R7,PC}
    262              }
    263          
    264              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4: (+1)
   \   0000004C   0x2400             MOVS     R4,#+0
   \   0000004E   0x....             LDR      R5,??DataTable16_5
   \   00000050   0x....             LDR      R0,??DataTable16_4
   \   00000052   0x6806             LDR      R6,[R0, #+0]
   \   00000054   0xE001             B        ??uif_cmd_set_5
   \                     ??uif_cmd_set_6: (+1)
   \   00000056   0x1C64             ADDS     R4,R4,#+1
   \   00000058   0x3514             ADDS     R5,R5,#+20
   \                     ??uif_cmd_set_5: (+1)
   \   0000005A   0x6879             LDR      R1,[R7, #+4]
   \   0000005C   0x42B4             CMP      R4,R6
   \   0000005E   0xDA17             BGE      ??uif_cmd_set_7
    265              {
    266                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0x.... 0x....      BL       strcasecmp
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD1F5             BNE      ??uif_cmd_set_6
    267                  {
    268                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    269                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   0000006A   0x....             LDR      R0,??DataTable16_5
   \   0000006C   0x00A1             LSLS     R1,R4,#+2
   \   0000006E   0x1909             ADDS     R1,R1,R4
   \   00000070   0x0089             LSLS     R1,R1,#+2
   \   00000072   0x1842             ADDS     R2,R0,R1
   \   00000074   0x6850             LDR      R0,[R2, #+4]
   \   00000076   0x2802             CMP      R0,#+2
   \   00000078   0xDA07             BGE      ??uif_cmd_set_8
   \   0000007A   0x6890             LDR      R0,[R2, #+8]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xDB04             BLT      ??uif_cmd_set_8
    270                      {
    271                          UIF_SETCMDTAB[index].func(argc,argv);
   \   00000080   0x0039             MOVS     R1,R7
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0x68D2             LDR      R2,[R2, #+12]
   \   00000086   0x4790             BLX      R2
    272                          return;
   \   00000088   0xBDF1             POP      {R0,R4-R7,PC}
    273                      }
    274                      else
    275                      {
    276                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8: (+1)
   \   0000008A   0x6879             LDR      R1,[R7, #+4]
   \   0000008C   0x....             ADR.N    R0,INVARG
   \   0000008E   0xE000             B        ??uif_cmd_set_9
    277                          return;
    278                      }
    279                  }
    280              }
    281              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_7: (+1)
   \   00000090   0x....             ADR.N    R0,INVOPT
   \                     ??uif_cmd_set_9: (+1)
   \   00000092   0x.... 0x....      BL       printf
    282          }
   \   00000096   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    283          
    284          /********************************************************************/

   \                                 In section .text, align 4, keep-with-next
    285          void
    286          uif_cmd_show (int argc, char **argv)
    287          {
   \                     uif_cmd_show: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000E             MOVS     R6,R1
    288              int index;
    289          
    290              printf("\n");
   \   00000006   0x....             ADR      R7,??DataTable16_3  ;; "\n"
   \   00000008   0x0038             MOVS     R0,R7
   \   0000000A   0x.... 0x....      BL       printf
    291              if (argc == 1)
   \   0000000E   0x....             LDR      R0,??DataTable16_4
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2400             MOVS     R4,#+0
   \   00000016   0x9802             LDR      R0,[SP, #+8]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD116             BNE      ??uif_cmd_show_0
    292              {
    293                  /*
    294                   * Show all Option settings
    295                   */
    296                  argc = 2;
    297                  argv[2] = NULL;
   \   0000001C   0x60B4             STR      R4,[R6, #+8]
    298                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xDB10             BLT      ??uif_cmd_show_1
   \   00000024   0x....             LDR      R4,??DataTable16_5
   \   00000026   0x4605             MOV      R5,R0
    299                  {
    300                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2: (+1)
   \   00000028   0x6821             LDR      R1,[R4, #+0]
   \   0000002A   0xBF00             Nop      
   \   0000002C   0x....             ADR.N    R0,OPTFMT
   \   0000002E   0x.... 0x....      BL       printf
    301                      UIF_SETCMDTAB[index].func(argc,argv);
   \   00000032   0x0031             MOVS     R1,R6
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0x68E2             LDR      R2,[R4, #+12]
   \   00000038   0x4790             BLX      R2
    302                      printf("\n");
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       printf
    303                  }
   \   00000040   0x3414             ADDS     R4,R4,#+20
   \   00000042   0x1E6D             SUBS     R5,R5,#+1
   \   00000044   0xD1F0             BNE      ??uif_cmd_show_2
    304                  printf("\n");
   \                     ??uif_cmd_show_1: (+1)
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0xE022             B.N      ??uif_cmd_show_3
    305                  return;
    306              }
    307          
    308              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0: (+1)
   \   0000004A   0x....             LDR      R7,??DataTable16_5
   \   0000004C   0x003D             MOVS     R5,R7
   \   0000004E   0xE001             B        ??uif_cmd_show_4
   \                     ??uif_cmd_show_5: (+1)
   \   00000050   0x1C64             ADDS     R4,R4,#+1
   \   00000052   0x3514             ADDS     R5,R5,#+20
   \                     ??uif_cmd_show_4: (+1)
   \   00000054   0x6871             LDR      R1,[R6, #+4]
   \   00000056   0x9800             LDR      R0,[SP, #+0]
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xDA1F             BGE      ??uif_cmd_show_6
    309              {
    310                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   0000005C   0x6828             LDR      R0,[R5, #+0]
   \   0000005E   0x.... 0x....      BL       strcasecmp
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD1F4             BNE      ??uif_cmd_show_5
    311                  {
    312                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    313                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000066   0x00A0             LSLS     R0,R4,#+2
   \   00000068   0x1900             ADDS     R0,R0,R4
   \   0000006A   0x0080             LSLS     R0,R0,#+2
   \   0000006C   0x183C             ADDS     R4,R7,R0
   \   0000006E   0x9802             LDR      R0,[SP, #+8]
   \   00000070   0x1E80             SUBS     R0,R0,#+2
   \   00000072   0x6861             LDR      R1,[R4, #+4]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xDB0E             BLT      ??uif_cmd_show_7
   \   00000078   0x68A1             LDR      R1,[R4, #+8]
   \   0000007A   0x4281             CMP      R1,R0
   \   0000007C   0xDB0B             BLT      ??uif_cmd_show_7
    314                      {
    315                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x....             ADR.N    R0,OPTFMT
   \   00000082   0x.... 0x....      BL       printf
    316                          UIF_SETCMDTAB[index].func(argc,argv);
   \   00000086   0x0031             MOVS     R1,R6
   \   00000088   0x9802             LDR      R0,[SP, #+8]
   \   0000008A   0x68E2             LDR      R2,[R4, #+12]
   \   0000008C   0x4790             BLX      R2
    317                          printf("\n\n");
   \   0000008E   0x....             ADR      R0,??DataTable16_7  ;; 0x0A, 0x0A, 0x00, 0x00
   \                     ??uif_cmd_show_3: (+1)
   \   00000090   0x.... 0x....      BL       printf
    318                          return;
   \   00000094   0xE005             B        ??uif_cmd_show_8
    319                      }
    320                      else
    321                      {
    322                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7: (+1)
   \   00000096   0x6871             LDR      R1,[R6, #+4]
   \   00000098   0x....             ADR.N    R0,INVARG
   \   0000009A   0xE000             B        ??uif_cmd_show_9
    323                          return;
    324                      }
    325                  }
    326              }
    327              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_6: (+1)
   \   0000009C   0x....             ADR.N    R0,INVOPT
   \                     ??uif_cmd_show_9: (+1)
   \   0000009E   0x.... 0x....      BL       printf
    328          }
   \                     ??uif_cmd_show_8: (+1)
   \   000000A2   0xB003             ADD      SP,SP,#+12
   \   000000A4   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     ?_0:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     ?_4:
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    329          
    330          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   get_line
        16   -> in_char
        16   -> out_char
      16   get_value
        16   -> strtoul
      12   make_argv
      72   run_cmd
        72   -- Indirect call
        72   -> get_line
        72   -> make_argv
        72   -> printf
        72   -> strcasecmp
        72   -> strcpy
      24   uif_cmd_help
        24   -> printf
      24   uif_cmd_set
        24   -- Indirect call
        24   -> printf
        24   -> strcasecmp
      32   uif_cmd_show
        32   -- Indirect call
        32   -> printf
        32   -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       2  ?_0
      24  ?_1
       4  ?_2
      32  ?_3
       4  ?_4
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
     160  cmdline2
          cmdline1
      96  get_line
      32  get_value
      70  make_argv
     166  run_cmd
      52  uif_cmd_help
     152  uif_cmd_set
     166  uif_cmd_show

 
   160 bytes in section .bss
    38 bytes in section .rodata
 1 006 bytes in section .text
 
 1 006 bytes of CODE  memory
    38 bytes of CONST memory
   160 bytes of DATA  memory

Errors: none
Warnings: none
