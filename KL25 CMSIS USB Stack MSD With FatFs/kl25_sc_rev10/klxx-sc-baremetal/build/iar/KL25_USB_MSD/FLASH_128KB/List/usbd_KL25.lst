###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        18/Feb/2016  22:53:05
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\usbd_KL25.c
#    Command line =  
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\usbd_KL25.c" -D IAR -D FREEDOM -D SD_DISK_ENABLE
#        -lCN "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -lB "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -o "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\common\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\i2c\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\platforms\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\" -I
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\inc\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack
#        MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB
#        Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\SPI_SDCard\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\"
#        -Ol
#    List file    =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\usbd_KL25.lst
#    Object file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\usbd_KL25.o
#
###############################################################################

D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\CMSIS USB Stack\Porting use\usbd_KL25.c
      1          /* CMSIS-DAP Interface Firmware
      2           * Copyright (c) 2009-2013 ARM Limited
      3           *
      4           * Licensed under the Apache License, Version 2.0 (the "License");
      5           * you may not use this file except in compliance with the License.
      6           * You may obtain a copy of the License at
      7           *
      8           *     http://www.apache.org/licenses/LICENSE-2.0
      9           *
     10           * Unless required by applicable law or agreed to in writing, software
     11           * distributed under the License is distributed on an "AS IS" BASIS,
     12           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     13           * See the License for the specific language governing permissions and
     14           * limitations under the License.
     15           */
     16          //#include <RTL.h>
     17          #include <rl_usb.h>
     18          #include <common.h>
     19          #include <intrinsics.h>
     20          
     21          #define __NO_USB_LIB_C
     22          #include "usb_config.h"
     23          
     24          
     25          typedef struct __BUF_DESC {
     26            uint8_t    stat;
     27            uint8_t    reserved;
     28            uint16_t   bc;
     29            uint32_t   buf_addr;
     30          }BUF_DESC;
     31          #pragma data_alignment = 512

   \                                 In section .bss, align 512
     32          BUF_DESC BD[(USBD_EP_NUM + 1) * 2 * 2];
   \                     BD:
   \   00000000                      DS8 96

   \                                 In section .bss, align 4
     33          uint8_t EPBuf[(USBD_EP_NUM + 1)* 2 * 2][64];
   \                     EPBuf:
   \   00000000                      DS8 768

   \                                 In section .bss, align 4
     34          uint8_t OutEpSize[USBD_EP_NUM + 1];
   \                     OutEpSize:
   \   00000000                      DS8 4
     35          

   \                                 In section .data, align 4
     36          uint32_t Data1  = 0x55555555;
   \                     Data1:
   \   00000000   0x55555555         DC32 1431655765
     37          
     38          #define BD_OWN_MASK        0x80
     39          #define BD_DATA01_MASK     0x40
     40          #define BD_KEEP_MASK       0x20
     41          #define BD_NINC_MASK       0x10
     42          #define BD_DTS_MASK        0x08
     43          #define BD_STALL_MASK      0x04
     44          
     45          #define TX    1
     46          #define RX    0
     47          #define ODD   0
     48          #define EVEN  1
     49          #define IDX(Ep, dir, Ev_Odd) ((((Ep & 0x0F) * 4) + (2 * dir) + (1 *  Ev_Odd)))
     50          
     51          #define SETUP_TOKEN    0x0D
     52          #define IN_TOKEN       0x09
     53          #define OUT_TOKEN      0x01
     54          #define TOK_PID(idx)   ((BD[idx].stat >> 2) & 0x0F)
     55          
     56          //inline static void protected_and (uint32_t *addr, uint32_t val) { while(__STREXH((__LDREXH(addr) & val),addr)); }
     57          //inline static void protected_or  (uint32_t *addr, uint32_t val) { while(__STREXH((__LDREXH(addr) | val),addr)); }
     58          //inline static void protected_xor (uint32_t *addr, uint32_t val) { while(__STREXH((__LDREXH(addr) ^ val),addr)); }

   \                                 In section .text, align 2, keep-with-next
     59          inline static void protected_and (uint32_t *addr, uint32_t val) { *addr = ((uint32_t)(*addr)) & val; }
   \                     protected_and: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x4011             ANDS     R1,R1,R2
   \   00000004   0x6001             STR      R1,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     60          inline static void protected_or  (uint32_t *addr, uint32_t val) { *addr = ((uint32_t)(*addr)) | val; }
   \                     protected_or: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x4311             ORRS     R1,R1,R2
   \   00000004   0x6001             STR      R1,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     61          inline static void protected_xor (uint32_t *addr, uint32_t val) { *addr = ((uint32_t)(*addr)) ^ val; }
   \                     protected_xor: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x4051             EORS     R1,R1,R2
   \   00000004   0x6001             STR      R1,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
     62          
     63          /*
     64           *  USB Device Interrupt enable
     65           *   Called by USBD_Init to enable the USB Interrupt
     66           *    Return Value:    None
     67           */
     68          
     69          #ifdef __RTX
     70          void __svc(1) USBD_IntrEna (void);
     71          void __SVC_1               (void) {
     72          #else

   \                                 In section .text, align 2, keep-with-next
     73          void          USBD_IntrEna (void) {
   \                     USBD_IntrEna: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     74          #endif
     75            //NVIC_EnableIRQ   (USB0_IRQn);         /* Enable OTG interrupt               */
     76            enable_irq(INT_USB0-16);
   \   00000002   0x2018             MOVS     R0,#+24
   \   00000004   0x.... 0x....      BL       enable_irq
     77          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
     78          
     79          

   \                                 In section .text, align 2, keep-with-next
     80          uint8_t USB_ClockInit(void)
     81          {
     82              /* open clock gate */
     83              SIM_SOPT2 |= SIM_SOPT2_USBSRC_MASK;
   \                     USB_ClockInit: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10  ;; 0x40048004
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x02C9             LSLS     R1,R1,#+11       ;; #+262144
   \   00000008   0x4301             ORRS     R1,R1,R0
   \   0000000A   0x....             LDR      R0,??DataTable10  ;; 0x40048004
   \   0000000C   0x6001             STR      R1,[R0, #+0]
     84              
     85              /* which MCG generator is to be used */
     86              SIM_SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK;
   \   0000000E   0x....             LDR      R0,??DataTable10  ;; 0x40048004
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2180             MOVS     R1,#+128
   \   00000014   0x0249             LSLS     R1,R1,#+9        ;; #+65536
   \   00000016   0x4301             ORRS     R1,R1,R0
   \   00000018   0x....             LDR      R0,??DataTable10  ;; 0x40048004
   \   0000001A   0x6001             STR      R1,[R0, #+0]
     87              
     88              return 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x4770             BX       LR               ;; return
     89          }
     90          /*
     91           *  USB Device Initialize Function
     92           *   Called by the User to initialize USB
     93           *   Return Value:    None
     94           */
     95          

   \                                 In section .text, align 2, keep-with-next
     96          void USBD_Init (void) {
   \                     USBD_Init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     97            OutEpSize[0] = USBD_MAX_PACKET0;
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x....             LDR      R1,??DataTable10_1
   \   00000006   0x7008             STRB     R0,[R1, #+0]
     98              
     99              /* config USB clock route */
    100              if(!USB_ClockInit())
   \   00000008   0x.... 0x....      BL       USB_ClockInit
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD03D             BEQ      ??USBD_Init_0
    101              {
    102          //        printf("USB  Init failed, clock must be 96M or 48M\r\n");
    103                  return;
    104              }
    105          
    106              /* Enable USBOTG clock        */
    107              SIM_SCGC4   |=   SIM_SCGC4_USBOTG_MASK;       
   \                     ??USBD_Init_1: (+1)
   \   00000010   0x....             LDR      R0,??DataTable10_2  ;; 0x40048034
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2180             MOVS     R1,#+128
   \   00000016   0x02C9             LSLS     R1,R1,#+11       ;; #+262144
   \   00000018   0x4301             ORRS     R1,R1,R0
   \   0000001A   0x....             LDR      R0,??DataTable10_2  ;; 0x40048034
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    108              
    109              USBD_IntrEna ();
   \   0000001E   0x.... 0x....      BL       USBD_IntrEna
    110          
    111              USB0_USBTRC0 |= USB_USBTRC0_USBRESET_MASK;
   \   00000022   0x....             LDR      R0,??DataTable11  ;; 0x4007210c
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x4301             ORRS     R1,R1,R0
   \   0000002A   0x....             LDR      R0,??DataTable11  ;; 0x4007210c
   \   0000002C   0x7001             STRB     R1,[R0, #+0]
    112              while (USB0_USBTRC0 & USB_USBTRC0_USBRESET_MASK);
   \                     ??USBD_Init_2: (+1)
   \   0000002E   0x....             LDR      R0,??DataTable11  ;; 0x4007210c
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x0600             LSLS     R0,R0,#+24
   \   00000034   0xD4FB             BMI      ??USBD_Init_2
    113          
    114              USB0_BDTPAGE1 = (uint8_t) ((uint32_t) BD >> 8 );
   \   00000036   0x....             LDR      R0,??DataTable10_3
   \   00000038   0x0A00             LSRS     R0,R0,#+8
   \   0000003A   0x....             LDR      R1,??DataTable10_4  ;; 0x4007209c
   \   0000003C   0x7008             STRB     R0,[R1, #+0]
    115              USB0_BDTPAGE2 = (uint8_t) ((uint32_t) BD >> 16);
   \   0000003E   0x....             LDR      R0,??DataTable10_3
   \   00000040   0x0C00             LSRS     R0,R0,#+16
   \   00000042   0x....             LDR      R1,??DataTable10_5  ;; 0x400720b0
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    116              USB0_BDTPAGE3 = (uint8_t) ((uint32_t) BD >> 24);
   \   00000046   0x....             LDR      R0,??DataTable10_3
   \   00000048   0x0E00             LSRS     R0,R0,#+24
   \   0000004A   0x....             LDR      R1,??DataTable10_6  ;; 0x400720b4
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
    117          
    118              USB0_ISTAT   = 0xFF;                 /* clear interrupt flags              */
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0x....             LDR      R1,??DataTable10_7  ;; 0x40072080
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    119          
    120              /* enable interrupts                                                        */
    121              USB0_INTEN = USB_INTEN_USBRSTEN_MASK | USB_INTEN_TOKDNEEN_MASK | USB_INTEN_SLEEPEN_MASK  |
    122          #ifdef __RTX
    123                        ((USBD_RTX_DevTask   != 0) ? USB_INTEN_SOFTOKEN_MASK : 0) |
    124                        ((USBD_RTX_DevTask   != 0) ? USB_INTEN_ERROREN_MASK  : 0) ;
    125          #else
    126                        ((USBD_P_SOF_Event   != 0) ? USB_INTEN_SOFTOKEN_MASK : 0) |
    127                        ((USBD_P_Error_Event != 0) ? USB_INTEN_ERROREN_MASK  : 0) ;
   \   00000054   0x....             LDR      R0,??DataTable10_8
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ      ??USBD_Init_3
   \   0000005C   0x2004             MOVS     R0,#+4
   \   0000005E   0xE000             B        ??USBD_Init_4
   \                     ??USBD_Init_3: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \                     ??USBD_Init_4: (+1)
   \   00000062   0x....             LDR      R1,??DataTable10_9
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x2900             CMP      R1,#+0
   \   00000068   0xD001             BEQ      ??USBD_Init_5
   \   0000006A   0x2102             MOVS     R1,#+2
   \   0000006C   0xE000             B        ??USBD_Init_6
   \                     ??USBD_Init_5: (+1)
   \   0000006E   0x2100             MOVS     R1,#+0
   \                     ??USBD_Init_6: (+1)
   \   00000070   0x4301             ORRS     R1,R1,R0
   \   00000072   0x2019             MOVS     R0,#+25
   \   00000074   0x4308             ORRS     R0,R0,R1
   \   00000076   0x....             LDR      R1,??DataTable10_10  ;; 0x40072084
   \   00000078   0x7008             STRB     R0,[R1, #+0]
    128          #endif
    129          
    130              /* pull dawn on D+ and D- */
    131              USB0_USBCTRL  = USB_USBCTRL_PDE_MASK;
   \   0000007A   0x2040             MOVS     R0,#+64
   \   0000007C   0x....             LDR      R1,??DataTable10_11  ;; 0x40072100
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
    132              
    133              /* bit 6 must be set to 1 */
    134              USB0_USBTRC0 |= (1 << 6);            
   \   00000080   0x....             LDR      R0,??DataTable11  ;; 0x4007210c
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x2140             MOVS     R1,#+64
   \   00000086   0x4301             ORRS     R1,R1,R0
   \   00000088   0x....             LDR      R0,??DataTable11  ;; 0x4007210c
   \   0000008A   0x7001             STRB     R1,[R0, #+0]
    135          }
   \                     ??USBD_Init_0: (+1)
   \   0000008C   0xBD01             POP      {R0,PC}          ;; return
    136          
    137          
    138          /*
    139           *  USB Device Connect Function
    140           *   Called by the User to Connect/Disconnect USB Device
    141           *    Parameters:      con:   Connect/Disconnect
    142           *    Return Value:    None
    143           */
    144          

   \                                 In section .text, align 2, keep-with-next
    145          void USBD_Connect (uint32_t con) {
   \                     USBD_Connect: (+1)
   \   00000000   0xB500             PUSH     {LR}
    146          
    147            if ( con) {
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD009             BEQ      ??USBD_Connect_0
    148              USB0_CTL  |= USB_CTL_USBENSOFEN_MASK;            /* enable USB           */
   \   00000006   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x4301             ORRS     R1,R1,R0
   \   0000000E   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    149              USB0_CONTROL = USB_CONTROL_DPPULLUPNONOTG_MASK;  /* pull up on D+        */
   \   00000012   0x2010             MOVS     R0,#+16
   \   00000014   0x....             LDR      R1,??DataTable13  ;; 0x40072108
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   \   00000018   0xE00B             B        ??USBD_Connect_1
    150            }
    151            else {
    152              USB0_CTL  &= ~USB_CTL_USBENSOFEN_MASK;           /* disable USB          */
   \                     ??USBD_Connect_0: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x21FE             MOVS     R1,#+254
   \   00000020   0x4001             ANDS     R1,R1,R0
   \   00000022   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   00000024   0x7001             STRB     R1,[R0, #+0]
    153              USB0_CONTROL &= ~USB_CONTROL_DPPULLUPNONOTG_MASK;/* pull down on D+      */
   \   00000026   0x....             LDR      R0,??DataTable13  ;; 0x40072108
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x21EF             MOVS     R1,#+239
   \   0000002C   0x4001             ANDS     R1,R1,R0
   \   0000002E   0x....             LDR      R0,??DataTable13  ;; 0x40072108
   \   00000030   0x7001             STRB     R1,[R0, #+0]
    154            }
    155          }
   \                     ??USBD_Connect_1: (+1)
   \   00000032   0xBD00             POP      {PC}             ;; return
    156          
    157          
    158          /*
    159           *  USB Device Reset Function
    160           *   Called automatically on USB Device Reset
    161           *    Return Value:    None
    162           */

   \                                 In section .text, align 2, keep-with-next
    163          void USBD_Reset (void) {
   \                     USBD_Reset: (+1)
   \   00000000   0xB500             PUSH     {LR}
    164            uint32_t i;
    165          
    166            for (i = 1; i < 16; i++) {
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0xE005             B        ??USBD_Reset_0
    167              USB_ENDPT_REG(USB0_BASE_PTR,i) = 0x00;
   \                     ??USBD_Reset_1: (+1)
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR      R2,??DataTable13_1  ;; 0x400720c0
   \   0000000A   0x2304             MOVS     R3,#+4
   \   0000000C   0x4343             MULS     R3,R0,R3
   \   0000000E   0x54D1             STRB     R1,[R2, R3]
    168            }
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \                     ??USBD_Reset_0: (+1)
   \   00000012   0x2810             CMP      R0,#+16
   \   00000014   0xD3F7             BCC      ??USBD_Reset_1
    169          
    170            /* EP0 control endpoint                                                     */
    171            BD[IDX(0, RX, ODD )].bc       = USBD_MAX_PACKET0;
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0x....             LDR      R1,??DataTable10_3
   \   0000001A   0x8048             STRH     R0,[R1, #+2]
    172            BD[IDX(0, RX, ODD )].buf_addr = (uint32_t) &(EPBuf[IDX(0, RX, ODD )][0]);
   \   0000001C   0x....             LDR      R0,??DataTable13_2
   \   0000001E   0x....             LDR      R1,??DataTable10_3
   \   00000020   0x6048             STR      R0,[R1, #+4]
    173            BD[IDX(0, RX, ODD )].stat     = BD_OWN_MASK | BD_DTS_MASK | BD_DATA01_MASK;
   \   00000022   0x20C8             MOVS     R0,#+200
   \   00000024   0x....             LDR      R1,??DataTable10_3
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    174          
    175            BD[IDX(0, RX, EVEN)].stat     = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x....             LDR      R1,??DataTable10_3
   \   0000002C   0x7208             STRB     R0,[R1, #+8]
    176          
    177            BD[IDX(0, TX, ODD )].buf_addr = (uint32_t) &(EPBuf[IDX(0, TX, ODD )][0]);
   \   0000002E   0x....             LDR      R0,??DataTable13_3
   \   00000030   0x....             LDR      R1,??DataTable10_3
   \   00000032   0x6148             STR      R0,[R1, #+20]
    178            BD[IDX(0, TX, EVEN)].buf_addr = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x....             LDR      R1,??DataTable10_3
   \   00000038   0x61C8             STR      R0,[R1, #+28]
    179          
    180            USB_ENDPT_REG(USB0_BASE_PTR,0) = USB_ENDPT_EPHSHK_MASK | /* enable ep handshaking  */
    181                                      USB_ENDPT_EPTXEN_MASK | /* enable TX (IN) tran.   */
    182                                      USB_ENDPT_EPRXEN_MASK;  /* enable RX (OUT) tran.  */
   \   0000003A   0x200D             MOVS     R0,#+13
   \   0000003C   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
    183          
    184            Data1 = 0x55555555;
   \   00000040   0x....             LDR      R0,??DataTable13_4  ;; 0x55555555
   \   00000042   0x....             LDR      R1,??DataTable13_5
   \   00000044   0x6008             STR      R0,[R1, #+0]
    185            USB0_CTL    |=  USB_CTL_ODDRST_MASK;
   \   00000046   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2102             MOVS     R1,#+2
   \   0000004C   0x4301             ORRS     R1,R1,R0
   \   0000004E   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   00000050   0x7001             STRB     R1,[R0, #+0]
    186          
    187            USB0_ISTAT   =  0xFF;                /* clear all interrupt status flags   */
   \   00000052   0x20FF             MOVS     R0,#+255
   \   00000054   0x....             LDR      R1,??DataTable10_7  ;; 0x40072080
   \   00000056   0x7008             STRB     R0,[R1, #+0]
    188            USB0_ERRSTAT =  0xFF;                /* clear all error flags              */
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0x....             LDR      R1,??DataTable13_6  ;; 0x40072088
   \   0000005C   0x7008             STRB     R0,[R1, #+0]
    189            USB0_ERREN   =  0xFF;                /* enable error interrupt sources     */
   \   0000005E   0x20FF             MOVS     R0,#+255
   \   00000060   0x....             LDR      R1,??DataTable13_7  ;; 0x4007208c
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    190            USB0_ADDR    =  0x00;                /* set default address                */
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x....             LDR      R1,??DataTable13_8  ;; 0x40072098
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    191          
    192          }
   \   0000006A   0xBD00             POP      {PC}             ;; return
    193          
    194          
    195          /*
    196           *  USB Device Suspend Function
    197           *   Called automatically on USB Device Suspend
    198           *    Return Value:    None
    199           */
    200          

   \                                 In section .text, align 2, keep-with-next
    201          void USBD_Suspend (void) {
    202            USB0_INTEN |= USB_INTEN_RESUMEEN_MASK;
   \                     USBD_Suspend: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10_10  ;; 0x40072084
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2120             MOVS     R1,#+32
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable10_10  ;; 0x40072084
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    203          }
   \   0000000C   0x4770             BX       LR               ;; return
    204          
    205          
    206          /*
    207           *  USB Device Resume Function
    208           *   Called automatically on USB Device Resume
    209           *    Return Value:    None
    210           */
    211          

   \                                 In section .text, align 2, keep-with-next
    212          void USBD_Resume (void) {
    213            USB0_INTEN &= ~USB_INTEN_RESUMEEN_MASK;
   \                     USBD_Resume: (+1)
   \   00000000   0x....             LDR      R0,??DataTable10_10  ;; 0x40072084
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x21DF             MOVS     R1,#+223
   \   00000006   0x4001             ANDS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable10_10  ;; 0x40072084
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    214          
    215          }
   \   0000000C   0x4770             BX       LR               ;; return
    216          
    217          
    218          /*
    219           *  USB Device Remote Wakeup Function
    220           *   Called automatically on USB Device Remote Wakeup
    221           *    Return Value:    None
    222           */
    223          

   \                                 In section .text, align 4, keep-with-next
    224          void USBD_WakeUp (void) {
   \                     USBD_WakeUp: (+1)
   \   00000000   0xB500             PUSH     {LR}
    225            uint32_t i = 50000;
   \   00000002   0x....             LDR      R0,??DataTable13_9  ;; 0xc350
    226            if (USBD_DeviceStatus & USB_GETSTATUS_REMOTE_WAKEUP) {
   \   00000004   0x....             LDR      R1,??DataTable13_10
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x0789             LSLS     R1,R1,#+30
   \   0000000A   0xD511             BPL      ??USBD_WakeUp_0
    227              USB0_CTL |=  USB_CTL_RESUME_MASK;
   \   0000000C   0x....             LDR      R1,??DataTable11_1  ;; 0x40072094
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0x430A             ORRS     R2,R2,R1
   \   00000014   0x....             LDR      R1,??DataTable11_1  ;; 0x40072094
   \   00000016   0x700A             STRB     R2,[R1, #+0]
   \   00000018   0xE000             B        ??USBD_WakeUp_1
    228              while (i--)   asm("nop");
   \                     ??USBD_WakeUp_2: (+1)
   \   0000001A   0xBF00             nop
   \                     ??USBD_WakeUp_1: (+1)
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0x1E48             SUBS     R0,R1,#+1
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD1FA             BNE      ??USBD_WakeUp_2
    229              USB0_CTL &= ~USB_CTL_RESUME_MASK;
   \   00000024   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x21FB             MOVS     R1,#+251
   \   0000002A   0x4001             ANDS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable11_1  ;; 0x40072094
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
    230            }
    231          }
   \                     ??USBD_WakeUp_0: (+1)
   \   00000030   0xBD00             POP      {PC}             ;; return
    232          
    233          
    234          /*
    235           *  USB Device Remote Wakeup Configuration Function
    236           *    Parameters:      cfg:   Device Enable/Disable
    237           *    Return Value:    None
    238           */
    239          

   \                                 In section .text, align 2, keep-with-next
    240          void USBD_WakeUpCfg (uint32_t cfg) {
    241            /* Not needed                                                               */
    242          }
   \                     USBD_WakeUpCfg: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    243          
    244          
    245          /*
    246           *  USB Device Set Address Function
    247           *    Parameters:      adr:   USB Device Address
    248           *    Return Value:    None
    249           */
    250          

   \                                 In section .text, align 2, keep-with-next
    251          void USBD_SetAddress (uint32_t  adr, uint32_t setup) {
   \                     USBD_SetAddress: (+1)
   \   00000000   0xB500             PUSH     {LR}
    252            if (!setup) {
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD103             BNE      ??USBD_SetAddress_0
    253              USB0_ADDR    = adr & 0x7F;
   \   00000006   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   00000008   0x0E40             LSRS     R0,R0,#+25
   \   0000000A   0x....             LDR      R1,??DataTable13_8  ;; 0x40072098
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    254            }
    255          }
   \                     ??USBD_SetAddress_0: (+1)
   \   0000000E   0xBD00             POP      {PC}             ;; return
    256          
    257          
    258          /*
    259           *  USB Device Configure Function
    260           *    Parameters:      cfg:   Device Configure/Deconfigure
    261           *    Return Value:    None
    262           */
    263          

   \                                 In section .text, align 2, keep-with-next
    264          void USBD_Configure (uint32_t cfg) {
    265          }
   \                     USBD_Configure: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    266          
    267          
    268          /*
    269           *  Configure USB Device Endpoint according to Descriptor
    270           *    Parameters:      pEPD:  Pointer to Device Endpoint Descriptor
    271           *    Return Value:    None
    272           */
    273          

   \                                 In section .text, align 2, keep-with-next
    274          void USBD_ConfigEP (USB_ENDPOINT_DESCRIPTOR *pEPD) {
   \                     USBD_ConfigEP: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    275            uint32_t num, val;
    276          
    277            num  = pEPD->bEndpointAddress;
   \   00000004   0x7888             LDRB     R0,[R1, #+2]
    278            val  = pEPD->wMaxPacketSize;
   \   00000006   0x790A             LDRB     R2,[R1, #+4]
   \   00000008   0x794B             LDRB     R3,[R1, #+5]
   \   0000000A   0x061B             LSLS     R3,R3,#+24       ;; ZeroExtS R3,R3,#+24,#+16
   \   0000000C   0x0C1B             LSRS     R3,R3,#+16
   \   0000000E   0x431A             ORRS     R2,R2,R3
   \   00000010   0xB292             UXTH     R2,R2
    279          
    280            if (!(pEPD->bEndpointAddress & 0x80)) {
   \   00000012   0x7889             LDRB     R1,[R1, #+2]
   \   00000014   0x0609             LSLS     R1,R1,#+24
   \   00000016   0xD401             BMI      ??USBD_ConfigEP_0
    281              OutEpSize[num] = val;
   \   00000018   0x....             LDR      R1,??DataTable10_1
   \   0000001A   0x540A             STRB     R2,[R1, R0]
    282            }
    283            USBD_ResetEP (num);
   \                     ??USBD_ConfigEP_0: (+1)
   \   0000001C   0x.... 0x....      BL       USBD_ResetEP
    284          }
   \   00000020   0xBD01             POP      {R0,PC}          ;; return
    285          
    286          
    287          /*
    288           *  Set Direction for USB Device Control Endpoint
    289           *    Parameters:      dir:   Out (dir == 0), In (dir <> 0)
    290           *    Return Value:    None
    291           */
    292          

   \                                 In section .text, align 2, keep-with-next
    293          void USBD_DirCtrlEP (uint32_t dir) {
    294            /* Not needed                                                               */
    295          }
   \                     USBD_DirCtrlEP: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    296          
    297          
    298          /*
    299           *  Enable USB Device Endpoint
    300           *    Parameters:      EPNum: Device Endpoint Number
    301           *                       EPNum.0..3: Address
    302           *                       EPNum.7:    Dir
    303           *    Return Value:    None
    304           */
    305          

   \                                 In section .text, align 2, keep-with-next
    306          void USBD_EnableEP (uint32_t EPNum) {
   \                     USBD_EnableEP: (+1)
   \   00000000   0xB500             PUSH     {LR}
    307          
    308            if (EPNum & 0x80) {
   \   00000002   0x0601             LSLS     R1,R0,#+24
   \   00000004   0xD50C             BPL      ??USBD_EnableEP_0
    309              EPNum &= 0x0F;
   \   00000006   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000008   0x0F00             LSRS     R0,R0,#+28
    310              USB_ENDPT_REG(USB0_BASE_PTR,EPNum) |= USB_ENDPT_EPHSHK_MASK | /*en ep handshaking*/
    311                                             USB_ENDPT_EPTXEN_MASK;  /*en TX (IN) tran  */
   \   0000000A   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x4342             MULS     R2,R0,R2
   \   00000010   0x5C89             LDRB     R1,[R1, R2]
   \   00000012   0x2205             MOVS     R2,#+5
   \   00000014   0x430A             ORRS     R2,R2,R1
   \   00000016   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000018   0x2304             MOVS     R3,#+4
   \   0000001A   0x4358             MULS     R0,R3,R0
   \   0000001C   0x540A             STRB     R2,[R1, R0]
   \   0000001E   0xE009             B        ??USBD_EnableEP_1
    312            }
    313            else {
    314              USB_ENDPT_REG(USB0_BASE_PTR,EPNum) |= USB_ENDPT_EPHSHK_MASK | /*en ep handshaking*/
    315                                             USB_ENDPT_EPRXEN_MASK;  /*en RX (OUT) tran.*/
   \                     ??USBD_EnableEP_0: (+1)
   \   00000020   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x4342             MULS     R2,R0,R2
   \   00000026   0x5C89             LDRB     R1,[R1, R2]
   \   00000028   0x2209             MOVS     R2,#+9
   \   0000002A   0x430A             ORRS     R2,R2,R1
   \   0000002C   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   0000002E   0x2304             MOVS     R3,#+4
   \   00000030   0x4358             MULS     R0,R3,R0
   \   00000032   0x540A             STRB     R2,[R1, R0]
    316            }
    317          }
   \                     ??USBD_EnableEP_1: (+1)
   \   00000034   0xBD00             POP      {PC}             ;; return
    318          
    319          
    320          /*
    321           *  Disable USB Endpoint
    322           *    Parameters:      EPNum: Endpoint Number
    323           *                       EPNum.0..3: Address
    324           *                       EPNum.7:    Dir
    325           *    Return Value:    None
    326           */
    327          

   \                                 In section .text, align 2, keep-with-next
    328          void USBD_DisableEP (uint32_t EPNum) {
   \                     USBD_DisableEP: (+1)
   \   00000000   0xB500             PUSH     {LR}
    329            if (EPNum & 0x80) {
   \   00000002   0x0601             LSLS     R1,R0,#+24
   \   00000004   0xD50C             BPL      ??USBD_DisableEP_0
    330              EPNum &= 0x0F;
   \   00000006   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000008   0x0F00             LSRS     R0,R0,#+28
    331              USB_ENDPT_REG(USB0_BASE_PTR,EPNum) &= ~(USB_ENDPT_EPHSHK_MASK |/*dis handshaking */
    332                                               USB_ENDPT_EPTXEN_MASK);/*dis TX(IN) tran */
   \   0000000A   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x4342             MULS     R2,R0,R2
   \   00000010   0x5C89             LDRB     R1,[R1, R2]
   \   00000012   0x22FA             MOVS     R2,#+250
   \   00000014   0x400A             ANDS     R2,R2,R1
   \   00000016   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000018   0x2304             MOVS     R3,#+4
   \   0000001A   0x4358             MULS     R0,R3,R0
   \   0000001C   0x540A             STRB     R2,[R1, R0]
   \   0000001E   0xE009             B        ??USBD_DisableEP_1
    333            }
    334            else {
    335              USB_ENDPT_REG(USB0_BASE_PTR,EPNum) &= ~(USB_ENDPT_EPHSHK_MASK |/*dis handshaking */
    336                                               USB_ENDPT_EPRXEN_MASK);/*dis RX(OUT) tran*/
   \                     ??USBD_DisableEP_0: (+1)
   \   00000020   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x4342             MULS     R2,R0,R2
   \   00000026   0x5C89             LDRB     R1,[R1, R2]
   \   00000028   0x22F6             MOVS     R2,#+246
   \   0000002A   0x400A             ANDS     R2,R2,R1
   \   0000002C   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   0000002E   0x2304             MOVS     R3,#+4
   \   00000030   0x4358             MULS     R0,R3,R0
   \   00000032   0x540A             STRB     R2,[R1, R0]
    337            }
    338          }
   \                     ??USBD_DisableEP_1: (+1)
   \   00000034   0xBD00             POP      {PC}             ;; return
    339          
    340          
    341          /*
    342           *  Reset USB Device Endpoint
    343           *    Parameters:      EPNum: Device Endpoint Number
    344           *                       EPNum.0..3: Address
    345           *                       EPNum.7:    Dir
    346           *    Return Value:    None
    347           */
    348          

   \                                 In section .text, align 2, keep-with-next
    349          void USBD_ResetEP (uint32_t EPNum) {
   \                     USBD_ResetEP: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    350            if (EPNum & 0x80) {
   \   00000004   0x0620             LSLS     R0,R4,#+24
   \   00000006   0xD52E             BPL      ??USBD_ResetEP_0
    351              EPNum &= 0x0F;
   \   00000008   0x0724             LSLS     R4,R4,#+28       ;; ZeroExtS R4,R4,#+28,#+28
   \   0000000A   0x0F24             LSRS     R4,R4,#+28
    352              protected_or(&Data1, (1 << ((EPNum * 2) + 1)));
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x4360             MULS     R0,R4,R0
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x4081             LSLS     R1,R1,R0
   \   00000016   0x....             LDR      R0,??DataTable13_5
   \   00000018   0x.... 0x....      BL       protected_or
    353              BD[IDX(EPNum, TX, ODD )].buf_addr = (uint32_t) &(EPBuf[IDX(EPNum, TX, ODD )][0]);
   \   0000001C   0x....             LDR      R0,??DataTable16
   \   0000001E   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   00000020   0x0F09             LSRS     R1,R1,#+28
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x4351             MULS     R1,R2,R1
   \   00000026   0x2208             MOVS     R2,#+8
   \   00000028   0x4351             MULS     R1,R2,R1
   \   0000002A   0x1840             ADDS     R0,R0,R1
   \   0000002C   0x....             LDR      R1,??DataTable13_2
   \   0000002E   0x0722             LSLS     R2,R4,#+28       ;; ZeroExtS R2,R4,#+28,#+28
   \   00000030   0x0F12             LSRS     R2,R2,#+28
   \   00000032   0x2304             MOVS     R3,#+4
   \   00000034   0x435A             MULS     R2,R3,R2
   \   00000036   0x2340             MOVS     R3,#+64
   \   00000038   0x435A             MULS     R2,R3,R2
   \   0000003A   0x1889             ADDS     R1,R1,R2
   \   0000003C   0x3180             ADDS     R1,R1,#+128
   \   0000003E   0x6141             STR      R1,[R0, #+20]
    354              BD[IDX(EPNum, TX, EVEN)].buf_addr = (uint32_t) &(EPBuf[IDX(EPNum, TX, EVEN )][0]);
   \   00000040   0x....             LDR      R0,??DataTable16
   \   00000042   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   00000044   0x0F09             LSRS     R1,R1,#+28
   \   00000046   0x2204             MOVS     R2,#+4
   \   00000048   0x4351             MULS     R1,R2,R1
   \   0000004A   0x2208             MOVS     R2,#+8
   \   0000004C   0x4351             MULS     R1,R2,R1
   \   0000004E   0x1840             ADDS     R0,R0,R1
   \   00000050   0x....             LDR      R1,??DataTable13_2
   \   00000052   0x0722             LSLS     R2,R4,#+28       ;; ZeroExtS R2,R4,#+28,#+28
   \   00000054   0x0F12             LSRS     R2,R2,#+28
   \   00000056   0x2304             MOVS     R3,#+4
   \   00000058   0x435A             MULS     R2,R3,R2
   \   0000005A   0x2340             MOVS     R3,#+64
   \   0000005C   0x435A             MULS     R2,R3,R2
   \   0000005E   0x1889             ADDS     R1,R1,R2
   \   00000060   0x31C0             ADDS     R1,R1,#+192
   \   00000062   0x61C1             STR      R1,[R0, #+28]
   \   00000064   0xE04D             B        ??USBD_ResetEP_1
    355            }
    356            else {
    357              protected_and(&Data1, ~(1 << (EPNum * 2)));
   \                     ??USBD_ResetEP_0: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x0021             MOVS     R1,R4
   \   0000006A   0x2202             MOVS     R2,#+2
   \   0000006C   0x4351             MULS     R1,R2,R1
   \   0000006E   0x4088             LSLS     R0,R0,R1
   \   00000070   0x43C1             MVNS     R1,R0
   \   00000072   0x....             LDR      R0,??DataTable13_5
   \   00000074   0x.... 0x....      BL       protected_and
    358              BD[IDX(EPNum, RX, ODD )].bc       = OutEpSize[EPNum];
   \   00000078   0x....             LDR      R0,??DataTable16_1
   \   0000007A   0x5D00             LDRB     R0,[R0, R4]
   \   0000007C   0x....             LDR      R1,??DataTable16
   \   0000007E   0x0722             LSLS     R2,R4,#+28       ;; ZeroExtS R2,R4,#+28,#+28
   \   00000080   0x0F12             LSRS     R2,R2,#+28
   \   00000082   0x2320             MOVS     R3,#+32
   \   00000084   0x435A             MULS     R2,R3,R2
   \   00000086   0x1889             ADDS     R1,R1,R2
   \   00000088   0x8048             STRH     R0,[R1, #+2]
    359              BD[IDX(EPNum, RX, ODD )].buf_addr = (uint32_t) &(EPBuf[IDX(EPNum, RX, ODD )][0]);
   \   0000008A   0x....             LDR      R0,??DataTable13_2
   \   0000008C   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   0000008E   0x0F09             LSRS     R1,R1,#+28
   \   00000090   0x2280             MOVS     R2,#+128
   \   00000092   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \   00000094   0x4351             MULS     R1,R2,R1
   \   00000096   0x1840             ADDS     R0,R0,R1
   \   00000098   0x....             LDR      R1,??DataTable16
   \   0000009A   0x0722             LSLS     R2,R4,#+28       ;; ZeroExtS R2,R4,#+28,#+28
   \   0000009C   0x0F12             LSRS     R2,R2,#+28
   \   0000009E   0x2320             MOVS     R3,#+32
   \   000000A0   0x435A             MULS     R2,R3,R2
   \   000000A2   0x1889             ADDS     R1,R1,R2
   \   000000A4   0x6048             STR      R0,[R1, #+4]
    360              BD[IDX(EPNum, RX, ODD )].stat     = BD_OWN_MASK | BD_DTS_MASK;
   \   000000A6   0x2088             MOVS     R0,#+136
   \   000000A8   0x....             LDR      R1,??DataTable16
   \   000000AA   0x0722             LSLS     R2,R4,#+28       ;; ZeroExtS R2,R4,#+28,#+28
   \   000000AC   0x0F12             LSRS     R2,R2,#+28
   \   000000AE   0x2320             MOVS     R3,#+32
   \   000000B0   0x435A             MULS     R2,R3,R2
   \   000000B2   0x5488             STRB     R0,[R1, R2]
    361          
    362              BD[IDX(EPNum, RX, EVEN )].bc       = OutEpSize[EPNum];
   \   000000B4   0x....             LDR      R0,??DataTable16
   \   000000B6   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   000000B8   0x0F09             LSRS     R1,R1,#+28
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0x4351             MULS     R1,R2,R1
   \   000000BE   0x2208             MOVS     R2,#+8
   \   000000C0   0x4351             MULS     R1,R2,R1
   \   000000C2   0x1840             ADDS     R0,R0,R1
   \   000000C4   0x....             LDR      R1,??DataTable16_1
   \   000000C6   0x5D09             LDRB     R1,[R1, R4]
   \   000000C8   0x8141             STRH     R1,[R0, #+10]
    363              BD[IDX(EPNum, RX, EVEN )].buf_addr = (uint32_t) &(EPBuf[IDX(EPNum, RX, EVEN )][0]);
   \   000000CA   0x....             LDR      R0,??DataTable16
   \   000000CC   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   000000CE   0x0F09             LSRS     R1,R1,#+28
   \   000000D0   0x2204             MOVS     R2,#+4
   \   000000D2   0x4351             MULS     R1,R2,R1
   \   000000D4   0x2208             MOVS     R2,#+8
   \   000000D6   0x4351             MULS     R1,R2,R1
   \   000000D8   0x1840             ADDS     R0,R0,R1
   \   000000DA   0x....             LDR      R1,??DataTable13_2
   \   000000DC   0x0722             LSLS     R2,R4,#+28       ;; ZeroExtS R2,R4,#+28,#+28
   \   000000DE   0x0F12             LSRS     R2,R2,#+28
   \   000000E0   0x2304             MOVS     R3,#+4
   \   000000E2   0x435A             MULS     R2,R3,R2
   \   000000E4   0x2340             MOVS     R3,#+64
   \   000000E6   0x435A             MULS     R2,R3,R2
   \   000000E8   0x1889             ADDS     R1,R1,R2
   \   000000EA   0x3140             ADDS     R1,R1,#+64
   \   000000EC   0x60C1             STR      R1,[R0, #+12]
    364              BD[IDX(EPNum, RX, EVEN )].stat     = BD_OWN_MASK | BD_DTS_MASK | BD_DATA01_MASK;
   \   000000EE   0x....             LDR      R0,??DataTable16
   \   000000F0   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   000000F2   0x0F09             LSRS     R1,R1,#+28
   \   000000F4   0x2204             MOVS     R2,#+4
   \   000000F6   0x4351             MULS     R1,R2,R1
   \   000000F8   0x2208             MOVS     R2,#+8
   \   000000FA   0x4351             MULS     R1,R2,R1
   \   000000FC   0x1840             ADDS     R0,R0,R1
   \   000000FE   0x21C8             MOVS     R1,#+200
   \   00000100   0x7201             STRB     R1,[R0, #+8]
    365            }
    366          }
   \                     ??USBD_ResetEP_1: (+1)
   \   00000102   0xBD10             POP      {R4,PC}          ;; return
    367          
    368          /*
    369           *  Set Stall for USB Device Endpoint
    370           *    Parameters:      EPNum: Device Endpoint Number
    371           *                       EPNum.0..3: Address
    372           *                       EPNum.7:    Dir
    373           *    Return Value:    None
    374           */
    375          

   \                                 In section .text, align 2, keep-with-next
    376          void USBD_SetStallEP (uint32_t EPNum) {
    377            EPNum &= 0x0F;
   \                     USBD_SetStallEP: (+1)
   \   00000000   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000002   0x0F00             LSRS     R0,R0,#+28
    378            USB_ENDPT_REG(USB0_BASE_PTR,EPNum) |= USB_ENDPT_EPSTALL_MASK;
   \   00000004   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x4342             MULS     R2,R0,R2
   \   0000000A   0x5C89             LDRB     R1,[R1, R2]
   \   0000000C   0x2202             MOVS     R2,#+2
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000012   0x2304             MOVS     R3,#+4
   \   00000014   0x4358             MULS     R0,R3,R0
   \   00000016   0x540A             STRB     R2,[R1, R0]
    379          }
   \   00000018   0x4770             BX       LR               ;; return
    380          
    381          
    382          /*
    383           *  Clear Stall for USB Device Endpoint
    384           *    Parameters:      EPNum: Device Endpoint Number
    385           *                       EPNum.0..3: Address
    386           *                       EPNum.7:    Dir
    387           *    Return Value:    None
    388           */
    389          

   \                                 In section .text, align 2, keep-with-next
    390          void USBD_ClrStallEP (uint32_t EPNum) {
   \                     USBD_ClrStallEP: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    391            USB_ENDPT_REG(USB0_BASE_PTR,EPNum&0x0F) &= ~USB_ENDPT_EPSTALL_MASK;
   \   00000002   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000004   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   00000006   0x0F12             LSRS     R2,R2,#+28
   \   00000008   0x2304             MOVS     R3,#+4
   \   0000000A   0x435A             MULS     R2,R3,R2
   \   0000000C   0x5C89             LDRB     R1,[R1, R2]
   \   0000000E   0x22FD             MOVS     R2,#+253
   \   00000010   0x400A             ANDS     R2,R2,R1
   \   00000012   0x....             LDR      R1,??DataTable13_1  ;; 0x400720c0
   \   00000014   0x0703             LSLS     R3,R0,#+28       ;; ZeroExtS R3,R0,#+28,#+28
   \   00000016   0x0F1B             LSRS     R3,R3,#+28
   \   00000018   0x2404             MOVS     R4,#+4
   \   0000001A   0x4363             MULS     R3,R4,R3
   \   0000001C   0x54CA             STRB     R2,[R1, R3]
    392            USBD_ResetEP (EPNum);
   \   0000001E   0x.... 0x....      BL       USBD_ResetEP
    393          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    394          
    395          
    396          /*
    397           *  Clear USB Device Endpoint Buffer
    398           *    Parameters:      EPNum: Device Endpoint Number
    399           *                       EPNum.0..3: Address
    400           *                       EPNum.7:    Dir
    401           *    Return Value:    None
    402           */
    403          

   \                                 In section .text, align 2, keep-with-next
    404          void USBD_ClearEPBuf (uint32_t EPNum) {
    405          }
   \                     USBD_ClearEPBuf: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    406          
    407          
    408          /*
    409           *  Read USB Device Endpoint Data
    410           *    Parameters:      EPNum: Device Endpoint Number
    411           *                       EPNum.0..3: Address
    412           *                       EPNum.7:    Dir
    413           *                     pData: Pointer to Data Buffer
    414           *    Return Value:    Number of bytes read
    415           */
    416          

   \                                 In section .text, align 2, keep-with-next
    417          uint32_t USBD_ReadEP (uint32_t EPNum, uint8_t *pData) {
   \                     USBD_ReadEP: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    418            uint32_t n, sz, idx, setup = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    419          
    420            idx = IDX(EPNum, RX, 0);
   \   00000004   0x0704             LSLS     R4,R0,#+28       ;; ZeroExtS R4,R0,#+28,#+28
   \   00000006   0x0F24             LSRS     R4,R4,#+28
   \   00000008   0x2304             MOVS     R3,#+4
   \   0000000A   0x435C             MULS     R4,R3,R4
    421            sz  = BD[idx].bc;
   \   0000000C   0x....             LDR      R3,??DataTable16
   \   0000000E   0x2508             MOVS     R5,#+8
   \   00000010   0x4365             MULS     R5,R4,R5
   \   00000012   0x195B             ADDS     R3,R3,R5
   \   00000014   0x885D             LDRH     R5,[R3, #+2]
    422          
    423            if ((EPNum == 0) && (TOK_PID(idx) == SETUP_TOKEN)) setup = 1;
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD109             BNE      ??USBD_ReadEP_0
   \   0000001A   0x....             LDR      R3,??DataTable16
   \   0000001C   0x2608             MOVS     R6,#+8
   \   0000001E   0x4366             MULS     R6,R4,R6
   \   00000020   0x5D9B             LDRB     R3,[R3, R6]
   \   00000022   0x109B             ASRS     R3,R3,#+2
   \   00000024   0x071B             LSLS     R3,R3,#+28       ;; ZeroExtS R3,R3,#+28,#+28
   \   00000026   0x0F1B             LSRS     R3,R3,#+28
   \   00000028   0x2B0D             CMP      R3,#+13
   \   0000002A   0xD100             BNE      ??USBD_ReadEP_0
   \   0000002C   0x2201             MOVS     R2,#+1
    424          
    425            for (n = 0; n < sz; n++) {
   \                     ??USBD_ReadEP_0: (+1)
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0xE006             B        ??USBD_ReadEP_1
    426              pData[n] = EPBuf[idx][n];
   \                     ??USBD_ReadEP_2: (+1)
   \   00000032   0x....             LDR      R6,??DataTable16_2
   \   00000034   0x2740             MOVS     R7,#+64
   \   00000036   0x4367             MULS     R7,R4,R7
   \   00000038   0x19F6             ADDS     R6,R6,R7
   \   0000003A   0x5CF6             LDRB     R6,[R6, R3]
   \   0000003C   0x54CE             STRB     R6,[R1, R3]
    427            }
   \   0000003E   0x1C5B             ADDS     R3,R3,#+1
   \                     ??USBD_ReadEP_1: (+1)
   \   00000040   0x42AB             CMP      R3,R5
   \   00000042   0xD3F6             BCC      ??USBD_ReadEP_2
    428          
    429            BD[idx].bc = OutEpSize[EPNum];
   \   00000044   0x....             LDR      R3,??DataTable16_1
   \   00000046   0x5C18             LDRB     R0,[R3, R0]
   \   00000048   0x....             LDR      R3,??DataTable16
   \   0000004A   0x2608             MOVS     R6,#+8
   \   0000004C   0x4366             MULS     R6,R4,R6
   \   0000004E   0x199B             ADDS     R3,R3,R6
   \   00000050   0x8058             STRH     R0,[R3, #+2]
    430          
    431            if ((Data1 >> (idx / 2) & 1) == ((BD[idx].stat >> 6) & 1)) {
   \   00000052   0x....             LDR      R0,??DataTable16_3
   \   00000054   0x6803             LDR      R3,[R0, #+0]
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x0840             LSRS     R0,R0,#+1
   \   0000005A   0x40C3             LSRS     R3,R3,R0
   \   0000005C   0x0018             MOVS     R0,R3
   \   0000005E   0x07C0             LSLS     R0,R0,#+31       ;; ZeroExtS R0,R0,#+31,#+31
   \   00000060   0x0FC0             LSRS     R0,R0,#+31
   \   00000062   0x....             LDR      R3,??DataTable16
   \   00000064   0x2608             MOVS     R6,#+8
   \   00000066   0x4366             MULS     R6,R4,R6
   \   00000068   0x5D9B             LDRB     R3,[R3, R6]
   \   0000006A   0x119B             ASRS     R3,R3,#+6
   \   0000006C   0x001E             MOVS     R6,R3
   \   0000006E   0x07F6             LSLS     R6,R6,#+31       ;; ZeroExtS R6,R6,#+31,#+31
   \   00000070   0x0FF6             LSRS     R6,R6,#+31
   \   00000072   0x42B0             CMP      R0,R6
   \   00000074   0xD111             BNE      ??USBD_ReadEP_3
    432              if (setup && (pData[6] == 0)) {     /* if no setup data stage,            */
   \   00000076   0x2A00             CMP      R2,#+0
   \   00000078   0xD008             BEQ      ??USBD_ReadEP_4
   \   0000007A   0x7988             LDRB     R0,[R1, #+6]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD105             BNE      ??USBD_ReadEP_4
    433                protected_and(&Data1, ~1);           /* set DATA0                          */
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x43C9             MVNS     R1,R1            ;; #-2
   \   00000084   0x....             LDR      R0,??DataTable16_3
   \   00000086   0x.... 0x....      BL       protected_and
   \   0000008A   0xE006             B        ??USBD_ReadEP_3
    434              } else {
    435                protected_xor(&Data1, (1 << (idx / 2)));
   \                     ??USBD_ReadEP_4: (+1)
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x0840             LSRS     R0,R0,#+1
   \   00000092   0x4081             LSLS     R1,R1,R0
   \   00000094   0x....             LDR      R0,??DataTable16_3
   \   00000096   0x.... 0x....      BL       protected_xor
    436              }
    437            }
    438          
    439            if ((Data1 >> (idx / 2)) & 1) {
   \                     ??USBD_ReadEP_3: (+1)
   \   0000009A   0x....             LDR      R0,??DataTable16_3
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x0021             MOVS     R1,R4
   \   000000A0   0x0849             LSRS     R1,R1,#+1
   \   000000A2   0x40C8             LSRS     R0,R0,R1
   \   000000A4   0x07C0             LSLS     R0,R0,#+31
   \   000000A6   0xD50F             BPL      ??USBD_ReadEP_5
    440              BD[idx].stat  = BD_DTS_MASK | BD_DATA01_MASK;
   \   000000A8   0x2048             MOVS     R0,#+72
   \   000000AA   0x....             LDR      R1,??DataTable16
   \   000000AC   0x2208             MOVS     R2,#+8
   \   000000AE   0x4362             MULS     R2,R4,R2
   \   000000B0   0x5488             STRB     R0,[R1, R2]
    441              BD[idx].stat |= BD_OWN_MASK;
   \   000000B2   0x....             LDR      R0,??DataTable16
   \   000000B4   0x2108             MOVS     R1,#+8
   \   000000B6   0x4361             MULS     R1,R4,R1
   \   000000B8   0x5C40             LDRB     R0,[R0, R1]
   \   000000BA   0x2180             MOVS     R1,#+128
   \   000000BC   0x4301             ORRS     R1,R1,R0
   \   000000BE   0x....             LDR      R0,??DataTable16
   \   000000C0   0x2208             MOVS     R2,#+8
   \   000000C2   0x4354             MULS     R4,R2,R4
   \   000000C4   0x5501             STRB     R1,[R0, R4]
   \   000000C6   0xE00E             B        ??USBD_ReadEP_6
    442            }
    443            else {
    444              BD[idx].stat  = BD_DTS_MASK;
   \                     ??USBD_ReadEP_5: (+1)
   \   000000C8   0x2008             MOVS     R0,#+8
   \   000000CA   0x....             LDR      R1,??DataTable16
   \   000000CC   0x2208             MOVS     R2,#+8
   \   000000CE   0x4362             MULS     R2,R4,R2
   \   000000D0   0x5488             STRB     R0,[R1, R2]
    445              BD[idx].stat |= BD_OWN_MASK;
   \   000000D2   0x....             LDR      R0,??DataTable16
   \   000000D4   0x2108             MOVS     R1,#+8
   \   000000D6   0x4361             MULS     R1,R4,R1
   \   000000D8   0x5C40             LDRB     R0,[R0, R1]
   \   000000DA   0x2180             MOVS     R1,#+128
   \   000000DC   0x4301             ORRS     R1,R1,R0
   \   000000DE   0x....             LDR      R0,??DataTable16
   \   000000E0   0x2208             MOVS     R2,#+8
   \   000000E2   0x4354             MULS     R4,R2,R4
   \   000000E4   0x5501             STRB     R1,[R0, R4]
    446            }
    447          
    448            USB0_CTL &= ~USB_CTL_TXSUSPENDTOKENBUSY_MASK;
   \                     ??USBD_ReadEP_6: (+1)
   \   000000E6   0x....             LDR      R0,??DataTable17  ;; 0x40072094
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x21DF             MOVS     R1,#+223
   \   000000EC   0x4001             ANDS     R1,R1,R0
   \   000000EE   0x....             LDR      R0,??DataTable17  ;; 0x40072094
   \   000000F0   0x7001             STRB     R1,[R0, #+0]
    449            return (sz);
   \   000000F2   0x0028             MOVS     R0,R5
   \   000000F4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    450          }
    451          
    452          
    453          /*
    454           *  Write USB Device Endpoint Data
    455           *    Parameters:      EPNum: Device Endpoint Number
    456           *                       EPNum.0..3: Address
    457           *                       EPNum.7:    Dir
    458           *                     pData: Pointer to Data Buffer
    459           *                     cnt:   Number of bytes to write
    460           *    Return Value:    Number of bytes written
    461           */
    462          

   \                                 In section .text, align 2, keep-with-next
    463          uint32_t USBD_WriteEP (uint32_t EPNum, uint8_t *pData, uint32_t cnt) {
   \                     USBD_WriteEP: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0014             MOVS     R4,R2
    464            uint32_t idx, n;
    465          
    466            EPNum &=0x0F;
   \   00000004   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000006   0x0F00             LSRS     R0,R0,#+28
    467          
    468            idx = IDX(EPNum, TX, 0);
   \   00000008   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   0000000A   0x0F00             LSRS     R0,R0,#+28
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x4350             MULS     R0,R2,R0
   \   00000010   0x1C80             ADDS     R0,R0,#+2
    469            BD[idx].bc = cnt;
   \   00000012   0x0022             MOVS     R2,R4
   \   00000014   0x....             LDR      R3,??DataTable16
   \   00000016   0x2508             MOVS     R5,#+8
   \   00000018   0x4345             MULS     R5,R0,R5
   \   0000001A   0x195B             ADDS     R3,R3,R5
   \   0000001C   0x805A             STRH     R2,[R3, #+2]
    470            for (n = 0; n < cnt; n++) {
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0xE006             B        ??USBD_WriteEP_0
    471              EPBuf[idx][n] = pData[n];
   \                     ??USBD_WriteEP_1: (+1)
   \   00000022   0x5C8B             LDRB     R3,[R1, R2]
   \   00000024   0x....             LDR      R5,??DataTable16_2
   \   00000026   0x2640             MOVS     R6,#+64
   \   00000028   0x4346             MULS     R6,R0,R6
   \   0000002A   0x19AD             ADDS     R5,R5,R6
   \   0000002C   0x54AB             STRB     R3,[R5, R2]
    472            }
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   \                     ??USBD_WriteEP_0: (+1)
   \   00000030   0x42A2             CMP      R2,R4
   \   00000032   0xD3F6             BCC      ??USBD_WriteEP_1
    473            if ((Data1 >> (idx / 2)) & 1) {
   \   00000034   0x....             LDR      R1,??DataTable17_1
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x0002             MOVS     R2,R0
   \   0000003A   0x0852             LSRS     R2,R2,#+1
   \   0000003C   0x40D1             LSRS     R1,R1,R2
   \   0000003E   0x07C9             LSLS     R1,R1,#+31
   \   00000040   0xD505             BPL      ??USBD_WriteEP_2
    474              BD[idx].stat = BD_OWN_MASK | BD_DTS_MASK;
   \   00000042   0x2188             MOVS     R1,#+136
   \   00000044   0x....             LDR      R2,??DataTable16
   \   00000046   0x2308             MOVS     R3,#+8
   \   00000048   0x4343             MULS     R3,R0,R3
   \   0000004A   0x54D1             STRB     R1,[R2, R3]
   \   0000004C   0xE004             B        ??USBD_WriteEP_3
    475            }
    476            else {
    477              BD[idx].stat = BD_OWN_MASK | BD_DTS_MASK | BD_DATA01_MASK;
   \                     ??USBD_WriteEP_2: (+1)
   \   0000004E   0x21C8             MOVS     R1,#+200
   \   00000050   0x....             LDR      R2,??DataTable16
   \   00000052   0x2308             MOVS     R3,#+8
   \   00000054   0x4343             MULS     R3,R0,R3
   \   00000056   0x54D1             STRB     R1,[R2, R3]
    478            }
    479            protected_xor(&Data1, (1 << (idx / 2)));
   \                     ??USBD_WriteEP_3: (+1)
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x0840             LSRS     R0,R0,#+1
   \   0000005C   0x4081             LSLS     R1,R1,R0
   \   0000005E   0x....             LDR      R0,??DataTable17_1
   \   00000060   0x.... 0x....      BL       protected_xor
    480            return(cnt);
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    481          }
    482          
    483          /*
    484           *  Get USB Device Last Frame Number
    485           *    Parameters:      None
    486           *    Return Value:    Frame Number
    487           */
    488          

   \                                 In section .text, align 2, keep-with-next
    489          uint32_t USBD_GetFrame (void) {
    490            return((USB0_FRMNUML | (USB0_FRMNUMH << 8) & 0x07FF));
   \                     USBD_GetFrame: (+1)
   \   00000000   0x....             LDR      R0,??DataTable17_2  ;; 0x400720a0
   \   00000002   0x7801             LDRB     R1,[R0, #+0]
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x....             LDR      R0,??DataTable17_3  ;; 0x400720a4
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x0200             LSLS     R0,R0,#+8
   \   0000000E   0x0540             LSLS     R0,R0,#+21       ;; ZeroExtS R0,R0,#+21,#+21
   \   00000010   0x0D40             LSRS     R0,R0,#+21
   \   00000012   0x4308             ORRS     R0,R0,R1
   \   00000014   0x4770             BX       LR               ;; return
    491          }
    492          
    493          #ifdef __RTX
    494          U32 LastError;                          /* Last Error                         */
    495          
    496          /*
    497           *  Get USB Device Last Error Code
    498           *    Parameters:      None
    499           *    Return Value:    Error Code
    500           */
    501          
    502          U32 USBD_GetError (void) {
    503            return (LastError);
    504          }
    505          #endif
    506          
    507          
    508          /*
    509           *  USB Device Interrupt Service Routine
    510           */

   \                                 In section .text, align 2, keep-with-next
    511          void USB0_IRQHandler(void) {
   \                     USB0_IRQHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    512            uint32_t istr, num, dir, ev_odd, stat;
    513            volatile uint32_t i;
    514              
    515            istr  = USB0_ISTAT;
   \   00000002   0x....             LDR      R0,??DataTable17_4  ;; 0x40072080
   \   00000004   0x7804             LDRB     R4,[R0, #+0]
   \   00000006   0xB2E4             UXTB     R4,R4
    516            stat  = USB0_STAT;
   \   00000008   0x....             LDR      R0,??DataTable17_5  ;; 0x40072090
   \   0000000A   0x7806             LDRB     R6,[R0, #+0]
   \   0000000C   0xB2F6             UXTB     R6,R6
    517            USB0_ISTAT = istr;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x....             LDR      R1,??DataTable17_4  ;; 0x40072080
   \   00000012   0x7008             STRB     R0,[R1, #+0]
    518          
    519            // for(i=0;i<10000;i++);
    520            istr &= USB0_INTEN;
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x....             LDR      R0,??DataTable17_6  ;; 0x40072084
   \   00000018   0x7804             LDRB     R4,[R0, #+0]
   \   0000001A   0xB2E4             UXTB     R4,R4
   \   0000001C   0x400C             ANDS     R4,R4,R1
    521          
    522          /* reset interrupt                                                            */
    523            if (istr & USB_ISTAT_USBRST_MASK) {
   \   0000001E   0x07E0             LSLS     R0,R4,#+31
   \   00000020   0xD50A             BPL      ??USB0_IRQHandler_0
    524              USBD_Reset();
   \   00000022   0x.... 0x....      BL       USBD_Reset
    525              usbd_reset_core();
   \   00000026   0x.... 0x....      BL       usbd_reset_core
    526          #ifdef __RTX
    527              if (USBD_RTX_DevTask) {
    528                isr_evt_set(USBD_EVT_RESET, USBD_RTX_DevTask);
    529              }
    530          #else
    531              if (USBD_P_Reset_Event) {
   \   0000002A   0x....             LDR      R0,??DataTable17_7
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD002             BEQ      ??USB0_IRQHandler_0
    532                USBD_P_Reset_Event();
   \   00000032   0x....             LDR      R0,??DataTable17_7
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x4780             BLX      R0
    533              }
    534          #endif
    535            }
    536          
    537          /* suspend interrupt                                                          */
    538            if (istr & USB_ISTAT_SLEEP_MASK) {
   \                     ??USB0_IRQHandler_0: (+1)
   \   00000038   0x06E0             LSLS     R0,R4,#+27
   \   0000003A   0xD508             BPL      ??USB0_IRQHandler_1
    539              USBD_Suspend();
   \   0000003C   0x.... 0x....      BL       USBD_Suspend
    540          #ifdef __RTX
    541              if (USBD_RTX_DevTask) {
    542                isr_evt_set(USBD_EVT_SUSPEND, USBD_RTX_DevTask);
    543              }
    544          #else
    545              if (USBD_P_Suspend_Event) {
   \   00000040   0x....             LDR      R0,??DataTable17_8
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD002             BEQ      ??USB0_IRQHandler_1
    546                USBD_P_Suspend_Event();
   \   00000048   0x....             LDR      R0,??DataTable17_8
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x4780             BLX      R0
    547              }
    548          #endif
    549            }
    550          
    551          /* resume interrupt                                                           */
    552            if (istr & USB_ISTAT_RESUME_MASK) {
   \                     ??USB0_IRQHandler_1: (+1)
   \   0000004E   0x06A0             LSLS     R0,R4,#+26
   \   00000050   0xD508             BPL      ??USB0_IRQHandler_2
    553              USBD_Resume();
   \   00000052   0x.... 0x....      BL       USBD_Resume
    554          #ifdef __RTX
    555              if (USBD_RTX_DevTask) {
    556                isr_evt_set(USBD_EVT_RESUME, USBD_RTX_DevTask);
    557              }
    558          #else
    559              if (USBD_P_Resume_Event) {
   \   00000056   0x....             LDR      R0,??DataTable17_9
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD002             BEQ      ??USB0_IRQHandler_2
    560                USBD_P_Resume_Event();
   \   0000005E   0x....             LDR      R0,??DataTable17_9
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x4780             BLX      R0
    561              }
    562          #endif
    563            }
    564          
    565          
    566          /* Start Of Frame                                                             */
    567            if (istr & USB_ISTAT_SOFTOK_MASK) {
   \                     ??USB0_IRQHandler_2: (+1)
   \   00000064   0x0760             LSLS     R0,R4,#+29
   \   00000066   0xD506             BPL      ??USB0_IRQHandler_3
    568          #ifdef __RTX
    569              if (USBD_RTX_DevTask) {
    570                isr_evt_set(USBD_EVT_SOF, USBD_RTX_DevTask);
    571              }
    572          #else
    573              if (USBD_P_SOF_Event) {
   \   00000068   0x....             LDR      R0,??DataTable17_10
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD002             BEQ      ??USB0_IRQHandler_3
    574                USBD_P_SOF_Event();
   \   00000070   0x....             LDR      R0,??DataTable17_10
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x4780             BLX      R0
    575              }
    576          #endif
    577            }
    578          
    579          
    580          /* Error interrupt                                                            */
    581            if (istr == USB_ISTAT_ERROR_MASK) {
   \                     ??USB0_IRQHandler_3: (+1)
   \   00000076   0x2C02             CMP      R4,#+2
   \   00000078   0xD10C             BNE      ??USB0_IRQHandler_4
    582          #ifdef __RTX
    583              LastError = USB0_ERRSTAT;
    584              if (USBD_RTX_DevTask) {
    585                isr_evt_set(USBD_EVT_ERROR, USBD_RTX_DevTask);
    586              }
    587          #else
    588              if (USBD_P_Error_Event) {
   \   0000007A   0x....             LDR      R0,??DataTable17_11
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD005             BEQ      ??USB0_IRQHandler_5
    589                USBD_P_Error_Event(USB0_ERRSTAT);
   \   00000082   0x....             LDR      R0,??DataTable17_12  ;; 0x40072088
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0xB2C0             UXTB     R0,R0
   \   00000088   0x....             LDR      R1,??DataTable17_11
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0x4788             BLX      R1
    590              }
    591          #endif
    592              USB0_ERRSTAT = 0xFF;
   \                     ??USB0_IRQHandler_5: (+1)
   \   0000008E   0x20FF             MOVS     R0,#+255
   \   00000090   0x....             LDR      R1,??DataTable17_12  ;; 0x40072088
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    593            }
    594          
    595          
    596          /* token interrupt                                                            */
    597            if (istr & USB_ISTAT_TOKDNE_MASK) {
   \                     ??USB0_IRQHandler_4: (+1)
   \   00000094   0x0720             LSLS     R0,R4,#+28
   \   00000096   0xD576             BPL      ??USB0_IRQHandler_6
    598          
    599              num    = (stat >> 4) & 0x0F;
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0x0900             LSRS     R0,R0,#+4
   \   0000009C   0x0704             LSLS     R4,R0,#+28       ;; ZeroExtS R4,R0,#+28,#+28
   \   0000009E   0x0F24             LSRS     R4,R4,#+28
    600              dir    = (stat >> 3) & 0x01;
   \   000000A0   0x0035             MOVS     R5,R6
   \   000000A2   0x072D             LSLS     R5,R5,#+28       ;; ZeroExtS R5,R5,#+28,#+31
   \   000000A4   0x0FED             LSRS     R5,R5,#+31
    601              ev_odd = (stat >> 2) & 0x01;
   \   000000A6   0x0030             MOVS     R0,R6
   \   000000A8   0x0006             MOVS     R6,R0
   \   000000AA   0x0776             LSLS     R6,R6,#+29       ;; ZeroExtS R6,R6,#+29,#+31
   \   000000AC   0x0FF6             LSRS     R6,R6,#+31
    602              
    603          /* setup packet                                                               */
    604              if ((num == 0) && (TOK_PID((IDX(num, dir, ev_odd))) == SETUP_TOKEN)) {
   \   000000AE   0x2C00             CMP      R4,#+0
   \   000000B0   0xD12F             BNE      ??USB0_IRQHandler_7
   \   000000B2   0x....             LDR      R0,??DataTable17_13
   \   000000B4   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   000000B6   0x0F09             LSRS     R1,R1,#+28
   \   000000B8   0x2204             MOVS     R2,#+4
   \   000000BA   0x4351             MULS     R1,R2,R1
   \   000000BC   0x2202             MOVS     R2,#+2
   \   000000BE   0x436A             MULS     R2,R5,R2
   \   000000C0   0x1889             ADDS     R1,R1,R2
   \   000000C2   0x1989             ADDS     R1,R1,R6
   \   000000C4   0x2208             MOVS     R2,#+8
   \   000000C6   0x4351             MULS     R1,R2,R1
   \   000000C8   0x5C40             LDRB     R0,[R0, R1]
   \   000000CA   0x1080             ASRS     R0,R0,#+2
   \   000000CC   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   000000CE   0x0F00             LSRS     R0,R0,#+28
   \   000000D0   0x280D             CMP      R0,#+13
   \   000000D2   0xD11E             BNE      ??USB0_IRQHandler_7
    605          
    606                Data1 &= ~0x02;
   \   000000D4   0x....             LDR      R0,??DataTable17_1
   \   000000D6   0x6800             LDR      R0,[R0, #+0]
   \   000000D8   0x2102             MOVS     R1,#+2
   \   000000DA   0x4388             BICS     R0,R0,R1
   \   000000DC   0x....             LDR      R1,??DataTable17_1
   \   000000DE   0x6008             STR      R0,[R1, #+0]
    607               BD[IDX(0, TX, EVEN)].stat &= ~BD_OWN_MASK;
   \   000000E0   0x....             LDR      R0,??DataTable17_13
   \   000000E2   0x7E00             LDRB     R0,[R0, #+24]
   \   000000E4   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   000000E6   0x0E40             LSRS     R0,R0,#+25
   \   000000E8   0x....             LDR      R1,??DataTable17_13
   \   000000EA   0x7608             STRB     R0,[R1, #+24]
    608               BD[IDX(0, TX, ODD)].stat  &= ~BD_OWN_MASK;
   \   000000EC   0x....             LDR      R0,??DataTable17_13
   \   000000EE   0x7C00             LDRB     R0,[R0, #+16]
   \   000000F0   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   000000F2   0x0E40             LSRS     R0,R0,#+25
   \   000000F4   0x....             LDR      R1,??DataTable17_13
   \   000000F6   0x7408             STRB     R0,[R1, #+16]
    609          #ifdef __RTX
    610                  if (USBD_RTX_EPTask[num]) {
    611                    isr_evt_set(USBD_EVT_SETUP, USBD_RTX_EPTask[num]);
    612                  }
    613          #else
    614                  if (USBD_P_EP[num]) {
   \   000000F8   0x....             LDR      R0,??DataTable17_14
   \   000000FA   0x2104             MOVS     R1,#+4
   \   000000FC   0x4361             MULS     R1,R4,R1
   \   000000FE   0x5840             LDR      R0,[R0, R1]
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD040             BEQ      ??USB0_IRQHandler_6
    615                    USBD_P_EP[num](USBD_EVT_SETUP);
   \   00000104   0x2002             MOVS     R0,#+2
   \   00000106   0x....             LDR      R1,??DataTable17_14
   \   00000108   0x2204             MOVS     R2,#+4
   \   0000010A   0x4354             MULS     R4,R2,R4
   \   0000010C   0x5909             LDR      R1,[R1, R4]
   \   0000010E   0x4788             BLX      R1
   \   00000110   0xE039             B        ??USB0_IRQHandler_6
    616                  }
    617          #endif
    618              }
    619              else {
    620          
    621          /* OUT packet                                                                 */
    622                if (TOK_PID((IDX(num, dir, ev_odd))) == OUT_TOKEN) {
   \                     ??USB0_IRQHandler_7: (+1)
   \   00000112   0x....             LDR      R0,??DataTable17_13
   \   00000114   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   00000116   0x0F09             LSRS     R1,R1,#+28
   \   00000118   0x2204             MOVS     R2,#+4
   \   0000011A   0x4351             MULS     R1,R2,R1
   \   0000011C   0x2202             MOVS     R2,#+2
   \   0000011E   0x436A             MULS     R2,R5,R2
   \   00000120   0x1889             ADDS     R1,R1,R2
   \   00000122   0x1989             ADDS     R1,R1,R6
   \   00000124   0x2208             MOVS     R2,#+8
   \   00000126   0x4351             MULS     R1,R2,R1
   \   00000128   0x5C40             LDRB     R0,[R0, R1]
   \   0000012A   0x1080             ASRS     R0,R0,#+2
   \   0000012C   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   0000012E   0x0F00             LSRS     R0,R0,#+28
   \   00000130   0x2801             CMP      R0,#+1
   \   00000132   0xD10B             BNE      ??USB0_IRQHandler_8
    623          #ifdef __RTX
    624                  if (USBD_RTX_EPTask[num]) {
    625                    isr_evt_set(USBD_EVT_OUT, USBD_RTX_EPTask[num]);
    626                  }
    627          #else
    628                  if (USBD_P_EP[num]) {
   \   00000134   0x....             LDR      R0,??DataTable17_14
   \   00000136   0x2104             MOVS     R1,#+4
   \   00000138   0x4361             MULS     R1,R4,R1
   \   0000013A   0x5840             LDR      R0,[R0, R1]
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD005             BEQ      ??USB0_IRQHandler_8
    629                    USBD_P_EP[num](USBD_EVT_OUT);
   \   00000140   0x2004             MOVS     R0,#+4
   \   00000142   0x....             LDR      R1,??DataTable17_14
   \   00000144   0x2204             MOVS     R2,#+4
   \   00000146   0x4362             MULS     R2,R4,R2
   \   00000148   0x5889             LDR      R1,[R1, R2]
   \   0000014A   0x4788             BLX      R1
    630                  }
    631          #endif
    632                }
    633          
    634          /* IN packet                                                                  */
    635                if (TOK_PID((IDX(num, dir, ev_odd))) == IN_TOKEN) {
   \                     ??USB0_IRQHandler_8: (+1)
   \   0000014C   0x....             LDR      R0,??DataTable17_13
   \   0000014E   0x0721             LSLS     R1,R4,#+28       ;; ZeroExtS R1,R4,#+28,#+28
   \   00000150   0x0F09             LSRS     R1,R1,#+28
   \   00000152   0x2204             MOVS     R2,#+4
   \   00000154   0x4351             MULS     R1,R2,R1
   \   00000156   0x2202             MOVS     R2,#+2
   \   00000158   0x4355             MULS     R5,R2,R5
   \   0000015A   0x1949             ADDS     R1,R1,R5
   \   0000015C   0x1989             ADDS     R1,R1,R6
   \   0000015E   0x2208             MOVS     R2,#+8
   \   00000160   0x4351             MULS     R1,R2,R1
   \   00000162   0x5C40             LDRB     R0,[R0, R1]
   \   00000164   0x1080             ASRS     R0,R0,#+2
   \   00000166   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   00000168   0x0F00             LSRS     R0,R0,#+28
   \   0000016A   0x2809             CMP      R0,#+9
   \   0000016C   0xD10B             BNE      ??USB0_IRQHandler_6
    636          #ifdef __RTX
    637                  if (USBD_RTX_EPTask[num]) {
    638                    isr_evt_set(USBD_EVT_IN,  USBD_RTX_EPTask[num]);
    639                  }
    640          #else
    641                  if (USBD_P_EP[num]) {
   \   0000016E   0x....             LDR      R0,??DataTable17_14
   \   00000170   0x2104             MOVS     R1,#+4
   \   00000172   0x4361             MULS     R1,R4,R1
   \   00000174   0x5840             LDR      R0,[R0, R1]
   \   00000176   0x2800             CMP      R0,#+0
   \   00000178   0xD005             BEQ      ??USB0_IRQHandler_6
    642                    USBD_P_EP[num](USBD_EVT_IN);
   \   0000017A   0x2008             MOVS     R0,#+8
   \   0000017C   0x....             LDR      R1,??DataTable17_14
   \   0000017E   0x2204             MOVS     R2,#+4
   \   00000180   0x4354             MULS     R4,R2,R4
   \   00000182   0x5909             LDR      R1,[R1, R4]
   \   00000184   0x4788             BLX      R1
    643                  }
    644          #endif
    645                }
    646              }
    647            }
    648          }
   \                     ??USB0_IRQHandler_6: (+1)
   \   00000186   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     OutEpSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     BD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x4007209C         DC32     0x4007209c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x400720B0         DC32     0x400720b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x400720B4         DC32     0x400720b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x40072080         DC32     0x40072080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     USBD_P_SOF_Event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     USBD_P_Error_Event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x40072084         DC32     0x40072084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x40072100         DC32     0x40072100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x4007210C         DC32     0x4007210c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x40072094         DC32     0x40072094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40072108         DC32     0x40072108

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x400720C0         DC32     0x400720c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     EPBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     EPBuf+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x55555555         DC32     0x55555555

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     Data1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x40072088         DC32     0x40072088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x4007208C         DC32     0x4007208c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40072098         DC32     0x40072098

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x0000C350         DC32     0xc350

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     USBD_DeviceStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     BD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     OutEpSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     EPBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     Data1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40072094         DC32     0x40072094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     Data1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x400720A0         DC32     0x400720a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x400720A4         DC32     0x400720a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40072080         DC32     0x40072080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x40072090         DC32     0x40072090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x40072084         DC32     0x40072084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     USBD_P_Reset_Event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     USBD_P_Suspend_Event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     USBD_P_Resume_Event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     USBD_P_SOF_Event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     USBD_P_Error_Event

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x40072088         DC32     0x40072088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     BD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     USBD_P_EP

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   USB0_IRQHandler
        16   -- Indirect call
        16   -> USBD_Reset
        16   -> USBD_Resume
        16   -> USBD_Suspend
        16   -> usbd_reset_core
       0   USBD_ClearEPBuf
       8   USBD_ClrStallEP
         8   -> USBD_ResetEP
       8   USBD_ConfigEP
         8   -> USBD_ResetEP
       0   USBD_Configure
       4   USBD_Connect
       0   USBD_DirCtrlEP
       4   USBD_DisableEP
       4   USBD_EnableEP
       0   USBD_GetFrame
       8   USBD_Init
         8   -> USBD_IntrEna
         8   -> USB_ClockInit
       8   USBD_IntrEna
         8   -> enable_irq
      24   USBD_ReadEP
        24   -> protected_and
        24   -> protected_xor
       4   USBD_Reset
       8   USBD_ResetEP
         8   -> protected_and
         8   -> protected_or
       0   USBD_Resume
       4   USBD_SetAddress
       0   USBD_SetStallEP
       0   USBD_Suspend
       4   USBD_WakeUp
       0   USBD_WakeUpCfg
      16   USBD_WriteEP
        16   -> protected_xor
       0   USB_ClockInit
       0   protected_and
       0   protected_or
       0   protected_xor


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      96  BD
       4  Data1
     768  EPBuf
       4  OutEpSize
     392  USB0_IRQHandler
       2  USBD_ClearEPBuf
      36  USBD_ClrStallEP
      34  USBD_ConfigEP
       2  USBD_Configure
      52  USBD_Connect
       2  USBD_DirCtrlEP
      54  USBD_DisableEP
      54  USBD_EnableEP
      22  USBD_GetFrame
     142  USBD_Init
      10  USBD_IntrEna
     246  USBD_ReadEP
     108  USBD_Reset
     260  USBD_ResetEP
      14  USBD_Resume
      16  USBD_SetAddress
      26  USBD_SetStallEP
      14  USBD_Suspend
      50  USBD_WakeUp
       2  USBD_WakeUpCfg
     104  USBD_WriteEP
      32  USB_ClockInit
       8  protected_and
       8  protected_or
       8  protected_xor

 
   868 bytes in section .bss
     4 bytes in section .data
 1 874 bytes in section .text
 
 1 874 bytes of CODE memory
   872 bytes of DATA memory

Errors: none
Warnings: 2
