###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        18/Feb/2016  22:53:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\uif.c
#    Command line =  
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\uif.c" -D IAR -D
#        FREEDOM -D SD_DISK_ENABLE -lCN "D:\My Project\SDCardJicheng\KL25 CMSIS
#        USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -lB "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -o "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\common\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\i2c\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\platforms\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\" -I
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\inc\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack
#        MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB
#        Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\SPI_SDCard\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\"
#        -Ol
#    List file    =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\uif.lst
#    Object file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\uif.o
#
###############################################################################

D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\common\uif.c
      1          /*
      2           * File:    uif.c
      3           * Purpose: Provide an interactive user interface
      4           *              
      5           * Notes:   The commands, set/show parameters, and prompt are configured 
      6           *          at the project level
      7           */
      8          
      9          #include "common.h"
     10          #include "uif.h"
     11          /********************************************************************/
     12          /*
     13           * Global messages -- constant strings
     14           */

   \                                 In section .rodata, align 4
     15          const char HELPMSG[] =
   \                     HELPMSG:
   \   00000000   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     16              "Enter 'help' for help.\n";
     17          

   \                                 In section .rodata, align 4
     18          const char INVARG[] =
   \                     INVARG:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     19              "Error: Invalid argument: %s\n";
     20          

   \                                 In section .rodata, align 4
     21          const char INVALUE[] = 
   \                     INVALUE:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
     22              "Error: Invalid value: %s\n";
     23          
     24          /*
     25           * Strings used by this file only
     26           */

   \                                 In section .rodata, align 4
     27          static const char INVCMD[] =
   \                     INVCMD:
   \   00000000   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     28              "Error: No such command: %s\n";
     29          

   \                                 In section .rodata, align 4
     30          static const char HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     31              "%8s  %-25s %s %s\n";
     32          

   \                                 In section .rodata, align 4
     33          static const char SYNTAX[] = 
   \                     SYNTAX:
   \   00000000   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
     34              "Error: Invalid syntax for: %s\n";
     35          

   \                                 In section .rodata, align 4
     36          static const char INVOPT[] = 
   \                     INVOPT:
   \   00000000   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     37              "Error:  Invalid set/show option: %s\n";
     38          

   \                                 In section .rodata, align 4
     39          static const char OPTFMT[] = 
   \                     OPTFMT:
   \   00000000   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
     40              "%12s: ";
     41          

   \                                 In section .bss, align 4
     42          static char cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
     43          static char cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
     44          
     45          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     46          char *
     47          get_line (char *line)
     48          {
   \                     get_line: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     49              int pos;
     50              int ch;
     51          
     52              pos = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     53              ch = (int)in_char();
   \   00000006   0x.... 0x....      BL       in_char
   \   0000000A   0xE00F             B        ??get_line_0
     54              while ( (ch != 0x0D /* CR */) &&
     55                      (ch != 0x0A /* LF/NL */) &&
     56                      (pos < UIF_MAX_LINE))
     57              {
     58                  switch (ch)
     59                  {
     60                      case 0x08:      /* Backspace */
     61                      case 0x7F:      /* Delete */
     62                          if (pos > 0)
     63                          {
     64                              pos -= 1;
     65                              out_char(0x08);    /* backspace */
     66                              out_char(' ');
     67                              out_char(0x08);    /* backspace */
     68                          }
     69                          break;
     70                      default:
     71                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_1: (+1)
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x2950             CMP      R1,#+80
   \   00000012   0xDA09             BGE      ??get_line_2
     72                          {
     73                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000014   0x0001             MOVS     R1,R0
   \   00000016   0x3920             SUBS     R1,R1,#+32
   \   00000018   0x2960             CMP      R1,#+96
   \   0000001A   0xD205             BCS      ??get_line_2
     74                              {
     75                                  line[pos++] = (char)ch;
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0x5561             STRB     R1,[R4, R5]
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
     76                                  out_char((char)ch);
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x.... 0x....      BL       out_char
     77                              }
     78                          }
     79                          break;
     80                  }
     81                  ch = (int)in_char();
   \                     ??get_line_2: (+1)
   \                     ??get_line_3: (+1)
   \   00000028   0x.... 0x....      BL       in_char
   \                     ??get_line_0: (+1)
   \   0000002C   0x280D             CMP      R0,#+13
   \   0000002E   0xD015             BEQ      ??get_line_4
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xD013             BEQ      ??get_line_4
   \   00000034   0x2D50             CMP      R5,#+80
   \   00000036   0xDA11             BGE      ??get_line_4
   \   00000038   0x0001             MOVS     R1,R0
   \   0000003A   0x2908             CMP      R1,#+8
   \   0000003C   0xD001             BEQ      ??get_line_5
   \   0000003E   0x297F             CMP      R1,#+127
   \   00000040   0xD1E4             BNE      ??get_line_1
   \                     ??get_line_5: (+1)
   \   00000042   0x2D01             CMP      R5,#+1
   \   00000044   0xDB09             BLT      ??get_line_6
   \   00000046   0x1E6D             SUBS     R5,R5,#+1
   \   00000048   0x2008             MOVS     R0,#+8
   \   0000004A   0x.... 0x....      BL       out_char
   \   0000004E   0x2020             MOVS     R0,#+32
   \   00000050   0x.... 0x....      BL       out_char
   \   00000054   0x2008             MOVS     R0,#+8
   \   00000056   0x.... 0x....      BL       out_char
   \                     ??get_line_6: (+1)
   \   0000005A   0xE7E5             B        ??get_line_3
     82              }
     83              line[pos] = '\0';
   \                     ??get_line_4: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x5560             STRB     R0,[R4, R5]
     84              out_char(0x0D);    /* CR */
   \   00000060   0x200D             MOVS     R0,#+13
   \   00000062   0x.... 0x....      BL       out_char
     85              out_char(0x0A);    /* LF */
   \   00000066   0x200A             MOVS     R0,#+10
   \   00000068   0x.... 0x....      BL       out_char
     86          
     87              return line;
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     88          }
     89          
     90          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     91          int
     92          make_argv (char *cmdline, char *argv[])
     93          {
   \                     make_argv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0002             MOVS     R2,R0
     94              int argc, i, in_text;
     95          
     96              /* 
     97               * Break cmdline into strings and argv
     98               * It is permissible for argv to be NULL, in which case
     99               * the purpose of this routine becomes to count args
    100               */
    101              argc = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    102              i = 0;
   \   00000006   0x2300             MOVS     R3,#+0
    103              in_text = FALSE;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0xE005             B        ??make_argv_0
    104              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    105              {
    106                  if (((cmdline[i] == ' ')   ||
    107                       (cmdline[i] == '\t')) )
    108                  {
    109                      if (in_text)
   \                     ??make_argv_1: (+1)
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD002             BEQ      ??make_argv_2
    110                      {
    111                          /* end of command line argument */
    112                          cmdline[i] = '\0';
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0x54D4             STRB     R4,[R2, R3]
    113                          in_text = FALSE;
   \   00000014   0x2400             MOVS     R4,#+0
    114                      }
    115                      else
    116                      {
    117                          /* still looking for next argument */
    118                          
    119                      }
    120                  }
    121                  else
    122                  {
    123                      /* got non-whitespace character */
    124                      if (in_text)
    125                      {
    126                      }
    127                      else
    128                      {
    129                          /* start of an argument */
    130                          in_text = TRUE;
    131                          if (argc < UIF_MAX_ARGS)
    132                          {
    133                              if (argv != NULL)
    134                                  argv[argc] = &cmdline[i];
    135                              argc++;
    136                          }
    137                          else
    138                              /*return argc;*/
    139                              break;
    140                      }
    141          
    142                  }
    143                  i++;    /* proceed to next character */
   \                     ??make_argv_2: (+1)
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
   \                     ??make_argv_0: (+1)
   \   00000018   0x5CD5             LDRB     R5,[R2, R3]
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD012             BEQ      ??make_argv_3
   \   0000001E   0x5CD5             LDRB     R5,[R2, R3]
   \   00000020   0x2D20             CMP      R5,#+32
   \   00000022   0xD0F3             BEQ      ??make_argv_1
   \   00000024   0x5CD5             LDRB     R5,[R2, R3]
   \   00000026   0x2D09             CMP      R5,#+9
   \   00000028   0xD0F0             BEQ      ??make_argv_1
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD1F3             BNE      ??make_argv_2
   \   0000002E   0x2401             MOVS     R4,#+1
   \   00000030   0x280A             CMP      R0,#+10
   \   00000032   0xDA07             BGE      ??make_argv_4
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD003             BEQ      ??make_argv_5
   \   00000038   0x18D5             ADDS     R5,R2,R3
   \   0000003A   0x2604             MOVS     R6,#+4
   \   0000003C   0x4346             MULS     R6,R0,R6
   \   0000003E   0x518D             STR      R5,[R1, R6]
   \                     ??make_argv_5: (+1)
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0xE7E8             B        ??make_argv_2
    144              }
    145              if (argv != NULL)
   \                     ??make_argv_4: (+1)
   \                     ??make_argv_3: (+1)
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD003             BEQ      ??make_argv_6
    146                  argv[argc] = NULL;
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x2304             MOVS     R3,#+4
   \   0000004C   0x4343             MULS     R3,R0,R3
   \   0000004E   0x50CA             STR      R2,[R1, R3]
    147              return argc;
   \                     ??make_argv_6: (+1)
   \   00000050   0xBD70             POP      {R4-R6,PC}       ;; return
    148          }
    149          
    150          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    151          void
    152          run_cmd (void)
    153          {
   \                     run_cmd: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    154              /*
    155               * Global array of pointers to emulate C argc,argv interface
    156               */
    157              int argc;
    158              char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    159          
    160              get_line(cmdline1);
   \   00000004   0x....             LDR      R0,??DataTable2
   \   00000006   0x.... 0x....      BL       get_line
    161          
    162          	  argc = make_argv(cmdline1,argv);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x....             LDR      R0,??DataTable2
   \   0000000E   0x.... 0x....      BL       make_argv
   \   00000012   0x0004             MOVS     R4,R0
    163          	
    164              if (!(argc))
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD108             BNE      ??run_cmd_0
    165              {
    166                  /* no command entered, just a blank line */
    167                  strcpy(cmdline1,cmdline2);
   \   00000018   0x....             LDR      R1,??DataTable2_1
   \   0000001A   0x....             LDR      R0,??DataTable2
   \   0000001C   0x.... 0x....      BL       strcpy
    168                  argc = make_argv(cmdline1,argv);
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x....             LDR      R0,??DataTable2
   \   00000024   0x.... 0x....      BL       make_argv
   \   00000028   0x0004             MOVS     R4,R0
    169              }
    170              cmdline2[0] = '\0';
   \                     ??run_cmd_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR      R1,??DataTable2_1
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    171          
    172              if (argc)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD03F             BEQ      ??run_cmd_1
    173              {
    174                  int i;
    175                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0xE000             B        ??run_cmd_2
   \                     ??run_cmd_3: (+1)
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \                     ??run_cmd_2: (+1)
   \   0000003A   0x....             LDR      R0,??DataTable3
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xDA31             BGE      ??run_cmd_4
    176                  {
    177                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0x....             LDR      R0,??DataTable3_1
   \   00000046   0x221C             MOVS     R2,#+28
   \   00000048   0x436A             MULS     R2,R5,R2
   \   0000004A   0x5880             LDR      R0,[R0, R2]
   \   0000004C   0x.... 0x....      BL       strcasecmp
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD1F1             BNE      ??run_cmd_3
    178                      {
    179                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    180                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   00000054   0x1E60             SUBS     R0,R4,#+1
   \   00000056   0x....             LDR      R1,??DataTable3_1
   \   00000058   0x221C             MOVS     R2,#+28
   \   0000005A   0x436A             MULS     R2,R5,R2
   \   0000005C   0x1889             ADDS     R1,R1,R2
   \   0000005E   0x6849             LDR      R1,[R1, #+4]
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xDB1B             BLT      ??run_cmd_5
   \   00000064   0x....             LDR      R0,??DataTable3_1
   \   00000066   0x211C             MOVS     R1,#+28
   \   00000068   0x4369             MULS     R1,R5,R1
   \   0000006A   0x1840             ADDS     R0,R0,R1
   \   0000006C   0x6880             LDR      R0,[R0, #+8]
   \   0000006E   0x1E61             SUBS     R1,R4,#+1
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xDB13             BLT      ??run_cmd_5
    181                          {
    182                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   00000074   0x....             LDR      R0,??DataTable3_1
   \   00000076   0x211C             MOVS     R1,#+28
   \   00000078   0x4369             MULS     R1,R5,R1
   \   0000007A   0x1840             ADDS     R0,R0,R1
   \   0000007C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000007E   0x07C0             LSLS     R0,R0,#+31
   \   00000080   0xD503             BPL      ??run_cmd_6
    183                              {
    184                                  strcpy(cmdline2,argv[0]);
   \   00000082   0x9900             LDR      R1,[SP, #+0]
   \   00000084   0x....             LDR      R0,??DataTable2_1
   \   00000086   0x.... 0x....      BL       strcpy
    185                              }
    186                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6: (+1)
   \   0000008A   0x4669             MOV      R1,SP
   \   0000008C   0x0020             MOVS     R0,R4
   \   0000008E   0x....             LDR      R2,??DataTable3_1
   \   00000090   0x231C             MOVS     R3,#+28
   \   00000092   0x435D             MULS     R5,R3,R5
   \   00000094   0x1952             ADDS     R2,R2,R5
   \   00000096   0x6912             LDR      R2,[R2, #+16]
   \   00000098   0x4790             BLX      R2
    187                              return;
   \   0000009A   0xE00B             B        ??run_cmd_7
    188                          }
    189                          else
    190                          {
    191                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5: (+1)
   \   0000009C   0x9900             LDR      R1,[SP, #+0]
   \   0000009E   0x....             LDR      R0,??DataTable3_2
   \   000000A0   0x.... 0x....      BL       printf
    192                              return;
   \   000000A4   0xE006             B        ??run_cmd_7
    193                          }
    194                      }
    195                  }
    196                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4: (+1)
   \   000000A6   0x9900             LDR      R1,[SP, #+0]
   \   000000A8   0x....             LDR      R0,??DataTable3_3
   \   000000AA   0x.... 0x....      BL       printf
    197                  printf(HELPMSG);
   \   000000AE   0x....             LDR      R0,??DataTable3_4
   \   000000B0   0x.... 0x....      BL       printf
    198              }
    199          }
   \                     ??run_cmd_1: (+1)
   \                     ??run_cmd_7: (+1)
   \   000000B4   0xB00B             ADD      SP,SP,#+44
   \   000000B6   0xBD30             POP      {R4,R5,PC}       ;; return
    200          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    201          uint32
    202          get_value (char *s, int *success, int base)
    203          {
   \                     get_value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    204              uint32 value;
    205              char *p;
    206          
    207              value = strtoul(s,&p,base);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       strtoul
    208              if ((value == 0) && (p == s))
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD106             BNE      ??get_value_0
   \   00000012   0x9900             LDR      R1,[SP, #+0]
   \   00000014   0x42A9             CMP      R1,R5
   \   00000016   0xD103             BNE      ??get_value_0
    209              {
    210                  *success = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    211                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE001             B        ??get_value_1
    212              }
    213              else
    214              {
    215                  *success = TRUE;
   \                     ??get_value_0: (+1)
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x6021             STR      R1,[R4, #+0]
    216                  return value;
   \                     ??get_value_1: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    217              }
    218          }
    219          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void
    221          uif_cmd_help (int argc, char **argv)
    222          {
   \                     uif_cmd_help: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    223              int index;
    224              
    225              (void)argc;
    226              (void)argv;
    227              
    228              printf("\n");
   \   00000004   0x....             ADR      R0,??DataTable3_5  ;; "\n"
   \   00000006   0x.... 0x....      BL       printf
    229              for (index = 0; index < UIF_NUM_CMD; index++)
   \   0000000A   0x2400             MOVS     R4,#+0
   \   0000000C   0xE016             B        ??uif_cmd_help_0
    230              {
    231                  printf(HELPFORMAT,
    232                      UIF_CMDTAB[index].cmd,
    233                      UIF_CMDTAB[index].description,
    234                      UIF_CMDTAB[index].cmd,
    235                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1: (+1)
   \   0000000E   0x....             LDR      R0,??DataTable3_1
   \   00000010   0x211C             MOVS     R1,#+28
   \   00000012   0x4361             MULS     R1,R4,R1
   \   00000014   0x1840             ADDS     R0,R0,R1
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x....             LDR      R0,??DataTable3_1
   \   0000001C   0x211C             MOVS     R1,#+28
   \   0000001E   0x4361             MULS     R1,R4,R1
   \   00000020   0x5843             LDR      R3,[R0, R1]
   \   00000022   0x....             LDR      R0,??DataTable3_1
   \   00000024   0x211C             MOVS     R1,#+28
   \   00000026   0x4361             MULS     R1,R4,R1
   \   00000028   0x1840             ADDS     R0,R0,R1
   \   0000002A   0x6942             LDR      R2,[R0, #+20]
   \   0000002C   0x....             LDR      R0,??DataTable3_1
   \   0000002E   0x211C             MOVS     R1,#+28
   \   00000030   0x4361             MULS     R1,R4,R1
   \   00000032   0x5841             LDR      R1,[R0, R1]
   \   00000034   0x....             LDR      R0,??DataTable3_6
   \   00000036   0x.... 0x....      BL       printf
    236              }
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_help_0: (+1)
   \   0000003C   0x....             LDR      R0,??DataTable3
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xDBE4             BLT      ??uif_cmd_help_1
    237              printf("\n");
   \   00000044   0x....             ADR      R0,??DataTable3_5  ;; "\n"
   \   00000046   0x.... 0x....      BL       printf
    238          }
   \   0000004A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    239          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    240          void
    241          uif_cmd_set (int argc, char **argv)
    242          {
   \                     uif_cmd_set: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    243              int index;
    244          
    245              printf("\n");
   \   00000006   0x....             ADR      R0,??DataTable3_5  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    246              if (argc == 1)
   \   0000000C   0x2E01             CMP      R6,#+1
   \   0000000E   0xD11C             BNE      ??uif_cmd_set_0
    247              {
    248                  printf("Valid 'set' options:\n");
   \   00000010   0x....             LDR      R0,??DataTable3_7
   \   00000012   0x.... 0x....      BL       printf
    249                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   00000016   0x2500             MOVS     R5,#+0
   \   00000018   0xE00F             B        ??uif_cmd_set_1
    250                  {
    251                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable3_8
   \   0000001C   0x2114             MOVS     R1,#+20
   \   0000001E   0x4369             MULS     R1,R5,R1
   \   00000020   0x5841             LDR      R1,[R0, R1]
   \   00000022   0x....             LDR      R0,??DataTable3_9
   \   00000024   0x.... 0x....      BL       printf
    252                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   00000028   0x....             LDR      R0,??DataTable3_8
   \   0000002A   0x2114             MOVS     R1,#+20
   \   0000002C   0x4369             MULS     R1,R5,R1
   \   0000002E   0x1840             ADDS     R0,R0,R1
   \   00000030   0x6901             LDR      R1,[R0, #+16]
   \   00000032   0x....             ADR      R0,??DataTable3_10  ;; "%s\n"
   \   00000034   0x.... 0x....      BL       printf
    253                  }
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_set_1: (+1)
   \   0000003A   0x....             LDR      R0,??DataTable3_11
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xDBEB             BLT      ??uif_cmd_set_2
    254                  printf("\n");
   \   00000042   0x....             ADR      R0,??DataTable3_5  ;; "\n"
   \   00000044   0x.... 0x....      BL       printf
    255                  return;
   \   00000048   0xE037             B        ??uif_cmd_set_3
    256              }
    257          
    258              if (argc != 3)
   \                     ??uif_cmd_set_0: (+1)
   \   0000004A   0x2E03             CMP      R6,#+3
   \   0000004C   0xD003             BEQ      ??uif_cmd_set_4
    259              {
    260                  printf("Error: Invalid argument list\n");
   \   0000004E   0x....             LDR      R0,??DataTable3_12
   \   00000050   0x.... 0x....      BL       printf
    261                  return;
   \   00000054   0xE031             B        ??uif_cmd_set_3
    262              }
    263          
    264              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4: (+1)
   \   00000056   0x2500             MOVS     R5,#+0
   \   00000058   0xE000             B        ??uif_cmd_set_5
   \                     ??uif_cmd_set_6: (+1)
   \   0000005A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_set_5: (+1)
   \   0000005C   0x....             LDR      R0,??DataTable3_11
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x4285             CMP      R5,R0
   \   00000062   0xDA26             BGE      ??uif_cmd_set_7
    265              {
    266                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000064   0x6861             LDR      R1,[R4, #+4]
   \   00000066   0x....             LDR      R0,??DataTable3_8
   \   00000068   0x2214             MOVS     R2,#+20
   \   0000006A   0x436A             MULS     R2,R5,R2
   \   0000006C   0x5880             LDR      R0,[R0, R2]
   \   0000006E   0x.... 0x....      BL       strcasecmp
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD1F1             BNE      ??uif_cmd_set_6
    267                  {
    268                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    269                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000076   0x1EB0             SUBS     R0,R6,#+2
   \   00000078   0x....             LDR      R1,??DataTable3_8
   \   0000007A   0x2214             MOVS     R2,#+20
   \   0000007C   0x436A             MULS     R2,R5,R2
   \   0000007E   0x1889             ADDS     R1,R1,R2
   \   00000080   0x6849             LDR      R1,[R1, #+4]
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xDB10             BLT      ??uif_cmd_set_8
   \   00000086   0x....             LDR      R0,??DataTable3_8
   \   00000088   0x2114             MOVS     R1,#+20
   \   0000008A   0x4369             MULS     R1,R5,R1
   \   0000008C   0x1840             ADDS     R0,R0,R1
   \   0000008E   0x6880             LDR      R0,[R0, #+8]
   \   00000090   0x1EB1             SUBS     R1,R6,#+2
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xDB08             BLT      ??uif_cmd_set_8
    270                      {
    271                          UIF_SETCMDTAB[index].func(argc,argv);
   \   00000096   0x0021             MOVS     R1,R4
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0x....             LDR      R2,??DataTable3_8
   \   0000009C   0x2314             MOVS     R3,#+20
   \   0000009E   0x435D             MULS     R5,R3,R5
   \   000000A0   0x1952             ADDS     R2,R2,R5
   \   000000A2   0x68D2             LDR      R2,[R2, #+12]
   \   000000A4   0x4790             BLX      R2
    272                          return;
   \   000000A6   0xE008             B        ??uif_cmd_set_3
    273                      }
    274                      else
    275                      {
    276                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8: (+1)
   \   000000A8   0x6861             LDR      R1,[R4, #+4]
   \   000000AA   0x....             LDR      R0,??DataTable3_13
   \   000000AC   0x.... 0x....      BL       printf
    277                          return;
   \   000000B0   0xE003             B        ??uif_cmd_set_3
    278                      }
    279                  }
    280              }
    281              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_7: (+1)
   \   000000B2   0x6861             LDR      R1,[R4, #+4]
   \   000000B4   0x....             LDR      R0,??DataTable3_14
   \   000000B6   0x.... 0x....      BL       printf
    282          }
   \                     ??uif_cmd_set_3: (+1)
   \   000000BA   0xBD70             POP      {R4-R6,PC}       ;; return
    283          
    284          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    285          void
    286          uif_cmd_show (int argc, char **argv)
    287          {
   \                     uif_cmd_show: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    288              int index;
    289          
    290              printf("\n");
   \   00000006   0x....             ADR      R0,??DataTable3_5  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    291              if (argc == 1)
   \   0000000C   0x2E01             CMP      R6,#+1
   \   0000000E   0xD11F             BNE      ??uif_cmd_show_0
    292              {
    293                  /*
    294                   * Show all Option settings
    295                   */
    296                  argc = 2;
   \   00000010   0x2602             MOVS     R6,#+2
    297                  argv[2] = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    298                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   00000016   0x2500             MOVS     R5,#+0
   \   00000018   0xE012             B        ??uif_cmd_show_1
    299                  {
    300                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2: (+1)
   \   0000001A   0x....             LDR      R0,??DataTable3_8
   \   0000001C   0x2114             MOVS     R1,#+20
   \   0000001E   0x4369             MULS     R1,R5,R1
   \   00000020   0x5841             LDR      R1,[R0, R1]
   \   00000022   0x....             LDR      R0,??DataTable3_9
   \   00000024   0x.... 0x....      BL       printf
    301                      UIF_SETCMDTAB[index].func(argc,argv);
   \   00000028   0x0021             MOVS     R1,R4
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0x....             LDR      R2,??DataTable3_8
   \   0000002E   0x2314             MOVS     R3,#+20
   \   00000030   0x436B             MULS     R3,R5,R3
   \   00000032   0x18D2             ADDS     R2,R2,R3
   \   00000034   0x68D2             LDR      R2,[R2, #+12]
   \   00000036   0x4790             BLX      R2
    302                      printf("\n");
   \   00000038   0x....             ADR      R0,??DataTable3_5  ;; "\n"
   \   0000003A   0x.... 0x....      BL       printf
    303                  }
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_show_1: (+1)
   \   00000040   0x....             LDR      R0,??DataTable3_11
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x4285             CMP      R5,R0
   \   00000046   0xDBE8             BLT      ??uif_cmd_show_2
    304                  printf("\n");
   \   00000048   0x....             ADR      R0,??DataTable3_5  ;; "\n"
   \   0000004A   0x.... 0x....      BL       printf
    305                  return;
   \   0000004E   0xE03B             B        ??uif_cmd_show_3
    306              }
    307          
    308              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0: (+1)
   \   00000050   0x2500             MOVS     R5,#+0
   \   00000052   0xE000             B        ??uif_cmd_show_4
   \                     ??uif_cmd_show_5: (+1)
   \   00000054   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_show_4: (+1)
   \   00000056   0x....             LDR      R0,??DataTable3_11
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x4285             CMP      R5,R0
   \   0000005C   0xDA30             BGE      ??uif_cmd_show_6
    309              {
    310                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   0000005E   0x6861             LDR      R1,[R4, #+4]
   \   00000060   0x....             LDR      R0,??DataTable3_8
   \   00000062   0x2214             MOVS     R2,#+20
   \   00000064   0x436A             MULS     R2,R5,R2
   \   00000066   0x5880             LDR      R0,[R0, R2]
   \   00000068   0x.... 0x....      BL       strcasecmp
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD1F1             BNE      ??uif_cmd_show_5
    311                  {
    312                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    313                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000070   0x1EB0             SUBS     R0,R6,#+2
   \   00000072   0x....             LDR      R1,??DataTable3_8
   \   00000074   0x2214             MOVS     R2,#+20
   \   00000076   0x436A             MULS     R2,R5,R2
   \   00000078   0x1889             ADDS     R1,R1,R2
   \   0000007A   0x6849             LDR      R1,[R1, #+4]
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xDB1A             BLT      ??uif_cmd_show_7
   \   00000080   0x....             LDR      R0,??DataTable3_8
   \   00000082   0x2114             MOVS     R1,#+20
   \   00000084   0x4369             MULS     R1,R5,R1
   \   00000086   0x1840             ADDS     R0,R0,R1
   \   00000088   0x6880             LDR      R0,[R0, #+8]
   \   0000008A   0x1EB1             SUBS     R1,R6,#+2
   \   0000008C   0x4288             CMP      R0,R1
   \   0000008E   0xDB12             BLT      ??uif_cmd_show_7
    314                      {
    315                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   00000090   0x....             LDR      R0,??DataTable3_8
   \   00000092   0x2114             MOVS     R1,#+20
   \   00000094   0x4369             MULS     R1,R5,R1
   \   00000096   0x5841             LDR      R1,[R0, R1]
   \   00000098   0x....             LDR      R0,??DataTable3_9
   \   0000009A   0x.... 0x....      BL       printf
    316                          UIF_SETCMDTAB[index].func(argc,argv);
   \   0000009E   0x0021             MOVS     R1,R4
   \   000000A0   0x0030             MOVS     R0,R6
   \   000000A2   0x....             LDR      R2,??DataTable3_8
   \   000000A4   0x2314             MOVS     R3,#+20
   \   000000A6   0x435D             MULS     R5,R3,R5
   \   000000A8   0x1952             ADDS     R2,R2,R5
   \   000000AA   0x68D2             LDR      R2,[R2, #+12]
   \   000000AC   0x4790             BLX      R2
    317                          printf("\n\n");
   \   000000AE   0x....             ADR      R0,??DataTable3_15  ;; 0x0A, 0x0A, 0x00, 0x00
   \   000000B0   0x.... 0x....      BL       printf
    318                          return;
   \   000000B4   0xE008             B        ??uif_cmd_show_3
    319                      }
    320                      else
    321                      {
    322                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7: (+1)
   \   000000B6   0x6861             LDR      R1,[R4, #+4]
   \   000000B8   0x....             LDR      R0,??DataTable3_13
   \   000000BA   0x.... 0x....      BL       printf
    323                          return;
   \   000000BE   0xE003             B        ??uif_cmd_show_3
    324                      }
    325                  }
    326              }
    327              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_6: (+1)
   \   000000C0   0x6861             LDR      R1,[R4, #+4]
   \   000000C2   0x....             LDR      R0,??DataTable3_14
   \   000000C4   0x.... 0x....      BL       printf
    328          }
   \                     ??uif_cmd_show_3: (+1)
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     SYNTAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     INVCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     HELPMSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     HELPFORMAT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x........         DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x........         DC32     OPTFMT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x........         DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0x........         DC32     INVARG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_14:
   \   00000000   0x........         DC32     INVOPT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_15:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    329          
    330          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   get_line
        16   -> in_char
        16   -> out_char
      16   get_value
        16   -> strtoul
      16   make_argv
      56   run_cmd
        56   -- Indirect call
        56   -> get_line
        56   -> make_argv
        56   -> printf
        56   -> strcasecmp
        56   -> strcpy
      16   uif_cmd_help
        16   -> printf
      16   uif_cmd_set
        16   -- Indirect call
        16   -> printf
        16   -> strcasecmp
      16   uif_cmd_show
        16   -- Indirect call
        16   -> printf
        16   -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       2  ?_0
      24  ?_1
       4  ?_2
      32  ?_3
       4  ?_4
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
      80  cmdline1
      80  cmdline2
     112  get_line
      38  get_value
      82  make_argv
     184  run_cmd
      76  uif_cmd_help
     188  uif_cmd_set
     202  uif_cmd_show

 
 160 bytes in section .bss
 278 bytes in section .rodata
 954 bytes in section .text
 
 954 bytes of CODE  memory
 278 bytes of CONST memory
 160 bytes of DATA  memory

Errors: none
Warnings: none
