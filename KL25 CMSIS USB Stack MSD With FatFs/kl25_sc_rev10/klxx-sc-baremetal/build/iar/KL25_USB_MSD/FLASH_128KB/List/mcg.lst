###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        18/Feb/2016  22:52:50
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\mcg\mcg.c
#    Command line =  
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\mcg\mcg.c" -D IAR -D
#        FREEDOM -D SD_DISK_ENABLE -lCN "D:\My Project\SDCardJicheng\KL25 CMSIS
#        USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -lB "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -o "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\common\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\i2c\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\platforms\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\" -I
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\inc\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack
#        MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB
#        Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\SPI_SDCard\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\"
#        -Ol
#    List file    =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\mcg.lst
#    Object file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\mcg.o
#
###############################################################################

D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\mcg\mcg.c
      1          /*
      2           * File:    mcg.c
      3           *
      4           * MCG drivers for Freescale Kinetis L - series devices
      5           * Notes:
      6           * Assumes the MCG mode is in the default FEI mode out of reset
      7           */
      8          
      9          #include "common.h"
     10          #include "mcg.h"
     11          
     12          
     13          // global variables
     14          extern int core_clk_khz;
     15          
     16          

   \                                 In section .bss, align 1
     17          char drs_val, dmx32_val;
   \                     drs_val:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     dmx32_val:
   \   00000000                      DS8 1
     18          
     19          
     20          
     21          
     22          
     23          /*********************************************************************************************/
     24          /* Functon name : pll_init
     25           *
     26           * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
     27           *
     28           * This function initializess PLL0. Either OSC0 is selected for the
     29           * reference clock source. The oscillators can be configured to use a crystal or take in an
     30           * external square wave clock.
     31           * Using the function parameter names the PLL frequency is calculated as follows:
     32           * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
     33           * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
     34           * All parameters must be provided, for example crystal_val must be provided even if the
     35           * oscillator associated with that parameter is already initialized.
     36           * The various passed parameters are checked to ensure they are within the allowed range. If any
     37           * of these checks fail the driver will exit and return a fail/error code. An error code will
     38           * also be returned if any error occurs during the PLL initialization sequence. Refer to the
     39           * readme file in the mcg driver directory for a list of all these codes.
     40           *
     41           * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
     42           *                           wave clock source
     43           *             hgo_val     - selects whether low power or high gain mode is selected
     44           *                           for the crystal oscillator. This has no meaning if an
     45           *                           external clock is used.
     46           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
     47           *             prdiv_val   - value to divide the external clock source by to create the desired
     48           *                           PLL reference clock frequency
     49           *             vdiv_val    - value to multiply the PLL reference clock frequency by
     50           *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
     51           *                              to provide the MCGOUT clock for the system.
     52           *
     53           * Return value : PLL frequency (Hz) or error code
     54           */
     55          

   \                                 In section .text, align 2, keep-with-next
     56          int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val, signed char vdiv_val, unsigned char mcgout_select)
     57          {
   \                     pll_init: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x001D             MOVS     R5,R3
     58            unsigned char frdiv_val;
     59            unsigned char temp_reg;
     60            unsigned char prdiv, vdiv;
     61            short i;
     62            int ref_freq;
     63            int pll_freq;
     64          
     65            // check if in FEI mode
     66            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
     67                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
     68                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000008   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0880             LSRS     R0,R0,#+2
   \   00000010   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000012   0x0F80             LSRS     R0,R0,#+30
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD107             BNE      ??pll_init_0
   \   00000018   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x06C0             LSLS     R0,R0,#+27
   \   0000001E   0xD503             BPL      ??pll_init_0
   \   00000020   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x0680             LSLS     R0,R0,#+26
   \   00000026   0xD501             BPL      ??pll_init_1
     69            {
     70              return 0x1;                                                     // return error code
   \                     ??pll_init_0: (+1)
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE139             B        ??pll_init_2
     71            }
     72          
     73            // check external frequency is less than the maximum frequency
     74            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??pll_init_1: (+1)
   \   0000002C   0x....             LDR      R0,??DataTable0_1  ;; 0x2faf081
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xDB01             BLT      ??pll_init_3
   \   00000032   0x2021             MOVS     R0,#+33
   \   00000034   0xE134             B        ??pll_init_2
     75          
     76            // check crystal frequency is within spec. if crystal osc is being used as PLL ref
     77            if (erefs_val)
   \                     ??pll_init_3: (+1)
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD006             BEQ      ??pll_init_4
     78            {
     79              if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of the available crystal options is not available
   \   0000003E   0x....             LDR      R0,??DataTable0_2  ;; 0x2dc6c0
   \   00000040   0x1A20             SUBS     R0,R4,R0
   \   00000042   0x....             LDR      R1,??DataTable0_3  ;; 0x1ba8141
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD301             BCC      ??pll_init_4
   \   00000048   0x2022             MOVS     R0,#+34
   \   0000004A   0xE129             B        ??pll_init_2
     80            }
     81          
     82            // make sure HGO will never be greater than 1. Could return an error instead if desired.
     83            if (hgo_val > 0)
   \                     ??pll_init_4: (+1)
   \   0000004C   0xB2FF             UXTB     R7,R7
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD000             BEQ      ??pll_init_5
     84            {
     85              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000052   0x2701             MOVS     R7,#+1
     86            }
     87          
     88            // Check PLL divider settings are within spec.
     89            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??pll_init_5: (+1)
   \   00000054   0xB26D             SXTB     R5,R5
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x2819             CMP      R0,#+25
   \   0000005C   0xD301             BCC      ??pll_init_6
   \   0000005E   0x2041             MOVS     R0,#+65
   \   00000060   0xE11E             B        ??pll_init_2
   \                     ??pll_init_6: (+1)
   \   00000062   0x4669             MOV      R1,SP
   \   00000064   0x2018             MOVS     R0,#+24
   \   00000066   0x560E             LDRSB    R6,[R1, R0]
     90            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
   \   00000068   0xB276             SXTB     R6,R6
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0x3818             SUBS     R0,R0,#+24
   \   0000006E   0x281B             CMP      R0,#+27
   \   00000070   0xD301             BCC      ??pll_init_7
   \   00000072   0x2042             MOVS     R0,#+66
   \   00000074   0xE114             B        ??pll_init_2
     91          
     92            // Check PLL reference clock frequency is within spec.
     93            ref_freq = crystal_val / prdiv_val;
   \                     ??pll_init_7: (+1)
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0xB26D             SXTB     R5,R5
   \   0000007A   0x0029             MOVS     R1,R5
   \   0000007C   0x.... 0x....      BL       __aeabi_idiv
     94            if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
   \   00000080   0x....             LDR      R1,??DataTable0_4  ;; 0x1e8480
   \   00000082   0x1A40             SUBS     R0,R0,R1
   \   00000084   0x....             LDR      R1,??DataTable0_5  ;; 0x1e8481
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD301             BCC      ??pll_init_8
   \   0000008A   0x2043             MOVS     R0,#+67
   \   0000008C   0xE108             B        ??pll_init_2
     95          
     96            // Check PLL output frequency is within spec.
     97            pll_freq = (crystal_val / prdiv_val) * vdiv_val;
   \                     ??pll_init_8: (+1)
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0xB26D             SXTB     R5,R5
   \   00000092   0x0029             MOVS     R1,R5
   \   00000094   0x.... 0x....      BL       __aeabi_idiv
   \   00000098   0xB276             SXTB     R6,R6
   \   0000009A   0x4370             MULS     R0,R6,R0
     98            if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
   \   0000009C   0x....             LDR      R1,??DataTable0_6  ;; 0x2dc6c00
   \   0000009E   0x1A40             SUBS     R0,R0,R1
   \   000000A0   0x....             LDR      R1,??DataTable0_7  ;; 0x3197501
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD301             BCC      ??pll_init_9
   \   000000A6   0x2045             MOVS     R0,#+69
   \   000000A8   0xE0FA             B        ??pll_init_2
     99          
    100            // configure the MCG_C2 register
    101            // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
    102            // it still needs to be set correctly even if the oscillator is not being used
    103                
    104            temp_reg = MCG_C2;
   \                     ??pll_init_9: (+1)
   \   000000AA   0x....             LDR      R0,??DataTable0_8  ;; 0x40064001
   \   000000AC   0x7801             LDRB     R1,[R0, #+0]
    105            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   000000AE   0x0008             MOVS     R0,R1
   \   000000B0   0x21C3             MOVS     R1,#+195
   \   000000B2   0x4001             ANDS     R1,R1,R0
    106              
    107            if (crystal_val <= 8000000)
   \   000000B4   0x....             LDR      R0,??DataTable0_9  ;; 0x7a1201
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xDA0A             BGE      ??pll_init_10
    108            {
    109              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   000000BA   0xB2FF             UXTB     R7,R7
   \   000000BC   0x00F8             LSLS     R0,R7,#+3
   \   000000BE   0x2210             MOVS     R2,#+16
   \   000000C0   0x4302             ORRS     R2,R2,R0
   \   000000C2   0x4668             MOV      R0,SP
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x0080             LSLS     R0,R0,#+2
   \   000000C8   0x4310             ORRS     R0,R0,R2
   \   000000CA   0x4308             ORRS     R0,R0,R1
   \   000000CC   0x0001             MOVS     R1,R0
   \   000000CE   0xE009             B        ??pll_init_11
    110            }
    111            else
    112            {
    113              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??pll_init_10: (+1)
   \   000000D0   0xB2FF             UXTB     R7,R7
   \   000000D2   0x00F8             LSLS     R0,R7,#+3
   \   000000D4   0x2220             MOVS     R2,#+32
   \   000000D6   0x4302             ORRS     R2,R2,R0
   \   000000D8   0x4668             MOV      R0,SP
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x0080             LSLS     R0,R0,#+2
   \   000000DE   0x4310             ORRS     R0,R0,R2
   \   000000E0   0x4308             ORRS     R0,R0,R1
   \   000000E2   0x0001             MOVS     R1,R0
    114            }
    115            MCG_C2 = temp_reg;
   \                     ??pll_init_11: (+1)
   \   000000E4   0x....             LDR      R0,??DataTable0_8  ;; 0x40064001
   \   000000E6   0x7001             STRB     R1,[R0, #+0]
    116            
    117            // determine FRDIV based on reference clock frequency
    118            // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
    119            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000E8   0x....             LDR      R0,??DataTable0_10  ;; 0x1312d1
   \   000000EA   0x4284             CMP      R4,R0
   \   000000EC   0xDA01             BGE      ??pll_init_12
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xE014             B        ??pll_init_13
    120            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??pll_init_12: (+1)
   \   000000F2   0x....             LDR      R0,??DataTable0_11  ;; 0x2625a1
   \   000000F4   0x4284             CMP      R4,R0
   \   000000F6   0xDA01             BGE      ??pll_init_14
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0xE00F             B        ??pll_init_13
    121            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??pll_init_14: (+1)
   \   000000FC   0x....             LDR      R0,??DataTable0_12  ;; 0x4c4b41
   \   000000FE   0x4284             CMP      R4,R0
   \   00000100   0xDA01             BGE      ??pll_init_15
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0xE00A             B        ??pll_init_13
    122            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??pll_init_15: (+1)
   \   00000106   0x....             LDR      R0,??DataTable0_13  ;; 0x989681
   \   00000108   0x4284             CMP      R4,R0
   \   0000010A   0xDA01             BGE      ??pll_init_16
   \   0000010C   0x2003             MOVS     R0,#+3
   \   0000010E   0xE005             B        ??pll_init_13
    123            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??pll_init_16: (+1)
   \   00000110   0x....             LDR      R0,??DataTable0_14  ;; 0x1312d01
   \   00000112   0x4284             CMP      R4,R0
   \   00000114   0xDA01             BGE      ??pll_init_17
   \   00000116   0x2004             MOVS     R0,#+4
   \   00000118   0xE000             B        ??pll_init_13
    124            else {frdiv_val = 5;}
   \                     ??pll_init_17: (+1)
   \   0000011A   0x2005             MOVS     R0,#+5
    125          
    126            // Select external oscillator and Reference Divider and clear IREFS to start ext osc
    127            // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
    128            // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
    129            temp_reg = MCG_C1;
   \                     ??pll_init_13: (+1)
   \   0000011C   0x....             LDR      R1,??DataTable0_15  ;; 0x40064000
   \   0000011E   0x7809             LDRB     R1,[R1, #+0]
    130            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   \   00000120   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000122   0x0F89             LSRS     R1,R1,#+30
    131            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   00000124   0x000B             MOVS     R3,R1
   \   00000126   0x00C0             LSLS     R0,R0,#+3
   \   00000128   0x2238             MOVS     R2,#+56
   \   0000012A   0x4002             ANDS     R2,R2,R0
   \   0000012C   0x2180             MOVS     R1,#+128
   \   0000012E   0x4311             ORRS     R1,R1,R2
   \   00000130   0x4319             ORRS     R1,R1,R3
    132            MCG_C1 = temp_reg;
   \   00000132   0x....             LDR      R0,??DataTable0_15  ;; 0x40064000
   \   00000134   0x7001             STRB     R1,[R0, #+0]
    133          
    134            // if the external oscillator is used need to wait for OSCINIT to set
    135            if (erefs_val)
   \   00000136   0x4668             MOV      R0,SP
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD010             BEQ      ??pll_init_18
    136            {
    137              for (i = 0 ; i < 20000 ; i++)
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0xE000             B        ??pll_init_19
   \                     ??pll_init_20: (+1)
   \   00000142   0x1C40             ADDS     R0,R0,#+1
   \                     ??pll_init_19: (+1)
   \   00000144   0xB200             SXTH     R0,R0
   \   00000146   0x....             LDR      R1,??DataTable0_16  ;; 0x4e20
   \   00000148   0x4288             CMP      R0,R1
   \   0000014A   0xDA03             BGE      ??pll_init_21
    138              {
    139                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   0000014C   0x....             LDR      R1,??DataTable0  ;; 0x40064006
   \   0000014E   0x7809             LDRB     R1,[R1, #+0]
   \   00000150   0x0789             LSLS     R1,R1,#+30
   \   00000152   0xD5F6             BPL      ??pll_init_20
    140              }
    141            if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??pll_init_21: (+1)
   \   00000154   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   00000156   0x7800             LDRB     R0,[R0, #+0]
   \   00000158   0x0780             LSLS     R0,R0,#+30
   \   0000015A   0xD401             BMI      ??pll_init_18
   \   0000015C   0x2023             MOVS     R0,#+35
   \   0000015E   0xE09F             B        ??pll_init_2
    142            }
    143          
    144            // wait for Reference clock Status bit to clear
    145            for (i = 0 ; i < 2000 ; i++)
   \                     ??pll_init_18: (+1)
   \   00000160   0x2000             MOVS     R0,#+0
   \   00000162   0xE000             B        ??pll_init_22
   \                     ??pll_init_23: (+1)
   \   00000164   0x1C40             ADDS     R0,R0,#+1
   \                     ??pll_init_22: (+1)
   \   00000166   0xB200             SXTH     R0,R0
   \   00000168   0x21FA             MOVS     R1,#+250
   \   0000016A   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xDA03             BGE      ??pll_init_24
    146            {
    147              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   00000170   0x....             LDR      R1,??DataTable0  ;; 0x40064006
   \   00000172   0x7809             LDRB     R1,[R1, #+0]
   \   00000174   0x06C9             LSLS     R1,R1,#+27
   \   00000176   0xD4F5             BMI      ??pll_init_23
    148            }
    149            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??pll_init_24: (+1)
   \   00000178   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   0000017A   0x7800             LDRB     R0,[R0, #+0]
   \   0000017C   0x06C0             LSLS     R0,R0,#+27
   \   0000017E   0xD501             BPL      ??pll_init_25
   \   00000180   0x2011             MOVS     R0,#+17
   \   00000182   0xE08D             B        ??pll_init_2
    150          
    151            // Wait for clock status bits to show clock source is ext ref clk
    152            for (i = 0 ; i < 2000 ; i++)
   \                     ??pll_init_25: (+1)
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0xE000             B        ??pll_init_26
   \                     ??pll_init_27: (+1)
   \   00000188   0x1C40             ADDS     R0,R0,#+1
   \                     ??pll_init_26: (+1)
   \   0000018A   0xB200             SXTH     R0,R0
   \   0000018C   0x21FA             MOVS     R1,#+250
   \   0000018E   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000190   0x4288             CMP      R0,R1
   \   00000192   0xDA07             BGE      ??pll_init_28
    153            {
    154              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000194   0x....             LDR      R1,??DataTable0  ;; 0x40064006
   \   00000196   0x7809             LDRB     R1,[R1, #+0]
   \   00000198   0xB2C9             UXTB     R1,R1
   \   0000019A   0x0889             LSRS     R1,R1,#+2
   \   0000019C   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000019E   0x0F89             LSRS     R1,R1,#+30
   \   000001A0   0x2902             CMP      R1,#+2
   \   000001A2   0xD1F1             BNE      ??pll_init_27
    155            }
    156            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??pll_init_28: (+1)
   \   000001A4   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   000001A6   0x7800             LDRB     R0,[R0, #+0]
   \   000001A8   0xB2C0             UXTB     R0,R0
   \   000001AA   0x0880             LSRS     R0,R0,#+2
   \   000001AC   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000001AE   0x0F80             LSRS     R0,R0,#+30
   \   000001B0   0x2802             CMP      R0,#+2
   \   000001B2   0xD001             BEQ      ??pll_init_29
   \   000001B4   0x201A             MOVS     R0,#+26
   \   000001B6   0xE073             B        ??pll_init_2
    157          
    158            // Now in FBE
    159            // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
    160            // It is enabled here but can be removed if this is not required.
    161            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??pll_init_29: (+1)
   \   000001B8   0x....             LDR      R0,??DataTable1  ;; 0x40064005
   \   000001BA   0x7800             LDRB     R0,[R0, #+0]
   \   000001BC   0x2120             MOVS     R1,#+32
   \   000001BE   0x4301             ORRS     R1,R1,R0
   \   000001C0   0x....             LDR      R0,??DataTable1  ;; 0x40064005
   \   000001C2   0x7001             STRB     R1,[R0, #+0]
    162            
    163            // Configure PLL
    164            // Configure MCG_C5
    165            // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.
    166            temp_reg = MCG_C5;
   \   000001C4   0x....             LDR      R0,??DataTable1_1  ;; 0x40064004
   \   000001C6   0x7801             LDRB     R1,[R0, #+0]
    167            temp_reg &= ~MCG_C5_PRDIV0_MASK;
   \   000001C8   0x0008             MOVS     R0,R1
   \   000001CA   0x21E0             MOVS     R1,#+224
   \   000001CC   0x4001             ANDS     R1,R1,R0
    168            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
   \   000001CE   0x000A             MOVS     R2,R1
   \   000001D0   0x1E68             SUBS     R0,R5,#+1
   \   000001D2   0x06C1             LSLS     R1,R0,#+27       ;; ZeroExtS R1,R0,#+27,#+27
   \   000001D4   0x0EC9             LSRS     R1,R1,#+27
   \   000001D6   0x4311             ORRS     R1,R1,R2
    169            MCG_C5 = temp_reg;
   \   000001D8   0x....             LDR      R0,??DataTable1_1  ;; 0x40064004
   \   000001DA   0x7001             STRB     R1,[R0, #+0]
    170          
    171            // Configure MCG_C6
    172            // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
    173            // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    174            temp_reg = MCG_C6; // store present C6 value
   \   000001DC   0x....             LDR      R0,??DataTable1  ;; 0x40064005
   \   000001DE   0x7801             LDRB     R1,[R0, #+0]
    175            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
   \   000001E0   0x0008             MOVS     R0,R1
   \   000001E2   0x21E0             MOVS     R1,#+224
   \   000001E4   0x4001             ANDS     R1,R1,R0
    176            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
   \   000001E6   0x000A             MOVS     R2,R1
   \   000001E8   0x3E18             SUBS     R6,R6,#+24
   \   000001EA   0x06F0             LSLS     R0,R6,#+27       ;; ZeroExtS R0,R6,#+27,#+27
   \   000001EC   0x0EC0             LSRS     R0,R0,#+27
   \   000001EE   0x2140             MOVS     R1,#+64
   \   000001F0   0x4301             ORRS     R1,R1,R0
   \   000001F2   0x4311             ORRS     R1,R1,R2
    177            MCG_C6 = temp_reg; // update MCG_C6
   \   000001F4   0x....             LDR      R0,??DataTable1  ;; 0x40064005
   \   000001F6   0x7001             STRB     R1,[R0, #+0]
    178          
    179            // wait for PLLST status bit to set
    180            for (i = 0 ; i < 2000 ; i++)
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0xE000             B        ??pll_init_30
   \                     ??pll_init_31: (+1)
   \   000001FC   0x1C40             ADDS     R0,R0,#+1
   \                     ??pll_init_30: (+1)
   \   000001FE   0xB200             SXTH     R0,R0
   \   00000200   0x21FA             MOVS     R1,#+250
   \   00000202   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000204   0x4288             CMP      R0,R1
   \   00000206   0xDA03             BGE      ??pll_init_32
    181            {
    182              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \   00000208   0x....             LDR      R1,??DataTable0  ;; 0x40064006
   \   0000020A   0x7809             LDRB     R1,[R1, #+0]
   \   0000020C   0x0689             LSLS     R1,R1,#+26
   \   0000020E   0xD5F5             BPL      ??pll_init_31
    183            }
    184            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??pll_init_32: (+1)
   \   00000210   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   00000212   0x7800             LDRB     R0,[R0, #+0]
   \   00000214   0x0680             LSLS     R0,R0,#+26
   \   00000216   0xD401             BMI      ??pll_init_33
   \   00000218   0x2016             MOVS     R0,#+22
   \   0000021A   0xE041             B        ??pll_init_2
    185          
    186            // Wait for LOCK bit to set
    187            for (i = 0 ; i < 4000 ; i++)
   \                     ??pll_init_33: (+1)
   \   0000021C   0x2000             MOVS     R0,#+0
   \   0000021E   0xE000             B        ??pll_init_34
   \                     ??pll_init_35: (+1)
   \   00000220   0x1C40             ADDS     R0,R0,#+1
   \                     ??pll_init_34: (+1)
   \   00000222   0xB200             SXTH     R0,R0
   \   00000224   0x21FA             MOVS     R1,#+250
   \   00000226   0x0109             LSLS     R1,R1,#+4        ;; #+4000
   \   00000228   0x4288             CMP      R0,R1
   \   0000022A   0xDA03             BGE      ??pll_init_36
    188            {
    189              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \   0000022C   0x....             LDR      R1,??DataTable0  ;; 0x40064006
   \   0000022E   0x7809             LDRB     R1,[R1, #+0]
   \   00000230   0x0649             LSLS     R1,R1,#+25
   \   00000232   0xD5F5             BPL      ??pll_init_35
    190            }
    191            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??pll_init_36: (+1)
   \   00000234   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   00000236   0x7800             LDRB     R0,[R0, #+0]
   \   00000238   0x0640             LSLS     R0,R0,#+25
   \   0000023A   0xD401             BMI      ??pll_init_37
   \   0000023C   0x2044             MOVS     R0,#+68
   \   0000023E   0xE02F             B        ??pll_init_2
    192          
    193            // Use actual PLL settings to calculate PLL frequency
    194            prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
   \                     ??pll_init_37: (+1)
   \   00000240   0x....             LDR      R0,??DataTable1_1  ;; 0x40064004
   \   00000242   0x7800             LDRB     R0,[R0, #+0]
   \   00000244   0x06C1             LSLS     R1,R0,#+27       ;; ZeroExtS R1,R0,#+27,#+27
   \   00000246   0x0EC9             LSRS     R1,R1,#+27
   \   00000248   0x1C49             ADDS     R1,R1,#+1
    195            vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
   \   0000024A   0x....             LDR      R0,??DataTable1  ;; 0x40064005
   \   0000024C   0x7800             LDRB     R0,[R0, #+0]
   \   0000024E   0x06C5             LSLS     R5,R0,#+27       ;; ZeroExtS R5,R0,#+27,#+27
   \   00000250   0x0EED             LSRS     R5,R5,#+27
   \   00000252   0x3518             ADDS     R5,R5,#+24
    196          
    197            // now in PBE
    198          
    199            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
   \   00000254   0x....             LDR      R0,??DataTable0_15  ;; 0x40064000
   \   00000256   0x7800             LDRB     R0,[R0, #+0]
   \   00000258   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   0000025A   0x0E80             LSRS     R0,R0,#+26
   \   0000025C   0x....             LDR      R2,??DataTable0_15  ;; 0x40064000
   \   0000025E   0x7010             STRB     R0,[R2, #+0]
    200          
    201            // Wait for clock status bits to update
    202            for (i = 0 ; i < 2000 ; i++)
   \   00000260   0x2000             MOVS     R0,#+0
   \   00000262   0xE000             B        ??pll_init_38
   \                     ??pll_init_39: (+1)
   \   00000264   0x1C40             ADDS     R0,R0,#+1
   \                     ??pll_init_38: (+1)
   \   00000266   0xB200             SXTH     R0,R0
   \   00000268   0x22FA             MOVS     R2,#+250
   \   0000026A   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000026C   0x4290             CMP      R0,R2
   \   0000026E   0xDA07             BGE      ??pll_init_40
    203            {
    204              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
   \   00000270   0x....             LDR      R2,??DataTable0  ;; 0x40064006
   \   00000272   0x7812             LDRB     R2,[R2, #+0]
   \   00000274   0xB2D2             UXTB     R2,R2
   \   00000276   0x0892             LSRS     R2,R2,#+2
   \   00000278   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000027A   0x0F92             LSRS     R2,R2,#+30
   \   0000027C   0x2A03             CMP      R2,#+3
   \   0000027E   0xD1F1             BNE      ??pll_init_39
    205            }
    206            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not
   \                     ??pll_init_40: (+1)
   \   00000280   0x....             LDR      R0,??DataTable0  ;; 0x40064006
   \   00000282   0x7800             LDRB     R0,[R0, #+0]
   \   00000284   0xB2C0             UXTB     R0,R0
   \   00000286   0x0880             LSRS     R0,R0,#+2
   \   00000288   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000028A   0x0F80             LSRS     R0,R0,#+30
   \   0000028C   0x2803             CMP      R0,#+3
   \   0000028E   0xD001             BEQ      ??pll_init_41
   \   00000290   0x201B             MOVS     R0,#+27
   \   00000292   0xE005             B        ??pll_init_2
    207          
    208            // Now in PEE
    209            
    210            return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
   \                     ??pll_init_41: (+1)
   \   00000294   0x0020             MOVS     R0,R4
   \   00000296   0xB2C9             UXTB     R1,R1
   \   00000298   0x.... 0x....      BL       __aeabi_idiv
   \   0000029C   0xB2ED             UXTB     R5,R5
   \   0000029E   0x4368             MULS     R0,R5,R0
   \                     ??pll_init_2: (+1)
   \   000002A0   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    211          } // pll_init
    212          
    213          
    214          /*********************************************************************************************/
    215          /* Functon name : new_pll_freq
    216           *
    217           * Mode transition: Moves from PEE to PBE mode before changing PLL settings and moves back to PEE mode
    218           *
    219           * This function provides a safe means of updating the PLL configurations to ensure the system
    220           * does not lose the clock source or is over-clocked as the PLL frequency changes.
    221           * Using the function parameter names the PLL frequency is calculated as follows:
    222           * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
    223           * The various passed parameters are checked to ensure they are within the allowed range. If any
    224           * of these checks fail the driver will exit and return a fail/error code. An error code will
    225           * also be returned if any error occurs during the PLL initialization sequence. Refer to the
    226           * readme file in the mcg driver directory for a list of all these codes.
    227           * This function first moves the MCG to PBE mode to use the external reference clock to provide the
    228           * system clock. The PLL settings are then updated. Once the PLL has re-locked the MCG is moved back
    229           * to PEE to use the PLL as the system clock.
    230           * Only the PLL PRDIV0 and VDIV0 fields are changed.
    231           * 
    232           * Prerequisistes : The MCG must be in PEE mode before calling this routine. It is the responsibility
    233           * of the calling routine to ensure the SIM_CLKDIV1 system clock dividers and any peripheral clock
    234           * dividers are set correctly before or after calling this function to ensure the appropriate clocks
    235           * are kept within specification. You would typically change the divider values before calling this
    236           * routine.
    237           * 
    238           * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
    239           *                           wave clock source
    240           *             prdiv_val   - value to divide the external clock source by to create the desired
    241           *                           PLL reference clock frequency
    242           *             vdiv_val    - value to multiply the PLL reference clock frequency by
    243           *
    244           * Return value : PLL frequency (Hz) or error code
    245           */

   \                                 In section .text, align 2, keep-with-next
    246          int new_pll_freq(int crystal_val, signed char prdiv_val, signed char vdiv_val)
    247          {
   \                     new_pll_freq: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    248            unsigned char temp_reg;
    249            unsigned char prdiv, vdiv;
    250            short i;
    251            int ref_freq;
    252            int pll_freq;
    253          
    254            
    255            // Check MCG is in PEE mode
    256            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted PLL output
    257                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    258                (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selected PLL 
   \   00000008   0x....             LDR      R0,??DataTable3  ;; 0x40064006
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0880             LSRS     R0,R0,#+2
   \   00000010   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000012   0x0F80             LSRS     R0,R0,#+30
   \   00000014   0x2803             CMP      R0,#+3
   \   00000016   0xD107             BNE      ??new_pll_freq_0
   \   00000018   0x....             LDR      R0,??DataTable3  ;; 0x40064006
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x06C0             LSLS     R0,R0,#+27
   \   0000001E   0xD403             BMI      ??new_pll_freq_0
   \   00000020   0x....             LDR      R0,??DataTable3  ;; 0x40064006
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x0680             LSLS     R0,R0,#+26
   \   00000026   0xD401             BMI      ??new_pll_freq_1
    259            {
    260              return 0x8;                                                       // return error code
   \                     ??new_pll_freq_0: (+1)
   \   00000028   0x2008             MOVS     R0,#+8
   \   0000002A   0xE0B5             B        ??new_pll_freq_2
    261            } 
    262            
    263            // Check PLL divider settings are within spec.
    264            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??new_pll_freq_1: (+1)
   \   0000002C   0xB26D             SXTB     R5,R5
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x2819             CMP      R0,#+25
   \   00000034   0xD301             BCC      ??new_pll_freq_3
   \   00000036   0x2041             MOVS     R0,#+65
   \   00000038   0xE0AE             B        ??new_pll_freq_2
    265            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
   \                     ??new_pll_freq_3: (+1)
   \   0000003A   0xB276             SXTB     R6,R6
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0x3818             SUBS     R0,R0,#+24
   \   00000040   0x281B             CMP      R0,#+27
   \   00000042   0xD301             BCC      ??new_pll_freq_4
   \   00000044   0x2042             MOVS     R0,#+66
   \   00000046   0xE0A7             B        ??new_pll_freq_2
    266          
    267            // Check PLL reference clock frequency is within spec.
    268            ref_freq = crystal_val / prdiv_val;
   \                     ??new_pll_freq_4: (+1)
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xB26D             SXTB     R5,R5
   \   0000004C   0x0029             MOVS     R1,R5
   \   0000004E   0x.... 0x....      BL       __aeabi_idiv
    269            if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
   \   00000052   0x....             LDR      R1,??DataTable3_1  ;; 0x1e8480
   \   00000054   0x1A40             SUBS     R0,R0,R1
   \   00000056   0x....             LDR      R1,??DataTable3_2  ;; 0x1e8481
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD301             BCC      ??new_pll_freq_5
   \   0000005C   0x2043             MOVS     R0,#+67
   \   0000005E   0xE09B             B        ??new_pll_freq_2
    270          
    271            // Check PLL output frequency is within spec.
    272            pll_freq = (crystal_val / prdiv_val) * vdiv_val;
   \                     ??new_pll_freq_5: (+1)
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0xB26D             SXTB     R5,R5
   \   00000064   0x0029             MOVS     R1,R5
   \   00000066   0x.... 0x....      BL       __aeabi_idiv
   \   0000006A   0xB276             SXTB     R6,R6
   \   0000006C   0x4370             MULS     R0,R6,R0
    273            if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
   \   0000006E   0x....             LDR      R1,??DataTable4  ;; 0x2dc6c00
   \   00000070   0x1A40             SUBS     R0,R0,R1
   \   00000072   0x....             LDR      R1,??DataTable4_1  ;; 0x3197501
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD301             BCC      ??new_pll_freq_6
   \   00000078   0x2045             MOVS     R0,#+69
   \   0000007A   0xE08D             B        ??new_pll_freq_2
    274            
    275            // First move to PBE mode so that the PLL frequency can be safely changed.
    276            // As we are running from the PLL by default the PLL and external clock settings are valid
    277            // To move to PBE from PEE SIMply requires the switching of the CLKS mux to select the ext clock 
    278            // As CLKS is already 0 the CLKS value can SIMply be OR'ed into the register 
    279            MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
   \                     ??new_pll_freq_6: (+1)
   \   0000007C   0x....             LDR      R0,??DataTable4_2  ;; 0x40064000
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x2180             MOVS     R1,#+128
   \   00000082   0x4301             ORRS     R1,R1,R0
   \   00000084   0x....             LDR      R0,??DataTable4_2  ;; 0x40064000
   \   00000086   0x7001             STRB     R1,[R0, #+0]
    280            
    281            // Wait for clock status bits to update 
    282            for (i = 0 ; i < 2000 ; i++)
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE000             B        ??new_pll_freq_7
   \                     ??new_pll_freq_8: (+1)
   \   0000008C   0x1C40             ADDS     R0,R0,#+1
   \                     ??new_pll_freq_7: (+1)
   \   0000008E   0xB200             SXTH     R0,R0
   \   00000090   0x21FA             MOVS     R1,#+250
   \   00000092   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xDA07             BGE      ??new_pll_freq_9
    283            {
    284              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000098   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0xB2C9             UXTB     R1,R1
   \   0000009E   0x0889             LSRS     R1,R1,#+2
   \   000000A0   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000A2   0x0F89             LSRS     R1,R1,#+30
   \   000000A4   0x2902             CMP      R1,#+2
   \   000000A6   0xD1F1             BNE      ??new_pll_freq_8
    285            }
    286            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??new_pll_freq_9: (+1)
   \   000000A8   0x....             LDR      R0,??DataTable3  ;; 0x40064006
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0xB2C0             UXTB     R0,R0
   \   000000AE   0x0880             LSRS     R0,R0,#+2
   \   000000B0   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000B2   0x0F80             LSRS     R0,R0,#+30
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xD001             BEQ      ??new_pll_freq_10
   \   000000B8   0x201A             MOVS     R0,#+26
   \   000000BA   0xE06D             B        ??new_pll_freq_2
    287          
    288            // Now in PBE mode 
    289            // System is clocked off the external clock. 
    290            // Now update the PLL settings and wait for the PLL to re-lock
    291            // Configure MCG_C5
    292            temp_reg = MCG_C5;
   \                     ??new_pll_freq_10: (+1)
   \   000000BC   0x....             LDR      R0,??DataTable1_1  ;; 0x40064004
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
    293            temp_reg &= ~MCG_C5_PRDIV0_MASK;
   \   000000C0   0x0001             MOVS     R1,R0
   \   000000C2   0x20E0             MOVS     R0,#+224
   \   000000C4   0x4008             ANDS     R0,R0,R1
    294            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
   \   000000C6   0x0001             MOVS     R1,R0
   \   000000C8   0x1E68             SUBS     R0,R5,#+1
   \   000000CA   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   000000CC   0x0EC0             LSRS     R0,R0,#+27
   \   000000CE   0x4308             ORRS     R0,R0,R1
    295            MCG_C5 = temp_reg;
   \   000000D0   0x....             LDR      R1,??DataTable1_1  ;; 0x40064004
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
    296          
    297            // Configure MCG_C6
    298            // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
    299            // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    300            temp_reg = MCG_C6; // store present C6 value
   \   000000D4   0x....             LDR      R0,??DataTable1  ;; 0x40064005
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
    301            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
   \   000000D8   0x0001             MOVS     R1,R0
   \   000000DA   0x20E0             MOVS     R0,#+224
   \   000000DC   0x4008             ANDS     R0,R0,R1
    302            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
   \   000000DE   0x0002             MOVS     R2,R0
   \   000000E0   0x3E18             SUBS     R6,R6,#+24
   \   000000E2   0x06F1             LSLS     R1,R6,#+27       ;; ZeroExtS R1,R6,#+27,#+27
   \   000000E4   0x0EC9             LSRS     R1,R1,#+27
   \   000000E6   0x2040             MOVS     R0,#+64
   \   000000E8   0x4308             ORRS     R0,R0,R1
   \   000000EA   0x4310             ORRS     R0,R0,R2
    303            MCG_C6 = temp_reg; // update MCG_C6
   \   000000EC   0x....             LDR      R1,??DataTable1  ;; 0x40064005
   \   000000EE   0x7008             STRB     R0,[R1, #+0]
    304          
    305            // wait for PLLST status bit to set
    306            for (i = 0 ; i < 2000 ; i++)
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xE000             B        ??new_pll_freq_11
   \                     ??new_pll_freq_12: (+1)
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
   \                     ??new_pll_freq_11: (+1)
   \   000000F6   0xB200             SXTH     R0,R0
   \   000000F8   0x21FA             MOVS     R1,#+250
   \   000000FA   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   000000FC   0x4288             CMP      R0,R1
   \   000000FE   0xDA03             BGE      ??new_pll_freq_13
    307            {
    308              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \   00000100   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000102   0x7809             LDRB     R1,[R1, #+0]
   \   00000104   0x0689             LSLS     R1,R1,#+26
   \   00000106   0xD5F5             BPL      ??new_pll_freq_12
    309            }
    310            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??new_pll_freq_13: (+1)
   \   00000108   0x....             LDR      R0,??DataTable3  ;; 0x40064006
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x0680             LSLS     R0,R0,#+26
   \   0000010E   0xD401             BMI      ??new_pll_freq_14
   \   00000110   0x2016             MOVS     R0,#+22
   \   00000112   0xE041             B        ??new_pll_freq_2
    311          
    312            // Wait for LOCK bit to set
    313            for (i = 0 ; i < 4000 ; i++)
   \                     ??new_pll_freq_14: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0xE000             B        ??new_pll_freq_15
   \                     ??new_pll_freq_16: (+1)
   \   00000118   0x1C40             ADDS     R0,R0,#+1
   \                     ??new_pll_freq_15: (+1)
   \   0000011A   0xB200             SXTH     R0,R0
   \   0000011C   0x21FA             MOVS     R1,#+250
   \   0000011E   0x0109             LSLS     R1,R1,#+4        ;; #+4000
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xDA03             BGE      ??new_pll_freq_17
    314            {
    315              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \   00000124   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000126   0x7809             LDRB     R1,[R1, #+0]
   \   00000128   0x0649             LSLS     R1,R1,#+25
   \   0000012A   0xD5F5             BPL      ??new_pll_freq_16
    316            }
    317            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??new_pll_freq_17: (+1)
   \   0000012C   0x....             LDR      R0,??DataTable3  ;; 0x40064006
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0x0640             LSLS     R0,R0,#+25
   \   00000132   0xD401             BMI      ??new_pll_freq_18
   \   00000134   0x2044             MOVS     R0,#+68
   \   00000136   0xE02F             B        ??new_pll_freq_2
    318          
    319            // Change CLKS mux to now select the PLL output
    320            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
   \                     ??new_pll_freq_18: (+1)
   \   00000138   0x....             LDR      R0,??DataTable4_2  ;; 0x40064000
   \   0000013A   0x7800             LDRB     R0,[R0, #+0]
   \   0000013C   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   0000013E   0x0E80             LSRS     R0,R0,#+26
   \   00000140   0x....             LDR      R1,??DataTable4_2  ;; 0x40064000
   \   00000142   0x7008             STRB     R0,[R1, #+0]
    321          
    322            // Wait for clock status bits to update
    323            for (i = 0 ; i < 2000 ; i++)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xE000             B        ??new_pll_freq_19
   \                     ??new_pll_freq_20: (+1)
   \   00000148   0x1C40             ADDS     R0,R0,#+1
   \                     ??new_pll_freq_19: (+1)
   \   0000014A   0xB200             SXTH     R0,R0
   \   0000014C   0x21FA             MOVS     R1,#+250
   \   0000014E   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000150   0x4288             CMP      R0,R1
   \   00000152   0xDA07             BGE      ??new_pll_freq_21
    324            {
    325              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
   \   00000154   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000156   0x7809             LDRB     R1,[R1, #+0]
   \   00000158   0xB2C9             UXTB     R1,R1
   \   0000015A   0x0889             LSRS     R1,R1,#+2
   \   0000015C   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000015E   0x0F89             LSRS     R1,R1,#+30
   \   00000160   0x2903             CMP      R1,#+3
   \   00000162   0xD1F1             BNE      ??new_pll_freq_20
    326            }
    327            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not
   \                     ??new_pll_freq_21: (+1)
   \   00000164   0x....             LDR      R0,??DataTable3  ;; 0x40064006
   \   00000166   0x7800             LDRB     R0,[R0, #+0]
   \   00000168   0xB2C0             UXTB     R0,R0
   \   0000016A   0x0880             LSRS     R0,R0,#+2
   \   0000016C   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000016E   0x0F80             LSRS     R0,R0,#+30
   \   00000170   0x2803             CMP      R0,#+3
   \   00000172   0xD001             BEQ      ??new_pll_freq_22
   \   00000174   0x201B             MOVS     R0,#+27
   \   00000176   0xE00F             B        ??new_pll_freq_2
    328          
    329            // Now in PEE
    330            // Use actual PLL settings to calculate PLL frequency
    331            prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
   \                     ??new_pll_freq_22: (+1)
   \   00000178   0x....             LDR      R0,??DataTable1_1  ;; 0x40064004
   \   0000017A   0x7800             LDRB     R0,[R0, #+0]
   \   0000017C   0x06C1             LSLS     R1,R0,#+27       ;; ZeroExtS R1,R0,#+27,#+27
   \   0000017E   0x0EC9             LSRS     R1,R1,#+27
   \   00000180   0x1C49             ADDS     R1,R1,#+1
    332            vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
   \   00000182   0x....             LDR      R0,??DataTable1  ;; 0x40064005
   \   00000184   0x7800             LDRB     R0,[R0, #+0]
   \   00000186   0x06C5             LSLS     R5,R0,#+27       ;; ZeroExtS R5,R0,#+27,#+27
   \   00000188   0x0EED             LSRS     R5,R5,#+27
   \   0000018A   0x3518             ADDS     R5,R5,#+24
    333            
    334            return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
   \   0000018C   0x0020             MOVS     R0,R4
   \   0000018E   0xB2C9             UXTB     R1,R1
   \   00000190   0x.... 0x....      BL       __aeabi_idiv
   \   00000194   0xB2ED             UXTB     R5,R5
   \   00000196   0x4368             MULS     R0,R5,R0
   \                     ??new_pll_freq_2: (+1)
   \   00000198   0xBD70             POP      {R4-R6,PC}       ;; return
    335          } // new_pll_freq
    336          
    337          
    338          /********************************************************************/
    339          

   \                                 In section .text, align 2, keep-with-next
    340          int pee_pbe(int crystal_val)
    341          {
   \                     pee_pbe: (+1)
   \   00000000   0xB500             PUSH     {LR}
    342            short i;
    343            
    344          // Check MCG is in PEE mode
    345            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted PLL output
    346                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    347                (MCG_S & MCG_S_PLLST_MASK)))                                    // check PLLS mux has selected PLL 
   \   00000002   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2903             CMP      R1,#+3
   \   00000010   0xD107             BNE      ??pee_pbe_0
   \   00000012   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??pee_pbe_0
   \   0000001A   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD401             BMI      ??pee_pbe_1
    348            {
    349              return 0x8;                                                       // return error code
   \                     ??pee_pbe_0: (+1)
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0xE01F             B        ??pee_pbe_2
    350            } 
    351            
    352          // As we are running from the PLL by default the PLL and external clock settings are valid
    353          // To move to PBE from PEE SIMply requires the switching of the CLKS mux to select the ext clock 
    354          // As CLKS is already 0 the CLKS value can SIMply be OR'ed into the register 
    355            MCG_C1 |= MCG_C1_CLKS(2); // switch CLKS mux to select external reference clock as MCG_OUT
   \                     ??pee_pbe_1: (+1)
   \   00000026   0x....             LDR      R1,??DataTable4_2  ;; 0x40064000
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x2280             MOVS     R2,#+128
   \   0000002C   0x430A             ORRS     R2,R2,R1
   \   0000002E   0x....             LDR      R1,??DataTable4_2  ;; 0x40064000
   \   00000030   0x700A             STRB     R2,[R1, #+0]
    356            
    357          // Wait for clock status bits to update 
    358            for (i = 0 ; i < 2000 ; i++)
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xE000             B        ??pee_pbe_3
   \                     ??pee_pbe_4: (+1)
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \                     ??pee_pbe_3: (+1)
   \   00000038   0xB209             SXTH     R1,R1
   \   0000003A   0x22FA             MOVS     R2,#+250
   \   0000003C   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xDA07             BGE      ??pee_pbe_5
    359            {
    360              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000042   0x....             LDR      R2,??DataTable3  ;; 0x40064006
   \   00000044   0x7812             LDRB     R2,[R2, #+0]
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0x0892             LSRS     R2,R2,#+2
   \   0000004A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000004C   0x0F92             LSRS     R2,R2,#+30
   \   0000004E   0x2A02             CMP      R2,#+2
   \   00000050   0xD1F1             BNE      ??pee_pbe_4
    361            }
    362            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??pee_pbe_5: (+1)
   \   00000052   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0xB2C9             UXTB     R1,R1
   \   00000058   0x0889             LSRS     R1,R1,#+2
   \   0000005A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000005C   0x0F89             LSRS     R1,R1,#+30
   \   0000005E   0x2902             CMP      R1,#+2
   \   00000060   0xD001             BEQ      ??pee_pbe_6
   \   00000062   0x201A             MOVS     R0,#+26
   \   00000064   0xE7FF             B        ??pee_pbe_2
    363          
    364          // Now in PBE mode  
    365            return crystal_val; // MCGOUT frequency equals external clock frequency
   \                     ??pee_pbe_6: (+1)
   \                     ??pee_pbe_2: (+1)
   \   00000066   0xBD00             POP      {PC}             ;; return
    366          } // pee_pbe
    367          
    368          

   \                                 In section .text, align 2, keep-with-next
    369          int pbe_pee(int crystal_val)
    370          {
   \                     pbe_pee: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    371            unsigned char prdiv, vdiv;
    372            short i;
    373          
    374            // Check MCG is in PBE mode
    375            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    376                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    377                (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selected PLL
    378                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set
   \   00000002   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD10B             BNE      ??pbe_pee_0
   \   00000012   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD407             BMI      ??pbe_pee_0
   \   0000001A   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD503             BPL      ??pbe_pee_0
   \   00000022   0x....             LDR      R1,??DataTable6  ;; 0x40064001
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD501             BPL      ??pbe_pee_1
    379            {
    380              return 0x7;                                                       // return error code
   \                     ??pbe_pee_0: (+1)
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE040             B        ??pbe_pee_2
    381            }
    382          
    383            // As the PLL settings have already been checked when PBE mode was enterred they are not checked here
    384          
    385            // Check the PLL state before transitioning to PEE mode
    386            
    387            // Check LOCK bit is set before transitioning MCG to PLL output (already checked in fbe_pbe but good practice
    388            // to re-check before switch to use PLL)
    389            for (i = 0 ; i < 2000 ; i++)
   \                     ??pbe_pee_1: (+1)
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0xE000             B        ??pbe_pee_3
   \                     ??pbe_pee_4: (+1)
   \   00000032   0x1C52             ADDS     R2,R2,#+1
   \                     ??pbe_pee_3: (+1)
   \   00000034   0xB212             SXTH     R2,R2
   \   00000036   0x21FA             MOVS     R1,#+250
   \   00000038   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   0000003A   0x428A             CMP      R2,R1
   \   0000003C   0xDA03             BGE      ??pbe_pee_5
    390            {
    391              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \   0000003E   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000040   0x7809             LDRB     R1,[R1, #+0]
   \   00000042   0x0649             LSLS     R1,R1,#+25
   \   00000044   0xD5F5             BPL      ??pbe_pee_4
    392            }
    393            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??pbe_pee_5: (+1)
   \   00000046   0x....             LDR      R1,??DataTable3  ;; 0x40064006
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0x0649             LSLS     R1,R1,#+25
   \   0000004C   0xD401             BMI      ??pbe_pee_6
   \   0000004E   0x2044             MOVS     R0,#+68
   \   00000050   0xE02E             B        ??pbe_pee_2
    394            // Use actual PLL settings to calculate PLL frequency
    395            prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
   \                     ??pbe_pee_6: (+1)
   \   00000052   0x....             LDR      R1,??DataTable6_1  ;; 0x40064004
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x06C9             LSLS     R1,R1,#+27       ;; ZeroExtS R1,R1,#+27,#+27
   \   00000058   0x0EC9             LSRS     R1,R1,#+27
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
    396            vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
   \   0000005C   0x....             LDR      R2,??DataTable6_2  ;; 0x40064005
   \   0000005E   0x7812             LDRB     R2,[R2, #+0]
   \   00000060   0x06D4             LSLS     R4,R2,#+27       ;; ZeroExtS R4,R2,#+27,#+27
   \   00000062   0x0EE4             LSRS     R4,R4,#+27
   \   00000064   0x3418             ADDS     R4,R4,#+24
    397            
    398            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
   \   00000066   0x....             LDR      R2,??DataTable4_2  ;; 0x40064000
   \   00000068   0x7812             LDRB     R2,[R2, #+0]
   \   0000006A   0x0692             LSLS     R2,R2,#+26       ;; ZeroExtS R2,R2,#+26,#+26
   \   0000006C   0x0E92             LSRS     R2,R2,#+26
   \   0000006E   0x....             LDR      R3,??DataTable4_2  ;; 0x40064000
   \   00000070   0x701A             STRB     R2,[R3, #+0]
    399          
    400            // Wait for clock status bits to update
    401            for (i = 0 ; i < 2000 ; i++)
   \   00000072   0x2200             MOVS     R2,#+0
   \   00000074   0xE000             B        ??pbe_pee_7
   \                     ??pbe_pee_8: (+1)
   \   00000076   0x1C52             ADDS     R2,R2,#+1
   \                     ??pbe_pee_7: (+1)
   \   00000078   0xB212             SXTH     R2,R2
   \   0000007A   0x23FA             MOVS     R3,#+250
   \   0000007C   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   0000007E   0x429A             CMP      R2,R3
   \   00000080   0xDA07             BGE      ??pbe_pee_9
    402            {
    403              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
   \   00000082   0x....             LDR      R3,??DataTable3  ;; 0x40064006
   \   00000084   0x781B             LDRB     R3,[R3, #+0]
   \   00000086   0xB2DB             UXTB     R3,R3
   \   00000088   0x089B             LSRS     R3,R3,#+2
   \   0000008A   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   0000008C   0x0F9B             LSRS     R3,R3,#+30
   \   0000008E   0x2B03             CMP      R3,#+3
   \   00000090   0xD1F1             BNE      ??pbe_pee_8
    404            }
    405            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not
   \                     ??pbe_pee_9: (+1)
   \   00000092   0x....             LDR      R2,??DataTable3  ;; 0x40064006
   \   00000094   0x7812             LDRB     R2,[R2, #+0]
   \   00000096   0xB2D2             UXTB     R2,R2
   \   00000098   0x0892             LSRS     R2,R2,#+2
   \   0000009A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000009C   0x0F92             LSRS     R2,R2,#+30
   \   0000009E   0x2A03             CMP      R2,#+3
   \   000000A0   0xD001             BEQ      ??pbe_pee_10
   \   000000A2   0x201B             MOVS     R0,#+27
   \   000000A4   0xE004             B        ??pbe_pee_2
    406          
    407            // Now in PEE
    408            return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
   \                     ??pbe_pee_10: (+1)
   \   000000A6   0xB2C9             UXTB     R1,R1
   \   000000A8   0x.... 0x....      BL       __aeabi_idiv
   \   000000AC   0xB2E4             UXTB     R4,R4
   \   000000AE   0x4360             MULS     R0,R4,R0
   \                     ??pbe_pee_2: (+1)
   \   000000B0   0xBD10             POP      {R4,PC}          ;; return
    409            
    410          }  // pbe_pee
    411          
    412          

   \                                 In section .text, align 2, keep-with-next
    413          int pbe_fbe(int crystal_val)
    414          {
   \                     pbe_fbe: (+1)
   \   00000000   0xB500             PUSH     {LR}
    415            short i;
    416            
    417          // Check MCG is in PBE mode
    418            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    419                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    420                (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selected PLL
    421                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable7  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD10B             BNE      ??pbe_fbe_0
   \   00000012   0x....             LDR      R1,??DataTable7  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD407             BMI      ??pbe_fbe_0
   \   0000001A   0x....             LDR      R1,??DataTable7  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD503             BPL      ??pbe_fbe_0
   \   00000022   0x....             LDR      R1,??DataTable6  ;; 0x40064001
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD501             BPL      ??pbe_fbe_1
    422            {
    423              return 0x7;                                                       // return error code
   \                     ??pbe_fbe_0: (+1)
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE017             B        ??pbe_fbe_2
    424            }
    425          
    426          // As we are running from the ext clock, by default the external clock settings are valid
    427          // To move to FBE from PBE SIMply requires the switching of the PLLS mux to disable the PLL 
    428            
    429            MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to disable PLL, still clocked from ext ref clk
   \                     ??pbe_fbe_1: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable6_2  ;; 0x40064005
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x22BF             MOVS     R2,#+191
   \   00000034   0x400A             ANDS     R2,R2,R1
   \   00000036   0x....             LDR      R1,??DataTable6_2  ;; 0x40064005
   \   00000038   0x700A             STRB     R2,[R1, #+0]
    430            
    431          // wait for PLLST status bit to set
    432            for (i = 0 ; i < 2000 ; i++)
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xE000             B        ??pbe_fbe_3
   \                     ??pbe_fbe_4: (+1)
   \   0000003E   0x1C49             ADDS     R1,R1,#+1
   \                     ??pbe_fbe_3: (+1)
   \   00000040   0xB209             SXTH     R1,R1
   \   00000042   0x22FA             MOVS     R2,#+250
   \   00000044   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000046   0x4291             CMP      R1,R2
   \   00000048   0xDA03             BGE      ??pbe_fbe_5
    433            {
    434              if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
   \   0000004A   0x....             LDR      R2,??DataTable7  ;; 0x40064006
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x0692             LSLS     R2,R2,#+26
   \   00000050   0xD4F5             BMI      ??pbe_fbe_4
    435            }
    436            if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if not clear  
   \                     ??pbe_fbe_5: (+1)
   \   00000052   0x....             LDR      R1,??DataTable7  ;; 0x40064006
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x0689             LSLS     R1,R1,#+26
   \   00000058   0xD501             BPL      ??pbe_fbe_6
   \   0000005A   0x2015             MOVS     R0,#+21
   \   0000005C   0xE7FF             B        ??pbe_fbe_2
    437          
    438          // Now in FBE mode  
    439            return crystal_val; // MCGOUT frequency equals external clock frequency 
   \                     ??pbe_fbe_6: (+1)
   \                     ??pbe_fbe_2: (+1)
   \   0000005E   0xBD00             POP      {PC}             ;; return
    440          } // pbe_fbe
    441          
    442          
    443          /********************************************************************/
    444          /* Functon name : fbe_pbe
    445           *
    446           * Mode transition: FBE to PBE mode
    447           *
    448           * This function transitions the MCG from FBE mode to PBE mode. 
    449           * This function presently only supports OSC0 and PLL0. Support for OSC1 and PLL1 will be added soon 
    450           * The function requires the desired OSC and PLL be passed in to it for compatibility with the
    451           * future support of OSC/PLL selection
    452           *
    453           * Parameters: crystal_val - external clock frequency in Hz
    454           *             prdiv_val   - value to divide the external clock source by to create the desired
    455           *                           PLL reference clock frequency
    456           *             vdiv_val    - value to multiply the PLL reference clock frequency by
    457           *
    458           * Return value : MCGCLKOUT frequency (Hz) or error code
    459           */

   \                                 In section .text, align 2, keep-with-next
    460          int fbe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
    461          {
   \                     fbe_pbe: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    462            unsigned char temp_reg;
    463            short i;
    464            int pll_freq;
    465            
    466          // Check MCG is in FBE mode
    467            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    468                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    469                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    470                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000008   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0880             LSRS     R0,R0,#+2
   \   00000010   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000012   0x0F80             LSRS     R0,R0,#+30
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD10B             BNE      ??fbe_pbe_0
   \   00000018   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x06C0             LSLS     R0,R0,#+27
   \   0000001E   0xD407             BMI      ??fbe_pbe_0
   \   00000020   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x0680             LSLS     R0,R0,#+26
   \   00000026   0xD403             BMI      ??fbe_pbe_0
   \   00000028   0x....             LDR      R0,??DataTable6  ;; 0x40064001
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x0780             LSLS     R0,R0,#+30
   \   0000002E   0xD501             BPL      ??fbe_pbe_1
    471            {
    472              return 0x4;                                                       // return error code
   \                     ??fbe_pbe_0: (+1)
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0xE066             B        ??fbe_pbe_2
    473            }
    474            
    475          // As the external frequency has already been checked when FBE mode was enterred it is not checked here
    476          
    477          // Check PLL divider settings are within spec.
    478            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??fbe_pbe_1: (+1)
   \   00000034   0xB26D             SXTB     R5,R5
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0x2819             CMP      R0,#+25
   \   0000003C   0xD301             BCC      ??fbe_pbe_3
   \   0000003E   0x2041             MOVS     R0,#+65
   \   00000040   0xE05F             B        ??fbe_pbe_2
    479            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
   \                     ??fbe_pbe_3: (+1)
   \   00000042   0xB276             SXTB     R6,R6
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0x3818             SUBS     R0,R0,#+24
   \   00000048   0x281B             CMP      R0,#+27
   \   0000004A   0xD301             BCC      ??fbe_pbe_4
   \   0000004C   0x2042             MOVS     R0,#+66
   \   0000004E   0xE058             B        ??fbe_pbe_2
    480            
    481          // Check PLL reference clock frequency is within spec.
    482            if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;}
   \                     ??fbe_pbe_4: (+1)
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xB26D             SXTB     R5,R5
   \   00000054   0x0029             MOVS     R1,R5
   \   00000056   0x.... 0x....      BL       __aeabi_idiv
   \   0000005A   0x....             LDR      R1,??DataTable9_1  ;; 0x1e8480
   \   0000005C   0x1A40             SUBS     R0,R0,R1
   \   0000005E   0x....             LDR      R1,??DataTable9_2  ;; 0x1e8481
   \   00000060   0x4288             CMP      R0,R1
   \   00000062   0xD301             BCC      ??fbe_pbe_5
   \   00000064   0x2043             MOVS     R0,#+67
   \   00000066   0xE04C             B        ??fbe_pbe_2
    483                 
    484          // Check PLL output frequency is within spec.
    485            pll_freq = (crystal_val / prdiv_val) * vdiv_val;
   \                     ??fbe_pbe_5: (+1)
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0xB26D             SXTB     R5,R5
   \   0000006C   0x0029             MOVS     R1,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_idiv
   \   00000072   0xB276             SXTB     R6,R6
   \   00000074   0x4370             MULS     R0,R6,R0
    486            if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
   \   00000076   0x....             LDR      R1,??DataTable9_3  ;; 0x2dc6c00
   \   00000078   0x1A40             SUBS     R0,R0,R1
   \   0000007A   0x....             LDR      R1,??DataTable9_4  ;; 0x3197501
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD301             BCC      ??fbe_pbe_6
   \   00000080   0x2045             MOVS     R0,#+69
   \   00000082   0xE03E             B        ??fbe_pbe_2
    487          
    488            // Configure MCG_C5
    489            // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.       
    490            temp_reg = MCG_C5;
   \                     ??fbe_pbe_6: (+1)
   \   00000084   0x....             LDR      R0,??DataTable6_1  ;; 0x40064004
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
    491            temp_reg &= ~MCG_C5_PRDIV0_MASK;
   \   00000088   0x0001             MOVS     R1,R0
   \   0000008A   0x20E0             MOVS     R0,#+224
   \   0000008C   0x4008             ANDS     R0,R0,R1
    492            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
   \   0000008E   0x0001             MOVS     R1,R0
   \   00000090   0x1E68             SUBS     R0,R5,#+1
   \   00000092   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000094   0x0EC0             LSRS     R0,R0,#+27
   \   00000096   0x4308             ORRS     R0,R0,R1
    493            MCG_C5 = temp_reg;
   \   00000098   0x....             LDR      R1,??DataTable6_1  ;; 0x40064004
   \   0000009A   0x7008             STRB     R0,[R1, #+0]
    494          
    495            // Configure MCG_C6
    496            // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
    497            // The clock monitor is not enabled here as it has likely been enabled previously and so the value of CME
    498            // is not altered here.
    499            // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    500            temp_reg = MCG_C6; // store present C6 value
   \   0000009C   0x....             LDR      R0,??DataTable6_2  ;; 0x40064005
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
    501            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
   \   000000A0   0x0001             MOVS     R1,R0
   \   000000A2   0x20E0             MOVS     R0,#+224
   \   000000A4   0x4008             ANDS     R0,R0,R1
    502            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
   \   000000A6   0x0002             MOVS     R2,R0
   \   000000A8   0x3E18             SUBS     R6,R6,#+24
   \   000000AA   0x06F1             LSLS     R1,R6,#+27       ;; ZeroExtS R1,R6,#+27,#+27
   \   000000AC   0x0EC9             LSRS     R1,R1,#+27
   \   000000AE   0x2040             MOVS     R0,#+64
   \   000000B0   0x4308             ORRS     R0,R0,R1
   \   000000B2   0x4310             ORRS     R0,R0,R2
    503            MCG_C6 = temp_reg; // update MCG_C6
   \   000000B4   0x....             LDR      R1,??DataTable6_2  ;; 0x40064005
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
    504            
    505            // wait for PLLST status bit to set
    506            for (i = 0 ; i < 2000 ; i++)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xE000             B        ??fbe_pbe_7
   \                     ??fbe_pbe_8: (+1)
   \   000000BC   0x1C40             ADDS     R0,R0,#+1
   \                     ??fbe_pbe_7: (+1)
   \   000000BE   0xB200             SXTH     R0,R0
   \   000000C0   0x21FA             MOVS     R1,#+250
   \   000000C2   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xDA03             BGE      ??fbe_pbe_9
    507            {
    508              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \   000000C8   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   000000CA   0x7809             LDRB     R1,[R1, #+0]
   \   000000CC   0x0689             LSLS     R1,R1,#+26
   \   000000CE   0xD5F5             BPL      ??fbe_pbe_8
    509            }
    510            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??fbe_pbe_9: (+1)
   \   000000D0   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x0680             LSLS     R0,R0,#+26
   \   000000D6   0xD401             BMI      ??fbe_pbe_10
   \   000000D8   0x2016             MOVS     R0,#+22
   \   000000DA   0xE012             B        ??fbe_pbe_2
    511          
    512            // Wait for LOCK bit to set
    513            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_pbe_10: (+1)
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xE000             B        ??fbe_pbe_11
   \                     ??fbe_pbe_12: (+1)
   \   000000E0   0x1C40             ADDS     R0,R0,#+1
   \                     ??fbe_pbe_11: (+1)
   \   000000E2   0xB200             SXTH     R0,R0
   \   000000E4   0x21FA             MOVS     R1,#+250
   \   000000E6   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   000000E8   0x4288             CMP      R0,R1
   \   000000EA   0xDA03             BGE      ??fbe_pbe_13
    514            {
    515              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \   000000EC   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   000000EE   0x7809             LDRB     R1,[R1, #+0]
   \   000000F0   0x0649             LSLS     R1,R1,#+25
   \   000000F2   0xD5F5             BPL      ??fbe_pbe_12
    516            }
    517            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??fbe_pbe_13: (+1)
   \   000000F4   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0x0640             LSLS     R0,R0,#+25
   \   000000FA   0xD401             BMI      ??fbe_pbe_14
   \   000000FC   0x2044             MOVS     R0,#+68
   \   000000FE   0xE000             B        ??fbe_pbe_2
    518              
    519          // now in PBE 
    520            return crystal_val; // MCGOUT frequency equals external clock frequency
   \                     ??fbe_pbe_14: (+1)
   \   00000100   0x0020             MOVS     R0,R4
   \                     ??fbe_pbe_2: (+1)
   \   00000102   0xBD70             POP      {R4-R6,PC}       ;; return
    521          } // fbe_pbe
    522          
    523          

   \                                 In section .text, align 2, keep-with-next
    524          int pbe_blpe(int crystal_val)
    525          {
   \                     pbe_blpe: (+1)
   \   00000000   0xB500             PUSH     {LR}
    526          // Check MCG is in PBE mode
    527            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    528                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    529                (MCG_S & MCG_S_PLLST_MASK) &&                                   // check PLLS mux has selected PLL
    530                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable7  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD10B             BNE      ??pbe_blpe_0
   \   00000012   0x....             LDR      R1,??DataTable7  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD407             BMI      ??pbe_blpe_0
   \   0000001A   0x....             LDR      R1,??DataTable7  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD503             BPL      ??pbe_blpe_0
   \   00000022   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD501             BPL      ??pbe_blpe_1
    531            {
    532              return 0x7;                                                       // return error code
   \                     ??pbe_blpe_0: (+1)
   \   0000002A   0x2007             MOVS     R0,#+7
   \   0000002C   0xE005             B        ??pbe_blpe_2
    533            }
    534            
    535          // To enter BLPE mode the LP bit must be set, disabling the PLL  
    536            MCG_C2 |= MCG_C2_LP_MASK;
   \                     ??pbe_blpe_1: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x430A             ORRS     R2,R2,R1
   \   00000036   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000038   0x700A             STRB     R2,[R1, #+0]
    537            
    538          // Now in BLPE mode
    539            return crystal_val;  
   \                     ??pbe_blpe_2: (+1)
   \   0000003A   0xBD00             POP      {PC}             ;; return
    540          } // pbe_blpe
    541          
    542          
    543          // ************************************************************************************************
    544          // Since PBE mode can be enterred via FBE -> BLPE modes, it cannot be assumed that the PLL has been 
    545          // previously configured correctly. That is why this general purpose driver has the PLL settings as
    546          // passed parameters.
    547          // ************************************************************************************************

   \                                 In section .text, align 2, keep-with-next
    548          int blpe_pbe(int crystal_val, signed char prdiv_val, signed char vdiv_val)
    549          {
   \                     blpe_pbe: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    550            unsigned char temp_reg;
    551            short i;
    552            
    553          // Check MCG is in BLPE mode
    554            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    555                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    556                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is set   
   \   00000008   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0880             LSRS     R0,R0,#+2
   \   00000010   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000012   0x0F80             LSRS     R0,R0,#+30
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD107             BNE      ??blpe_pbe_0
   \   00000018   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x06C0             LSLS     R0,R0,#+27
   \   0000001E   0xD403             BMI      ??blpe_pbe_0
   \   00000020   0x....             LDR      R0,??DataTable10  ;; 0x40064001
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x0780             LSLS     R0,R0,#+30
   \   00000026   0xD401             BMI      ??blpe_pbe_1
    557            {
    558              return 0x6;                                                       // return error code
   \                     ??blpe_pbe_0: (+1)
   \   00000028   0x2006             MOVS     R0,#+6
   \   0000002A   0xE05E             B        ??blpe_pbe_2
    559            }
    560            
    561          // As the external frequency has already been checked when FBE mode was enterred it is not checked here
    562          
    563          // Check PLL divider settings are within spec.
    564            if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
   \                     ??blpe_pbe_1: (+1)
   \   0000002C   0xB26D             SXTB     R5,R5
   \   0000002E   0x0028             MOVS     R0,R5
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x2819             CMP      R0,#+25
   \   00000034   0xD301             BCC      ??blpe_pbe_3
   \   00000036   0x2041             MOVS     R0,#+65
   \   00000038   0xE057             B        ??blpe_pbe_2
    565            if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;} 
   \                     ??blpe_pbe_3: (+1)
   \   0000003A   0xB276             SXTB     R6,R6
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0x3818             SUBS     R0,R0,#+24
   \   00000040   0x281B             CMP      R0,#+27
   \   00000042   0xD301             BCC      ??blpe_pbe_4
   \   00000044   0x2042             MOVS     R0,#+66
   \   00000046   0xE050             B        ??blpe_pbe_2
    566            
    567          // Check PLL reference clock frequency is within spec.
    568            if (((crystal_val / prdiv_val) < 2000000) || ((crystal_val / prdiv_val) > 4000000)) {return 0x43;}
   \                     ??blpe_pbe_4: (+1)
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xB26D             SXTB     R5,R5
   \   0000004C   0x0029             MOVS     R1,R5
   \   0000004E   0x.... 0x....      BL       __aeabi_idiv
   \   00000052   0x....             LDR      R1,??DataTable9_1  ;; 0x1e8480
   \   00000054   0x1A40             SUBS     R0,R0,R1
   \   00000056   0x....             LDR      R1,??DataTable9_2  ;; 0x1e8481
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD301             BCC      ??blpe_pbe_5
   \   0000005C   0x2043             MOVS     R0,#+67
   \   0000005E   0xE044             B        ??blpe_pbe_2
    569                 
    570          // If PRDIV, VDIV and the PLL ref clock are in spec. then the PLL frequency is within spec.
    571          
    572          // Configure MCG_C5
    573          // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.       
    574            temp_reg = MCG_C5;
   \                     ??blpe_pbe_5: (+1)
   \   00000060   0x....             LDR      R0,??DataTable10_1  ;; 0x40064004
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
    575            temp_reg &= ~MCG_C5_PRDIV0_MASK;
   \   00000064   0x0001             MOVS     R1,R0
   \   00000066   0x20E0             MOVS     R0,#+224
   \   00000068   0x4008             ANDS     R0,R0,R1
    576            temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
   \   0000006A   0x0001             MOVS     R1,R0
   \   0000006C   0x1E68             SUBS     R0,R5,#+1
   \   0000006E   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000070   0x0EC0             LSRS     R0,R0,#+27
   \   00000072   0x4308             ORRS     R0,R0,R1
    577            MCG_C5 = temp_reg;
   \   00000074   0x....             LDR      R1,??DataTable10_1  ;; 0x40064004
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    578          
    579          // Configure MCG_C6
    580          // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk 
    581          // The clock monitor is not enabled here as it has likely been enabled previously and so the value of CME
    582          // is not altered here.
    583          // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
    584            temp_reg = MCG_C6; // store present C6 value
   \   00000078   0x....             LDR      R0,??DataTable10_2  ;; 0x40064005
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
    585            temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
   \   0000007C   0x0001             MOVS     R1,R0
   \   0000007E   0x20E0             MOVS     R0,#+224
   \   00000080   0x4008             ANDS     R0,R0,R1
    586            temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
   \   00000082   0x0002             MOVS     R2,R0
   \   00000084   0x3E18             SUBS     R6,R6,#+24
   \   00000086   0x06F1             LSLS     R1,R6,#+27       ;; ZeroExtS R1,R6,#+27,#+27
   \   00000088   0x0EC9             LSRS     R1,R1,#+27
   \   0000008A   0x2040             MOVS     R0,#+64
   \   0000008C   0x4308             ORRS     R0,R0,R1
   \   0000008E   0x4310             ORRS     R0,R0,R2
    587            MCG_C6 = temp_reg; // update MCG_C6
   \   00000090   0x....             LDR      R1,??DataTable10_2  ;; 0x40064005
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    588            
    589          // Now that PLL is configured, LP is cleared to enable the PLL
    590            MCG_C2 &= ~MCG_C2_LP_MASK;
   \   00000094   0x....             LDR      R0,??DataTable10  ;; 0x40064001
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x21FD             MOVS     R1,#+253
   \   0000009A   0x4001             ANDS     R1,R1,R0
   \   0000009C   0x....             LDR      R0,??DataTable10  ;; 0x40064001
   \   0000009E   0x7001             STRB     R1,[R0, #+0]
    591            
    592          // wait for PLLST status bit to set
    593            for (i = 0 ; i < 2000 ; i++)
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE000             B        ??blpe_pbe_6
   \                     ??blpe_pbe_7: (+1)
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \                     ??blpe_pbe_6: (+1)
   \   000000A6   0xB200             SXTH     R0,R0
   \   000000A8   0x21FA             MOVS     R1,#+250
   \   000000AA   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xDA03             BGE      ??blpe_pbe_8
    594            {
    595              if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
   \   000000B0   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   000000B2   0x7809             LDRB     R1,[R1, #+0]
   \   000000B4   0x0689             LSLS     R1,R1,#+26
   \   000000B6   0xD5F5             BPL      ??blpe_pbe_7
    596            }
    597            if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
   \                     ??blpe_pbe_8: (+1)
   \   000000B8   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x0680             LSLS     R0,R0,#+26
   \   000000BE   0xD401             BMI      ??blpe_pbe_9
   \   000000C0   0x2016             MOVS     R0,#+22
   \   000000C2   0xE012             B        ??blpe_pbe_2
    598          
    599          // Wait for LOCK bit to set
    600            for (i = 0 ; i < 2000 ; i++)
   \                     ??blpe_pbe_9: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xE000             B        ??blpe_pbe_10
   \                     ??blpe_pbe_11: (+1)
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \                     ??blpe_pbe_10: (+1)
   \   000000CA   0xB200             SXTH     R0,R0
   \   000000CC   0x21FA             MOVS     R1,#+250
   \   000000CE   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xDA03             BGE      ??blpe_pbe_12
    601            {
    602              if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
   \   000000D4   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x0649             LSLS     R1,R1,#+25
   \   000000DA   0xD5F5             BPL      ??blpe_pbe_11
    603            }
    604            if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
   \                     ??blpe_pbe_12: (+1)
   \   000000DC   0x....             LDR      R0,??DataTable9  ;; 0x40064006
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x0640             LSLS     R0,R0,#+25
   \   000000E2   0xD401             BMI      ??blpe_pbe_13
   \   000000E4   0x2044             MOVS     R0,#+68
   \   000000E6   0xE000             B        ??blpe_pbe_2
    605          
    606          // now in PBE 
    607            return crystal_val; // MCGOUT frequency equals external clock frequency  
   \                     ??blpe_pbe_13: (+1)
   \   000000E8   0x0020             MOVS     R0,R4
   \                     ??blpe_pbe_2: (+1)
   \   000000EA   0xBD70             POP      {R4-R6,PC}       ;; return
    608          } // blpe_pbe
    609          
    610          

   \                                 In section .text, align 2, keep-with-next
    611          int blpe_fbe(int crystal_val)
    612          {
   \                     blpe_fbe: (+1)
   \   00000000   0xB500             PUSH     {LR}
    613            short i;
    614            
    615          // Check MCG is in BLPE mode
    616            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    617                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    618                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is set   
   \   00000002   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD107             BNE      ??blpe_fbe_0
   \   00000012   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??blpe_fbe_0
   \   0000001A   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD401             BMI      ??blpe_fbe_1
    619            {
    620              return 0x6;                                                       // return error code
   \                     ??blpe_fbe_0: (+1)
   \   00000022   0x2006             MOVS     R0,#+6
   \   00000024   0xE01D             B        ??blpe_fbe_2
    621            }
    622           
    623          // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be cleared
    624            MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
   \                     ??blpe_fbe_1: (+1)
   \   00000026   0x....             LDR      R1,??DataTable10_2  ;; 0x40064005
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x22BF             MOVS     R2,#+191
   \   0000002C   0x400A             ANDS     R2,R2,R1
   \   0000002E   0x....             LDR      R1,??DataTable10_2  ;; 0x40064005
   \   00000030   0x700A             STRB     R2,[R1, #+0]
    625            MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
   \   00000032   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0x22FD             MOVS     R2,#+253
   \   00000038   0x400A             ANDS     R2,R2,R1
   \   0000003A   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   0000003C   0x700A             STRB     R2,[R1, #+0]
    626          
    627          // wait for PLLST status bit to clear
    628            for (i = 0 ; i < 2000 ; i++)
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0xE000             B        ??blpe_fbe_3
   \                     ??blpe_fbe_4: (+1)
   \   00000042   0x1C49             ADDS     R1,R1,#+1
   \                     ??blpe_fbe_3: (+1)
   \   00000044   0xB209             SXTH     R1,R1
   \   00000046   0x22FA             MOVS     R2,#+250
   \   00000048   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000004A   0x4291             CMP      R1,R2
   \   0000004C   0xDA03             BGE      ??blpe_fbe_5
    629            {
    630              if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
   \   0000004E   0x....             LDR      R2,??DataTable9  ;; 0x40064006
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0x0692             LSLS     R2,R2,#+26
   \   00000054   0xD4F5             BMI      ??blpe_fbe_4
    631            }
    632            if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if not clear  
   \                     ??blpe_fbe_5: (+1)
   \   00000056   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   00000058   0x7809             LDRB     R1,[R1, #+0]
   \   0000005A   0x0689             LSLS     R1,R1,#+26
   \   0000005C   0xD501             BPL      ??blpe_fbe_6
   \   0000005E   0x2015             MOVS     R0,#+21
   \   00000060   0xE7FF             B        ??blpe_fbe_2
    633            
    634          // now in FBE mode
    635            return crystal_val; // MCGOUT frequency equals external clock frequency     
   \                     ??blpe_fbe_6: (+1)
   \                     ??blpe_fbe_2: (+1)
   \   00000062   0xBD00             POP      {PC}             ;; return
    636          } // blpe_fbe
    637          
    638          

   \                                 In section .text, align 2, keep-with-next
    639          int fbe_blpe(int crystal_val)
    640          {
   \                     fbe_blpe: (+1)
   \   00000000   0xB500             PUSH     {LR}
    641          // Check MCG is in FBE mode
    642            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    643                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    644                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    645                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD10B             BNE      ??fbe_blpe_0
   \   00000012   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD407             BMI      ??fbe_blpe_0
   \   0000001A   0x....             LDR      R1,??DataTable9  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD403             BMI      ??fbe_blpe_0
   \   00000022   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD501             BPL      ??fbe_blpe_1
    646            {
    647              return 0x4;                                                       // return error code
   \                     ??fbe_blpe_0: (+1)
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0xE005             B        ??fbe_blpe_2
    648            }
    649           
    650          // To move from FBE to BLPE the LP bit must be set
    651            MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
   \                     ??fbe_blpe_1: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0x2202             MOVS     R2,#+2
   \   00000034   0x430A             ORRS     R2,R2,R1
   \   00000036   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000038   0x700A             STRB     R2,[R1, #+0]
    652           
    653          // now in FBE mode
    654            return crystal_val; // MCGOUT frequency equals external clock frequency     
   \                     ??fbe_blpe_2: (+1)
   \   0000003A   0xBD00             POP      {PC}             ;; return
    655          } // fbe_blpe
    656          
    657          

   \                                 In section .text, align 2, keep-with-next
    658          int fbe_fei(int slow_irc_freq)
    659          {
   \                     fbe_fei: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    660            unsigned char temp_reg;
    661            short i;
    662            int mcg_out;
    663            
    664          // Check MCG is in FBE mode
    665            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    666                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    667                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    668                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD10B             BNE      ??fbe_fei_0
   \   00000012   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD407             BMI      ??fbe_fei_0
   \   0000001A   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD403             BMI      ??fbe_fei_0
   \   00000022   0x....             LDR      R1,??DataTable10  ;; 0x40064001
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD501             BPL      ??fbe_fei_1
    669            {
    670              return 0x4;                                                       // return error code
   \                     ??fbe_fei_0: (+1)
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0xE045             B        ??fbe_fei_2
    671            }
    672          
    673          // Check IRC frequency is within spec.
    674            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fbe_fei_1: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable11_1  ;; 0x7a12
   \   00000030   0x1A41             SUBS     R1,R0,R1
   \   00000032   0x....             LDR      R2,??DataTable11_2  ;; 0x1e86
   \   00000034   0x4291             CMP      R1,R2
   \   00000036   0xD301             BCC      ??fbe_fei_3
    675            {
    676              return 0x31;
   \   00000038   0x2031             MOVS     R0,#+49
   \   0000003A   0xE03E             B        ??fbe_fei_2
    677            }
    678            
    679          // Check resulting FLL frequency 
    680            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fbe_fei_3: (+1)
   \   0000003C   0x.... 0x....      BL       fll_freq
    681            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000040   0x283C             CMP      R0,#+60
   \   00000042   0xDB3A             BLT      ??fbe_fei_2
    682          
    683          // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
    684            MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
   \                     ??fbe_fei_4: (+1)
   \   00000044   0x....             LDR      R1,??DataTable10_2  ;; 0x40064005
   \   00000046   0x7809             LDRB     R1,[R1, #+0]
   \   00000048   0x22DF             MOVS     R2,#+223
   \   0000004A   0x400A             ANDS     R2,R2,R1
   \   0000004C   0x....             LDR      R1,??DataTable10_2  ;; 0x40064005
   \   0000004E   0x700A             STRB     R2,[R1, #+0]
    685            
    686          // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
    687            temp_reg = MCG_C1;
   \   00000050   0x....             LDR      R1,??DataTable11_3  ;; 0x40064000
   \   00000052   0x7809             LDRB     R1,[R1, #+0]
    688            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
   \   00000054   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000056   0x0E89             LSRS     R1,R1,#+26
    689            temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
   \   00000058   0x000A             MOVS     R2,R1
   \   0000005A   0x2104             MOVS     R1,#+4
   \   0000005C   0x4311             ORRS     R1,R1,R2
    690            MCG_C1 = temp_reg; // update MCG_C1 
   \   0000005E   0x....             LDR      R2,??DataTable11_3  ;; 0x40064000
   \   00000060   0x7011             STRB     R1,[R2, #+0]
    691            
    692          // wait for Reference clock Status bit to set
    693            for (i = 0 ; i < 2000 ; i++)
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0xE000             B        ??fbe_fei_5
   \                     ??fbe_fei_6: (+1)
   \   00000066   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbe_fei_5: (+1)
   \   00000068   0xB209             SXTH     R1,R1
   \   0000006A   0x22FA             MOVS     R2,#+250
   \   0000006C   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000006E   0x4291             CMP      R1,R2
   \   00000070   0xDA03             BGE      ??fbe_fei_7
    694            {
    695              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   00000072   0x....             LDR      R2,??DataTable11  ;; 0x40064006
   \   00000074   0x7812             LDRB     R2,[R2, #+0]
   \   00000076   0x06D2             LSLS     R2,R2,#+27
   \   00000078   0xD5F5             BPL      ??fbe_fei_6
    696            }
    697            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbe_fei_7: (+1)
   \   0000007A   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   0000007C   0x7809             LDRB     R1,[R1, #+0]
   \   0000007E   0x06C9             LSLS     R1,R1,#+27
   \   00000080   0xD401             BMI      ??fbe_fei_8
   \   00000082   0x2012             MOVS     R0,#+18
   \   00000084   0xE019             B        ??fbe_fei_2
    698            
    699          // Wait for clock status bits to show clock source is ext ref clk
    700            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fei_8: (+1)
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0xE000             B        ??fbe_fei_9
   \                     ??fbe_fei_10: (+1)
   \   0000008A   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbe_fei_9: (+1)
   \   0000008C   0xB209             SXTH     R1,R1
   \   0000008E   0x22FA             MOVS     R2,#+250
   \   00000090   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000092   0x4291             CMP      R1,R2
   \   00000094   0xDA07             BGE      ??fbe_fei_11
    701            {
    702              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000096   0x....             LDR      R2,??DataTable11  ;; 0x40064006
   \   00000098   0x7812             LDRB     R2,[R2, #+0]
   \   0000009A   0xB2D2             UXTB     R2,R2
   \   0000009C   0x0892             LSRS     R2,R2,#+2
   \   0000009E   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000A0   0x0F92             LSRS     R2,R2,#+30
   \   000000A2   0x2A00             CMP      R2,#+0
   \   000000A4   0xD1F1             BNE      ??fbe_fei_10
    703            }
    704            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is really selected and return with error if not
   \                     ??fbe_fei_11: (+1)
   \   000000A6   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   000000A8   0x7809             LDRB     R1,[R1, #+0]
   \   000000AA   0xB2C9             UXTB     R1,R1
   \   000000AC   0x0889             LSRS     R1,R1,#+2
   \   000000AE   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000B0   0x0F89             LSRS     R1,R1,#+30
   \   000000B2   0x2900             CMP      R1,#+0
   \   000000B4   0xD001             BEQ      ??fbe_fei_12
   \   000000B6   0x2018             MOVS     R0,#+24
   \   000000B8   0xE7FF             B        ??fbe_fei_2
    705          
    706          // Now in FEI mode
    707            return mcg_out;
   \                     ??fbe_fei_12: (+1)
   \                     ??fbe_fei_2: (+1)
   \   000000BA   0xBD02             POP      {R1,PC}          ;; return
    708          } // fbe_fei
    709          
    710          
    711          /********************************************************************/
    712          /* Functon name : fei_fbe
    713           *
    714           * Mode transition: FEI to FBE mode
    715           *
    716           * This function transitions the MCG from FEI mode to FBE mode. This is
    717           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
    718           * check so 0 is always returned if the function was called with the MCG
    719           * in FBI mode. The MCGCLKOUT frequency does not change
    720           *
    721           * Parameters: crystal_val - external clock frequency in Hz
    722           *             hgo_val     - selects whether low power or high gain mode is selected
    723           *                           for the crystal oscillator. This has no meaning if an 
    724           *                           external clock is used.
    725           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
    726           *
    727           * Return value : MCGCLKOUT frequency (Hz) or error code
    728           */

   \                                 In section .text, align 2, keep-with-next
    729          int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
    730          {
   \                     fei_fbe: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    731            unsigned char frdiv_val;
    732            unsigned char temp_reg;
    733            short i;
    734            
    735          // check if in FEI mode
    736            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    737                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    738                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R3,??DataTable11  ;; 0x40064006
   \   00000004   0x781B             LDRB     R3,[R3, #+0]
   \   00000006   0xB2DB             UXTB     R3,R3
   \   00000008   0x089B             LSRS     R3,R3,#+2
   \   0000000A   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   0000000C   0x0F9B             LSRS     R3,R3,#+30
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD107             BNE      ??fei_fbe_0
   \   00000012   0x....             LDR      R3,??DataTable11  ;; 0x40064006
   \   00000014   0x781B             LDRB     R3,[R3, #+0]
   \   00000016   0x06DB             LSLS     R3,R3,#+27
   \   00000018   0xD503             BPL      ??fei_fbe_0
   \   0000001A   0x....             LDR      R3,??DataTable11  ;; 0x40064006
   \   0000001C   0x781B             LDRB     R3,[R3, #+0]
   \   0000001E   0x069B             LSLS     R3,R3,#+26
   \   00000020   0xD501             BPL      ??fei_fbe_1
    739            {
    740              return 0x1;                                                     // return error code
   \                     ??fei_fbe_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE0AD             B        ??fei_fbe_2
    741            }
    742          
    743          // check external frequency is less than the maximum frequency
    744            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fei_fbe_1: (+1)
   \   00000026   0x....             LDR      R3,??DataTable12  ;; 0x2faf081
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xDB01             BLT      ??fei_fbe_3
   \   0000002C   0x2021             MOVS     R0,#+33
   \   0000002E   0xE0A8             B        ??fei_fbe_2
    745            
    746          // check crystal frequency is within spec. if crystal osc is being used
    747            if (erefs_val)
   \                     ??fei_fbe_3: (+1)
   \   00000030   0xB2D2             UXTB     R2,R2
   \   00000032   0x2A00             CMP      R2,#+0
   \   00000034   0xD00C             BEQ      ??fei_fbe_4
    748            {
    749              if ((crystal_val < 30000) ||
    750                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
    751                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000036   0x....             LDR      R3,??DataTable13  ;; 0x7530
   \   00000038   0x4298             CMP      R0,R3
   \   0000003A   0xDB07             BLT      ??fei_fbe_5
   \   0000003C   0x....             LDR      R3,??DataTable13_1  ;; 0x9c41
   \   0000003E   0x1AC3             SUBS     R3,R0,R3
   \   00000040   0x....             LDR      R4,??DataTable13_2  ;; 0x2d2a7f
   \   00000042   0x42A3             CMP      R3,R4
   \   00000044   0xD302             BCC      ??fei_fbe_5
   \   00000046   0x....             LDR      R3,??DataTable13_3  ;; 0x1e84801
   \   00000048   0x4298             CMP      R0,R3
   \   0000004A   0xDB01             BLT      ??fei_fbe_4
   \                     ??fei_fbe_5: (+1)
   \   0000004C   0x2022             MOVS     R0,#+34
   \   0000004E   0xE098             B        ??fei_fbe_2
    752            }
    753          
    754          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
    755            if (hgo_val > 0)
   \                     ??fei_fbe_4: (+1)
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD000             BEQ      ??fei_fbe_6
    756            {
    757              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000056   0x2101             MOVS     R1,#+1
    758            }
    759          
    760          // configure the MCG_C2 register
    761          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
    762          // it still needs to be set correctly even if the oscillator is not being used
    763            temp_reg = MCG_C2;
   \                     ??fei_fbe_6: (+1)
   \   00000058   0x....             LDR      R3,??DataTable13_4  ;; 0x40064001
   \   0000005A   0x781B             LDRB     R3,[R3, #+0]
    764            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   0000005C   0x001C             MOVS     R4,R3
   \   0000005E   0x23C3             MOVS     R3,#+195
   \   00000060   0x4023             ANDS     R3,R3,R4
    765            if (crystal_val <= 40000)
   \   00000062   0x....             LDR      R4,??DataTable13_1  ;; 0x9c41
   \   00000064   0x42A0             CMP      R0,R4
   \   00000066   0xDA07             BGE      ??fei_fbe_7
    766            {
    767              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000068   0x001C             MOVS     R4,R3
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x00C9             LSLS     R1,R1,#+3
   \   0000006E   0xB2D2             UXTB     R2,R2
   \   00000070   0x0093             LSLS     R3,R2,#+2
   \   00000072   0x430B             ORRS     R3,R3,R1
   \   00000074   0x4323             ORRS     R3,R3,R4
   \   00000076   0xE015             B        ??fei_fbe_8
    768            }
    769            else if (crystal_val <= 8000000)
   \                     ??fei_fbe_7: (+1)
   \   00000078   0x....             LDR      R4,??DataTable13_5  ;; 0x7a1201
   \   0000007A   0x42A0             CMP      R0,R4
   \   0000007C   0xDA09             BGE      ??fei_fbe_9
    770            {
    771              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   0000007E   0x001D             MOVS     R5,R3
   \   00000080   0xB2C9             UXTB     R1,R1
   \   00000082   0x00C9             LSLS     R1,R1,#+3
   \   00000084   0x2410             MOVS     R4,#+16
   \   00000086   0x430C             ORRS     R4,R4,R1
   \   00000088   0xB2D2             UXTB     R2,R2
   \   0000008A   0x0093             LSLS     R3,R2,#+2
   \   0000008C   0x4323             ORRS     R3,R3,R4
   \   0000008E   0x432B             ORRS     R3,R3,R5
   \   00000090   0xE008             B        ??fei_fbe_8
    772            }
    773            else
    774            {
    775              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fei_fbe_9: (+1)
   \   00000092   0x001D             MOVS     R5,R3
   \   00000094   0xB2C9             UXTB     R1,R1
   \   00000096   0x00C9             LSLS     R1,R1,#+3
   \   00000098   0x2420             MOVS     R4,#+32
   \   0000009A   0x430C             ORRS     R4,R4,R1
   \   0000009C   0xB2D2             UXTB     R2,R2
   \   0000009E   0x0093             LSLS     R3,R2,#+2
   \   000000A0   0x4323             ORRS     R3,R3,R4
   \   000000A2   0x432B             ORRS     R3,R3,R5
    776            }
    777            MCG_C2 = temp_reg;
   \                     ??fei_fbe_8: (+1)
   \   000000A4   0x....             LDR      R1,??DataTable13_4  ;; 0x40064001
   \   000000A6   0x700B             STRB     R3,[R1, #+0]
    778          // determine FRDIV based on reference clock frequency
    779          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
    780            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000A8   0x....             LDR      R1,??DataTable13_6  ;; 0x1312d1
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xDA01             BGE      ??fei_fbe_10
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0xE014             B        ??fei_fbe_11
    781            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fei_fbe_10: (+1)
   \   000000B2   0x....             LDR      R1,??DataTable13_7  ;; 0x2625a1
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xDA01             BGE      ??fei_fbe_12
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0xE00F             B        ??fei_fbe_11
    782            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fei_fbe_12: (+1)
   \   000000BC   0x....             LDR      R1,??DataTable13_8  ;; 0x4c4b41
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xDA01             BGE      ??fei_fbe_13
   \   000000C2   0x2102             MOVS     R1,#+2
   \   000000C4   0xE00A             B        ??fei_fbe_11
    783            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fei_fbe_13: (+1)
   \   000000C6   0x....             LDR      R1,??DataTable13_9  ;; 0x989681
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xDA01             BGE      ??fei_fbe_14
   \   000000CC   0x2103             MOVS     R1,#+3
   \   000000CE   0xE005             B        ??fei_fbe_11
    784            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fei_fbe_14: (+1)
   \   000000D0   0x....             LDR      R1,??DataTable13_10  ;; 0x1312d01
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xDA01             BGE      ??fei_fbe_15
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0xE000             B        ??fei_fbe_11
    785            else {frdiv_val = 5;}
   \                     ??fei_fbe_15: (+1)
   \   000000DA   0x2105             MOVS     R1,#+5
    786            
    787          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    788          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
    789          // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
    790            temp_reg = MCG_C1;
   \                     ??fei_fbe_11: (+1)
   \   000000DC   0x....             LDR      R3,??DataTable11_3  ;; 0x40064000
   \   000000DE   0x781B             LDRB     R3,[R3, #+0]
    791            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   \   000000E0   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000E2   0x0F9B             LSRS     R3,R3,#+30
    792            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   000000E4   0x001D             MOVS     R5,R3
   \   000000E6   0x00C9             LSLS     R1,R1,#+3
   \   000000E8   0x2438             MOVS     R4,#+56
   \   000000EA   0x400C             ANDS     R4,R4,R1
   \   000000EC   0x2380             MOVS     R3,#+128
   \   000000EE   0x4323             ORRS     R3,R3,R4
   \   000000F0   0x432B             ORRS     R3,R3,R5
    793            MCG_C1 = temp_reg;
   \   000000F2   0x....             LDR      R1,??DataTable11_3  ;; 0x40064000
   \   000000F4   0x700B             STRB     R3,[R1, #+0]
    794          
    795          // if the external oscillator is used need to wait for OSCINIT to set
    796            if (erefs_val)
   \   000000F6   0xB2D2             UXTB     R2,R2
   \   000000F8   0x2A00             CMP      R2,#+0
   \   000000FA   0xD010             BEQ      ??fei_fbe_16
    797            {
    798              for (i = 0 ; i < 10000 ; i++)
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0xE000             B        ??fei_fbe_17
   \                     ??fei_fbe_18: (+1)
   \   00000100   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fbe_17: (+1)
   \   00000102   0xB209             SXTH     R1,R1
   \   00000104   0x....             LDR      R2,??DataTable13_11  ;; 0x2710
   \   00000106   0x4291             CMP      R1,R2
   \   00000108   0xDA03             BGE      ??fei_fbe_19
    799              {
    800                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   0000010A   0x....             LDR      R2,??DataTable11  ;; 0x40064006
   \   0000010C   0x7812             LDRB     R2,[R2, #+0]
   \   0000010E   0x0792             LSLS     R2,R2,#+30
   \   00000110   0xD5F6             BPL      ??fei_fbe_18
    801              }
    802              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fei_fbe_19: (+1)
   \   00000112   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   00000114   0x7809             LDRB     R1,[R1, #+0]
   \   00000116   0x0789             LSLS     R1,R1,#+30
   \   00000118   0xD401             BMI      ??fei_fbe_16
   \   0000011A   0x2023             MOVS     R0,#+35
   \   0000011C   0xE031             B        ??fei_fbe_2
    803            }
    804          
    805          // wait for Reference clock Status bit to clear
    806            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbe_16: (+1)
   \   0000011E   0x2100             MOVS     R1,#+0
   \   00000120   0xE000             B        ??fei_fbe_20
   \                     ??fei_fbe_21: (+1)
   \   00000122   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fbe_20: (+1)
   \   00000124   0xB209             SXTH     R1,R1
   \   00000126   0x22FA             MOVS     R2,#+250
   \   00000128   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000012A   0x4291             CMP      R1,R2
   \   0000012C   0xDA03             BGE      ??fei_fbe_22
    807            {
    808              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   0000012E   0x....             LDR      R2,??DataTable11  ;; 0x40064006
   \   00000130   0x7812             LDRB     R2,[R2, #+0]
   \   00000132   0x06D2             LSLS     R2,R2,#+27
   \   00000134   0xD4F5             BMI      ??fei_fbe_21
    809            }
    810            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fei_fbe_22: (+1)
   \   00000136   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   00000138   0x7809             LDRB     R1,[R1, #+0]
   \   0000013A   0x06C9             LSLS     R1,R1,#+27
   \   0000013C   0xD501             BPL      ??fei_fbe_23
   \   0000013E   0x2011             MOVS     R0,#+17
   \   00000140   0xE01F             B        ??fei_fbe_2
    811            
    812          // Wait for clock status bits to show clock source is ext ref clk
    813            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbe_23: (+1)
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0xE000             B        ??fei_fbe_24
   \                     ??fei_fbe_25: (+1)
   \   00000146   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fbe_24: (+1)
   \   00000148   0xB209             SXTH     R1,R1
   \   0000014A   0x22FA             MOVS     R2,#+250
   \   0000014C   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000014E   0x4291             CMP      R1,R2
   \   00000150   0xDA07             BGE      ??fei_fbe_26
    814            {
    815              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000152   0x....             LDR      R2,??DataTable11  ;; 0x40064006
   \   00000154   0x7812             LDRB     R2,[R2, #+0]
   \   00000156   0xB2D2             UXTB     R2,R2
   \   00000158   0x0892             LSRS     R2,R2,#+2
   \   0000015A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000015C   0x0F92             LSRS     R2,R2,#+30
   \   0000015E   0x2A02             CMP      R2,#+2
   \   00000160   0xD1F1             BNE      ??fei_fbe_25
    816            }
    817            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fei_fbe_26: (+1)
   \   00000162   0x....             LDR      R1,??DataTable11  ;; 0x40064006
   \   00000164   0x7809             LDRB     R1,[R1, #+0]
   \   00000166   0xB2C9             UXTB     R1,R1
   \   00000168   0x0889             LSRS     R1,R1,#+2
   \   0000016A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000016C   0x0F89             LSRS     R1,R1,#+30
   \   0000016E   0x2902             CMP      R1,#+2
   \   00000170   0xD001             BEQ      ??fei_fbe_27
   \   00000172   0x201A             MOVS     R0,#+26
   \   00000174   0xE005             B        ??fei_fbe_2
    818           
    819          // Now in FBE  
    820          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
    821          // It is enabled here but can be removed if this is not required.
    822            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fei_fbe_27: (+1)
   \   00000176   0x....             LDR      R1,??DataTable14  ;; 0x40064005
   \   00000178   0x7809             LDRB     R1,[R1, #+0]
   \   0000017A   0x2220             MOVS     R2,#+32
   \   0000017C   0x430A             ORRS     R2,R2,R1
   \   0000017E   0x....             LDR      R1,??DataTable14  ;; 0x40064005
   \   00000180   0x700A             STRB     R2,[R1, #+0]
    823            
    824            return crystal_val; // MCGOUT frequency equals external clock frequency
   \                     ??fei_fbe_2: (+1)
   \   00000182   0xBD30             POP      {R4,R5,PC}       ;; return
    825          } // fei_fbe
    826          
    827          

   \                                 In section .text, align 2, keep-with-next
    828          int fbe_fee(int crystal_val)
    829          {
   \                     fbe_fee: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    830            short i, fll_ref_freq;
    831            int mcg_out;
    832          
    833          // Check MCG is in FBE mode
    834            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    835                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    836                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    837                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD10B             BNE      ??fbe_fee_0
   \   00000012   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD407             BMI      ??fbe_fee_0
   \   0000001A   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD403             BMI      ??fbe_fee_0
   \   00000022   0x....             LDR      R1,??DataTable13_4  ;; 0x40064001
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD501             BPL      ??fbe_fee_1
    838            {
    839              return 0x4;                                                       // return error code
   \                     ??fbe_fee_0: (+1)
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0xE041             B        ??fbe_fee_2
    840            }
    841            
    842            // The FLL ref clk divide value depends on FRDIV and the RANGE value
    843            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fbe_fee_1: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable13_4  ;; 0x40064001
   \   00000030   0x7809             LDRB     R1,[R1, #+0]
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0x0909             LSRS     R1,R1,#+4
   \   00000036   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000038   0x0F89             LSRS     R1,R1,#+30
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD00A             BEQ      ??fbe_fee_3
    844            {
    845              fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
   \   0000003E   0x2120             MOVS     R1,#+32
   \   00000040   0x....             LDR      R2,??DataTable14_2  ;; 0x40064000
   \   00000042   0x7812             LDRB     R2,[R2, #+0]
   \   00000044   0xB2D2             UXTB     R2,R2
   \   00000046   0x08D2             LSRS     R2,R2,#+3
   \   00000048   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   0000004A   0x0F52             LSRS     R2,R2,#+29
   \   0000004C   0x4091             LSLS     R1,R1,R2
   \   0000004E   0x.... 0x....      BL       __aeabi_idiv
   \   00000052   0xE009             B        ??fbe_fee_4
    846            }
    847            else
    848            {
    849              fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT))));
   \                     ??fbe_fee_3: (+1)
   \   00000054   0x2101             MOVS     R1,#+1
   \   00000056   0x....             LDR      R2,??DataTable13_4  ;; 0x40064001
   \   00000058   0x7812             LDRB     R2,[R2, #+0]
   \   0000005A   0xB2D2             UXTB     R2,R2
   \   0000005C   0x0912             LSRS     R2,R2,#+4
   \   0000005E   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000060   0x0F92             LSRS     R2,R2,#+30
   \   00000062   0x4091             LSLS     R1,R1,R2
   \   00000064   0x.... 0x....      BL       __aeabi_idiv
    850            }
    851            
    852          // Check resulting FLL frequency 
    853            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \                     ??fbe_fee_4: (+1)
   \   00000068   0xB200             SXTH     R0,R0
   \   0000006A   0x.... 0x....      BL       fll_freq
    854            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   0000006E   0x283C             CMP      R0,#+60
   \   00000070   0xDB1F             BLT      ??fbe_fee_2
    855            
    856          // Clear CLKS field to switch CLKS mux to select FLL output
    857            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
   \                     ??fbe_fee_5: (+1)
   \   00000072   0x....             LDR      R1,??DataTable14_2  ;; 0x40064000
   \   00000074   0x7809             LDRB     R1,[R1, #+0]
   \   00000076   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000078   0x0E89             LSRS     R1,R1,#+26
   \   0000007A   0x....             LDR      R2,??DataTable14_2  ;; 0x40064000
   \   0000007C   0x7011             STRB     R1,[R2, #+0]
    858          
    859          // Wait for clock status bits to show clock source is FLL
    860            for (i = 0 ; i < 2000 ; i++)
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xE000             B        ??fbe_fee_6
   \                     ??fbe_fee_7: (+1)
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbe_fee_6: (+1)
   \   00000084   0xB209             SXTH     R1,R1
   \   00000086   0x22FA             MOVS     R2,#+250
   \   00000088   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000008A   0x4291             CMP      R1,R2
   \   0000008C   0xDA07             BGE      ??fbe_fee_8
    861            {
    862              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL selected before loop finishes
   \   0000008E   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   00000090   0x7812             LDRB     R2,[R2, #+0]
   \   00000092   0xB2D2             UXTB     R2,R2
   \   00000094   0x0892             LSRS     R2,R2,#+2
   \   00000096   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000098   0x0F92             LSRS     R2,R2,#+30
   \   0000009A   0x2A00             CMP      R2,#+0
   \   0000009C   0xD1F1             BNE      ??fbe_fee_7
    863            }
    864            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really selected and return with error if not
   \                     ??fbe_fee_8: (+1)
   \   0000009E   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0xB2C9             UXTB     R1,R1
   \   000000A4   0x0889             LSRS     R1,R1,#+2
   \   000000A6   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000A8   0x0F89             LSRS     R1,R1,#+30
   \   000000AA   0x2900             CMP      R1,#+0
   \   000000AC   0xD001             BEQ      ??fbe_fee_9
   \   000000AE   0x2018             MOVS     R0,#+24
   \   000000B0   0xE7FF             B        ??fbe_fee_2
    865            
    866          // Now in FEE mode
    867            return mcg_out;
   \                     ??fbe_fee_9: (+1)
   \                     ??fbe_fee_2: (+1)
   \   000000B2   0xBD02             POP      {R1,PC}          ;; return
    868          } // fbe_fee
    869          
    870          

   \                                 In section .text, align 2, keep-with-next
    871          int fee_fbe(int crystal_val)
    872          { 
   \                     fee_fbe: (+1)
   \   00000000   0xB500             PUSH     {LR}
    873            short i;
    874            
    875          // Check MCG is in FEE mode
    876            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
    877                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    878                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD107             BNE      ??fee_fbe_0
   \   00000012   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??fee_fbe_0
   \   0000001A   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD501             BPL      ??fee_fbe_1
    879            {
    880              return 0x2;                                                       // return error code
   \                     ??fee_fbe_0: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE01F             B        ??fee_fbe_2
    881            }
    882            
    883          // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
    884          // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
    885            MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
   \                     ??fee_fbe_1: (+1)
   \   00000026   0x....             LDR      R1,??DataTable14_2  ;; 0x40064000
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x2280             MOVS     R2,#+128
   \   0000002C   0x430A             ORRS     R2,R2,R1
   \   0000002E   0x....             LDR      R1,??DataTable14_2  ;; 0x40064000
   \   00000030   0x700A             STRB     R2,[R1, #+0]
    886          
    887          /// Wait for clock status bits to show clock source is ext ref clk
    888            for (i = 0 ; i < 2000 ; i++)
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xE000             B        ??fee_fbe_3
   \                     ??fee_fbe_4: (+1)
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \                     ??fee_fbe_3: (+1)
   \   00000038   0xB209             SXTH     R1,R1
   \   0000003A   0x22FA             MOVS     R2,#+250
   \   0000003C   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000003E   0x4291             CMP      R1,R2
   \   00000040   0xDA07             BGE      ??fee_fbe_5
    889            {
    890              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000042   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   00000044   0x7812             LDRB     R2,[R2, #+0]
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0x0892             LSRS     R2,R2,#+2
   \   0000004A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000004C   0x0F92             LSRS     R2,R2,#+30
   \   0000004E   0x2A02             CMP      R2,#+2
   \   00000050   0xD1F1             BNE      ??fee_fbe_4
    891            }
    892            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fee_fbe_5: (+1)
   \   00000052   0x....             LDR      R1,??DataTable14_1  ;; 0x40064006
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0xB2C9             UXTB     R1,R1
   \   00000058   0x0889             LSRS     R1,R1,#+2
   \   0000005A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000005C   0x0F89             LSRS     R1,R1,#+30
   \   0000005E   0x2902             CMP      R1,#+2
   \   00000060   0xD001             BEQ      ??fee_fbe_6
   \   00000062   0x201A             MOVS     R0,#+26
   \   00000064   0xE7FF             B        ??fee_fbe_2
    893            
    894          // Now in FBE mode
    895            return crystal_val;
   \                     ??fee_fbe_6: (+1)
   \                     ??fee_fbe_2: (+1)
   \   00000066   0xBD00             POP      {PC}             ;; return
    896          } // fee_fbe
    897          
    898          

   \                                 In section .text, align 2, keep-with-next
    899          int fbe_fbi(int irc_freq, unsigned char irc_select)
    900          {
   \                     fbe_fbi: (+1)
   \   00000000   0xB500             PUSH     {LR}
    901            unsigned char temp_reg;
    902            unsigned char fcrdiv_val;
    903            short i;
    904            
    905          // Check MCG is in FBE mode
    906            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    907                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    908                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    909                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A02             CMP      R2,#+2
   \   00000010   0xD10B             BNE      ??fbe_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD407             BMI      ??fbe_fbi_0
   \   0000001A   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0692             LSLS     R2,R2,#+26
   \   00000020   0xD403             BMI      ??fbe_fbi_0
   \   00000022   0x....             LDR      R2,??DataTable14_3  ;; 0x40064001
   \   00000024   0x7812             LDRB     R2,[R2, #+0]
   \   00000026   0x0792             LSLS     R2,R2,#+30
   \   00000028   0xD501             BPL      ??fbe_fbi_1
    910            {
    911              return 0x4;                                                       // return error code
   \                     ??fbe_fbi_0: (+1)
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0xE091             B        ??fbe_fbi_2
    912            }
    913          
    914          // Check that the irc frequency matches the selected IRC 
    915            if (!(irc_select))
   \                     ??fbe_fbi_1: (+1)
   \   0000002E   0xB2C9             UXTB     R1,R1
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD106             BNE      ??fbe_fbi_3
    916            {    
    917              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   00000034   0x....             LDR      R2,??DataTable14_4  ;; 0x7a12
   \   00000036   0x1A82             SUBS     R2,R0,R2
   \   00000038   0x....             LDR      R3,??DataTable14_5  ;; 0x1e86
   \   0000003A   0x429A             CMP      R2,R3
   \   0000003C   0xD308             BCC      ??fbe_fbi_4
   \   0000003E   0x2031             MOVS     R0,#+49
   \   00000040   0xE087             B        ??fbe_fbi_2
    918            }
    919            else
    920            {
    921              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fbe_fbi_3: (+1)
   \   00000042   0x....             LDR      R2,??DataTable14_6  ;; 0x2dc6c0
   \   00000044   0x1A82             SUBS     R2,R0,R2
   \   00000046   0x....             LDR      R3,??DataTable14_7  ;; 0x1e8481
   \   00000048   0x429A             CMP      R2,R3
   \   0000004A   0xD301             BCC      ??fbe_fbi_4
   \   0000004C   0x2032             MOVS     R0,#+50
   \   0000004E   0xE080             B        ??fbe_fbi_2
    922            }
    923            
    924          // Select the required IRC
    925            if (irc_select)
   \                     ??fbe_fbi_4: (+1)
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x2900             CMP      R1,#+0
   \   00000054   0xD006             BEQ      ??fbe_fbi_5
    926            {
    927              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
   \   00000056   0x....             LDR      R2,??DataTable14_3  ;; 0x40064001
   \   00000058   0x7812             LDRB     R2,[R2, #+0]
   \   0000005A   0x2301             MOVS     R3,#+1
   \   0000005C   0x4313             ORRS     R3,R3,R2
   \   0000005E   0x....             LDR      R2,??DataTable14_3  ;; 0x40064001
   \   00000060   0x7013             STRB     R3,[R2, #+0]
   \   00000062   0xE005             B        ??fbe_fbi_6
    928            }
    929            else
    930            {
    931              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
   \                     ??fbe_fbi_5: (+1)
   \   00000064   0x....             LDR      R2,??DataTable14_3  ;; 0x40064001
   \   00000066   0x7812             LDRB     R2,[R2, #+0]
   \   00000068   0x23FE             MOVS     R3,#+254
   \   0000006A   0x4013             ANDS     R3,R3,R2
   \   0000006C   0x....             LDR      R2,??DataTable14_3  ;; 0x40064001
   \   0000006E   0x7013             STRB     R3,[R2, #+0]
    932            }
    933            
    934          // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
    935            MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??fbe_fbi_6: (+1)
   \   00000070   0x....             LDR      R2,??DataTable14  ;; 0x40064005
   \   00000072   0x7812             LDRB     R2,[R2, #+0]
   \   00000074   0x23DF             MOVS     R3,#+223
   \   00000076   0x4013             ANDS     R3,R3,R2
   \   00000078   0x....             LDR      R2,??DataTable14  ;; 0x40064005
   \   0000007A   0x7013             STRB     R3,[R2, #+0]
    936            
    937          // Select the IRC as the CLKS mux selection
    938            temp_reg = MCG_C1;
   \   0000007C   0x....             LDR      R2,??DataTable14_2  ;; 0x40064000
   \   0000007E   0x7812             LDRB     R2,[R2, #+0]
    939            temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
   \   00000080   0x0692             LSLS     R2,R2,#+26       ;; ZeroExtS R2,R2,#+26,#+26
   \   00000082   0x0E92             LSRS     R2,R2,#+26
    940            temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
   \   00000084   0x0013             MOVS     R3,R2
   \   00000086   0x2244             MOVS     R2,#+68
   \   00000088   0x431A             ORRS     R2,R2,R3
    941            MCG_C1 = temp_reg; // update MCG_C1
   \   0000008A   0x....             LDR      R3,??DataTable14_2  ;; 0x40064000
   \   0000008C   0x701A             STRB     R2,[R3, #+0]
    942            
    943          // wait until internal reference switches to requested irc.
    944            if (!(irc_select))
   \   0000008E   0xB2C9             UXTB     R1,R1
   \   00000090   0x2900             CMP      R1,#+0
   \   00000092   0xD111             BNE      ??fbe_fbi_7
    945            {
    946              for (i = 0 ; i < 2000 ; i++)
   \   00000094   0x2200             MOVS     R2,#+0
   \   00000096   0xE000             B        ??fbe_fbi_8
   \                     ??fbe_fbi_9: (+1)
   \   00000098   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_8: (+1)
   \   0000009A   0xB212             SXTH     R2,R2
   \   0000009C   0x23FA             MOVS     R3,#+250
   \   0000009E   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000A0   0x429A             CMP      R2,R3
   \   000000A2   0xDA03             BGE      ??fbe_fbi_10
    947              {
    948                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \   000000A4   0x....             LDR      R3,??DataTable14_1  ;; 0x40064006
   \   000000A6   0x781B             LDRB     R3,[R3, #+0]
   \   000000A8   0x07DB             LSLS     R3,R3,#+31
   \   000000AA   0xD4F5             BMI      ??fbe_fbi_9
    949              }
    950              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fbe_fbi_10: (+1)
   \   000000AC   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   000000AE   0x7812             LDRB     R2,[R2, #+0]
   \   000000B0   0x07D2             LSLS     R2,R2,#+31
   \   000000B2   0xD513             BPL      ??fbe_fbi_11
   \   000000B4   0x2013             MOVS     R0,#+19
   \   000000B6   0xE04C             B        ??fbe_fbi_2
    951            }
    952            else
    953            {
    954              for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_7: (+1)
   \   000000B8   0x2200             MOVS     R2,#+0
   \   000000BA   0xE000             B        ??fbe_fbi_12
   \                     ??fbe_fbi_13: (+1)
   \   000000BC   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_12: (+1)
   \   000000BE   0xB212             SXTH     R2,R2
   \   000000C0   0x23FA             MOVS     R3,#+250
   \   000000C2   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000C4   0x429A             CMP      R2,R3
   \   000000C6   0xDA03             BGE      ??fbe_fbi_14
    955              {
    956                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \   000000C8   0x....             LDR      R3,??DataTable14_1  ;; 0x40064006
   \   000000CA   0x781B             LDRB     R3,[R3, #+0]
   \   000000CC   0x07DB             LSLS     R3,R3,#+31
   \   000000CE   0xD5F5             BPL      ??fbe_fbi_13
    957              }
    958              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fbe_fbi_14: (+1)
   \   000000D0   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   000000D2   0x7812             LDRB     R2,[R2, #+0]
   \   000000D4   0x07D2             LSLS     R2,R2,#+31
   \   000000D6   0xD401             BMI      ??fbe_fbi_11
   \   000000D8   0x2014             MOVS     R0,#+20
   \   000000DA   0xE03A             B        ??fbe_fbi_2
    959            }
    960           
    961          // Wait for clock status bits to update
    962            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_11: (+1)
   \   000000DC   0x2200             MOVS     R2,#+0
   \   000000DE   0xE000             B        ??fbe_fbi_15
   \                     ??fbe_fbi_16: (+1)
   \   000000E0   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_15: (+1)
   \   000000E2   0xB212             SXTH     R2,R2
   \   000000E4   0x23FA             MOVS     R3,#+250
   \   000000E6   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000E8   0x429A             CMP      R2,R3
   \   000000EA   0xDA07             BGE      ??fbe_fbi_17
    963            {
    964              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \   000000EC   0x....             LDR      R3,??DataTable14_1  ;; 0x40064006
   \   000000EE   0x781B             LDRB     R3,[R3, #+0]
   \   000000F0   0xB2DB             UXTB     R3,R3
   \   000000F2   0x089B             LSRS     R3,R3,#+2
   \   000000F4   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000F6   0x0F9B             LSRS     R3,R3,#+30
   \   000000F8   0x2B01             CMP      R3,#+1
   \   000000FA   0xD1F1             BNE      ??fbe_fbi_16
    965            }
    966            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fbe_fbi_17: (+1)
   \   000000FC   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   000000FE   0x7812             LDRB     R2,[R2, #+0]
   \   00000100   0xB2D2             UXTB     R2,R2
   \   00000102   0x0892             LSRS     R2,R2,#+2
   \   00000104   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000106   0x0F92             LSRS     R2,R2,#+30
   \   00000108   0x2A01             CMP      R2,#+1
   \   0000010A   0xD001             BEQ      ??fbe_fbi_18
   \   0000010C   0x2019             MOVS     R0,#+25
   \   0000010E   0xE020             B        ??fbe_fbi_2
    967            
    968            // wait for Reference clock Status bit to set
    969            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_18: (+1)
   \   00000110   0x2200             MOVS     R2,#+0
   \   00000112   0xE000             B        ??fbe_fbi_19
   \                     ??fbe_fbi_20: (+1)
   \   00000114   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_19: (+1)
   \   00000116   0xB212             SXTH     R2,R2
   \   00000118   0x23FA             MOVS     R3,#+250
   \   0000011A   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   0000011C   0x429A             CMP      R2,R3
   \   0000011E   0xDA03             BGE      ??fbe_fbi_21
    970            {
    971              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   00000120   0x....             LDR      R3,??DataTable14_1  ;; 0x40064006
   \   00000122   0x781B             LDRB     R3,[R3, #+0]
   \   00000124   0x06DB             LSLS     R3,R3,#+27
   \   00000126   0xD5F5             BPL      ??fbe_fbi_20
    972            }
    973            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbe_fbi_21: (+1)
   \   00000128   0x....             LDR      R2,??DataTable14_1  ;; 0x40064006
   \   0000012A   0x7812             LDRB     R2,[R2, #+0]
   \   0000012C   0x06D2             LSLS     R2,R2,#+27
   \   0000012E   0xD401             BMI      ??fbe_fbi_22
   \   00000130   0x2012             MOVS     R0,#+18
   \   00000132   0xE00E             B        ??fbe_fbi_2
    974            
    975          // Now in FBI mode
    976            
    977            if (irc_select)
   \                     ??fbe_fbi_22: (+1)
   \   00000134   0xB2C9             UXTB     R1,R1
   \   00000136   0x2900             CMP      R1,#+0
   \   00000138   0xD00B             BEQ      ??fbe_fbi_23
    978            {
    979              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   0000013A   0x2101             MOVS     R1,#+1
   \   0000013C   0x....             LDR      R2,??DataTable17  ;; 0x40064008
   \   0000013E   0x7812             LDRB     R2,[R2, #+0]
   \   00000140   0xB2D2             UXTB     R2,R2
   \   00000142   0x0852             LSRS     R2,R2,#+1
   \   00000144   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000146   0x0F52             LSRS     R2,R2,#+29
   \   00000148   0x4091             LSLS     R1,R1,R2
    980              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV factor
   \   0000014A   0xB2C9             UXTB     R1,R1
   \   0000014C   0x.... 0x....      BL       __aeabi_idiv
   \   00000150   0xE7FF             B        ??fbe_fbi_2
    981            }
    982            else
    983            {
    984              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fbe_fbi_23: (+1)
   \                     ??fbe_fbi_2: (+1)
   \   00000152   0xBD00             POP      {PC}             ;; return
    985            }
    986          } //fbe_fbi
    987          
    988          

   \                                 In section .text, align 2, keep-with-next
    989          int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
    990          {
   \                     fbi_fbe: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    991            unsigned char temp_reg;
    992            unsigned char frdiv_val;
    993            short i;
    994            
    995          // check if in FBI mode
    996            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
    997                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    998                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    999                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x....             LDR      R3,??DataTable17_1  ;; 0x40064006
   \   00000004   0x781B             LDRB     R3,[R3, #+0]
   \   00000006   0xB2DB             UXTB     R3,R3
   \   00000008   0x089B             LSRS     R3,R3,#+2
   \   0000000A   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   0000000C   0x0F9B             LSRS     R3,R3,#+30
   \   0000000E   0x2B01             CMP      R3,#+1
   \   00000010   0xD10B             BNE      ??fbi_fbe_0
   \   00000012   0x....             LDR      R3,??DataTable17_1  ;; 0x40064006
   \   00000014   0x781B             LDRB     R3,[R3, #+0]
   \   00000016   0x06DB             LSLS     R3,R3,#+27
   \   00000018   0xD507             BPL      ??fbi_fbe_0
   \   0000001A   0x....             LDR      R3,??DataTable17_1  ;; 0x40064006
   \   0000001C   0x781B             LDRB     R3,[R3, #+0]
   \   0000001E   0x069B             LSLS     R3,R3,#+26
   \   00000020   0xD403             BMI      ??fbi_fbe_0
   \   00000022   0x....             LDR      R3,??DataTable17_2  ;; 0x40064001
   \   00000024   0x781B             LDRB     R3,[R3, #+0]
   \   00000026   0x079B             LSLS     R3,R3,#+30
   \   00000028   0xD501             BPL      ??fbi_fbe_1
   1000            {  
   1001              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fbe_0: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE0AD             B        ??fbi_fbe_2
   1002            }
   1003           
   1004          // check external frequency is less than the maximum frequency
   1005            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fbi_fbe_1: (+1)
   \   0000002E   0x....             LDR      R3,??DataTable17_3  ;; 0x2faf081
   \   00000030   0x4298             CMP      R0,R3
   \   00000032   0xDB01             BLT      ??fbi_fbe_3
   \   00000034   0x2021             MOVS     R0,#+33
   \   00000036   0xE0A8             B        ??fbi_fbe_2
   1006            
   1007          // check crystal frequency is within spec. if crystal osc is being used
   1008            if (erefs_val)
   \                     ??fbi_fbe_3: (+1)
   \   00000038   0xB2D2             UXTB     R2,R2
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD00C             BEQ      ??fbi_fbe_4
   1009            {
   1010              if ((crystal_val < 30000) ||
   1011                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1012                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   0000003E   0x....             LDR      R3,??DataTable17_4  ;; 0x7530
   \   00000040   0x4298             CMP      R0,R3
   \   00000042   0xDB07             BLT      ??fbi_fbe_5
   \   00000044   0x....             LDR      R3,??DataTable17_5  ;; 0x9c41
   \   00000046   0x1AC3             SUBS     R3,R0,R3
   \   00000048   0x....             LDR      R4,??DataTable17_6  ;; 0x2d2a7f
   \   0000004A   0x42A3             CMP      R3,R4
   \   0000004C   0xD302             BCC      ??fbi_fbe_5
   \   0000004E   0x....             LDR      R3,??DataTable17_7  ;; 0x1e84801
   \   00000050   0x4298             CMP      R0,R3
   \   00000052   0xDB01             BLT      ??fbi_fbe_4
   \                     ??fbi_fbe_5: (+1)
   \   00000054   0x2022             MOVS     R0,#+34
   \   00000056   0xE098             B        ??fbi_fbe_2
   1013            }
   1014          
   1015          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1016            if (hgo_val > 0)
   \                     ??fbi_fbe_4: (+1)
   \   00000058   0xB2C9             UXTB     R1,R1
   \   0000005A   0x2900             CMP      R1,#+0
   \   0000005C   0xD000             BEQ      ??fbi_fbe_6
   1017            {
   1018              hgo_val = 1; // force hgo_val to 1 if > 0
   \   0000005E   0x2101             MOVS     R1,#+1
   1019            }
   1020          
   1021          // configure the MCG_C2 register
   1022          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1023          // it still needs to be set correctly even if the oscillator is not being used
   1024            temp_reg = MCG_C2;
   \                     ??fbi_fbe_6: (+1)
   \   00000060   0x....             LDR      R3,??DataTable17_2  ;; 0x40064001
   \   00000062   0x781B             LDRB     R3,[R3, #+0]
   1025            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   00000064   0x001C             MOVS     R4,R3
   \   00000066   0x23C3             MOVS     R3,#+195
   \   00000068   0x4023             ANDS     R3,R3,R4
   1026            if (crystal_val <= 40000)
   \   0000006A   0x....             LDR      R4,??DataTable17_5  ;; 0x9c41
   \   0000006C   0x42A0             CMP      R0,R4
   \   0000006E   0xDA07             BGE      ??fbi_fbe_7
   1027            {
   1028              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000070   0x001C             MOVS     R4,R3
   \   00000072   0xB2C9             UXTB     R1,R1
   \   00000074   0x00C9             LSLS     R1,R1,#+3
   \   00000076   0xB2D2             UXTB     R2,R2
   \   00000078   0x0093             LSLS     R3,R2,#+2
   \   0000007A   0x430B             ORRS     R3,R3,R1
   \   0000007C   0x4323             ORRS     R3,R3,R4
   \   0000007E   0xE015             B        ??fbi_fbe_8
   1029            }
   1030            else if (crystal_val <= 8000000)
   \                     ??fbi_fbe_7: (+1)
   \   00000080   0x....             LDR      R4,??DataTable17_8  ;; 0x7a1201
   \   00000082   0x42A0             CMP      R0,R4
   \   00000084   0xDA09             BGE      ??fbi_fbe_9
   1031            {
   1032              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000086   0x001D             MOVS     R5,R3
   \   00000088   0xB2C9             UXTB     R1,R1
   \   0000008A   0x00C9             LSLS     R1,R1,#+3
   \   0000008C   0x2410             MOVS     R4,#+16
   \   0000008E   0x430C             ORRS     R4,R4,R1
   \   00000090   0xB2D2             UXTB     R2,R2
   \   00000092   0x0093             LSLS     R3,R2,#+2
   \   00000094   0x4323             ORRS     R3,R3,R4
   \   00000096   0x432B             ORRS     R3,R3,R5
   \   00000098   0xE008             B        ??fbi_fbe_8
   1033            }
   1034            else
   1035            {
   1036              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fbi_fbe_9: (+1)
   \   0000009A   0x001D             MOVS     R5,R3
   \   0000009C   0xB2C9             UXTB     R1,R1
   \   0000009E   0x00C9             LSLS     R1,R1,#+3
   \   000000A0   0x2420             MOVS     R4,#+32
   \   000000A2   0x430C             ORRS     R4,R4,R1
   \   000000A4   0xB2D2             UXTB     R2,R2
   \   000000A6   0x0093             LSLS     R3,R2,#+2
   \   000000A8   0x4323             ORRS     R3,R3,R4
   \   000000AA   0x432B             ORRS     R3,R3,R5
   1037            }
   1038            MCG_C2 = temp_reg;
   \                     ??fbi_fbe_8: (+1)
   \   000000AC   0x....             LDR      R1,??DataTable17_2  ;; 0x40064001
   \   000000AE   0x700B             STRB     R3,[R1, #+0]
   1039          
   1040          // determine FRDIV based on reference clock frequency
   1041          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1042            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000B0   0x....             LDR      R1,??DataTable17_9  ;; 0x1312d1
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xDA01             BGE      ??fbi_fbe_10
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0xE014             B        ??fbi_fbe_11
   1043            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fbi_fbe_10: (+1)
   \   000000BA   0x....             LDR      R1,??DataTable17_10  ;; 0x2625a1
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xDA01             BGE      ??fbi_fbe_12
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0xE00F             B        ??fbi_fbe_11
   1044            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fbi_fbe_12: (+1)
   \   000000C4   0x....             LDR      R1,??DataTable17_11  ;; 0x4c4b41
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xDA01             BGE      ??fbi_fbe_13
   \   000000CA   0x2102             MOVS     R1,#+2
   \   000000CC   0xE00A             B        ??fbi_fbe_11
   1045            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fbi_fbe_13: (+1)
   \   000000CE   0x....             LDR      R1,??DataTable17_12  ;; 0x989681
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xDA01             BGE      ??fbi_fbe_14
   \   000000D4   0x2103             MOVS     R1,#+3
   \   000000D6   0xE005             B        ??fbi_fbe_11
   1046            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fbi_fbe_14: (+1)
   \   000000D8   0x....             LDR      R1,??DataTable17_13  ;; 0x1312d01
   \   000000DA   0x4288             CMP      R0,R1
   \   000000DC   0xDA01             BGE      ??fbi_fbe_15
   \   000000DE   0x2104             MOVS     R1,#+4
   \   000000E0   0xE000             B        ??fbi_fbe_11
   1047            else {frdiv_val = 5;}
   \                     ??fbi_fbe_15: (+1)
   \   000000E2   0x2105             MOVS     R1,#+5
   1048            
   1049          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1050          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1051          // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
   1052            temp_reg = MCG_C1;
   \                     ??fbi_fbe_11: (+1)
   \   000000E4   0x....             LDR      R3,??DataTable17_14  ;; 0x40064000
   \   000000E6   0x781B             LDRB     R3,[R3, #+0]
   1053            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   \   000000E8   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000EA   0x0F9B             LSRS     R3,R3,#+30
   1054            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   000000EC   0x001D             MOVS     R5,R3
   \   000000EE   0x00C9             LSLS     R1,R1,#+3
   \   000000F0   0x2438             MOVS     R4,#+56
   \   000000F2   0x400C             ANDS     R4,R4,R1
   \   000000F4   0x2380             MOVS     R3,#+128
   \   000000F6   0x4323             ORRS     R3,R3,R4
   \   000000F8   0x432B             ORRS     R3,R3,R5
   1055            MCG_C1 = temp_reg;
   \   000000FA   0x....             LDR      R1,??DataTable17_14  ;; 0x40064000
   \   000000FC   0x700B             STRB     R3,[R1, #+0]
   1056          
   1057          // if the external oscillator is used need to wait for OSCINIT to set
   1058            if (erefs_val)
   \   000000FE   0xB2D2             UXTB     R2,R2
   \   00000100   0x2A00             CMP      R2,#+0
   \   00000102   0xD010             BEQ      ??fbi_fbe_16
   1059            {
   1060              for (i = 0 ; i < 10000 ; i++)
   \   00000104   0x2100             MOVS     R1,#+0
   \   00000106   0xE000             B        ??fbi_fbe_17
   \                     ??fbi_fbe_18: (+1)
   \   00000108   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fbe_17: (+1)
   \   0000010A   0xB209             SXTH     R1,R1
   \   0000010C   0x....             LDR      R2,??DataTable17_15  ;; 0x2710
   \   0000010E   0x4291             CMP      R1,R2
   \   00000110   0xDA03             BGE      ??fbi_fbe_19
   1061              {
   1062                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   00000112   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   00000114   0x7812             LDRB     R2,[R2, #+0]
   \   00000116   0x0792             LSLS     R2,R2,#+30
   \   00000118   0xD5F6             BPL      ??fbi_fbe_18
   1063              }
   1064              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fbi_fbe_19: (+1)
   \   0000011A   0x....             LDR      R1,??DataTable17_1  ;; 0x40064006
   \   0000011C   0x7809             LDRB     R1,[R1, #+0]
   \   0000011E   0x0789             LSLS     R1,R1,#+30
   \   00000120   0xD401             BMI      ??fbi_fbe_16
   \   00000122   0x2023             MOVS     R0,#+35
   \   00000124   0xE031             B        ??fbi_fbe_2
   1065            }
   1066          
   1067          // wait for Reference clock Status bit to clear
   1068            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fbe_16: (+1)
   \   00000126   0x2100             MOVS     R1,#+0
   \   00000128   0xE000             B        ??fbi_fbe_20
   \                     ??fbi_fbe_21: (+1)
   \   0000012A   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fbe_20: (+1)
   \   0000012C   0xB209             SXTH     R1,R1
   \   0000012E   0x22FA             MOVS     R2,#+250
   \   00000130   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000132   0x4291             CMP      R1,R2
   \   00000134   0xDA03             BGE      ??fbi_fbe_22
   1069            {
   1070              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   00000136   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   00000138   0x7812             LDRB     R2,[R2, #+0]
   \   0000013A   0x06D2             LSLS     R2,R2,#+27
   \   0000013C   0xD4F5             BMI      ??fbi_fbe_21
   1071            }
   1072            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fbi_fbe_22: (+1)
   \   0000013E   0x....             LDR      R1,??DataTable17_1  ;; 0x40064006
   \   00000140   0x7809             LDRB     R1,[R1, #+0]
   \   00000142   0x06C9             LSLS     R1,R1,#+27
   \   00000144   0xD501             BPL      ??fbi_fbe_23
   \   00000146   0x2011             MOVS     R0,#+17
   \   00000148   0xE01F             B        ??fbi_fbe_2
   1073            
   1074          // Wait for clock status bits to show clock source is ext ref clk
   1075            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fbe_23: (+1)
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0xE000             B        ??fbi_fbe_24
   \                     ??fbi_fbe_25: (+1)
   \   0000014E   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fbe_24: (+1)
   \   00000150   0xB209             SXTH     R1,R1
   \   00000152   0x22FA             MOVS     R2,#+250
   \   00000154   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000156   0x4291             CMP      R1,R2
   \   00000158   0xDA07             BGE      ??fbi_fbe_26
   1076            {
   1077              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   0000015A   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   0000015C   0x7812             LDRB     R2,[R2, #+0]
   \   0000015E   0xB2D2             UXTB     R2,R2
   \   00000160   0x0892             LSRS     R2,R2,#+2
   \   00000162   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000164   0x0F92             LSRS     R2,R2,#+30
   \   00000166   0x2A02             CMP      R2,#+2
   \   00000168   0xD1F1             BNE      ??fbi_fbe_25
   1078            }
   1079            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fbi_fbe_26: (+1)
   \   0000016A   0x....             LDR      R1,??DataTable17_1  ;; 0x40064006
   \   0000016C   0x7809             LDRB     R1,[R1, #+0]
   \   0000016E   0xB2C9             UXTB     R1,R1
   \   00000170   0x0889             LSRS     R1,R1,#+2
   \   00000172   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000174   0x0F89             LSRS     R1,R1,#+30
   \   00000176   0x2902             CMP      R1,#+2
   \   00000178   0xD001             BEQ      ??fbi_fbe_27
   \   0000017A   0x201A             MOVS     R0,#+26
   \   0000017C   0xE005             B        ??fbi_fbe_2
   1080           
   1081          // Now in FBE  
   1082          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1083          // It is enabled here but can be removed if this is not required.
   1084            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fbi_fbe_27: (+1)
   \   0000017E   0x....             LDR      R1,??DataTable18  ;; 0x40064005
   \   00000180   0x7809             LDRB     R1,[R1, #+0]
   \   00000182   0x2220             MOVS     R2,#+32
   \   00000184   0x430A             ORRS     R2,R2,R1
   \   00000186   0x....             LDR      R1,??DataTable18  ;; 0x40064005
   \   00000188   0x700A             STRB     R2,[R1, #+0]
   1085            
   1086            return crystal_val; // MCGOUT frequency equals external clock frequency  
   \                     ??fbi_fbe_2: (+1)
   \   0000018A   0xBD30             POP      {R4,R5,PC}       ;; return
   1087          } // fbi_fbe
   1088          
   1089          
   1090          /********************************************************************/
   1091          /* Functon name : fbi_blpi
   1092           *
   1093           * Mode transition: FBI to BLPI mode
   1094           *
   1095           * This function transitions the MCG from FBI mode to BLPI mode. This is
   1096           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
   1097           * check so 0 is always returned if the function was called with the MCG
   1098           * in FBI mode. 
   1099           *
   1100           * Parameters: irc_freq - internal reference clock frequency
   1101           *             ircs_select - 0 if slow irc, 1 if fast irc
   1102           *
   1103           * Return value : MCGOUT frequency or error code 0x13
   1104           */

   \                                 In section .text, align 2, keep-with-next
   1105          int fbi_blpi(int irc_freq, unsigned char irc_select)
   1106          {
   \                     fbi_blpi: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1107            unsigned char fcrdiv_val;
   1108            
   1109          // check if in FBI mode
   1110            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1111                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1112                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1113                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD10B             BNE      ??fbi_blpi_0
   \   00000012   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD507             BPL      ??fbi_blpi_0
   \   0000001A   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0692             LSLS     R2,R2,#+26
   \   00000020   0xD403             BMI      ??fbi_blpi_0
   \   00000022   0x....             LDR      R2,??DataTable17_2  ;; 0x40064001
   \   00000024   0x7812             LDRB     R2,[R2, #+0]
   \   00000026   0x0792             LSLS     R2,R2,#+30
   \   00000028   0xD501             BPL      ??fbi_blpi_1
   1114            {  
   1115              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_blpi_0: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE014             B        ??fbi_blpi_2
   1116            }
   1117          
   1118          // Set LP bit to disable the FLL and enter BLPI
   1119            MCG_C2 |= MCG_C2_LP_MASK;
   \                     ??fbi_blpi_1: (+1)
   \   0000002E   0x....             LDR      R2,??DataTable17_2  ;; 0x40064001
   \   00000030   0x7812             LDRB     R2,[R2, #+0]
   \   00000032   0x2302             MOVS     R3,#+2
   \   00000034   0x4313             ORRS     R3,R3,R2
   \   00000036   0x....             LDR      R2,??DataTable17_2  ;; 0x40064001
   \   00000038   0x7013             STRB     R3,[R2, #+0]
   1120            
   1121          // Now in BLPI
   1122            if (irc_select)
   \   0000003A   0xB2C9             UXTB     R1,R1
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD00B             BEQ      ??fbi_blpi_3
   1123            {
   1124              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x....             LDR      R2,??DataTable17  ;; 0x40064008
   \   00000044   0x7812             LDRB     R2,[R2, #+0]
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0x0852             LSRS     R2,R2,#+1
   \   0000004A   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   0000004C   0x0F52             LSRS     R2,R2,#+29
   \   0000004E   0x4091             LSLS     R1,R1,R2
   1125              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x.... 0x....      BL       __aeabi_idiv
   \   00000056   0xE7FF             B        ??fbi_blpi_2
   1126            }
   1127            else
   1128            {
   1129              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fbi_blpi_3: (+1)
   \                     ??fbi_blpi_2: (+1)
   \   00000058   0xBD00             POP      {PC}             ;; return
   1130            }   
   1131          } // fbi_blpi
   1132          
   1133          
   1134          
   1135          /********************************************************************/
   1136          /* Functon name : blpi_fbi
   1137           *
   1138           * Mode transition: BLPI to FBI mode
   1139           *
   1140           * This function transitions the MCG from BLPI mode to FBI mode. This is
   1141           * achieved by clearing the MCG_C2[LP] bit. There is no status bit to 
   1142           * check so 0 is always returned if the function was called with the MCG
   1143           * in BLPI mode. 
   1144           *
   1145           * Parameters: irc_freq - internal reference clock frequency
   1146           *             ircs_select - 0 if slow irc, 1 if fast irc
   1147           *
   1148           * Return value : MCGOUT frequency or error code 0x15
   1149           */

   \                                 In section .text, align 2, keep-with-next
   1150          int blpi_fbi(int irc_freq, unsigned char irc_select)
   1151          {
   \                     blpi_fbi: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1152            unsigned char fcrdiv_val;
   1153            // check if in BLPI mode
   1154            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1155                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1156                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1157                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
   \   00000002   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD10B             BNE      ??blpi_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD507             BPL      ??blpi_fbi_0
   \   0000001A   0x....             LDR      R2,??DataTable17_1  ;; 0x40064006
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0692             LSLS     R2,R2,#+26
   \   00000020   0xD403             BMI      ??blpi_fbi_0
   \   00000022   0x....             LDR      R2,??DataTable17_2  ;; 0x40064001
   \   00000024   0x7812             LDRB     R2,[R2, #+0]
   \   00000026   0x0792             LSLS     R2,R2,#+30
   \   00000028   0xD401             BMI      ??blpi_fbi_1
   1158            {
   1159              return 0x5;                                                       // MCG not in correct mode return fail code
   \                     ??blpi_fbi_0: (+1)
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0xE014             B        ??blpi_fbi_2
   1160            }
   1161          
   1162          // Clear LP bit to enable the FLL and enter FBI mode   
   1163            MCG_C2 &= ~MCG_C2_LP_MASK;
   \                     ??blpi_fbi_1: (+1)
   \   0000002E   0x....             LDR      R2,??DataTable17_2  ;; 0x40064001
   \   00000030   0x7812             LDRB     R2,[R2, #+0]
   \   00000032   0x23FD             MOVS     R3,#+253
   \   00000034   0x4013             ANDS     R3,R3,R2
   \   00000036   0x....             LDR      R2,??DataTable17_2  ;; 0x40064001
   \   00000038   0x7013             STRB     R3,[R2, #+0]
   1164            
   1165          // Now in FBI mode
   1166            if (irc_select)
   \   0000003A   0xB2C9             UXTB     R1,R1
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD00B             BEQ      ??blpi_fbi_3
   1167            {
   1168              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x....             LDR      R2,??DataTable17  ;; 0x40064008
   \   00000044   0x7812             LDRB     R2,[R2, #+0]
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0x0852             LSRS     R2,R2,#+1
   \   0000004A   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   0000004C   0x0F52             LSRS     R2,R2,#+29
   \   0000004E   0x4091             LSLS     R1,R1,R2
   1169              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x.... 0x....      BL       __aeabi_idiv
   \   00000056   0xE7FF             B        ??blpi_fbi_2
   1170            }
   1171            else
   1172            {
   1173              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??blpi_fbi_3: (+1)
   \                     ??blpi_fbi_2: (+1)
   \   00000058   0xBD00             POP      {PC}             ;; return
   1174            }
   1175          } // blpi_fbi
   1176          
   1177          

   \                                 In section .text, align 2, keep-with-next
   1178          int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
   1179          {
   \                     fbi_fee: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0015             MOVS     R5,R2
   1180            unsigned char temp_reg;
   1181            unsigned char frdiv_val;
   1182            short i;
   1183            int mcg_out, fll_ref_freq;
   1184          
   1185          // check if in FBI mode
   1186            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1187                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1188                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1189                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000004   0x....             LDR      R2,??DataTable18_1  ;; 0x40064006
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0xB2D2             UXTB     R2,R2
   \   0000000A   0x0892             LSRS     R2,R2,#+2
   \   0000000C   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000E   0x0F92             LSRS     R2,R2,#+30
   \   00000010   0x2A01             CMP      R2,#+1
   \   00000012   0xD10B             BNE      ??fbi_fee_0
   \   00000014   0x....             LDR      R2,??DataTable18_1  ;; 0x40064006
   \   00000016   0x7812             LDRB     R2,[R2, #+0]
   \   00000018   0x06D2             LSLS     R2,R2,#+27
   \   0000001A   0xD507             BPL      ??fbi_fee_0
   \   0000001C   0x....             LDR      R2,??DataTable18_1  ;; 0x40064006
   \   0000001E   0x7812             LDRB     R2,[R2, #+0]
   \   00000020   0x0692             LSLS     R2,R2,#+26
   \   00000022   0xD403             BMI      ??fbi_fee_0
   \   00000024   0x....             LDR      R2,??DataTable18_2  ;; 0x40064001
   \   00000026   0x7812             LDRB     R2,[R2, #+0]
   \   00000028   0x0792             LSLS     R2,R2,#+30
   \   0000002A   0xD501             BPL      ??fbi_fee_1
   1190            {  
   1191              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fee_0: (+1)
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0xE0C0             B        ??fbi_fee_2
   1192            }
   1193            
   1194          // check external frequency is less than the maximum frequency
   1195            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fbi_fee_1: (+1)
   \   00000030   0x....             LDR      R2,??DataTable18_3  ;; 0x2faf081
   \   00000032   0x4290             CMP      R0,R2
   \   00000034   0xDB01             BLT      ??fbi_fee_3
   \   00000036   0x2021             MOVS     R0,#+33
   \   00000038   0xE0BB             B        ??fbi_fee_2
   1196            
   1197          // check crystal frequency is within spec. if crystal osc is being used
   1198            if (erefs_val)
   \                     ??fbi_fee_3: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD00C             BEQ      ??fbi_fee_4
   1199            {
   1200              if ((crystal_val < 30000) ||
   1201                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1202                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000040   0x....             LDR      R2,??DataTable18_4  ;; 0x7530
   \   00000042   0x4290             CMP      R0,R2
   \   00000044   0xDB07             BLT      ??fbi_fee_5
   \   00000046   0x....             LDR      R2,??DataTable18_5  ;; 0x9c41
   \   00000048   0x1A82             SUBS     R2,R0,R2
   \   0000004A   0x....             LDR      R3,??DataTable18_6  ;; 0x2d2a7f
   \   0000004C   0x429A             CMP      R2,R3
   \   0000004E   0xD302             BCC      ??fbi_fee_5
   \   00000050   0x....             LDR      R2,??DataTable18_7  ;; 0x1e84801
   \   00000052   0x4290             CMP      R0,R2
   \   00000054   0xDB01             BLT      ??fbi_fee_4
   \                     ??fbi_fee_5: (+1)
   \   00000056   0x2022             MOVS     R0,#+34
   \   00000058   0xE0AB             B        ??fbi_fee_2
   1203            }
   1204          
   1205          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1206            if (hgo_val > 0)
   \                     ??fbi_fee_4: (+1)
   \   0000005A   0xB2C9             UXTB     R1,R1
   \   0000005C   0x2900             CMP      R1,#+0
   \   0000005E   0xD000             BEQ      ??fbi_fee_6
   1207            {
   1208              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000060   0x2101             MOVS     R1,#+1
   1209            }
   1210          
   1211          // configure the MCG_C2 register
   1212          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1213          // it still needs to be set correctly even if the oscillator is not being used
   1214            temp_reg = MCG_C2;
   \                     ??fbi_fee_6: (+1)
   \   00000062   0x....             LDR      R2,??DataTable18_2  ;; 0x40064001
   \   00000064   0x7812             LDRB     R2,[R2, #+0]
   1215            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   00000066   0x0013             MOVS     R3,R2
   \   00000068   0x22C3             MOVS     R2,#+195
   \   0000006A   0x401A             ANDS     R2,R2,R3
   1216            if (crystal_val <= 40000)
   \   0000006C   0x....             LDR      R3,??DataTable18_5  ;; 0x9c41
   \   0000006E   0x4298             CMP      R0,R3
   \   00000070   0xDA07             BGE      ??fbi_fee_7
   1217            {
   1218              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000072   0x0013             MOVS     R3,R2
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x00C9             LSLS     R1,R1,#+3
   \   00000078   0xB2ED             UXTB     R5,R5
   \   0000007A   0x00AA             LSLS     R2,R5,#+2
   \   0000007C   0x430A             ORRS     R2,R2,R1
   \   0000007E   0x431A             ORRS     R2,R2,R3
   \   00000080   0xE015             B        ??fbi_fee_8
   1219            }
   1220            else if (crystal_val <= 8000000)
   \                     ??fbi_fee_7: (+1)
   \   00000082   0x....             LDR      R3,??DataTable18_8  ;; 0x7a1201
   \   00000084   0x4298             CMP      R0,R3
   \   00000086   0xDA09             BGE      ??fbi_fee_9
   1221            {
   1222              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000088   0xB2C9             UXTB     R1,R1
   \   0000008A   0x00C9             LSLS     R1,R1,#+3
   \   0000008C   0x2310             MOVS     R3,#+16
   \   0000008E   0x430B             ORRS     R3,R3,R1
   \   00000090   0xB2ED             UXTB     R5,R5
   \   00000092   0x00A9             LSLS     R1,R5,#+2
   \   00000094   0x4319             ORRS     R1,R1,R3
   \   00000096   0x4311             ORRS     R1,R1,R2
   \   00000098   0x000A             MOVS     R2,R1
   \   0000009A   0xE008             B        ??fbi_fee_8
   1223            }
   1224            else
   1225            {
   1226              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fbi_fee_9: (+1)
   \   0000009C   0x0014             MOVS     R4,R2
   \   0000009E   0xB2C9             UXTB     R1,R1
   \   000000A0   0x00C9             LSLS     R1,R1,#+3
   \   000000A2   0x2320             MOVS     R3,#+32
   \   000000A4   0x430B             ORRS     R3,R3,R1
   \   000000A6   0xB2ED             UXTB     R5,R5
   \   000000A8   0x00AA             LSLS     R2,R5,#+2
   \   000000AA   0x431A             ORRS     R2,R2,R3
   \   000000AC   0x4322             ORRS     R2,R2,R4
   1227            }
   1228            MCG_C2 = temp_reg;
   \                     ??fbi_fee_8: (+1)
   \   000000AE   0x....             LDR      R1,??DataTable18_2  ;; 0x40064001
   \   000000B0   0x700A             STRB     R2,[R1, #+0]
   1229          
   1230          // determine FRDIV based on reference clock frequency
   1231          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1232            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000B2   0x....             LDR      R1,??DataTable19  ;; 0x1312d1
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xDA01             BGE      ??fbi_fee_10
   \   000000B8   0x2400             MOVS     R4,#+0
   \   000000BA   0xE014             B        ??fbi_fee_11
   1233            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fbi_fee_10: (+1)
   \   000000BC   0x....             LDR      R1,??DataTable19_1  ;; 0x2625a1
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xDA01             BGE      ??fbi_fee_12
   \   000000C2   0x2401             MOVS     R4,#+1
   \   000000C4   0xE00F             B        ??fbi_fee_11
   1234            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fbi_fee_12: (+1)
   \   000000C6   0x....             LDR      R1,??DataTable19_2  ;; 0x4c4b41
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xDA01             BGE      ??fbi_fee_13
   \   000000CC   0x2402             MOVS     R4,#+2
   \   000000CE   0xE00A             B        ??fbi_fee_11
   1235            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fbi_fee_13: (+1)
   \   000000D0   0x....             LDR      R1,??DataTable19_3  ;; 0x989681
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xDA01             BGE      ??fbi_fee_14
   \   000000D6   0x2403             MOVS     R4,#+3
   \   000000D8   0xE005             B        ??fbi_fee_11
   1236            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fbi_fee_14: (+1)
   \   000000DA   0x....             LDR      R1,??DataTable19_4  ;; 0x1312d01
   \   000000DC   0x4288             CMP      R0,R1
   \   000000DE   0xDA01             BGE      ??fbi_fee_15
   \   000000E0   0x2404             MOVS     R4,#+4
   \   000000E2   0xE000             B        ??fbi_fee_11
   1237            else {frdiv_val = 5;}
   \                     ??fbi_fee_15: (+1)
   \   000000E4   0x2405             MOVS     R4,#+5
   1238          // The FLL ref clk divide value depends on FRDIV and the RANGE value
   1239            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fbi_fee_11: (+1)
   \   000000E6   0x....             LDR      R1,??DataTable18_2  ;; 0x40064001
   \   000000E8   0x7809             LDRB     R1,[R1, #+0]
   \   000000EA   0xB2C9             UXTB     R1,R1
   \   000000EC   0x0909             LSRS     R1,R1,#+4
   \   000000EE   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000F0   0x0F89             LSRS     R1,R1,#+30
   \   000000F2   0x2900             CMP      R1,#+0
   \   000000F4   0xD004             BEQ      ??fbi_fee_16
   1240            {
   1241              fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
   \   000000F6   0x2120             MOVS     R1,#+32
   \   000000F8   0x40A1             LSLS     R1,R1,R4
   \   000000FA   0x.... 0x....      BL       __aeabi_idiv
   \   000000FE   0xE003             B        ??fbi_fee_17
   1242            }
   1243            else
   1244            {
   1245              fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
   \                     ??fbi_fee_16: (+1)
   \   00000100   0x2101             MOVS     R1,#+1
   \   00000102   0x40A1             LSLS     R1,R1,R4
   \   00000104   0x.... 0x....      BL       __aeabi_idiv
   1246            }
   1247            
   1248          // Check resulting FLL frequency 
   1249            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \                     ??fbi_fee_17: (+1)
   \   00000108   0x.... 0x....      BL       fll_freq
   1250            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   0000010C   0x283C             CMP      R0,#+60
   \   0000010E   0xDB50             BLT      ??fbi_fee_2
   1251            
   1252          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1253          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1254          // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
   1255            temp_reg = MCG_C1;
   \                     ??fbi_fee_18: (+1)
   \   00000110   0x....             LDR      R1,??DataTable19_5  ;; 0x40064000
   \   00000112   0x780A             LDRB     R2,[R1, #+0]
   1256            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and IREFS fields
   \   00000114   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000116   0x0F92             LSRS     R2,R2,#+30
   1257            temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   00000118   0x0013             MOVS     R3,R2
   \   0000011A   0x00E1             LSLS     R1,R4,#+3
   \   0000011C   0x2238             MOVS     R2,#+56
   \   0000011E   0x400A             ANDS     R2,R2,R1
   \   00000120   0x431A             ORRS     R2,R2,R3
   1258            MCG_C1 = temp_reg;
   \   00000122   0x....             LDR      R1,??DataTable19_5  ;; 0x40064000
   \   00000124   0x700A             STRB     R2,[R1, #+0]
   1259          
   1260          // if the external oscillator is used need to wait for OSCINIT to set
   1261            if (erefs_val)
   \   00000126   0xB2ED             UXTB     R5,R5
   \   00000128   0x2D00             CMP      R5,#+0
   \   0000012A   0xD010             BEQ      ??fbi_fee_19
   1262            {
   1263              for (i = 0 ; i < 10000 ; i++)
   \   0000012C   0x2100             MOVS     R1,#+0
   \   0000012E   0xE000             B        ??fbi_fee_20
   \                     ??fbi_fee_21: (+1)
   \   00000130   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fee_20: (+1)
   \   00000132   0xB209             SXTH     R1,R1
   \   00000134   0x....             LDR      R2,??DataTable19_6  ;; 0x2710
   \   00000136   0x4291             CMP      R1,R2
   \   00000138   0xDA03             BGE      ??fbi_fee_22
   1264              {
   1265                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   0000013A   0x....             LDR      R2,??DataTable18_1  ;; 0x40064006
   \   0000013C   0x7812             LDRB     R2,[R2, #+0]
   \   0000013E   0x0792             LSLS     R2,R2,#+30
   \   00000140   0xD5F6             BPL      ??fbi_fee_21
   1266              }
   1267              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fbi_fee_22: (+1)
   \   00000142   0x....             LDR      R1,??DataTable18_1  ;; 0x40064006
   \   00000144   0x7809             LDRB     R1,[R1, #+0]
   \   00000146   0x0789             LSLS     R1,R1,#+30
   \   00000148   0xD401             BMI      ??fbi_fee_19
   \   0000014A   0x2023             MOVS     R0,#+35
   \   0000014C   0xE031             B        ??fbi_fee_2
   1268            }
   1269          
   1270          // wait for Reference clock Status bit to clear
   1271            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fee_19: (+1)
   \   0000014E   0x2100             MOVS     R1,#+0
   \   00000150   0xE000             B        ??fbi_fee_23
   \                     ??fbi_fee_24: (+1)
   \   00000152   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fee_23: (+1)
   \   00000154   0xB209             SXTH     R1,R1
   \   00000156   0x22FA             MOVS     R2,#+250
   \   00000158   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000015A   0x4291             CMP      R1,R2
   \   0000015C   0xDA03             BGE      ??fbi_fee_25
   1272            {
   1273              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   0000015E   0x....             LDR      R2,??DataTable18_1  ;; 0x40064006
   \   00000160   0x7812             LDRB     R2,[R2, #+0]
   \   00000162   0x06D2             LSLS     R2,R2,#+27
   \   00000164   0xD4F5             BMI      ??fbi_fee_24
   1274            }
   1275            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fbi_fee_25: (+1)
   \   00000166   0x....             LDR      R1,??DataTable18_1  ;; 0x40064006
   \   00000168   0x7809             LDRB     R1,[R1, #+0]
   \   0000016A   0x06C9             LSLS     R1,R1,#+27
   \   0000016C   0xD501             BPL      ??fbi_fee_26
   \   0000016E   0x2011             MOVS     R0,#+17
   \   00000170   0xE01F             B        ??fbi_fee_2
   1276            
   1277          // Wait for clock status bits to show clock source is ext ref clk
   1278            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fee_26: (+1)
   \   00000172   0x2100             MOVS     R1,#+0
   \   00000174   0xE000             B        ??fbi_fee_27
   \                     ??fbi_fee_28: (+1)
   \   00000176   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fee_27: (+1)
   \   00000178   0xB209             SXTH     R1,R1
   \   0000017A   0x22FA             MOVS     R2,#+250
   \   0000017C   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000017E   0x4291             CMP      R1,R2
   \   00000180   0xDA07             BGE      ??fbi_fee_29
   1279            {
   1280              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL selected before loop finishes
   \   00000182   0x....             LDR      R2,??DataTable18_1  ;; 0x40064006
   \   00000184   0x7812             LDRB     R2,[R2, #+0]
   \   00000186   0xB2D2             UXTB     R2,R2
   \   00000188   0x0892             LSRS     R2,R2,#+2
   \   0000018A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000018C   0x0F92             LSRS     R2,R2,#+30
   \   0000018E   0x2A00             CMP      R2,#+0
   \   00000190   0xD1F1             BNE      ??fbi_fee_28
   1281            }
   1282            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is really selected and return with error if not
   \                     ??fbi_fee_29: (+1)
   \   00000192   0x....             LDR      R1,??DataTable18_1  ;; 0x40064006
   \   00000194   0x7809             LDRB     R1,[R1, #+0]
   \   00000196   0xB2C9             UXTB     R1,R1
   \   00000198   0x0889             LSRS     R1,R1,#+2
   \   0000019A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000019C   0x0F89             LSRS     R1,R1,#+30
   \   0000019E   0x2900             CMP      R1,#+0
   \   000001A0   0xD001             BEQ      ??fbi_fee_30
   \   000001A2   0x2018             MOVS     R0,#+24
   \   000001A4   0xE005             B        ??fbi_fee_2
   1283           
   1284          // Now in FEE  
   1285          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1286          // It is enabled here but can be removed if this is not required.
   1287          // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and BLPI)
   1288            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fbi_fee_30: (+1)
   \   000001A6   0x....             LDR      R1,??DataTable20  ;; 0x40064005
   \   000001A8   0x7809             LDRB     R1,[R1, #+0]
   \   000001AA   0x2220             MOVS     R2,#+32
   \   000001AC   0x430A             ORRS     R2,R2,R1
   \   000001AE   0x....             LDR      R1,??DataTable20  ;; 0x40064005
   \   000001B0   0x700A             STRB     R2,[R1, #+0]
   1289            
   1290            return mcg_out; // MCGOUT frequency equals FLL frequency
   \                     ??fbi_fee_2: (+1)
   \   000001B2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1291          } //fbi_fee
   1292          
   1293          

   \                                 In section .text, align 2, keep-with-next
   1294          int fee_fbi(int irc_freq, unsigned char irc_select)
   1295          { 
   \                     fee_fbi: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1296            unsigned char fcrdiv_val;
   1297            short i;
   1298            
   1299          // Check MCG is in FEE mode
   1300            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1301                (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external ref clk
   1302                (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R2,??DataTable20_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD107             BNE      ??fee_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable20_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD403             BMI      ??fee_fbi_0
   \   0000001A   0x....             LDR      R2,??DataTable20_1  ;; 0x40064006
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0692             LSLS     R2,R2,#+26
   \   00000020   0xD501             BPL      ??fee_fbi_1
   1303            {
   1304              return 0x2;                                                     // return error code
   \                     ??fee_fbi_0: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE08E             B        ??fee_fbi_2
   1305            }
   1306            
   1307            // Check that the irc frequency matches the selected IRC 
   1308            if (!(irc_select))
   \                     ??fee_fbi_1: (+1)
   \   00000026   0xB2C9             UXTB     R1,R1
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD106             BNE      ??fee_fbi_3
   1309            {    
   1310              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   0000002C   0x....             LDR      R2,??DataTable20_2  ;; 0x7a12
   \   0000002E   0x1A82             SUBS     R2,R0,R2
   \   00000030   0x....             LDR      R3,??DataTable20_3  ;; 0x1e86
   \   00000032   0x429A             CMP      R2,R3
   \   00000034   0xD308             BCC      ??fee_fbi_4
   \   00000036   0x2031             MOVS     R0,#+49
   \   00000038   0xE084             B        ??fee_fbi_2
   1311            }
   1312            else
   1313            {
   1314              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fee_fbi_3: (+1)
   \   0000003A   0x....             LDR      R2,??DataTable20_4  ;; 0x2dc6c0
   \   0000003C   0x1A82             SUBS     R2,R0,R2
   \   0000003E   0x....             LDR      R3,??DataTable20_5  ;; 0x1e8481
   \   00000040   0x429A             CMP      R2,R3
   \   00000042   0xD301             BCC      ??fee_fbi_4
   \   00000044   0x2032             MOVS     R0,#+50
   \   00000046   0xE07D             B        ??fee_fbi_2
   1315            }
   1316            
   1317          // Select the required IRC
   1318            if (irc_select)
   \                     ??fee_fbi_4: (+1)
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD006             BEQ      ??fee_fbi_5
   1319            {
   1320              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
   \   0000004E   0x....             LDR      R2,??DataTable20_6  ;; 0x40064001
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0x2301             MOVS     R3,#+1
   \   00000054   0x4313             ORRS     R3,R3,R2
   \   00000056   0x....             LDR      R2,??DataTable20_6  ;; 0x40064001
   \   00000058   0x7013             STRB     R3,[R2, #+0]
   \   0000005A   0xE005             B        ??fee_fbi_6
   1321            }
   1322            else
   1323            {
   1324              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
   \                     ??fee_fbi_5: (+1)
   \   0000005C   0x....             LDR      R2,??DataTable20_6  ;; 0x40064001
   \   0000005E   0x7812             LDRB     R2,[R2, #+0]
   \   00000060   0x23FE             MOVS     R3,#+254
   \   00000062   0x4013             ANDS     R3,R3,R2
   \   00000064   0x....             LDR      R2,??DataTable20_6  ;; 0x40064001
   \   00000066   0x7013             STRB     R3,[R2, #+0]
   1325            }
   1326            
   1327          // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
   1328            MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??fee_fbi_6: (+1)
   \   00000068   0x....             LDR      R2,??DataTable20  ;; 0x40064005
   \   0000006A   0x7812             LDRB     R2,[R2, #+0]
   \   0000006C   0x23DF             MOVS     R3,#+223
   \   0000006E   0x4013             ANDS     R3,R3,R2
   \   00000070   0x....             LDR      R2,??DataTable20  ;; 0x40064005
   \   00000072   0x7013             STRB     R3,[R2, #+0]
   1329            
   1330          // Select the IRC as the CLKS mux selection
   1331            MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
   \   00000074   0x....             LDR      R2,??DataTable19_5  ;; 0x40064000
   \   00000076   0x7812             LDRB     R2,[R2, #+0]
   \   00000078   0x2344             MOVS     R3,#+68
   \   0000007A   0x4313             ORRS     R3,R3,R2
   \   0000007C   0x....             LDR      R2,??DataTable19_5  ;; 0x40064000
   \   0000007E   0x7013             STRB     R3,[R2, #+0]
   1332           
   1333          // wait until internal reference switches to requested irc.
   1334            if (!(irc_select))
   \   00000080   0xB2C9             UXTB     R1,R1
   \   00000082   0x2900             CMP      R1,#+0
   \   00000084   0xD111             BNE      ??fee_fbi_7
   1335            {
   1336              for (i = 0 ; i < 2000 ; i++)
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0xE000             B        ??fee_fbi_8
   \                     ??fee_fbi_9: (+1)
   \   0000008A   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_8: (+1)
   \   0000008C   0xB212             SXTH     R2,R2
   \   0000008E   0x23FA             MOVS     R3,#+250
   \   00000090   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   00000092   0x429A             CMP      R2,R3
   \   00000094   0xDA03             BGE      ??fee_fbi_10
   1337              {
   1338                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \   00000096   0x....             LDR      R3,??DataTable20_1  ;; 0x40064006
   \   00000098   0x781B             LDRB     R3,[R3, #+0]
   \   0000009A   0x07DB             LSLS     R3,R3,#+31
   \   0000009C   0xD4F5             BMI      ??fee_fbi_9
   1339              }
   1340              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fee_fbi_10: (+1)
   \   0000009E   0x....             LDR      R2,??DataTable20_1  ;; 0x40064006
   \   000000A0   0x7812             LDRB     R2,[R2, #+0]
   \   000000A2   0x07D2             LSLS     R2,R2,#+31
   \   000000A4   0xD513             BPL      ??fee_fbi_11
   \   000000A6   0x2013             MOVS     R0,#+19
   \   000000A8   0xE04C             B        ??fee_fbi_2
   1341            }
   1342            else
   1343            {
   1344              for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_7: (+1)
   \   000000AA   0x2200             MOVS     R2,#+0
   \   000000AC   0xE000             B        ??fee_fbi_12
   \                     ??fee_fbi_13: (+1)
   \   000000AE   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_12: (+1)
   \   000000B0   0xB212             SXTH     R2,R2
   \   000000B2   0x23FA             MOVS     R3,#+250
   \   000000B4   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000B6   0x429A             CMP      R2,R3
   \   000000B8   0xDA03             BGE      ??fee_fbi_14
   1345              {
   1346                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \   000000BA   0x....             LDR      R3,??DataTable20_1  ;; 0x40064006
   \   000000BC   0x781B             LDRB     R3,[R3, #+0]
   \   000000BE   0x07DB             LSLS     R3,R3,#+31
   \   000000C0   0xD5F5             BPL      ??fee_fbi_13
   1347              }
   1348              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fee_fbi_14: (+1)
   \   000000C2   0x....             LDR      R2,??DataTable20_1  ;; 0x40064006
   \   000000C4   0x7812             LDRB     R2,[R2, #+0]
   \   000000C6   0x07D2             LSLS     R2,R2,#+31
   \   000000C8   0xD401             BMI      ??fee_fbi_11
   \   000000CA   0x2014             MOVS     R0,#+20
   \   000000CC   0xE03A             B        ??fee_fbi_2
   1349            }
   1350            
   1351          // Wait for clock status bits to update
   1352            for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_11: (+1)
   \   000000CE   0x2200             MOVS     R2,#+0
   \   000000D0   0xE000             B        ??fee_fbi_15
   \                     ??fee_fbi_16: (+1)
   \   000000D2   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_15: (+1)
   \   000000D4   0xB212             SXTH     R2,R2
   \   000000D6   0x23FA             MOVS     R3,#+250
   \   000000D8   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000DA   0x429A             CMP      R2,R3
   \   000000DC   0xDA07             BGE      ??fee_fbi_17
   1353            {
   1354              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \   000000DE   0x....             LDR      R3,??DataTable20_1  ;; 0x40064006
   \   000000E0   0x781B             LDRB     R3,[R3, #+0]
   \   000000E2   0xB2DB             UXTB     R3,R3
   \   000000E4   0x089B             LSRS     R3,R3,#+2
   \   000000E6   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000E8   0x0F9B             LSRS     R3,R3,#+30
   \   000000EA   0x2B01             CMP      R3,#+1
   \   000000EC   0xD1F1             BNE      ??fee_fbi_16
   1355            }
   1356            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fee_fbi_17: (+1)
   \   000000EE   0x....             LDR      R2,??DataTable20_1  ;; 0x40064006
   \   000000F0   0x7812             LDRB     R2,[R2, #+0]
   \   000000F2   0xB2D2             UXTB     R2,R2
   \   000000F4   0x0892             LSRS     R2,R2,#+2
   \   000000F6   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000F8   0x0F92             LSRS     R2,R2,#+30
   \   000000FA   0x2A01             CMP      R2,#+1
   \   000000FC   0xD001             BEQ      ??fee_fbi_18
   \   000000FE   0x2019             MOVS     R0,#+25
   \   00000100   0xE020             B        ??fee_fbi_2
   1357            
   1358          // wait for Reference clock Status bit to set
   1359            for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_18: (+1)
   \   00000102   0x2200             MOVS     R2,#+0
   \   00000104   0xE000             B        ??fee_fbi_19
   \                     ??fee_fbi_20: (+1)
   \   00000106   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_19: (+1)
   \   00000108   0xB212             SXTH     R2,R2
   \   0000010A   0x23FA             MOVS     R3,#+250
   \   0000010C   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   0000010E   0x429A             CMP      R2,R3
   \   00000110   0xDA03             BGE      ??fee_fbi_21
   1360            {
   1361              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   00000112   0x....             LDR      R3,??DataTable20_1  ;; 0x40064006
   \   00000114   0x781B             LDRB     R3,[R3, #+0]
   \   00000116   0x06DB             LSLS     R3,R3,#+27
   \   00000118   0xD5F5             BPL      ??fee_fbi_20
   1362            }
   1363            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set  
   \                     ??fee_fbi_21: (+1)
   \   0000011A   0x....             LDR      R2,??DataTable20_1  ;; 0x40064006
   \   0000011C   0x7812             LDRB     R2,[R2, #+0]
   \   0000011E   0x06D2             LSLS     R2,R2,#+27
   \   00000120   0xD401             BMI      ??fee_fbi_22
   \   00000122   0x2012             MOVS     R0,#+18
   \   00000124   0xE00E             B        ??fee_fbi_2
   1364            
   1365          // Now in FBI mode
   1366            if (irc_select)
   \                     ??fee_fbi_22: (+1)
   \   00000126   0xB2C9             UXTB     R1,R1
   \   00000128   0x2900             CMP      R1,#+0
   \   0000012A   0xD00B             BEQ      ??fee_fbi_23
   1367            {
   1368              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   0000012C   0x2101             MOVS     R1,#+1
   \   0000012E   0x....             LDR      R2,??DataTable21  ;; 0x40064008
   \   00000130   0x7812             LDRB     R2,[R2, #+0]
   \   00000132   0xB2D2             UXTB     R2,R2
   \   00000134   0x0852             LSRS     R2,R2,#+1
   \   00000136   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000138   0x0F52             LSRS     R2,R2,#+29
   \   0000013A   0x4091             LSLS     R1,R1,R2
   1369              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   0000013C   0xB2C9             UXTB     R1,R1
   \   0000013E   0x.... 0x....      BL       __aeabi_idiv
   \   00000142   0xE7FF             B        ??fee_fbi_2
   1370            }
   1371            else
   1372            {
   1373              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fee_fbi_23: (+1)
   \                     ??fee_fbi_2: (+1)
   \   00000144   0xBD00             POP      {PC}             ;; return
   1374            }
   1375          } // fee_fbi 
   1376          
   1377          

   \                                 In section .text, align 2, keep-with-next
   1378          int fbi_fei(int slow_irc_freq)
   1379          {
   \                     fbi_fei: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1380            unsigned char temp_reg;
   1381            short i;
   1382            int mcg_out;
   1383          
   1384          // check if in FBI mode
   1385            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1386                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1387                (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
   1388                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x....             LDR      R1,??DataTable21_1  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD10B             BNE      ??fbi_fei_0
   \   00000012   0x....             LDR      R1,??DataTable21_1  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD507             BPL      ??fbi_fei_0
   \   0000001A   0x....             LDR      R1,??DataTable21_1  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD403             BMI      ??fbi_fei_0
   \   00000022   0x....             LDR      R1,??DataTable20_6  ;; 0x40064001
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0x0789             LSLS     R1,R1,#+30
   \   00000028   0xD501             BPL      ??fbi_fei_1
   1389            {  
   1390              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fei_0: (+1)
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE03F             B        ??fbi_fei_2
   1391            }
   1392          
   1393          // Check IRC frequency is within spec.
   1394            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fbi_fei_1: (+1)
   \   0000002E   0x....             LDR      R1,??DataTable20_2  ;; 0x7a12
   \   00000030   0x1A41             SUBS     R1,R0,R1
   \   00000032   0x....             LDR      R2,??DataTable20_3  ;; 0x1e86
   \   00000034   0x4291             CMP      R1,R2
   \   00000036   0xD301             BCC      ??fbi_fei_3
   1395            {
   1396              return 0x31;
   \   00000038   0x2031             MOVS     R0,#+49
   \   0000003A   0xE038             B        ??fbi_fei_2
   1397            }
   1398          
   1399          // Check resulting FLL frequency 
   1400            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fbi_fei_3: (+1)
   \   0000003C   0x.... 0x....      BL       fll_freq
   1401            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000040   0x283C             CMP      R0,#+60
   \   00000042   0xDB34             BLT      ??fbi_fei_2
   1402            
   1403          // Change the CLKS mux to select the FLL output as MCGOUT  
   1404            temp_reg = MCG_C1;
   \                     ??fbi_fei_4: (+1)
   \   00000044   0x....             LDR      R1,??DataTable21_2  ;; 0x40064000
   \   00000046   0x7809             LDRB     R1,[R1, #+0]
   1405            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
   \   00000048   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   0000004A   0x0E89             LSRS     R1,R1,#+26
   1406            temp_reg |= MCG_C1_CLKS(0); // select FLL as MCGOUT
   1407            temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
   \   0000004C   0x000A             MOVS     R2,R1
   \   0000004E   0x2104             MOVS     R1,#+4
   \   00000050   0x4311             ORRS     R1,R1,R2
   1408            MCG_C1 = temp_reg; // update MCG_C1
   \   00000052   0x....             LDR      R2,??DataTable21_2  ;; 0x40064000
   \   00000054   0x7011             STRB     R1,[R2, #+0]
   1409            
   1410          // wait for Reference clock Status bit to clear
   1411            for (i = 0 ; i < 2000 ; i++)
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xE000             B        ??fbi_fei_5
   \                     ??fbi_fei_6: (+1)
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fei_5: (+1)
   \   0000005C   0xB209             SXTH     R1,R1
   \   0000005E   0x22FA             MOVS     R2,#+250
   \   00000060   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000062   0x4291             CMP      R1,R2
   \   00000064   0xDA03             BGE      ??fbi_fei_7
   1412            {
   1413              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
   \   00000066   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   00000068   0x7812             LDRB     R2,[R2, #+0]
   \   0000006A   0x06D2             LSLS     R2,R2,#+27
   \   0000006C   0xD5F5             BPL      ??fbi_fei_6
   1414            }
   1415            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbi_fei_7: (+1)
   \   0000006E   0x....             LDR      R1,??DataTable21_1  ;; 0x40064006
   \   00000070   0x7809             LDRB     R1,[R1, #+0]
   \   00000072   0x06C9             LSLS     R1,R1,#+27
   \   00000074   0xD401             BMI      ??fbi_fei_8
   \   00000076   0x2012             MOVS     R0,#+18
   \   00000078   0xE019             B        ??fbi_fei_2
   1416            
   1417          // Wait for clock status bits to show clock source is ext ref clk
   1418            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fei_8: (+1)
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0xE000             B        ??fbi_fei_9
   \                     ??fbi_fei_10: (+1)
   \   0000007E   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fei_9: (+1)
   \   00000080   0xB209             SXTH     R1,R1
   \   00000082   0x22FA             MOVS     R2,#+250
   \   00000084   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000086   0x4291             CMP      R1,R2
   \   00000088   0xDA07             BGE      ??fbi_fei_11
   1419            {
   1420              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL slected before loop finishes
   \   0000008A   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   0000008C   0x7812             LDRB     R2,[R2, #+0]
   \   0000008E   0xB2D2             UXTB     R2,R2
   \   00000090   0x0892             LSRS     R2,R2,#+2
   \   00000092   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000094   0x0F92             LSRS     R2,R2,#+30
   \   00000096   0x2A00             CMP      R2,#+0
   \   00000098   0xD1F1             BNE      ??fbi_fei_10
   1421            }
   1422            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really selected and return with error if not
   \                     ??fbi_fei_11: (+1)
   \   0000009A   0x....             LDR      R1,??DataTable21_1  ;; 0x40064006
   \   0000009C   0x7809             LDRB     R1,[R1, #+0]
   \   0000009E   0xB2C9             UXTB     R1,R1
   \   000000A0   0x0889             LSRS     R1,R1,#+2
   \   000000A2   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000A4   0x0F89             LSRS     R1,R1,#+30
   \   000000A6   0x2900             CMP      R1,#+0
   \   000000A8   0xD001             BEQ      ??fbi_fei_12
   \   000000AA   0x2018             MOVS     R0,#+24
   \   000000AC   0xE7FF             B        ??fbi_fei_2
   1423          
   1424          // Now in FEI mode
   1425            return mcg_out;  
   \                     ??fbi_fei_12: (+1)
   \                     ??fbi_fei_2: (+1)
   \   000000AE   0xBD02             POP      {R1,PC}          ;; return
   1426          } // fbi_fei
   1427          
   1428          

   \                                 In section .text, align 2, keep-with-next
   1429          int fei_fbi(int irc_freq, unsigned char irc_select)
   1430          {
   \                     fei_fbi: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1431            unsigned char temp_reg;
   1432            unsigned char fcrdiv_val;
   1433            short i;
   1434            
   1435          // Check MCG is in FEI mode
   1436            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1437                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1438                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD107             BNE      ??fei_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD503             BPL      ??fei_fbi_0
   \   0000001A   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0692             LSLS     R2,R2,#+26
   \   00000020   0xD501             BPL      ??fei_fbi_1
   1439            {
   1440              return 0x1;                                                       // return error code
   \                     ??fei_fbi_0: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE079             B        ??fei_fbi_2
   1441            } 
   1442          
   1443          // Check that the irc frequency matches the selected IRC 
   1444            if (!(irc_select))
   \                     ??fei_fbi_1: (+1)
   \   00000026   0xB2C9             UXTB     R1,R1
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD106             BNE      ??fei_fbi_3
   1445            {    
   1446              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   0000002C   0x....             LDR      R2,??DataTable21_3  ;; 0x7a12
   \   0000002E   0x1A82             SUBS     R2,R0,R2
   \   00000030   0x....             LDR      R3,??DataTable22  ;; 0x1e86
   \   00000032   0x429A             CMP      R2,R3
   \   00000034   0xD308             BCC      ??fei_fbi_4
   \   00000036   0x2031             MOVS     R0,#+49
   \   00000038   0xE06F             B        ??fei_fbi_2
   1447            }
   1448            else
   1449            {
   1450              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fei_fbi_3: (+1)
   \   0000003A   0x....             LDR      R2,??DataTable22_1  ;; 0x2dc6c0
   \   0000003C   0x1A82             SUBS     R2,R0,R2
   \   0000003E   0x....             LDR      R3,??DataTable22_2  ;; 0x1e8481
   \   00000040   0x429A             CMP      R2,R3
   \   00000042   0xD301             BCC      ??fei_fbi_4
   \   00000044   0x2032             MOVS     R0,#+50
   \   00000046   0xE068             B        ??fei_fbi_2
   1451            }
   1452            
   1453          // Select the desired IRC
   1454            if (irc_select)
   \                     ??fei_fbi_4: (+1)
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD006             BEQ      ??fei_fbi_5
   1455            {
   1456              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
   \   0000004E   0x....             LDR      R2,??DataTable22_3  ;; 0x40064001
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0x2301             MOVS     R3,#+1
   \   00000054   0x4313             ORRS     R3,R3,R2
   \   00000056   0x....             LDR      R2,??DataTable22_3  ;; 0x40064001
   \   00000058   0x7013             STRB     R3,[R2, #+0]
   \   0000005A   0xE005             B        ??fei_fbi_6
   1457            }
   1458            else
   1459            {
   1460              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
   \                     ??fei_fbi_5: (+1)
   \   0000005C   0x....             LDR      R2,??DataTable22_3  ;; 0x40064001
   \   0000005E   0x7812             LDRB     R2,[R2, #+0]
   \   00000060   0x23FE             MOVS     R3,#+254
   \   00000062   0x4013             ANDS     R3,R3,R2
   \   00000064   0x....             LDR      R2,??DataTable22_3  ;; 0x40064001
   \   00000066   0x7013             STRB     R3,[R2, #+0]
   1461            }
   1462            
   1463          // Change the CLKS mux to select the IRC as the MCGOUT
   1464            temp_reg = MCG_C1;
   \                     ??fei_fbi_6: (+1)
   \   00000068   0x....             LDR      R2,??DataTable21_2  ;; 0x40064000
   \   0000006A   0x7812             LDRB     R2,[R2, #+0]
   1465            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
   \   0000006C   0x0692             LSLS     R2,R2,#+26       ;; ZeroExtS R2,R2,#+26,#+26
   \   0000006E   0x0E92             LSRS     R2,R2,#+26
   1466            temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
   \   00000070   0x0013             MOVS     R3,R2
   \   00000072   0x2240             MOVS     R2,#+64
   \   00000074   0x431A             ORRS     R2,R2,R3
   1467            MCG_C1 = temp_reg;
   \   00000076   0x....             LDR      R3,??DataTable21_2  ;; 0x40064000
   \   00000078   0x701A             STRB     R2,[R3, #+0]
   1468          
   1469          // wait until internal reference switches to requested irc.
   1470            if (!(irc_select))
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD111             BNE      ??fei_fbi_7
   1471            {
   1472              for (i = 0 ; i < 2000 ; i++)
   \   00000080   0x2200             MOVS     R2,#+0
   \   00000082   0xE000             B        ??fei_fbi_8
   \                     ??fei_fbi_9: (+1)
   \   00000084   0x1C52             ADDS     R2,R2,#+1
   \                     ??fei_fbi_8: (+1)
   \   00000086   0xB212             SXTH     R2,R2
   \   00000088   0x23FA             MOVS     R3,#+250
   \   0000008A   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   0000008C   0x429A             CMP      R2,R3
   \   0000008E   0xDA03             BGE      ??fei_fbi_10
   1473              {
   1474                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \   00000090   0x....             LDR      R3,??DataTable21_1  ;; 0x40064006
   \   00000092   0x781B             LDRB     R3,[R3, #+0]
   \   00000094   0x07DB             LSLS     R3,R3,#+31
   \   00000096   0xD4F5             BMI      ??fei_fbi_9
   1475              }
   1476              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fei_fbi_10: (+1)
   \   00000098   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   0000009A   0x7812             LDRB     R2,[R2, #+0]
   \   0000009C   0x07D2             LSLS     R2,R2,#+31
   \   0000009E   0xD513             BPL      ??fei_fbi_11
   \   000000A0   0x2013             MOVS     R0,#+19
   \   000000A2   0xE03A             B        ??fei_fbi_2
   1477            }
   1478            else
   1479            {
   1480              for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbi_7: (+1)
   \   000000A4   0x2200             MOVS     R2,#+0
   \   000000A6   0xE000             B        ??fei_fbi_12
   \                     ??fei_fbi_13: (+1)
   \   000000A8   0x1C52             ADDS     R2,R2,#+1
   \                     ??fei_fbi_12: (+1)
   \   000000AA   0xB212             SXTH     R2,R2
   \   000000AC   0x23FA             MOVS     R3,#+250
   \   000000AE   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000B0   0x429A             CMP      R2,R3
   \   000000B2   0xDA03             BGE      ??fei_fbi_14
   1481              {
   1482                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \   000000B4   0x....             LDR      R3,??DataTable21_1  ;; 0x40064006
   \   000000B6   0x781B             LDRB     R3,[R3, #+0]
   \   000000B8   0x07DB             LSLS     R3,R3,#+31
   \   000000BA   0xD5F5             BPL      ??fei_fbi_13
   1483              }
   1484              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fei_fbi_14: (+1)
   \   000000BC   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   000000BE   0x7812             LDRB     R2,[R2, #+0]
   \   000000C0   0x07D2             LSLS     R2,R2,#+31
   \   000000C2   0xD401             BMI      ??fei_fbi_11
   \   000000C4   0x2014             MOVS     R0,#+20
   \   000000C6   0xE028             B        ??fei_fbi_2
   1485            }
   1486            
   1487          // Wait for clock status bits to update
   1488            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbi_11: (+1)
   \   000000C8   0x2200             MOVS     R2,#+0
   \   000000CA   0xE000             B        ??fei_fbi_15
   \                     ??fei_fbi_16: (+1)
   \   000000CC   0x1C52             ADDS     R2,R2,#+1
   \                     ??fei_fbi_15: (+1)
   \   000000CE   0xB212             SXTH     R2,R2
   \   000000D0   0x23FA             MOVS     R3,#+250
   \   000000D2   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000D4   0x429A             CMP      R2,R3
   \   000000D6   0xDA07             BGE      ??fei_fbi_17
   1489            {
   1490              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \   000000D8   0x....             LDR      R3,??DataTable21_1  ;; 0x40064006
   \   000000DA   0x781B             LDRB     R3,[R3, #+0]
   \   000000DC   0xB2DB             UXTB     R3,R3
   \   000000DE   0x089B             LSRS     R3,R3,#+2
   \   000000E0   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000E2   0x0F9B             LSRS     R3,R3,#+30
   \   000000E4   0x2B01             CMP      R3,#+1
   \   000000E6   0xD1F1             BNE      ??fei_fbi_16
   1491            }
   1492            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fei_fbi_17: (+1)
   \   000000E8   0x....             LDR      R2,??DataTable21_1  ;; 0x40064006
   \   000000EA   0x7812             LDRB     R2,[R2, #+0]
   \   000000EC   0xB2D2             UXTB     R2,R2
   \   000000EE   0x0892             LSRS     R2,R2,#+2
   \   000000F0   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000F2   0x0F92             LSRS     R2,R2,#+30
   \   000000F4   0x2A01             CMP      R2,#+1
   \   000000F6   0xD001             BEQ      ??fei_fbi_18
   \   000000F8   0x2019             MOVS     R0,#+25
   \   000000FA   0xE00E             B        ??fei_fbi_2
   1493            
   1494          // Now in FBI mode
   1495            if (irc_select)
   \                     ??fei_fbi_18: (+1)
   \   000000FC   0xB2C9             UXTB     R1,R1
   \   000000FE   0x2900             CMP      R1,#+0
   \   00000100   0xD00B             BEQ      ??fei_fbi_19
   1496            {
   1497              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   00000102   0x2101             MOVS     R1,#+1
   \   00000104   0x....             LDR      R2,??DataTable21  ;; 0x40064008
   \   00000106   0x7812             LDRB     R2,[R2, #+0]
   \   00000108   0xB2D2             UXTB     R2,R2
   \   0000010A   0x0852             LSRS     R2,R2,#+1
   \   0000010C   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   0000010E   0x0F52             LSRS     R2,R2,#+29
   \   00000110   0x4091             LSLS     R1,R1,R2
   1498              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   00000112   0xB2C9             UXTB     R1,R1
   \   00000114   0x.... 0x....      BL       __aeabi_idiv
   \   00000118   0xE7FF             B        ??fei_fbi_2
   1499            }
   1500            else
   1501            {
   1502              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fei_fbi_19: (+1)
   \                     ??fei_fbi_2: (+1)
   \   0000011A   0xBD00             POP      {PC}             ;; return
   1503            }   
   1504          } // fei_fbi
   1505          
   1506          
   1507          /********************************************************************/
   1508          /* Functon name : fei_fee
   1509           *
   1510           * Mode transition: FEI to FEE mode
   1511           *
   1512           * This function transitions the MCG from FEI mode to FEE mode. This is
   1513           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
   1514           * check so 0 is always returned if the function was called with the MCG
   1515           * in FBI mode. The MCGCLKOUT frequency does not change
   1516           *
   1517           * Parameters: crystal_val - external clock frequency in Hz
   1518           *             hgo_val     - selects whether low power or high gain mode is selected
   1519           *                           for the crystal oscillator. This has no meaning if an 
   1520           *                           external clock is used.
   1521           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
   1522           *
   1523           * Return value : MCGCLKOUT frequency (Hz) or error code
   1524           */

   \                                 In section .text, align 2, keep-with-next
   1525          int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
   1526          {
   \                     fei_fee: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0015             MOVS     R5,R2
   1527            unsigned char frdiv_val;
   1528            unsigned char temp_reg;
   1529           // short i;
   1530            int mcg_out, fll_ref_freq, i;
   1531            
   1532          // check if in FEI mode
   1533            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1534                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1535                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000004   0x....             LDR      R2,??DataTable23  ;; 0x40064006
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0xB2D2             UXTB     R2,R2
   \   0000000A   0x0892             LSRS     R2,R2,#+2
   \   0000000C   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000E   0x0F92             LSRS     R2,R2,#+30
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD107             BNE      ??fei_fee_0
   \   00000014   0x....             LDR      R2,??DataTable23  ;; 0x40064006
   \   00000016   0x7812             LDRB     R2,[R2, #+0]
   \   00000018   0x06D2             LSLS     R2,R2,#+27
   \   0000001A   0xD503             BPL      ??fei_fee_0
   \   0000001C   0x....             LDR      R2,??DataTable23  ;; 0x40064006
   \   0000001E   0x7812             LDRB     R2,[R2, #+0]
   \   00000020   0x0692             LSLS     R2,R2,#+26
   \   00000022   0xD501             BPL      ??fei_fee_1
   1536            {
   1537              return 0x1;                                                     // return error code
   \                     ??fei_fee_0: (+1)
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE0A4             B        ??fei_fee_2
   1538            }
   1539          
   1540          // check external frequency is less than the maximum frequency
   1541            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fei_fee_1: (+1)
   \   00000028   0x....             LDR      R2,??DataTable23_1  ;; 0x2faf081
   \   0000002A   0x4290             CMP      R0,R2
   \   0000002C   0xDB01             BLT      ??fei_fee_3
   \   0000002E   0x2021             MOVS     R0,#+33
   \   00000030   0xE09F             B        ??fei_fee_2
   1542            
   1543          // check crystal frequency is within spec. if crystal osc is being used
   1544            if (erefs_val)
   \                     ??fei_fee_3: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD00C             BEQ      ??fei_fee_4
   1545            {
   1546              if ((crystal_val < 30000) ||
   1547                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1548                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000038   0x....             LDR      R2,??DataTable23_2  ;; 0x7530
   \   0000003A   0x4290             CMP      R0,R2
   \   0000003C   0xDB07             BLT      ??fei_fee_5
   \   0000003E   0x....             LDR      R2,??DataTable23_3  ;; 0x9c41
   \   00000040   0x1A82             SUBS     R2,R0,R2
   \   00000042   0x....             LDR      R3,??DataTable23_4  ;; 0x2d2a7f
   \   00000044   0x429A             CMP      R2,R3
   \   00000046   0xD302             BCC      ??fei_fee_5
   \   00000048   0x....             LDR      R2,??DataTable23_5  ;; 0x1e84801
   \   0000004A   0x4290             CMP      R0,R2
   \   0000004C   0xDB01             BLT      ??fei_fee_4
   \                     ??fei_fee_5: (+1)
   \   0000004E   0x2022             MOVS     R0,#+34
   \   00000050   0xE08F             B        ??fei_fee_2
   1549            }
   1550          
   1551          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1552            if (hgo_val > 0)
   \                     ??fei_fee_4: (+1)
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD000             BEQ      ??fei_fee_6
   1553            {
   1554              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000058   0x2101             MOVS     R1,#+1
   1555            }
   1556          
   1557          // configure the MCG_C2 register
   1558          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1559          // it still needs to be set correctly even if the oscillator is not being used
   1560            temp_reg = MCG_C2;
   \                     ??fei_fee_6: (+1)
   \   0000005A   0x....             LDR      R2,??DataTable22_3  ;; 0x40064001
   \   0000005C   0x7812             LDRB     R2,[R2, #+0]
   1561            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   0000005E   0x0013             MOVS     R3,R2
   \   00000060   0x22C3             MOVS     R2,#+195
   \   00000062   0x401A             ANDS     R2,R2,R3
   1562            if (crystal_val <= 40000)
   \   00000064   0x....             LDR      R3,??DataTable23_3  ;; 0x9c41
   \   00000066   0x4298             CMP      R0,R3
   \   00000068   0xDA07             BGE      ??fei_fee_7
   1563            {
   1564              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   0000006A   0x0013             MOVS     R3,R2
   \   0000006C   0xB2C9             UXTB     R1,R1
   \   0000006E   0x00C9             LSLS     R1,R1,#+3
   \   00000070   0xB2ED             UXTB     R5,R5
   \   00000072   0x00AA             LSLS     R2,R5,#+2
   \   00000074   0x430A             ORRS     R2,R2,R1
   \   00000076   0x431A             ORRS     R2,R2,R3
   \   00000078   0xE015             B        ??fei_fee_8
   1565            }
   1566            else if (crystal_val <= 8000000)
   \                     ??fei_fee_7: (+1)
   \   0000007A   0x....             LDR      R3,??DataTable23_6  ;; 0x7a1201
   \   0000007C   0x4298             CMP      R0,R3
   \   0000007E   0xDA09             BGE      ??fei_fee_9
   1567            {
   1568              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000080   0x0014             MOVS     R4,R2
   \   00000082   0xB2C9             UXTB     R1,R1
   \   00000084   0x00C9             LSLS     R1,R1,#+3
   \   00000086   0x2310             MOVS     R3,#+16
   \   00000088   0x430B             ORRS     R3,R3,R1
   \   0000008A   0xB2ED             UXTB     R5,R5
   \   0000008C   0x00AA             LSLS     R2,R5,#+2
   \   0000008E   0x431A             ORRS     R2,R2,R3
   \   00000090   0x4322             ORRS     R2,R2,R4
   \   00000092   0xE008             B        ??fei_fee_8
   1569            }
   1570            else
   1571            {
   1572              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fei_fee_9: (+1)
   \   00000094   0x0014             MOVS     R4,R2
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x00C9             LSLS     R1,R1,#+3
   \   0000009A   0x2320             MOVS     R3,#+32
   \   0000009C   0x430B             ORRS     R3,R3,R1
   \   0000009E   0xB2ED             UXTB     R5,R5
   \   000000A0   0x00AA             LSLS     R2,R5,#+2
   \   000000A2   0x431A             ORRS     R2,R2,R3
   \   000000A4   0x4322             ORRS     R2,R2,R4
   1573            }
   1574            MCG_C2 = temp_reg;
   \                     ??fei_fee_8: (+1)
   \   000000A6   0x....             LDR      R1,??DataTable22_3  ;; 0x40064001
   \   000000A8   0x700A             STRB     R2,[R1, #+0]
   1575          
   1576          // determine FRDIV based on reference clock frequency
   1577          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1578            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000AA   0x....             LDR      R1,??DataTable23_7  ;; 0x1312d1
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xDA01             BGE      ??fei_fee_10
   \   000000B0   0x2400             MOVS     R4,#+0
   \   000000B2   0xE014             B        ??fei_fee_11
   1579            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fei_fee_10: (+1)
   \   000000B4   0x....             LDR      R1,??DataTable23_8  ;; 0x2625a1
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xDA01             BGE      ??fei_fee_12
   \   000000BA   0x2401             MOVS     R4,#+1
   \   000000BC   0xE00F             B        ??fei_fee_11
   1580            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fei_fee_12: (+1)
   \   000000BE   0x....             LDR      R1,??DataTable23_9  ;; 0x4c4b41
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xDA01             BGE      ??fei_fee_13
   \   000000C4   0x2402             MOVS     R4,#+2
   \   000000C6   0xE00A             B        ??fei_fee_11
   1581            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fei_fee_13: (+1)
   \   000000C8   0x....             LDR      R1,??DataTable23_10  ;; 0x989681
   \   000000CA   0x4288             CMP      R0,R1
   \   000000CC   0xDA01             BGE      ??fei_fee_14
   \   000000CE   0x2403             MOVS     R4,#+3
   \   000000D0   0xE005             B        ??fei_fee_11
   1582            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fei_fee_14: (+1)
   \   000000D2   0x....             LDR      R1,??DataTable23_11  ;; 0x1312d01
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xDA01             BGE      ??fei_fee_15
   \   000000D8   0x2404             MOVS     R4,#+4
   \   000000DA   0xE000             B        ??fei_fee_11
   1583            else {frdiv_val = 5;}
   \                     ??fei_fee_15: (+1)
   \   000000DC   0x2405             MOVS     R4,#+5
   1584             
   1585            // The FLL ref clk divide value depends on FRDIV and the RANGE value
   1586            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fei_fee_11: (+1)
   \   000000DE   0x....             LDR      R1,??DataTable22_3  ;; 0x40064001
   \   000000E0   0x7809             LDRB     R1,[R1, #+0]
   \   000000E2   0xB2C9             UXTB     R1,R1
   \   000000E4   0x0909             LSRS     R1,R1,#+4
   \   000000E6   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000E8   0x0F89             LSRS     R1,R1,#+30
   \   000000EA   0x2900             CMP      R1,#+0
   \   000000EC   0xD004             BEQ      ??fei_fee_16
   1587            {
   1588              fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
   \   000000EE   0x2120             MOVS     R1,#+32
   \   000000F0   0x40A1             LSLS     R1,R1,R4
   \   000000F2   0x.... 0x....      BL       __aeabi_idiv
   \   000000F6   0xE003             B        ??fei_fee_17
   1589            }
   1590            else
   1591            {
   1592              fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
   \                     ??fei_fee_16: (+1)
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x40A1             LSLS     R1,R1,R4
   \   000000FC   0x.... 0x....      BL       __aeabi_idiv
   1593            }
   1594            
   1595          // Check resulting FLL frequency 
   1596            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \                     ??fei_fee_17: (+1)
   \   00000100   0x.... 0x....      BL       fll_freq
   1597            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000104   0x283C             CMP      R0,#+60
   \   00000106   0xDB34             BLT      ??fei_fee_2
   1598            
   1599          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1600          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1601          // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
   1602            temp_reg = MCG_C1;
   \                     ??fei_fee_18: (+1)
   \   00000108   0x....             LDR      R1,??DataTable23_12  ;; 0x40064000
   \   0000010A   0x780A             LDRB     R2,[R1, #+0]
   1603            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   \   0000010C   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000010E   0x0F92             LSRS     R2,R2,#+30
   1604            temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   00000110   0x0013             MOVS     R3,R2
   \   00000112   0x00E1             LSLS     R1,R4,#+3
   \   00000114   0x2238             MOVS     R2,#+56
   \   00000116   0x400A             ANDS     R2,R2,R1
   \   00000118   0x431A             ORRS     R2,R2,R3
   1605            MCG_C1 = temp_reg;
   \   0000011A   0x....             LDR      R1,??DataTable23_12  ;; 0x40064000
   \   0000011C   0x700A             STRB     R2,[R1, #+0]
   1606          
   1607          // if the external oscillator is used need to wait for OSCINIT to set
   1608            if (erefs_val)
   \   0000011E   0xB2ED             UXTB     R5,R5
   \   00000120   0x2D00             CMP      R5,#+0
   \   00000122   0xD00F             BEQ      ??fei_fee_19
   1609            {
   1610              for (i = 0 ; i < 20000000 ; i++)
   \   00000124   0x2100             MOVS     R1,#+0
   \   00000126   0xE000             B        ??fei_fee_20
   \                     ??fei_fee_21: (+1)
   \   00000128   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fee_20: (+1)
   \   0000012A   0x....             LDR      R2,??DataTable23_13  ;; 0x1312d00
   \   0000012C   0x4291             CMP      R1,R2
   \   0000012E   0xDA03             BGE      ??fei_fee_22
   1611              {
   1612                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   00000130   0x....             LDR      R2,??DataTable23  ;; 0x40064006
   \   00000132   0x7812             LDRB     R2,[R2, #+0]
   \   00000134   0x0792             LSLS     R2,R2,#+30
   \   00000136   0xD5F7             BPL      ??fei_fee_21
   1613              }
   1614              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fei_fee_22: (+1)
   \   00000138   0x....             LDR      R1,??DataTable23  ;; 0x40064006
   \   0000013A   0x7809             LDRB     R1,[R1, #+0]
   \   0000013C   0x0789             LSLS     R1,R1,#+30
   \   0000013E   0xD401             BMI      ??fei_fee_19
   \   00000140   0x2023             MOVS     R0,#+35
   \   00000142   0xE016             B        ??fei_fee_2
   1615            }
   1616          
   1617          // wait for Reference clock Status bit to clear
   1618            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fee_19: (+1)
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0xE000             B        ??fei_fee_23
   \                     ??fei_fee_24: (+1)
   \   00000148   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fee_23: (+1)
   \   0000014A   0x22FA             MOVS     R2,#+250
   \   0000014C   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000014E   0x4291             CMP      R1,R2
   \   00000150   0xDA03             BGE      ??fei_fee_25
   1619            {
   1620              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   00000152   0x....             LDR      R2,??DataTable23  ;; 0x40064006
   \   00000154   0x7812             LDRB     R2,[R2, #+0]
   \   00000156   0x06D2             LSLS     R2,R2,#+27
   \   00000158   0xD4F6             BMI      ??fei_fee_24
   1621            }
   1622            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fei_fee_25: (+1)
   \   0000015A   0x....             LDR      R1,??DataTable23  ;; 0x40064006
   \   0000015C   0x7809             LDRB     R1,[R1, #+0]
   \   0000015E   0x06C9             LSLS     R1,R1,#+27
   \   00000160   0xD501             BPL      ??fei_fee_26
   \   00000162   0x2011             MOVS     R0,#+17
   \   00000164   0xE005             B        ??fei_fee_2
   1623            
   1624          // Now in FBE  
   1625          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1626          // It is enabled here but can be removed if this is not required.
   1627            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fei_fee_26: (+1)
   \   00000166   0x....             LDR      R1,??DataTable24  ;; 0x40064005
   \   00000168   0x7809             LDRB     R1,[R1, #+0]
   \   0000016A   0x2220             MOVS     R2,#+32
   \   0000016C   0x430A             ORRS     R2,R2,R1
   \   0000016E   0x....             LDR      R1,??DataTable24  ;; 0x40064005
   \   00000170   0x700A             STRB     R2,[R1, #+0]
   1628            
   1629            return mcg_out; // MCGOUT frequency equals FLL frequency
   \                     ??fei_fee_2: (+1)
   \   00000172   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1630          } // fei_fee
   1631          
   1632          

   \                                 In section .text, align 2, keep-with-next
   1633          int fee_fei(int slow_irc_freq)
   1634          {
   \                     fee_fei: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1635            short i;
   1636            int mcg_out;
   1637          
   1638          // Check MCG is in FEE mode
   1639            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
   1640                (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external ref clk
   1641                (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R1,??DataTable23  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD107             BNE      ??fee_fei_0
   \   00000012   0x....             LDR      R1,??DataTable23  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??fee_fei_0
   \   0000001A   0x....             LDR      R1,??DataTable23  ;; 0x40064006
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0689             LSLS     R1,R1,#+26
   \   00000020   0xD501             BPL      ??fee_fei_1
   1642            {
   1643              return 0x2;                                                     // return error code
   \                     ??fee_fei_0: (+1)
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE028             B        ??fee_fei_2
   1644            } 
   1645                
   1646          // Check IRC frequency is within spec.
   1647            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fee_fei_1: (+1)
   \   00000026   0x....             LDR      R1,??DataTable24_1  ;; 0x7a12
   \   00000028   0x1A41             SUBS     R1,R0,R1
   \   0000002A   0x....             LDR      R2,??DataTable24_2  ;; 0x1e86
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD301             BCC      ??fee_fei_3
   1648            {
   1649              return 0x31;
   \   00000030   0x2031             MOVS     R0,#+49
   \   00000032   0xE021             B        ??fee_fei_2
   1650            }
   1651          
   1652            // Check resulting FLL frequency 
   1653            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fee_fei_3: (+1)
   \   00000034   0x.... 0x....      BL       fll_freq
   1654            if (mcg_out < 0x3C) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000038   0x283C             CMP      R0,#+60
   \   0000003A   0xDB1D             BLT      ??fee_fei_2
   1655            
   1656          // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trigger
   1657            MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??fee_fei_4: (+1)
   \   0000003C   0x....             LDR      R1,??DataTable24  ;; 0x40064005
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
   \   00000040   0x22DF             MOVS     R2,#+223
   \   00000042   0x400A             ANDS     R2,R2,R1
   \   00000044   0x....             LDR      R1,??DataTable24  ;; 0x40064005
   \   00000046   0x700A             STRB     R2,[R1, #+0]
   1658          
   1659          // Change FLL reference clock from external to internal by setting IREFS bit
   1660            MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
   \   00000048   0x....             LDR      R1,??DataTable23_12  ;; 0x40064000
   \   0000004A   0x7809             LDRB     R1,[R1, #+0]
   \   0000004C   0x2204             MOVS     R2,#+4
   \   0000004E   0x430A             ORRS     R2,R2,R1
   \   00000050   0x....             LDR      R1,??DataTable23_12  ;; 0x40064000
   \   00000052   0x700A             STRB     R2,[R1, #+0]
   1661            
   1662          // wait for Reference clock to switch to internal reference 
   1663            for (i = 0 ; i < 2000 ; i++)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0xE000             B        ??fee_fei_5
   \                     ??fee_fei_6: (+1)
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   \                     ??fee_fei_5: (+1)
   \   0000005A   0xB209             SXTH     R1,R1
   \   0000005C   0x22FA             MOVS     R2,#+250
   \   0000005E   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000060   0x4291             CMP      R1,R2
   \   00000062   0xDA03             BGE      ??fee_fei_7
   1664            {
   1665              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   00000064   0x....             LDR      R2,??DataTable23  ;; 0x40064006
   \   00000066   0x7812             LDRB     R2,[R2, #+0]
   \   00000068   0x06D2             LSLS     R2,R2,#+27
   \   0000006A   0xD5F5             BPL      ??fee_fei_6
   1666            }
   1667            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set  
   \                     ??fee_fei_7: (+1)
   \   0000006C   0x....             LDR      R1,??DataTable23  ;; 0x40064006
   \   0000006E   0x7809             LDRB     R1,[R1, #+0]
   \   00000070   0x06C9             LSLS     R1,R1,#+27
   \   00000072   0xD401             BMI      ??fee_fei_8
   \   00000074   0x2012             MOVS     R0,#+18
   \   00000076   0xE7FF             B        ??fee_fei_2
   1668            
   1669          // Now in FEI mode  
   1670            return mcg_out;  
   \                     ??fee_fei_8: (+1)
   \                     ??fee_fei_2: (+1)
   \   00000078   0xBD02             POP      {R1,PC}          ;; return
   1671          } // fee_fei
   1672          
   1673          
   1674          

   \                                 In section .text, align 2, keep-with-next
   1675          unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq)
   1676          {
   \                     atc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1677            unsigned char mcg_mode;
   1678            unsigned short atcv;
   1679            int bus_clock_freq;
   1680            int  bus_clk_div_val;
   1681            int orig_div;
   1682            int temp_reg;
   1683            
   1684            if (irc_select > 0) // force irc to 1 if greater than 0
   \   00000008   0xB2E4             UXTB     R4,R4
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD000             BEQ      ??atc_0
   1685            {
   1686              irc_select = 1;
   \   0000000E   0x2401             MOVS     R4,#+1
   1687            }
   1688            
   1689            mcg_mode = what_mcg_mode(); // get present MCG mode
   \                     ??atc_0: (+1)
   \   00000010   0x.... 0x....      BL       what_mcg_mode
   1690            if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2808             CMP      R0,#+8
   \   00000018   0xD007             BEQ      ??atc_1
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x2807             CMP      R0,#+7
   \   0000001E   0xD004             BEQ      ??atc_1
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD001             BEQ      ??atc_1
   1691            {
   1692              return 1; // return error code if not in PEE, PBE or FBE modes
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE0B1             B        ??atc_2
   1693            }
   1694            
   1695            orig_div = SIM_CLKDIV1; //store present clock divider values
   \                     ??atc_1: (+1)
   \   0000002A   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000002C   0x6807             LDR      R7,[R0, #+0]
   1696            
   1697            bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest allowed bus clock for autotrim
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x....             LDR      R1,??DataTable24_4  ;; 0xf42400
   \   00000032   0x.... 0x....      BL       __aeabi_idiv
   1698            temp_reg = SIM_CLKDIV1;
   \   00000036   0x....             LDR      R1,??DataTable24_3  ;; 0x40048044
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   1699            temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
   \   0000003A   0x000A             MOVS     R2,R1
   \   0000003C   0x....             LDR      R1,??DataTable24_5  ;; 0xfff8ffff
   \   0000003E   0x4011             ANDS     R1,R1,R2
   1700            // set all bus and flash dividers to same value to ensure clocking restrictions are met
   1701            temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
   \   00000040   0x000A             MOVS     R2,R1
   \   00000042   0x0400             LSLS     R0,R0,#+16
   \   00000044   0x21E0             MOVS     R1,#+224
   \   00000046   0x02C9             LSLS     R1,R1,#+11       ;; #+458752
   \   00000048   0x4001             ANDS     R1,R1,R0
   \   0000004A   0x4311             ORRS     R1,R1,R2
   1702            SIM_CLKDIV1 = temp_reg; // set actual dividers
   \   0000004C   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1703            
   1704            bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For KL25, flash and bus use the same bus div
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x....             LDR      R1,??DataTable24_3  ;; 0x40048044
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0x0C09             LSRS     R1,R1,#+16
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_uidiv
   1705            if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
   \   0000005E   0x....             LDR      R1,??DataTable24_6  ;; 0x7a1200
   \   00000060   0x1A41             SUBS     R1,R0,R1
   \   00000062   0x....             LDR      R2,??DataTable24_7  ;; 0x7a1201
   \   00000064   0x4291             CMP      R1,R2
   \   00000066   0xD303             BCC      ??atc_3
   1706            {
   1707              SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000068   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000006A   0x6007             STR      R7,[R0, #+0]
   1708              return 3; // error, bus clock frequency is not within 8MHz to 16MHz
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0xE08E             B        ??atc_2
   1709            }
   1710                          
   1711            if(!irc_select) //determine if slow or fast IRC to be trimmed
   \                     ??atc_3: (+1)
   \   00000070   0xB2E4             UXTB     R4,R4
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD10D             BNE      ??atc_4
   1712            {
   1713              if (irc_freq < 31250) // check frequency is above min spec.
   \   00000076   0x....             LDR      R1,??DataTable24_1  ;; 0x7a12
   \   00000078   0x428D             CMP      R5,R1
   \   0000007A   0xDA03             BGE      ??atc_5
   1714              {
   1715                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   0000007C   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000007E   0x6007             STR      R7,[R0, #+0]
   1716                return 4;
   \   00000080   0x2004             MOVS     R0,#+4
   \   00000082   0xE084             B        ??atc_2
   1717              }
   1718              if (irc_freq > 39062) // check frequency is below max spec.
   \                     ??atc_5: (+1)
   \   00000084   0x....             LDR      R1,??DataTable24_8  ;; 0x9897
   \   00000086   0x428D             CMP      R5,R1
   \   00000088   0xDB11             BLT      ??atc_6
   1719              {
   1720                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   0000008A   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000008C   0x6007             STR      R7,[R0, #+0]
   1721                return 5;
   \   0000008E   0x2005             MOVS     R0,#+5
   \   00000090   0xE07D             B        ??atc_2
   1722              }         
   1723            }
   1724            else
   1725            {
   1726              if (irc_freq < 3000000) // check frequency is above min spec.
   \                     ??atc_4: (+1)
   \   00000092   0x....             LDR      R1,??DataTable25  ;; 0x2dc6c0
   \   00000094   0x428D             CMP      R5,R1
   \   00000096   0xDA03             BGE      ??atc_7
   1727              {
   1728                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000098   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000009A   0x6007             STR      R7,[R0, #+0]
   1729                return 6;
   \   0000009C   0x2006             MOVS     R0,#+6
   \   0000009E   0xE076             B        ??atc_2
   1730              }
   1731              if (irc_freq > 5000000) // check frequency is below max spec.
   \                     ??atc_7: (+1)
   \   000000A0   0x....             LDR      R1,??DataTable25_1  ;; 0x4c4b41
   \   000000A2   0x428D             CMP      R5,R1
   \   000000A4   0xDB03             BLT      ??atc_6
   1732              {
   1733                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   000000A6   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   000000A8   0x6007             STR      R7,[R0, #+0]
   1734                return 7;
   \   000000AA   0x2007             MOVS     R0,#+7
   \   000000AC   0xE06F             B        ??atc_2
   1735              }            
   1736            } // if
   1737                  
   1738          // Set up autocal registers, must use floating point calculation
   1739            if (irc_select) 
   \                     ??atc_6: (+1)
   \   000000AE   0xB2E4             UXTB     R4,R4
   \   000000B0   0x2C00             CMP      R4,#+0
   \   000000B2   0xD013             BEQ      ??atc_8
   1740              atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
   \   000000B4   0x.... 0x....      BL       __aeabi_i2f
   \   000000B8   0x0006             MOVS     R6,R0
   \   000000BA   0x0028             MOVS     R0,R5
   \   000000BC   0x.... 0x....      BL       __aeabi_i2f
   \   000000C0   0x0001             MOVS     R1,R0
   \   000000C2   0x0030             MOVS     R0,R6
   \   000000C4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000C8   0x....             LDR      R1,??DataTable25_2  ;; 0x41a80000
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x2186             MOVS     R1,#+134
   \   000000D0   0x05C9             LSLS     R1,R1,#+23       ;; #+1124073472
   \   000000D2   0x.... 0x....      BL       __aeabi_fmul
   \   000000D6   0x.... 0x....      BL       __aeabi_f2iz
   \   000000DA   0xE00E             B        ??atc_9
   1741            else
   1742              atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
   \                     ??atc_8: (+1)
   \   000000DC   0x.... 0x....      BL       __aeabi_i2f
   \   000000E0   0x0006             MOVS     R6,R0
   \   000000E2   0x0028             MOVS     R0,R5
   \   000000E4   0x.... 0x....      BL       __aeabi_i2f
   \   000000E8   0x0001             MOVS     R1,R0
   \   000000EA   0x0030             MOVS     R0,R6
   \   000000EC   0x.... 0x....      BL       __aeabi_fdiv
   \   000000F0   0x....             LDR      R1,??DataTable25_2  ;; 0x41a80000
   \   000000F2   0x.... 0x....      BL       __aeabi_fmul
   \   000000F6   0x.... 0x....      BL       __aeabi_f2iz
   1743                  
   1744            MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
   \                     ??atc_9: (+1)
   \   000000FA   0x0001             MOVS     R1,R0
   \   000000FC   0x....             LDR      R2,??DataTable25_3  ;; 0x4006400b
   \   000000FE   0x7011             STRB     R1,[R2, #+0]
   1745            MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
   \   00000100   0xB280             UXTH     R0,R0
   \   00000102   0x0A00             LSRS     R0,R0,#+8
   \   00000104   0x....             LDR      R1,??DataTable25_4  ;; 0x4006400a
   \   00000106   0x7008             STRB     R0,[R1, #+0]
   1746          
   1747          // Enable autocal
   1748            MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
   \   00000108   0x....             LDR      R0,??DataTable25_5  ;; 0x40064008
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000010E   0x0EC0             LSRS     R0,R0,#+27
   \   00000110   0x....             LDR      R1,??DataTable25_5  ;; 0x40064008
   \   00000112   0x7008             STRB     R0,[R1, #+0]
   1749            temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enable trim machine
   \   00000114   0xB2E4             UXTB     R4,R4
   \   00000116   0x01A0             LSLS     R0,R4,#+6
   \   00000118   0x2180             MOVS     R1,#+128
   \   0000011A   0x4301             ORRS     R1,R1,R0
   1750            MCG_SC |= temp_reg;
   \   0000011C   0x....             LDR      R0,??DataTable25_5  ;; 0x40064008
   \   0000011E   0x7800             LDRB     R0,[R0, #+0]
   \   00000120   0x4301             ORRS     R1,R1,R0
   \   00000122   0x....             LDR      R0,??DataTable25_5  ;; 0x40064008
   \   00000124   0x7001             STRB     R1,[R0, #+0]
   1751                  
   1752            while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
   \                     ??atc_10: (+1)
   \   00000126   0x....             LDR      R0,??DataTable25_5  ;; 0x40064008
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0x0600             LSLS     R0,R0,#+24
   \   0000012C   0xD4FB             BMI      ??atc_10
   1753                  
   1754            if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
   \   0000012E   0x....             LDR      R0,??DataTable25_5  ;; 0x40064008
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x0680             LSLS     R0,R0,#+26
   \   00000134   0xD503             BPL      ??atc_11
   1755            {
   1756              SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000136   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   00000138   0x6007             STR      R7,[R0, #+0]
   1757              return 8;
   \   0000013A   0x2008             MOVS     R0,#+8
   \   0000013C   0xE027             B        ??atc_2
   1758            } 
   1759            else 
   1760            {      
   1761              if (!irc_select)
   \                     ??atc_11: (+1)
   \   0000013E   0xB2E4             UXTB     R4,R4
   \   00000140   0x2C00             CMP      R4,#+0
   \   00000142   0xD10D             BNE      ??atc_12
   1762              {
   1763                if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
   \   00000144   0x....             LDR      R0,??DataTable25_6  ;; 0x40064002
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0xB2C0             UXTB     R0,R0
   \   0000014A   0x28FF             CMP      R0,#+255
   \   0000014C   0xD004             BEQ      ??atc_13
   \   0000014E   0x....             LDR      R0,??DataTable25_6  ;; 0x40064002
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \   00000152   0xB2C0             UXTB     R0,R0
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD117             BNE      ??atc_14
   1764                {
   1765                  SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_13: (+1)
   \   00000158   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000015A   0x6007             STR      R7,[R0, #+0]
   1766                  return 9;
   \   0000015C   0x2009             MOVS     R0,#+9
   \   0000015E   0xE016             B        ??atc_2
   1767                }
   1768              }
   1769              else
   1770              {
   1771                if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
   1772                    (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
   \                     ??atc_12: (+1)
   \   00000160   0x....             LDR      R0,??DataTable25_7  ;; 0x40064003
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0xB2C0             UXTB     R0,R0
   \   00000166   0x0840             LSRS     R0,R0,#+1
   \   00000168   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   0000016A   0x0F00             LSRS     R0,R0,#+28
   \   0000016C   0x280F             CMP      R0,#+15
   \   0000016E   0xD007             BEQ      ??atc_15
   \   00000170   0x....             LDR      R0,??DataTable25_7  ;; 0x40064003
   \   00000172   0x7800             LDRB     R0,[R0, #+0]
   \   00000174   0xB2C0             UXTB     R0,R0
   \   00000176   0x0840             LSRS     R0,R0,#+1
   \   00000178   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   0000017A   0x0F00             LSRS     R0,R0,#+28
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD103             BNE      ??atc_14
   1773                {
   1774                  SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_15: (+1)
   \   00000180   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   00000182   0x6007             STR      R7,[R0, #+0]
   1775                  return 10;
   \   00000184   0x200A             MOVS     R0,#+10
   \   00000186   0xE002             B        ??atc_2
   1776                }
   1777              }
   1778            }
   1779            SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_14: (+1)
   \   00000188   0x....             LDR      R0,??DataTable24_3  ;; 0x40048044
   \   0000018A   0x6007             STR      R7,[R0, #+0]
   1780            return 0;
   \   0000018C   0x2000             MOVS     R0,#+0
   \                     ??atc_2: (+1)
   \   0000018E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1781          }// atc
   1782          
   1783          
   1784          
   1785          

   \                                 In section .text, align 2, keep-with-next
   1786          int fll_freq(int fll_ref)
   1787          {
   \                     fll_freq: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
   1788            int fll_freq_hz = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   1789            
   1790            // Check that only allowed ranges have been selected
   1791            if (((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) > 0x1) 
   \   00000006   0x....             LDR      R2,??DataTable25_7  ;; 0x40064003
   \   00000008   0x7812             LDRB     R2,[R2, #+0]
   \   0000000A   0xB2D2             UXTB     R2,R2
   \   0000000C   0x0952             LSRS     R2,R2,#+5
   \   0000000E   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000010   0x0F92             LSRS     R2,R2,#+30
   \   00000012   0x2A02             CMP      R2,#+2
   \   00000014   0xD301             BCC      ??fll_freq_0
   1792            {
   1793              return 0x3B; // return error code if DRS range 2 or 3 selected
   \   00000016   0x203B             MOVS     R0,#+59
   \   00000018   0xE094             B        ??fll_freq_1
   1794            }
   1795            
   1796            if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
   \                     ??fll_freq_0: (+1)
   \   0000001A   0x....             LDR      R2,??DataTable25_7  ;; 0x40064003
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0612             LSLS     R2,R2,#+24
   \   00000020   0xD547             BPL      ??fll_freq_2
   1797            {
   1798              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   \   00000022   0x....             LDR      R2,??DataTable25_7  ;; 0x40064003
   \   00000024   0x7812             LDRB     R2,[R2, #+0]
   \   00000026   0xB2D2             UXTB     R2,R2
   \   00000028   0x0952             LSRS     R2,R2,#+5
   \   0000002A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000002C   0x0F92             LSRS     R2,R2,#+30
   \   0000002E   0x2A00             CMP      R2,#+0
   \   00000030   0xD005             BEQ      ??fll_freq_3
   \   00000032   0x2A02             CMP      R2,#+2
   \   00000034   0xD021             BEQ      ??fll_freq_4
   \   00000036   0xD311             BCC      ??fll_freq_5
   \   00000038   0x2A03             CMP      R2,#+3
   \   0000003A   0xD02C             BEQ      ??fll_freq_6
   \   0000003C   0xE082             B        ??fll_freq_7
   1799              {
   1800              case 0:
   1801                fll_freq_hz = (fll_ref * 732);
   \                     ??fll_freq_3: (+1)
   \   0000003E   0x20B7             MOVS     R0,#+183
   \   00000040   0x0080             LSLS     R0,R0,#+2        ;; #+732
   \   00000042   0x4341             MULS     R1,R0,R1
   \   00000044   0x0008             MOVS     R0,R1
   1802                if (fll_freq_hz < 20000000) {return 0x33;}
   \   00000046   0x....             LDR      R1,??DataTable27  ;; 0x1312d00
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xDA01             BGE      ??fll_freq_8
   \   0000004C   0x2033             MOVS     R0,#+51
   \   0000004E   0xE079             B        ??fll_freq_1
   1803                else if (fll_freq_hz > 25000000) {return 0x34;}
   \                     ??fll_freq_8: (+1)
   \   00000050   0x....             LDR      R1,??DataTable27_1  ;; 0x17d7841
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xDB01             BLT      ??fll_freq_9
   \   00000056   0x2034             MOVS     R0,#+52
   \   00000058   0xE074             B        ??fll_freq_1
   1804                break;
   \                     ??fll_freq_9: (+1)
   \   0000005A   0xE073             B        ??fll_freq_7
   1805              case 1:
   1806                fll_freq_hz = (fll_ref * 1464);
   \                     ??fll_freq_5: (+1)
   \   0000005C   0x20B7             MOVS     R0,#+183
   \   0000005E   0x00C0             LSLS     R0,R0,#+3        ;; #+1464
   \   00000060   0x4341             MULS     R1,R0,R1
   \   00000062   0x0008             MOVS     R0,R1
   1807                if (fll_freq_hz < 40000000) {return 0x35;}
   \   00000064   0x....             LDR      R1,??DataTable27_2  ;; 0x2625a00
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xDA01             BGE      ??fll_freq_10
   \   0000006A   0x2035             MOVS     R0,#+53
   \   0000006C   0xE06A             B        ??fll_freq_1
   1808                else if (fll_freq_hz > 50000000) {return 0x36;}
   \                     ??fll_freq_10: (+1)
   \   0000006E   0x....             LDR      R1,??DataTable27_3  ;; 0x2faf081
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xDB01             BLT      ??fll_freq_11
   \   00000074   0x2036             MOVS     R0,#+54
   \   00000076   0xE065             B        ??fll_freq_1
   1809                break;
   \                     ??fll_freq_11: (+1)
   \   00000078   0xE064             B        ??fll_freq_7
   1810              case 2:
   1811                fll_freq_hz = (fll_ref * 2197);
   \                     ??fll_freq_4: (+1)
   \   0000007A   0x....             LDR      R0,??DataTable27_4  ;; 0x895
   \   0000007C   0x4341             MULS     R1,R0,R1
   \   0000007E   0x0008             MOVS     R0,R1
   1812                if (fll_freq_hz < 60000000) {return 0x37;}
   \   00000080   0x....             LDR      R1,??DataTable27_5  ;; 0x3938700
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xDA01             BGE      ??fll_freq_12
   \   00000086   0x2037             MOVS     R0,#+55
   \   00000088   0xE05C             B        ??fll_freq_1
   1813                else if (fll_freq_hz > 75000000) {return 0x38;}
   \                     ??fll_freq_12: (+1)
   \   0000008A   0x....             LDR      R1,??DataTable27_6  ;; 0x47868c1
   \   0000008C   0x4288             CMP      R0,R1
   \   0000008E   0xDB01             BLT      ??fll_freq_13
   \   00000090   0x2038             MOVS     R0,#+56
   \   00000092   0xE057             B        ??fll_freq_1
   1814                break;
   \                     ??fll_freq_13: (+1)
   \   00000094   0xE056             B        ??fll_freq_7
   1815              case 3:
   1816                fll_freq_hz = (fll_ref * 2929);
   \                     ??fll_freq_6: (+1)
   \   00000096   0x....             LDR      R0,??DataTable27_7  ;; 0xb71
   \   00000098   0x4341             MULS     R1,R0,R1
   \   0000009A   0x0008             MOVS     R0,R1
   1817                if (fll_freq_hz < 80000000) {return 0x39;}
   \   0000009C   0x....             LDR      R1,??DataTable27_8  ;; 0x4c4b400
   \   0000009E   0x4288             CMP      R0,R1
   \   000000A0   0xDA01             BGE      ??fll_freq_14
   \   000000A2   0x2039             MOVS     R0,#+57
   \   000000A4   0xE04E             B        ??fll_freq_1
   1818                else if (fll_freq_hz > 100000000) {return 0x3A;}
   \                     ??fll_freq_14: (+1)
   \   000000A6   0x....             LDR      R1,??DataTable27_9  ;; 0x5f5e101
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xDB01             BLT      ??fll_freq_15
   \   000000AC   0x203A             MOVS     R0,#+58
   \   000000AE   0xE049             B        ??fll_freq_1
   1819                break;
   \                     ??fll_freq_15: (+1)
   \   000000B0   0xE048             B        ??fll_freq_7
   1820              }
   1821            }
   1822            else // if DMX32 = 0
   1823            {
   1824              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   \                     ??fll_freq_2: (+1)
   \   000000B2   0x....             LDR      R2,??DataTable25_7  ;; 0x40064003
   \   000000B4   0x7812             LDRB     R2,[R2, #+0]
   \   000000B6   0xB2D2             UXTB     R2,R2
   \   000000B8   0x0952             LSRS     R2,R2,#+5
   \   000000BA   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000BC   0x0F92             LSRS     R2,R2,#+30
   \   000000BE   0x2A00             CMP      R2,#+0
   \   000000C0   0xD005             BEQ      ??fll_freq_16
   \   000000C2   0x2A02             CMP      R2,#+2
   \   000000C4   0xD021             BEQ      ??fll_freq_17
   \   000000C6   0xD311             BCC      ??fll_freq_18
   \   000000C8   0x2A03             CMP      R2,#+3
   \   000000CA   0xD02D             BEQ      ??fll_freq_19
   \   000000CC   0xE03A             B        ??fll_freq_7
   1825              {
   1826              case 0:
   1827                fll_freq_hz = (fll_ref * 640);
   \                     ??fll_freq_16: (+1)
   \   000000CE   0x20A0             MOVS     R0,#+160
   \   000000D0   0x0080             LSLS     R0,R0,#+2        ;; #+640
   \   000000D2   0x4341             MULS     R1,R0,R1
   \   000000D4   0x0008             MOVS     R0,R1
   1828                if (fll_freq_hz < 20000000) {return 0x33;}
   \   000000D6   0x....             LDR      R1,??DataTable27  ;; 0x1312d00
   \   000000D8   0x4288             CMP      R0,R1
   \   000000DA   0xDA01             BGE      ??fll_freq_20
   \   000000DC   0x2033             MOVS     R0,#+51
   \   000000DE   0xE031             B        ??fll_freq_1
   1829                else if (fll_freq_hz > 25000000) {return 0x34;}
   \                     ??fll_freq_20: (+1)
   \   000000E0   0x....             LDR      R1,??DataTable27_1  ;; 0x17d7841
   \   000000E2   0x4288             CMP      R0,R1
   \   000000E4   0xDB01             BLT      ??fll_freq_21
   \   000000E6   0x2034             MOVS     R0,#+52
   \   000000E8   0xE02C             B        ??fll_freq_1
   1830                break;
   \                     ??fll_freq_21: (+1)
   \   000000EA   0xE02B             B        ??fll_freq_7
   1831              case 1:
   1832                fll_freq_hz = (fll_ref * 1280);
   \                     ??fll_freq_18: (+1)
   \   000000EC   0x20A0             MOVS     R0,#+160
   \   000000EE   0x00C0             LSLS     R0,R0,#+3        ;; #+1280
   \   000000F0   0x4341             MULS     R1,R0,R1
   \   000000F2   0x0008             MOVS     R0,R1
   1833                if (fll_freq_hz < 40000000) {return 0x35;}
   \   000000F4   0x....             LDR      R1,??DataTable27_2  ;; 0x2625a00
   \   000000F6   0x4288             CMP      R0,R1
   \   000000F8   0xDA01             BGE      ??fll_freq_22
   \   000000FA   0x2035             MOVS     R0,#+53
   \   000000FC   0xE022             B        ??fll_freq_1
   1834                else if (fll_freq_hz > 50000000) {return 0x36;}
   \                     ??fll_freq_22: (+1)
   \   000000FE   0x....             LDR      R1,??DataTable27_3  ;; 0x2faf081
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xDB01             BLT      ??fll_freq_23
   \   00000104   0x2036             MOVS     R0,#+54
   \   00000106   0xE01D             B        ??fll_freq_1
   1835                break;
   \                     ??fll_freq_23: (+1)
   \   00000108   0xE01C             B        ??fll_freq_7
   1836              case 2:
   1837                fll_freq_hz = (fll_ref * 1920);
   \                     ??fll_freq_17: (+1)
   \   0000010A   0x20F0             MOVS     R0,#+240
   \   0000010C   0x00C0             LSLS     R0,R0,#+3        ;; #+1920
   \   0000010E   0x4341             MULS     R1,R0,R1
   \   00000110   0x0008             MOVS     R0,R1
   1838                if (fll_freq_hz < 60000000) {return 0x37;}
   \   00000112   0x....             LDR      R1,??DataTable27_5  ;; 0x3938700
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xDA01             BGE      ??fll_freq_24
   \   00000118   0x2037             MOVS     R0,#+55
   \   0000011A   0xE013             B        ??fll_freq_1
   1839                else if (fll_freq_hz > 75000000) {return 0x38;}
   \                     ??fll_freq_24: (+1)
   \   0000011C   0x....             LDR      R1,??DataTable27_6  ;; 0x47868c1
   \   0000011E   0x4288             CMP      R0,R1
   \   00000120   0xDB01             BLT      ??fll_freq_25
   \   00000122   0x2038             MOVS     R0,#+56
   \   00000124   0xE00E             B        ??fll_freq_1
   1840                break;
   \                     ??fll_freq_25: (+1)
   \   00000126   0xE00D             B        ??fll_freq_7
   1841              case 3:
   1842                fll_freq_hz = (fll_ref * 2560);
   \                     ??fll_freq_19: (+1)
   \   00000128   0x20A0             MOVS     R0,#+160
   \   0000012A   0x0100             LSLS     R0,R0,#+4        ;; #+2560
   \   0000012C   0x4341             MULS     R1,R0,R1
   \   0000012E   0x0008             MOVS     R0,R1
   1843                if (fll_freq_hz < 80000000) {return 0x39;}
   \   00000130   0x....             LDR      R1,??DataTable27_8  ;; 0x4c4b400
   \   00000132   0x4288             CMP      R0,R1
   \   00000134   0xDA01             BGE      ??fll_freq_26
   \   00000136   0x2039             MOVS     R0,#+57
   \   00000138   0xE004             B        ??fll_freq_1
   1844                else if (fll_freq_hz > 100000000) {return 0x3A;}
   \                     ??fll_freq_26: (+1)
   \   0000013A   0x....             LDR      R1,??DataTable27_9  ;; 0x5f5e101
   \   0000013C   0x4288             CMP      R0,R1
   \   0000013E   0xDB01             BLT      ??fll_freq_27
   \   00000140   0x203A             MOVS     R0,#+58
   \   00000142   0xE7FF             B        ??fll_freq_1
   1845                break;
   1846              }
   1847            }    
   1848            return fll_freq_hz;
   \                     ??fll_freq_27: (+1)
   \                     ??fll_freq_7: (+1)
   \                     ??fll_freq_1: (+1)
   \   00000144   0xBD00             POP      {PC}             ;; return
   1849          } // fll_freq
   1850          
   1851          

   \                                 In section .text, align 2, keep-with-next
   1852          unsigned char what_mcg_mode(void)
   1853          {
   \                     what_mcg_mode: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1854            // check if in FEI mode
   1855            if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selcted FLL output
   1856                (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is internal ref clk
   1857                (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x0880             LSRS     R0,R0,#+2
   \   0000000A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000000C   0x0F80             LSRS     R0,R0,#+30
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD109             BNE      ??what_mcg_mode_0
   \   00000012   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x06C0             LSLS     R0,R0,#+27
   \   00000018   0xD505             BPL      ??what_mcg_mode_0
   \   0000001A   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x0680             LSLS     R0,R0,#+26
   \   00000020   0xD401             BMI      ??what_mcg_mode_0
   1858            {
   1859              return FEI;                                                          // return FEI code
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE08E             B        ??what_mcg_mode_1
   1860            }
   1861            // Check MCG is in PEE mode
   1862            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted PLL output
   1863                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1864                    (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has selected PLL 
   \                     ??what_mcg_mode_0: (+1)
   \   00000026   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x0880             LSRS     R0,R0,#+2
   \   0000002E   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000030   0x0F80             LSRS     R0,R0,#+30
   \   00000032   0x2803             CMP      R0,#+3
   \   00000034   0xD109             BNE      ??what_mcg_mode_2
   \   00000036   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x06C0             LSLS     R0,R0,#+27
   \   0000003C   0xD405             BMI      ??what_mcg_mode_2
   \   0000003E   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x0680             LSLS     R0,R0,#+26
   \   00000044   0xD501             BPL      ??what_mcg_mode_2
   1865            {
   1866              return PEE;                                                          // return PEE code
   \   00000046   0x2008             MOVS     R0,#+8
   \   00000048   0xE07C             B        ??what_mcg_mode_1
   1867            }
   1868            // Check MCG is in PBE mode
   1869            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1870                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1871                    (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has selected PLL
   1872                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is not set
   \                     ??what_mcg_mode_2: (+1)
   \   0000004A   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0xB2C0             UXTB     R0,R0
   \   00000050   0x0880             LSRS     R0,R0,#+2
   \   00000052   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000054   0x0F80             LSRS     R0,R0,#+30
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD10D             BNE      ??what_mcg_mode_3
   \   0000005A   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x06C0             LSLS     R0,R0,#+27
   \   00000060   0xD409             BMI      ??what_mcg_mode_3
   \   00000062   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x0680             LSLS     R0,R0,#+26
   \   00000068   0xD505             BPL      ??what_mcg_mode_3
   \   0000006A   0x....             LDR      R0,??DataTable28_1  ;; 0x40064001
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x0780             LSLS     R0,R0,#+30
   \   00000070   0xD401             BMI      ??what_mcg_mode_3
   1873            {
   1874              return PBE;                                                          // return PBE code
   \   00000072   0x2007             MOVS     R0,#+7
   \   00000074   0xE066             B        ??what_mcg_mode_1
   1875            }
   1876            // Check MCG is in FBE mode
   1877            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1878                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1879                    (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1880                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is not set   
   \                     ??what_mcg_mode_3: (+1)
   \   00000076   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0xB2C0             UXTB     R0,R0
   \   0000007C   0x0880             LSRS     R0,R0,#+2
   \   0000007E   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000080   0x0F80             LSRS     R0,R0,#+30
   \   00000082   0x2802             CMP      R0,#+2
   \   00000084   0xD10D             BNE      ??what_mcg_mode_4
   \   00000086   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x06C0             LSLS     R0,R0,#+27
   \   0000008C   0xD409             BMI      ??what_mcg_mode_4
   \   0000008E   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x0680             LSLS     R0,R0,#+26
   \   00000094   0xD405             BMI      ??what_mcg_mode_4
   \   00000096   0x....             LDR      R0,??DataTable28_1  ;; 0x40064001
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x0780             LSLS     R0,R0,#+30
   \   0000009C   0xD401             BMI      ??what_mcg_mode_4
   1881            {
   1882              return FBE;                                                          // return FBE code
   \   0000009E   0x2005             MOVS     R0,#+5
   \   000000A0   0xE050             B        ??what_mcg_mode_1
   1883            }
   1884            // Check MCG is in BLPE mode
   1885            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1886                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1887                    (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is set   
   \                     ??what_mcg_mode_4: (+1)
   \   000000A2   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0xB2C0             UXTB     R0,R0
   \   000000A8   0x0880             LSRS     R0,R0,#+2
   \   000000AA   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000AC   0x0F80             LSRS     R0,R0,#+30
   \   000000AE   0x2802             CMP      R0,#+2
   \   000000B0   0xD109             BNE      ??what_mcg_mode_5
   \   000000B2   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0x06C0             LSLS     R0,R0,#+27
   \   000000B8   0xD405             BMI      ??what_mcg_mode_5
   \   000000BA   0x....             LDR      R0,??DataTable28_1  ;; 0x40064001
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x0780             LSLS     R0,R0,#+30
   \   000000C0   0xD501             BPL      ??what_mcg_mode_5
   1888            {
   1889              return BLPE;                                                         // return BLPE code
   \   000000C2   0x2006             MOVS     R0,#+6
   \   000000C4   0xE03E             B        ??what_mcg_mode_1
   1890            }
   1891            // check if in BLPI mode
   1892            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1893                    (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is internal ref clk
   1894                    (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1895                    (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
   \                     ??what_mcg_mode_5: (+1)
   \   000000C6   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0xB2C0             UXTB     R0,R0
   \   000000CC   0x0880             LSRS     R0,R0,#+2
   \   000000CE   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000D0   0x0F80             LSRS     R0,R0,#+30
   \   000000D2   0x2801             CMP      R0,#+1
   \   000000D4   0xD10D             BNE      ??what_mcg_mode_6
   \   000000D6   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x06C0             LSLS     R0,R0,#+27
   \   000000DC   0xD509             BPL      ??what_mcg_mode_6
   \   000000DE   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x0680             LSLS     R0,R0,#+26
   \   000000E4   0xD405             BMI      ??what_mcg_mode_6
   \   000000E6   0x....             LDR      R0,??DataTable28_1  ;; 0x40064001
   \   000000E8   0x7800             LDRB     R0,[R0, #+0]
   \   000000EA   0x0780             LSLS     R0,R0,#+30
   \   000000EC   0xD501             BPL      ??what_mcg_mode_6
   1896            {
   1897              return BLPI;                                                         // return BLPI code
   \   000000EE   0x2001             MOVS     R0,#+1
   \   000000F0   0xE028             B        ??what_mcg_mode_1
   1898            }
   1899            // check if in FBI mode
   1900            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1901                    (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is internal ref clk
   1902                    (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1903                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
   \                     ??what_mcg_mode_6: (+1)
   \   000000F2   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0xB2C0             UXTB     R0,R0
   \   000000F8   0x0880             LSRS     R0,R0,#+2
   \   000000FA   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000FC   0x0F80             LSRS     R0,R0,#+30
   \   000000FE   0x2801             CMP      R0,#+1
   \   00000100   0xD10D             BNE      ??what_mcg_mode_7
   \   00000102   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x06C0             LSLS     R0,R0,#+27
   \   00000108   0xD509             BPL      ??what_mcg_mode_7
   \   0000010A   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   0000010C   0x7800             LDRB     R0,[R0, #+0]
   \   0000010E   0x0680             LSLS     R0,R0,#+26
   \   00000110   0xD405             BMI      ??what_mcg_mode_7
   \   00000112   0x....             LDR      R0,??DataTable28_1  ;; 0x40064001
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x0780             LSLS     R0,R0,#+30
   \   00000118   0xD401             BMI      ??what_mcg_mode_7
   1904            {  
   1905              return FBI;                                                          // return FBI code 
   \   0000011A   0x2002             MOVS     R0,#+2
   \   0000011C   0xE012             B        ??what_mcg_mode_1
   1906            }
   1907            // Check MCG is in FEE mode
   1908            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
   1909                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1910                    (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has selected FLL
   \                     ??what_mcg_mode_7: (+1)
   \   0000011E   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0xB2C0             UXTB     R0,R0
   \   00000124   0x0880             LSRS     R0,R0,#+2
   \   00000126   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000128   0x0F80             LSRS     R0,R0,#+30
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD109             BNE      ??what_mcg_mode_8
   \   0000012E   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x06C0             LSLS     R0,R0,#+27
   \   00000134   0xD405             BMI      ??what_mcg_mode_8
   \   00000136   0x....             LDR      R0,??DataTable28  ;; 0x40064006
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x0680             LSLS     R0,R0,#+26
   \   0000013C   0xD401             BMI      ??what_mcg_mode_8
   1911            {
   1912              return FEE;                                                          // return FEE code
   \   0000013E   0x2004             MOVS     R0,#+4
   \   00000140   0xE000             B        ??what_mcg_mode_1
   1913            }
   1914            else
   1915            {
   1916              return 0;                                                            // error condition
   \                     ??what_mcg_mode_8: (+1)
   \   00000142   0x2000             MOVS     R0,#+0
   \                     ??what_mcg_mode_1: (+1)
   \   00000144   0xBD00             POP      {PC}             ;; return
   1917            }
   1918          } // what_mcg_mode
   1919          
   1920          
   1921          /********************************************************************/
   1922          /* Functon name : clk_monitor_0
   1923           *
   1924           * This function SIMply enables or disables the OSC 0 clock monitor. This is
   1925           * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to  
   1926           * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
   1927           * It MUST be disabled in all other modes or a reset may be generated. It must
   1928           * also be disabled if it is desired to enter VLPR from BLPE mode.
   1929           *
   1930           * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
   1931           *
   1932           * Return value : none
   1933           */

   \                                 In section .text, align 2, keep-with-next
   1934          void clk_monitor_0(unsigned char en_dis)
   1935          {         
   \                     clk_monitor_0: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1936            if (en_dis)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??clk_monitor_0_0
   1937            {
   1938              MCG_C6 |= MCG_C6_CME0_MASK;   
   \   00000008   0x....             LDR      R0,??DataTable28_2  ;; 0x40064005
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x4301             ORRS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable28_2  ;; 0x40064005
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0xE005             B        ??clk_monitor_0_1
   1939            }
   1940            else
   1941            {
   1942              MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??clk_monitor_0_0: (+1)
   \   00000016   0x....             LDR      R0,??DataTable28_2  ;; 0x40064005
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x21DF             MOVS     R1,#+223
   \   0000001C   0x4001             ANDS     R1,R1,R0
   \   0000001E   0x....             LDR      R0,??DataTable28_2  ;; 0x40064005
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   1943            }
   1944          }    // end clk_monitor_0
   \                     ??clk_monitor_0_1: (+1)
   \   00000022   0xBD00             POP      {PC}             ;; return
   1945          
   1946          
   1947          /********************************************************************/
   1948          /* Functon name : chk_for_resistor
   1949           *
   1950           * This function is specifically for the Freescale Tower and Freedom boards.
   1951           * It performs a SIMple check to determine if there is an 1M ohm external 
   1952           * feedback resistor connected between extal and xtal. It returns a 1 if the
   1953           * resistor is detected or a 0 if the resistor is not detected. This can be used
   1954           * by the calling routine to compare the test result with the value for HGO that
   1955           * is being used to configure the oscillator. This helps ensure the correct
   1956           * configuration is used.
   1957           *
   1958           * This check is used just to test for the presence of a 1M resistor, it MUST
   1959           * NOT be used in user code to automatically configure the oscillator HGO value.
   1960           *
   1961           * It SIMply configures the crystal pins as GPIO outputs, sets them both low,
   1962           * configures one as high and then configures the other as an input (no pull
   1963           * up). If the resistor is present then the input will be pulled high. This
   1964           * process is repeated for the pin functions reversed. Both conditions have 
   1965           * to result in the input being pulled high for the resistor to be identifiedas
   1966           * being present.
   1967           */

   \                                 In section .text, align 2, keep-with-next
   1968          unsigned char chk_for_resistor(void)
   1969          {
   \                     chk_for_resistor: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1970            unsigned char extal_high = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   1971            unsigned char xtal_high = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   1972            short i;
   1973            
   1974            // Configure EXTAL (PTA18) and XTAL PTA(19) as GPIO driving Low, no pull enabled
   1975            FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 output data
   \   00000006   0x22C0             MOVS     R2,#+192
   \   00000008   0x0312             LSLS     R2,R2,#+12       ;; #+786432
   \   0000000A   0x....             LDR      R3,??DataTable28_3  ;; 0xf80ff008
   \   0000000C   0x601A             STR      R2,[R3, #+0]
   1976            FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
   \   0000000E   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x23C0             MOVS     R3,#+192
   \   00000014   0x031B             LSLS     R3,R3,#+12       ;; #+786432
   \   00000016   0x4313             ORRS     R3,R3,R2
   \   00000018   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   0000001A   0x6013             STR      R3,[R2, #+0]
   1977            PORTA_GPCHR = (0xC0000 | PORT_PCR_MUX(1)); // configure the pin muxes for GPIO
   \   0000001C   0x....             LDR      R2,??DataTable28_5  ;; 0xc0100
   \   0000001E   0x....             LDR      R3,??DataTable28_6  ;; 0x40049084
   \   00000020   0x601A             STR      R2,[R3, #+0]
   1978            // Drive EXTAL high
   1979            FGPIOA_PSOR = 0x40000; // set PTA18 data out high
   \   00000022   0x2280             MOVS     R2,#+128
   \   00000024   0x02D2             LSLS     R2,R2,#+11       ;; #+262144
   \   00000026   0x....             LDR      R3,??DataTable28_7  ;; 0xf80ff004
   \   00000028   0x601A             STR      R2,[R3, #+0]
   1980            // Configure XTAL as an Input, no pull up 
   1981            FGPIOA_PDDR &= ~(0x80000); // clear PTA19 data direction to make it an input 
   \   0000002A   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x....             LDR      R3,??DataTable28_8  ;; 0xfff7ffff
   \   00000030   0x4013             ANDS     R3,R3,R2
   \   00000032   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   00000034   0x6013             STR      R3,[R2, #+0]
   1982            // Wait for ~2 time constants
   1983            for (i = 0 ; i < 300 ; i++) {} 
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0xE000             B        ??chk_for_resistor_0
   \                     ??chk_for_resistor_1: (+1)
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
   \                     ??chk_for_resistor_0: (+1)
   \   0000003C   0xB212             SXTH     R2,R2
   \   0000003E   0x2396             MOVS     R3,#+150
   \   00000040   0x005B             LSLS     R3,R3,#+1        ;; #+300
   \   00000042   0x429A             CMP      R2,R3
   \   00000044   0xDBF9             BLT      ??chk_for_resistor_1
   1984            // Check if XTAL was pulled high
   1985            if (FGPIOA_PDIR & 0x80000)
   \   00000046   0x....             LDR      R2,??DataTable28_9  ;; 0xf80ff010
   \   00000048   0x6812             LDR      R2,[R2, #+0]
   \   0000004A   0x0312             LSLS     R2,R2,#+12
   \   0000004C   0xD500             BPL      ??chk_for_resistor_2
   1986            {
   1987              xtal_high = 1;
   \   0000004E   0x2101             MOVS     R1,#+1
   1988            }
   1989            // Configure EXTAL and XTAL as GPIO driving low
   1990            FGPIOA_PCOR = 0xC0000; // clear PTA18 and 19 data output
   \                     ??chk_for_resistor_2: (+1)
   \   00000050   0x22C0             MOVS     R2,#+192
   \   00000052   0x0312             LSLS     R2,R2,#+12       ;; #+786432
   \   00000054   0x....             LDR      R3,??DataTable28_3  ;; 0xf80ff008
   \   00000056   0x601A             STR      R2,[R3, #+0]
   1991            FGPIOA_PDDR |= 0xC0000; // set PTA18 and 19 as outputs
   \   00000058   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   0000005A   0x6812             LDR      R2,[R2, #+0]
   \   0000005C   0x23C0             MOVS     R3,#+192
   \   0000005E   0x031B             LSLS     R3,R3,#+12       ;; #+786432
   \   00000060   0x4313             ORRS     R3,R3,R2
   \   00000062   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   00000064   0x6013             STR      R3,[R2, #+0]
   1992            // Drive XTAL high
   1993            FGPIOA_PSOR = 0x80000; // set PTA19 data out high
   \   00000066   0x2280             MOVS     R2,#+128
   \   00000068   0x0312             LSLS     R2,R2,#+12       ;; #+524288
   \   0000006A   0x....             LDR      R3,??DataTable28_7  ;; 0xf80ff004
   \   0000006C   0x601A             STR      R2,[R3, #+0]
   1994            // Configure EXTAL as Input, no pull up
   1995            FGPIOA_PDDR &= ~(0x40000); // clear PTA18 data direction to make it an input
   \   0000006E   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   00000070   0x6812             LDR      R2,[R2, #+0]
   \   00000072   0x....             LDR      R3,??DataTable28_10  ;; 0xfffbffff
   \   00000074   0x4013             ANDS     R3,R3,R2
   \   00000076   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   00000078   0x6013             STR      R3,[R2, #+0]
   1996            // Wait for ~2 time constants
   1997            for (i = 0 ; i < 300 ; i++) {} 
   \   0000007A   0x2200             MOVS     R2,#+0
   \   0000007C   0xE000             B        ??chk_for_resistor_3
   \                     ??chk_for_resistor_4: (+1)
   \   0000007E   0x1C52             ADDS     R2,R2,#+1
   \                     ??chk_for_resistor_3: (+1)
   \   00000080   0xB212             SXTH     R2,R2
   \   00000082   0x2396             MOVS     R3,#+150
   \   00000084   0x005B             LSLS     R3,R3,#+1        ;; #+300
   \   00000086   0x429A             CMP      R2,R3
   \   00000088   0xDBF9             BLT      ??chk_for_resistor_4
   1998            // Check if EXTAL was pulled high
   1999            if (FGPIOA_PDIR & 0x40000)
   \   0000008A   0x....             LDR      R2,??DataTable28_9  ;; 0xf80ff010
   \   0000008C   0x6812             LDR      R2,[R2, #+0]
   \   0000008E   0x0352             LSLS     R2,R2,#+13
   \   00000090   0xD500             BPL      ??chk_for_resistor_5
   2000            {
   2001              extal_high = 1;
   \   00000092   0x2001             MOVS     R0,#+1
   2002            }
   2003          
   2004            // Now configure both pins back to their default state
   2005            PORTA_GPCHR = 0x000C0000; // clear pta18 and 19 mux values to default
   \                     ??chk_for_resistor_5: (+1)
   \   00000094   0x22C0             MOVS     R2,#+192
   \   00000096   0x0312             LSLS     R2,R2,#+12       ;; #+786432
   \   00000098   0x....             LDR      R3,??DataTable28_6  ;; 0x40049084
   \   0000009A   0x601A             STR      R2,[R3, #+0]
   2006            FGPIOA_PDDR &= ~(0xC0000);    // set PTA18 and 19 as inputs
   \   0000009C   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   0000009E   0x6812             LDR      R2,[R2, #+0]
   \   000000A0   0x....             LDR      R3,??DataTable28_11  ;; 0xfff3ffff
   \   000000A2   0x4013             ANDS     R3,R3,R2
   \   000000A4   0x....             LDR      R2,??DataTable28_4  ;; 0xf80ff014
   \   000000A6   0x6013             STR      R3,[R2, #+0]
   2007            FGPIOA_PCOR = 0xC0000;        // clear PTA18 and 19 output data
   \   000000A8   0x22C0             MOVS     R2,#+192
   \   000000AA   0x0312             LSLS     R2,R2,#+12       ;; #+786432
   \   000000AC   0x....             LDR      R3,??DataTable28_3  ;; 0xf80ff008
   \   000000AE   0x601A             STR      R2,[R3, #+0]
   2008          
   2009            // If both rising and falling are true return 1, else return 0
   2010            if (extal_high && xtal_high)
   \   000000B0   0xB2C0             UXTB     R0,R0
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD004             BEQ      ??chk_for_resistor_6
   \   000000B6   0xB2C9             UXTB     R1,R1
   \   000000B8   0x2900             CMP      R1,#+0
   \   000000BA   0xD001             BEQ      ??chk_for_resistor_6
   2011            {
   2012              return 1;
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0xE000             B        ??chk_for_resistor_7
   2013            }
   2014            else
   2015            {
   2016              return 0;
   \                     ??chk_for_resistor_6: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \                     ??chk_for_resistor_7: (+1)
   \   000000C2   0xBD00             POP      {PC}             ;; return
   2017            }       
   2018          } // chk_for_resistor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x01BA8141         DC32     0x1ba8141

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x02DC6C00         DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   0x03197501         DC32     0x3197501

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_9:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_10:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_11:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_12:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_13:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_14:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_15:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_16:
   \   00000000   0x00004E20         DC32     0x4e20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x02DC6C00         DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x03197501         DC32     0x3197501

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x001E8480         DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x02DC6C00         DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x03197501         DC32     0x3197501

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_6:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_7:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_8:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_9:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_10:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_11:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_12:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_13:
   \   00000000   0x01312D00         DC32     0x1312d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \   00000000   0xFFF8FFFF         DC32     0xfff8ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \   00000000   0x00009897         DC32     0x9897

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x41A80000         DC32     0x41a80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x4006400B         DC32     0x4006400b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x4006400A         DC32     0x4006400a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0x40064002         DC32     0x40064002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x40064003         DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x01312D00         DC32     0x1312d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x017D7841         DC32     0x17d7841

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \   00000000   0x02625A00         DC32     0x2625a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \   00000000   0x00000895         DC32     0x895

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \   00000000   0x03938700         DC32     0x3938700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \   00000000   0x047868C1         DC32     0x47868c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \   00000000   0x00000B71         DC32     0xb71

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \   00000000   0x04C4B400         DC32     0x4c4b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \   00000000   0x05F5E101         DC32     0x5f5e101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_2:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_3:
   \   00000000   0xF80FF008         DC32     0xf80ff008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_4:
   \   00000000   0xF80FF014         DC32     0xf80ff014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_5:
   \   00000000   0x000C0100         DC32     0xc0100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_6:
   \   00000000   0x40049084         DC32     0x40049084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_7:
   \   00000000   0xF80FF004         DC32     0xf80ff004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_8:
   \   00000000   0xFFF7FFFF         DC32     0xfff7ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_9:
   \   00000000   0xF80FF010         DC32     0xf80ff010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_10:
   \   00000000   0xFFFBFFFF         DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_11:
   \   00000000   0xFFF3FFFF         DC32     0xfff3ffff
   2019          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   atc
        24   -> __aeabi_f2iz
        24   -> __aeabi_fdiv
        24   -> __aeabi_fmul
        24   -> __aeabi_i2f
        24   -> what_mcg_mode
        24 __aeabi_idiv
        24 __aeabi_uidiv
       4   blpe_fbe
      16   blpe_pbe
        16 __aeabi_idiv
       4   blpi_fbi
         4 __aeabi_idiv
       4   chk_for_resistor
       4   clk_monitor_0
       4   fbe_blpe
       4   fbe_fbi
         4 __aeabi_idiv
       8   fbe_fee
         8   -> fll_freq
         8 __aeabi_idiv
       8   fbe_fei
         8   -> fll_freq
      16   fbe_pbe
        16 __aeabi_idiv
       4   fbi_blpi
         4 __aeabi_idiv
      12   fbi_fbe
      16   fbi_fee
        16   -> fll_freq
        16 __aeabi_idiv
       8   fbi_fei
         8   -> fll_freq
       4   fee_fbe
       4   fee_fbi
         4 __aeabi_idiv
       8   fee_fei
         8   -> fll_freq
      12   fei_fbe
       4   fei_fbi
         4 __aeabi_idiv
      16   fei_fee
        16   -> fll_freq
        16 __aeabi_idiv
       4   fll_freq
      16   new_pll_freq
        16 __aeabi_idiv
       4   pbe_blpe
       4   pbe_fbe
       8   pbe_pee
         8 __aeabi_idiv
       4   pee_pbe
      24   pll_init
        24 __aeabi_idiv
       4   what_mcg_mode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_10
       4  ??DataTable0_11
       4  ??DataTable0_12
       4  ??DataTable0_13
       4  ??DataTable0_14
       4  ??DataTable0_15
       4  ??DataTable0_16
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable0_8
       4  ??DataTable0_9
       4  ??DataTable1
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable1_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_10
       4  ??DataTable23_11
       4  ??DataTable23_12
       4  ??DataTable23_13
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable23_6
       4  ??DataTable23_7
       4  ??DataTable23_8
       4  ??DataTable23_9
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_10
       4  ??DataTable28_11
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       4  ??DataTable28_5
       4  ??DataTable28_6
       4  ??DataTable28_7
       4  ??DataTable28_8
       4  ??DataTable28_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable7
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
     400  atc
     100  blpe_fbe
     236  blpe_pbe
      90  blpi_fbi
     196  chk_for_resistor
      36  clk_monitor_0
       1  dmx32_val
       1  drs_val
      60  fbe_blpe
     340  fbe_fbi
     180  fbe_fee
     188  fbe_fei
     260  fbe_pbe
      90  fbi_blpi
     396  fbi_fbe
     436  fbi_fee
     176  fbi_fei
     104  fee_fbe
     326  fee_fbi
     122  fee_fei
     388  fei_fbe
     284  fei_fbi
     372  fei_fee
     326  fll_freq
     410  new_pll_freq
      60  pbe_blpe
      96  pbe_fbe
     178  pbe_pee
     104  pee_pbe
     674  pll_init
     326  what_mcg_mode

 
     2 bytes in section .bss
 7 602 bytes in section .text
 
 7 602 bytes of CODE memory
     2 bytes of DATA memory

Errors: none
Warnings: none
