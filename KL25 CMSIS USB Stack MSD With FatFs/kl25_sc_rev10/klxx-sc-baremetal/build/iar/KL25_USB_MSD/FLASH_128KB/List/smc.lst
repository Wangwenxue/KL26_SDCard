###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        18/Feb/2016  22:52:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\smc\smc.c
#    Command line =  
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\smc\smc.c" -D IAR -D
#        FREEDOM -D SD_DISK_ENABLE -lCN "D:\My Project\SDCardJicheng\KL25 CMSIS
#        USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -lB "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -o "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\common\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\i2c\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\platforms\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\" -I
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\inc\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack
#        MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB
#        Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\SPI_SDCard\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\"
#        -Ol
#    List file    =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\smc.lst
#    Object file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\smc.o
#
###############################################################################

D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\drivers\smc\smc.c
      1          /*
      2           * File:        smc.c
      3           * Purpose:     Provides routines for entering low power modes.
      4           *
      5           * Notes:	Since the wakeup mechanism for low power modes
      6           *              will be application specific, these routines
      7           *              do not include code to setup interrupts to exit
      8           *              from the low power modes. The desired means of
      9           *              low power mode exit should be configured before
     10           *              calling any of these functions.
     11           *
     12           *              These routines do not include protection to
     13           *              prevent illegal state transitions in the mode
     14           *              controller, and all routines that write to the
     15           *              PMPROT register write a value to allow all
     16           *              possible low power modes (it is write once, so
     17           *              if only the currently requested mode is enabled
     18           *              a different mode couldn't be enabled later on).
     19           *              
     20           */
     21          
     22          #include "common.h"
     23          #include "smc.h"
     24          
     25          /***************************************************************/
     26          /*
     27           * Configures the ARM system control register for WAIT(sleep)mode
     28           * and then executes the WFI instruction to enter the mode.
     29           *
     30           * Parameters:
     31           * none
     32           *
     33           */
     34          

   \                                 In section .text, align 4, keep-with-next
     35          void sleep (void)
     36          {
     37          /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) 
     38           * mode instead of deep sleep.
     39           */
     40          SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
   \                     sleep: (+1)
   \   00000000   0x....             LDR      R0,??DataTable11  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x4388             BICS     R0,R0,R1
   \   00000008   0x....             LDR      R1,??DataTable11  ;; 0xe000ed10
   \   0000000A   0x6008             STR      R0,[R1, #+0]
     41          
     42          #ifdef CMSIS
     43            __wfi();
     44          #else
     45            /* WFI instruction will start entry into WAIT mode */
     46            asm("WFI");
   \   0000000C   0xBF30             WFI
     47          #endif 
     48          }
   \   0000000E   0x4770             BX       LR               ;; return
     49          /***************************************************************/
     50          /*
     51           * Configures the ARM system control register for STOP  
     52           * (deepsleep) mode and then executes the WFI instruction 
     53           * to enter the mode.
     54           *
     55           * Parameters:
     56           * none
     57           *
     58           */
     59          

   \                                 In section .text, align 4, keep-with-next
     60          void deepsleep (void)
     61          {
     62            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
     63            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
   \                     deepsleep: (+1)
   \   00000000   0x....             LDR      R0,??DataTable11  ;; 0xe000ed10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable11  ;; 0xe000ed10
   \   0000000A   0x6001             STR      R1,[R0, #+0]
     64          
     65          #ifdef CMSIS
     66            __wfi();
     67          #else
     68            /* WFI instruction will start entry into STOP mode */
     69            asm("WFI");
   \   0000000C   0xBF30             WFI
     70          #endif
     71          }
   \   0000000E   0x4770             BX       LR               ;; return
     72          /********************************************************************/
     73          /* WAIT mode entry routine. Puts the processor into wait mode.
     74           * In this mode the core clock is disabled (no code executing), but 
     75           * bus clocks are enabled (peripheral modules are operational). 
     76           *
     77           * Mode transitions:
     78           * RUN -> WAIT
     79           * VLPR -> VLPW
     80           *
     81           * This function can be used to enter normal wait mode or VLPW
     82           * mode. If you are executing in normal run mode when calling this
     83           * function, then you will enter normal wait mode. If you are in VLPR
     84           * mode when calling this function, then you will enter VLPW mode instead.
     85           *
     86           * NOTE: Some modules include a programmable option to disable them in 
     87           * wait mode. If those modules are programmed to disable in wait mode, 
     88           * they will not be able to generate interrupts to wake up the core.
     89           *
     90           * WAIT mode is exited using any enabled interrupt or RESET, so no
     91           * exit_wait routine is needed. 
     92           * 
     93           * 
     94           * Parameters:
     95           * none
     96           */

   \                                 In section .text, align 2, keep-with-next
     97          void enter_wait(void)
     98          {
   \                     enter_wait: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     99          #ifdef CMSIS
    100              /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
    101               * of deep sleep.
    102               */
    103          	SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
    104                  
    105              __wfi();
    106          #else
    107              wait();
   \   00000002   0x.... 0x....      BL       wait
    108          #endif
    109          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    110          /********************************************************************/
    111          /* STOP mode entry routine. Puts the processor into normal stop mode.
    112           * In this mode core, bus and peripheral clocks are disabled.
    113           *
    114           * Mode transitions:
    115           * RUN -> STOP
    116           *
    117           * This function can be used to enter normal stop mode. 
    118           * If you are executing in normal run mode when calling this
    119           * function and AVLP = 0, then you will enter normal stop mode. 
    120           * If AVLP = 1 with previous write to PMPROT
    121           * then you will enter VLPS mode instead.
    122           *
    123           * STOP mode is exited using any enabled interrupt or RESET, so no
    124           * exit_stop routine is needed.
    125           *
    126           * Parameters:
    127           * Partial Stop Option:  
    128           *  0x00 = STOP - Normal Stop Mode
    129           *  0x40 = PSTOP1 - Partial Stop with both system and bus clocks disabled
    130           *  0x80 = PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
    131           *  0xC0 = Reserved
    132           */

   \                                 In section .text, align 2, keep-with-next
    133          void enter_stop(unsigned char partial_stop_opt)
    134          {
   \                     enter_stop: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    135            /* The PMPROT register may have already been written by init code
    136               If so then this next write is not done since  
    137               PMPROT is write once after RESET  
    138               this write-once bit allows the MCU to enter the
    139               normal STOP mode.
    140               If AVLP is already a 1, VLPS mode is entered instead of normal STOP*/
    141            SMC_PMPROT = 0;  
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR      R2,??DataTable10  ;; 0x4007e000
   \   00000006   0x7011             STRB     R1,[R2, #+0]
    142          
    143            /* Set the STOPM field to 0b000 for normal STOP mode */
    144            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
   \   00000008   0x....             LDR      R1,??DataTable11_1  ;; 0x4007e001
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x22F8             MOVS     R2,#+248
   \   0000000E   0x400A             ANDS     R2,R2,R1
   \   00000010   0x....             LDR      R1,??DataTable11_1  ;; 0x4007e001
   \   00000012   0x700A             STRB     R2,[R1, #+0]
    145            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0); 
   \   00000014   0x....             LDR      R1,??DataTable11_1  ;; 0x4007e001
   \   00000016   0x7809             LDRB     R1,[R1, #+0]
   \   00000018   0x....             LDR      R2,??DataTable11_1  ;; 0x4007e001
   \   0000001A   0x7011             STRB     R1,[R2, #+0]
    146            SMC_STOPCTRL &= ~SMC_STOPCTRL_PSTOPO_MASK;
   \   0000001C   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000022   0x0E89             LSRS     R1,R1,#+26
   \   00000024   0x....             LDR      R2,??DataTable10_1  ;; 0x4007e002
   \   00000026   0x7011             STRB     R1,[R2, #+0]
    147            SMC_STOPCTRL |= partial_stop_opt;
   \   00000028   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   0000002A   0x7809             LDRB     R1,[R1, #+0]
   \   0000002C   0x4308             ORRS     R0,R0,R1
   \   0000002E   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    148            /*wait for write to complete to SMC before stopping core */  
    149            partial_stop_opt = SMC_PMCTRL;
   \   00000032   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
    150            
    151          #ifdef CMSIS
    152            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    153            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    154            __wfi();
    155          #else
    156            stop();
   \   00000036   0x.... 0x....      BL       stop
    157          #endif
    158          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    159          /****************************************************************/
    160          /* VLPR mode entry routine.Puts the processor into very low power
    161           * run mode. In this mode all clocks are enabled, but the core clock limited. 
    162           * The flash clock is limited to 1MHz or less. 
    163           *
    164           * Mode transitions:
    165           * RUN -> VLPR
    166           *
    167           * exit_vlpr() function can be used 
    168           * to switch from VLPR back to RUN. 
    169           * 
    170           * while in VLPR,VLPW or VLPS the exit to VLPR is not possible  
    171           *
    172           *
    173           * Parameters:
    174           * Return value : PMSTAT value or error code
    175           *                PMSTAT = return_value = PMSTAT
    176           *                         000_0001 Current power mode is RUN
    177           *                         000_0100 Current power mode is VLPR
    178           *                ERROR Code =  0x14 - already in VLPR mode
    179           *                           =  0x24 - REGONS never clear indicating stop regulation
    180           */

   \                                 In section .text, align 2, keep-with-next
    181          int enter_vlpr(void)
    182          {
   \                     enter_vlpr: (+1)
   \   00000000   0xB500             PUSH     {LR}
    183            int i; 
    184            unsigned int return_value = 0;  //default return value = indicates error
   \   00000002   0x2000             MOVS     R0,#+0
    185            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
   \   00000004   0x....             LDR      R1,??DataTable11_2  ;; 0x4007e003
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0xB2C9             UXTB     R1,R1
   \   0000000A   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   0000000C   0x0E49             LSRS     R1,R1,#+25
   \   0000000E   0x2904             CMP      R1,#+4
   \   00000010   0xD100             BNE      ??enter_vlpr_0
    186                   return_value = 0x14;
   \   00000012   0x2014             MOVS     R0,#+20
    187                   }
    188            /* The PMPROT register may have already been written by init code
    189               If so then this next write is not done.  
    190               PMPROT is write once after RESET  
    191               this write-once bit allows the MCU to enter the
    192               very low power modes: VLPR, VLPW, and VLPS   */
    193            SMC_PMPROT = SMC_PMPROT_AVLP_MASK;  
   \                     ??enter_vlpr_0: (+1)
   \   00000014   0x2120             MOVS     R1,#+32
   \   00000016   0x....             LDR      R2,??DataTable10  ;; 0x4007e000
   \   00000018   0x7011             STRB     R1,[R2, #+0]
    194              
    195            /* Set the (for MC1)LPLLSM or (for MC2)STOPM field 
    196               to 0b010 for VLPS mode -
    197               and RUNM bits to 0b010 for VLPR mode  */
    198            SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK; 
   \   0000001A   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x229F             MOVS     R2,#+159
   \   00000020   0x400A             ANDS     R2,R2,R1
   \   00000022   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000024   0x700A             STRB     R2,[R1, #+0]
    199            SMC_PMCTRL  |= SMC_PMCTRL_RUNM(0x2);
   \   00000026   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x2240             MOVS     R2,#+64
   \   0000002C   0x430A             ORRS     R2,R2,R1
   \   0000002E   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000030   0x700A             STRB     R2,[R1, #+0]
    200            /* Wait for VLPS regulator mode to be confirmed */
    201            for (i = 0 ; i < 10000 ; i++)
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xE000             B        ??enter_vlpr_1
   \                     ??enter_vlpr_2: (+1)
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \                     ??enter_vlpr_1: (+1)
   \   00000038   0x....             LDR      R2,??DataTable11_3  ;; 0x2710
   \   0000003A   0x4291             CMP      R1,R2
   \   0000003C   0xDA04             BGE      ??enter_vlpr_3
    202              {     /* check that the value of REGONS bit is not 0
    203                       once it is a zero we can stop checking */
    204                if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04){
   \   0000003E   0x....             LDR      R2,??DataTable11_4  ;; 0x4007d002
   \   00000040   0x7812             LDRB     R2,[R2, #+0]
   \   00000042   0xB2D2             UXTB     R2,R2
   \   00000044   0x0752             LSLS     R2,R2,#+29
   \   00000046   0xD4F6             BMI      ??enter_vlpr_2
    205                 /* 0 Regulator is in stop regulation or in transition 
    206                      to/from it
    207                    1 MCU is in Run regulation mode */
    208                }  
    209                else  break;
    210              }  
    211            if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04) 
   \                     ??enter_vlpr_3: (+1)
   \   00000048   0x....             LDR      R1,??DataTable11_4  ;; 0x4007d002
   \   0000004A   0x7809             LDRB     R1,[R1, #+0]
   \   0000004C   0xB2C9             UXTB     R1,R1
   \   0000004E   0x0749             LSLS     R1,R1,#+29
   \   00000050   0xD500             BPL      ??enter_vlpr_4
    212              {  
    213                return_value = 0x24; 
   \   00000052   0x2024             MOVS     R0,#+36
    214              }
    215            /* SMC_PMSTAT register only exist in Mode Controller 2 MCU versions */
    216            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) == 4)  
   \                     ??enter_vlpr_4: (+1)
   \   00000054   0x....             LDR      R1,??DataTable11_2  ;; 0x4007e003
   \   00000056   0x7809             LDRB     R1,[R1, #+0]
   \   00000058   0xB2C9             UXTB     R1,R1
   \   0000005A   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   0000005C   0x0E49             LSRS     R1,R1,#+25
   \   0000005E   0x2904             CMP      R1,#+4
   \   00000060   0xD102             BNE      ??enter_vlpr_5
    217              {
    218                return_value = SMC_PMSTAT;
   \   00000062   0x....             LDR      R0,??DataTable11_2  ;; 0x4007e003
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0xB2C0             UXTB     R0,R0
    219              }
    220            return (return_value);
   \                     ??enter_vlpr_5: (+1)
   \   00000068   0xBD00             POP      {PC}             ;; return
    221          }
    222          /********************************************************************/
    223          /* VLPR mode exit routine. Puts the processor into normal run mode
    224           * from VLPR mode. You can transition from VLPR to normal run using
    225           * this function.
    226           *
    227           * Mode transitions:
    228           * VLPR -> RUN
    229           *
    230           * Parameters:
    231           * none
    232           */
    233           /********************************************************************/
    234          

   \                                 In section .text, align 2, keep-with-next
    235          void exit_vlpr(void)
    236          {
   \                     exit_vlpr: (+1)
   \   00000000   0xB500             PUSH     {LR}
    237              int i;
    238              /* check to make sure in VLPR before exiting    */
    239              if  ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4) {
   \   00000002   0x....             LDR      R0,??DataTable11_2  ;; 0x4007e003
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   0000000A   0x0E40             LSRS     R0,R0,#+25
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD116             BNE      ??exit_vlpr_0
    240                
    241                 /* Clear RUNM */
    242                 SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;
   \   00000010   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x219F             MOVS     R1,#+159
   \   00000016   0x4001             ANDS     R1,R1,R0
   \   00000018   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    243                                
    244                 /* Wait for normal RUN regulation mode to be confirmed */                   
    245                 // 1 PMSTAT MCU is in RUN  mode
    246                 // 4 PMSTAT MCU is in VLPR mode
    247                 for (i=0;i<0xff;i++)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE000             B        ??exit_vlpr_1
   \                     ??exit_vlpr_2: (+1)
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \                     ??exit_vlpr_1: (+1)
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xDA0B             BGE      ??exit_vlpr_0
    248                 {
    249                     if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== SMC_PMSTAT_PMSTAT_MASK)
   \   00000026   0x....             LDR      R1,??DataTable11_2  ;; 0x4007e003
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0xB2C9             UXTB     R1,R1
   \   0000002C   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   0000002E   0x0E49             LSRS     R1,R1,#+25
   \   00000030   0x297F             CMP      R1,#+127
   \   00000032   0xD1F5             BNE      ??exit_vlpr_2
    250                       if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) == PMC_REGSC_REGONS_MASK)
   \   00000034   0x....             LDR      R1,??DataTable11_4  ;; 0x4007d002
   \   00000036   0x7809             LDRB     R1,[R1, #+0]
   \   00000038   0xB2C9             UXTB     R1,R1
   \   0000003A   0x0749             LSLS     R1,R1,#+29
   \   0000003C   0xD5F0             BPL      ??exit_vlpr_2
    251              	        break;
    252                 }           
    253              }  //if in VLPR mode
    254               // else if not in VLPR ignore call
    255          }
   \                     ??exit_vlpr_0: (+1)
   \   0000003E   0xBD00             POP      {PC}             ;; return
    256          /***************************************************************/
    257          /* VLPS mode entry routine. Puts the processor into VLPS mode 
    258           * directly from run or VLPR modes. 
    259           *
    260           * Mode transitions:
    261           * RUN  -> VLPS
    262           * VLPR -> VLPS
    263           *
    264           * Note, when VLPS is entered directly from RUN or VLPR mode, 
    265           * exit to VLPR is disabled by hardware and the system will
    266           * always exit back to RUN.
    267           *
    268           * Parameters:  
    269           * none
    270           */
    271           /****************************************************************/
    272          

   \                                 In section .text, align 2, keep-with-next
    273          void enter_vlps(void)
    274          {
   \                     enter_vlps: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    275            volatile unsigned int dummyread;
    276            /* The PMPROT register may have already been written by init code
    277               If so then this next write is not done since  
    278               PMPROT is write once after RESET 
    279               allows the MCU to enter the VLPR, VLPW, and VLPS modes.
    280               If AVLP is already writen to 0 
    281               Stop is entered instead of VLPS*/
    282            SMC_PMPROT = SMC_PMPROT_AVLP_MASK;           
   \   00000002   0x2020             MOVS     R0,#+32
   \   00000004   0x....             LDR      R1,??DataTable10  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    283            /* Set the STOPM field to 0b010 for VLPS mode */
    284            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    285            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x2); 
   \   00000014   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    286            /*wait for write to complete to SMC before stopping core */  
    287            dummyread = SMC_PMCTRL;
   \   00000020   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x9000             STR      R0,[SP, #+0]
    288            dummyread++;
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    289            /* Now execute the stop instruction to go into VLPS */
    290            #ifdef CMSIS
    291            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    292            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    293            __wfi();
    294          #else
    295            stop();
   \   0000002E   0x.... 0x....      BL       stop
    296          #endif
    297          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    298          /****************************************************************/
    299          /* LLS mode entry routine. Puts the processor into LLS mode from
    300           * normal run mode or VLPR. 
    301           *
    302           * Mode transitions:
    303           * RUN -> LLS
    304           * VLPR -> LLS
    305           *
    306           * NOTE: LLS mode will always exit to RUN mode even if you were 
    307           * in VLPR mode before entering LLS.
    308           *
    309           * Wakeup from LLS mode is controlled by the LLWU module. Most
    310           * modules cannot issue a wakeup interrupt in LLS mode, so make
    311           * sure to setup the desired wakeup sources in the LLWU before 
    312           * calling this function.
    313           *
    314           * Parameters:
    315           * none
    316           */
    317           /********************************************************************/
    318          

   \                                 In section .text, align 2, keep-with-next
    319          void enter_lls(void)
    320          {
   \                     enter_lls: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    321            volatile unsigned int dummyread;
    322            /* Write to PMPROT to allow LLS power modes this write-once 
    323               bit allows the MCU to enter the LLS low power mode*/
    324            SMC_PMPROT = SMC_PMPROT_ALLS_MASK;   
   \   00000002   0x2008             MOVS     R0,#+8
   \   00000004   0x....             LDR      R1,??DataTable10  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    325            /* Set the STOPM field to 0b011 for LLS mode  */
    326            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    327            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x3); 
   \   00000014   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2103             MOVS     R1,#+3
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    328            /*wait for write to complete to SMC before stopping core */  
    329            dummyread = SMC_PMCTRL;
   \   00000020   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x9000             STR      R0,[SP, #+0]
    330            dummyread++;
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    331            /* Now execute the stop instruction to go into LLS */
    332            #ifdef CMSIS
    333            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    334            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    335            __wfi();
    336          #else
    337            stop();
   \   0000002E   0x.... 0x....      BL       stop
    338          #endif
    339          }
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    340          /***************************************************************/
    341          /* VLLS3 mode entry routine. Puts the processor into 
    342           * VLLS3 mode from normal run mode or VLPR. 
    343           *
    344           * Mode transitions:
    345           * RUN -> VLLS3
    346           * VLPR -> VLLS3
    347           *
    348           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    349           * in VLPR mode before entering VLLSx.
    350           *
    351           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    352           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    353           * sure to setup the desired wakeup sources in the LLWU before 
    354           * calling this function.
    355           *
    356           * Parameters:
    357           * none  
    358           */
    359           /********************************************************************/
    360          

   \                                 In section .text, align 2, keep-with-next
    361          void enter_vlls3(void)
    362          {
   \                     enter_vlls3: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    363            volatile unsigned int dummyread;
    364            /* Write to PMPROT to allow VLLS3 power modes */
    365            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable10  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    366            /* Set the STOPM field to 0b100 for VLLS3 mode */
    367            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    368            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000014   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    369            /* set VLLSM = 0b11 */
    370            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(3);          
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    371            /*wait for write to complete to SMC before stopping core */  
    372            dummyread = SMC_STOPCTRL;
   \   00000026   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e002
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    373            dummyread++;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x9000             STR      R0,[SP, #+0]
    374            /* Now execute the stop instruction to go into VLLS3 */
    375            #ifdef CMSIS
    376            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    377            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    378            __wfi();
    379          #else
    380            stop();
   \   00000034   0x.... 0x....      BL       stop
    381          #endif
    382          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    383          /***************************************************************/
    384          /* VLLS2 mode entry routine. Puts the processor into 
    385           * VLLS2 mode from normal run mode or VLPR. 
    386           *
    387           * Mode transitions:
    388           * RUN -> VLLS2
    389           * VLPR -> VLLS2
    390           *
    391           * NOTE: VLLSx modes will always exit to RUN mode even  
    392           *       if you werein VLPR mode before entering VLLSx.
    393           *
    394           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    395           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    396           * sure to setup the desired wakeup sources in the LLWU before 
    397           * calling this function.
    398           *
    399           * Parameters:
    400           * none  
    401           */
    402           /********************************************************************/
    403          

   \                                 In section .text, align 2, keep-with-next
    404          void enter_vlls2(void)
    405          {
   \                     enter_vlls2: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    406            volatile unsigned int dummyread;
    407            /* Write to PMPROT to allow VLLS2 power modes */
    408            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable10  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    409            /* Set the STOPM field to 0b100 for VLLS2 mode */
    410            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    411            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000014   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    412            /* set VLLSM = 0b10 */
    413            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(2);                
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    414            /*wait for write to complete to SMC before stopping core */  
    415            dummyread = SMC_STOPCTRL;
   \   00000026   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e002
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    416            dummyread++;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x9000             STR      R0,[SP, #+0]
    417            /* Now execute the stop instruction to go into VLLS2 */
    418            #ifdef CMSIS
    419            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    420            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    421            __wfi();
    422          #else
    423            stop();
   \   00000034   0x.... 0x....      BL       stop
    424          #endif
    425          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    426          /***************************************************************/
    427          /* VLLS1 mode entry routine. Puts the processor into 
    428           * VLLS1 mode from normal run mode or VLPR. 
    429           *
    430           * Mode transitions:
    431           * RUN -> VLLS1
    432           * VLPR -> VLLS1
    433           *
    434           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    435           * in VLPR mode before entering VLLSx.
    436           *
    437           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    438           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    439           * sure to setup the desired wakeup sources in the LLWU before 
    440           * calling this function.
    441           *
    442           * Parameters:
    443           * none  
    444           */
    445           /********************************************************************/
    446          

   \                                 In section .text, align 2, keep-with-next
    447          void enter_vlls1(void)
    448          {
   \                     enter_vlls1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    449            volatile unsigned int dummyread;
    450            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable10  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    451              
    452            /* Write to PMPROT to allow all possible power modes */
    453            /* Set the STOPM field to 0b100 for VLLS1 mode */
    454            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x21F8             MOVS     R1,#+248
   \   0000000E   0x4001             ANDS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   00000012   0x7001             STRB     R1,[R0, #+0]
    455            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000014   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x2104             MOVS     R1,#+4
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable10_2  ;; 0x4007e001
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
    456            /* set VLLSM = 0b01 */
    457            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(1);          
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    458            /*wait for write to complete to SMC before stopping core */  
    459            dummyread = SMC_STOPCTRL;
   \   00000026   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e002
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
    460            dummyread++;
   \   0000002E   0x9800             LDR      R0,[SP, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x9000             STR      R0,[SP, #+0]
    461            /* Now execute the stop instruction to go into VLLS1 */
    462            #ifdef CMSIS
    463            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    464            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    465            __wfi();
    466          #else
    467            stop();
   \   00000034   0x.... 0x....      BL       stop
    468          #endif
    469          }
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    470          
    471          /********************************************************************/
    472          /* VLLS0 mode entry routine. Puts the processor into VLLS0 mode from
    473           * normal run mode or VLPR. 
    474           *
    475           * Mode transitions:
    476           * RUN -> VLLS0
    477           * VLPR -> VLLS0
    478           *
    479           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    480           * in VLPR mode before entering VLLSx.
    481           *
    482           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    483           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    484           * sure to setup the desired wakeup sources in the LLWU before 
    485           * calling this function.
    486           *
    487           * Parameters:
    488           * PORPO_value - 0 POR detect circuit is enabled in VLLS0
    489           *               1 POR detect circuit is disabled in VLLS0
    490           */
    491           /***************************************************************/
    492          

   \                                 In section .text, align 2, keep-with-next
    493          void enter_vlls0(unsigned char PORPO_value )
    494          {
   \                     enter_vlls0: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    495            int i;
    496            /* Write to PMPROT to allow all possible power modes */
    497            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
   \   00000002   0x2102             MOVS     R1,#+2
   \   00000004   0x....             LDR      R2,??DataTable10  ;; 0x4007e000
   \   00000006   0x7011             STRB     R1,[R2, #+0]
    498            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
   \   00000008   0x....             LDR      R1,??DataTable11_2  ;; 0x4007e003
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0xB2C9             UXTB     R1,R1
   \   0000000E   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   00000010   0x0E49             LSRS     R1,R1,#+25
   \   00000012   0x2904             CMP      R1,#+4
   \   00000014   0xD111             BNE      ??enter_vlls0_0
    499               SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
   \   00000016   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000018   0x7809             LDRB     R1,[R1, #+0]
   \   0000001A   0x229F             MOVS     R2,#+159
   \   0000001C   0x400A             ANDS     R2,R2,R1
   \   0000001E   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000020   0x700A             STRB     R2,[R1, #+0]
    500               for (i=0;i<0xff;i++)
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xE000             B        ??enter_vlls0_1
   \                     ??enter_vlls0_2: (+1)
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \                     ??enter_vlls0_1: (+1)
   \   00000028   0x29FF             CMP      R1,#+255
   \   0000002A   0xDA06             BGE      ??enter_vlls0_0
    501                 {
    502                 if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
   \   0000002C   0x....             LDR      R2,??DataTable11_2  ;; 0x4007e003
   \   0000002E   0x7812             LDRB     R2,[R2, #+0]
   \   00000030   0xB2D2             UXTB     R2,R2
   \   00000032   0x0652             LSLS     R2,R2,#+25       ;; ZeroExtS R2,R2,#+25,#+25
   \   00000034   0x0E52             LSRS     R2,R2,#+25
   \   00000036   0x2A01             CMP      R2,#+1
   \   00000038   0xD1F5             BNE      ??enter_vlls0_2
    503              	 break;
    504                 }
    505            }
    506            /* Set the STOPM field to 0b100 for VLLS0 mode */
    507            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \                     ??enter_vlls0_0: (+1)
   \   0000003A   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x22F8             MOVS     R2,#+248
   \   00000040   0x400A             ANDS     R2,R2,R1
   \   00000042   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000044   0x700A             STRB     R2,[R1, #+0]
    508            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000046   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000048   0x7809             LDRB     R1,[R1, #+0]
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0x430A             ORRS     R2,R2,R1
   \   0000004E   0x....             LDR      R1,??DataTable10_2  ;; 0x4007e001
   \   00000050   0x700A             STRB     R2,[R1, #+0]
    509            /* set VLLSM = 0b00 */
    510            SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
   \   00000052   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0x22F8             MOVS     R2,#+248
   \   00000058   0x400A             ANDS     R2,R2,R1
   \   0000005A   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   0000005C   0x700A             STRB     R2,[R1, #+0]
    511            SMC_STOPCTRL &= ~SMC_STOPCTRL_PORPO_MASK;
   \   0000005E   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000060   0x7809             LDRB     R1,[R1, #+0]
   \   00000062   0x22DF             MOVS     R2,#+223
   \   00000064   0x400A             ANDS     R2,R2,R1
   \   00000066   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000068   0x700A             STRB     R2,[R1, #+0]
    512            SMC_STOPCTRL |=  (PORPO_value <<SMC_STOPCTRL_PORPO_SHIFT) 
    513                           | SMC_STOPCTRL_VLLSM(0);          
   \   0000006A   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0xB2C0             UXTB     R0,R0
   \   00000070   0x0140             LSLS     R0,R0,#+5
   \   00000072   0x4308             ORRS     R0,R0,R1
   \   00000074   0x....             LDR      R1,??DataTable10_1  ;; 0x4007e002
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    514            /*wait for write to complete to SMC before stopping core */  
    515            PORPO_value = SMC_STOPCTRL;
   \   00000078   0x....             LDR      R0,??DataTable10_1  ;; 0x4007e002
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
    516            /* Now execute the stop instruction to go into VLLS0 */
    517            #ifdef CMSIS
    518            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    519            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    520            __wfi();
    521          #else
    522            stop();
   \   0000007C   0x.... 0x....      BL       stop
    523          #endif
    524          }
   \   00000080   0xBD01             POP      {R0,PC}          ;; return
    525          /***************************************************************/
    526          /* VLLS0 mode entry routine. Puts the processor into VLLS0 mode from
    527           * normal run mode or VLPR with the POR circuit disabled
    528           *
    529           * Mode transitions:
    530           * RUN -> VLLS0
    531           * VLPR -> VLLS0
    532           *
    533           * NOTE: VLLSx modes will always exit to RUN mode even if you were 
    534           * in VLPR mode before entering VLLSx.
    535           *
    536           * Wakeup from VLLSx mode is controlled by the LLWU module. Most
    537           * modules cannot issue a wakeup interrupt in VLLSx mode, so make
    538           * sure to setup the desired wakeup sources in the LLWU before 
    539           * calling this function.
    540           *
    541           * Parameters:
    542           * PORPO = 1-  POR detect circuit is disabled in VLLS0
    543           */
    544          /***************************************************************/

   \                                 In section .text, align 2, keep-with-next
    545          void enter_vlls0_nopor(void)
    546          {
   \                     enter_vlls0_nopor: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    547            volatile unsigned int dummyread;
    548            int i;
    549            /* Write to PMPROT to allow all possible power modes */
    550            SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x....             LDR      R1,??DataTable11_5  ;; 0x4007e000
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    551            if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
   \   00000008   0x....             LDR      R0,??DataTable11_2  ;; 0x4007e003
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   00000010   0x0E40             LSRS     R0,R0,#+25
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD111             BNE      ??enter_vlls0_nopor_0
    552               SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
   \   00000016   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x219F             MOVS     R1,#+159
   \   0000001C   0x4001             ANDS     R1,R1,R0
   \   0000001E   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000020   0x7001             STRB     R1,[R0, #+0]
    553               for (i=0;i<0xff;i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE000             B        ??enter_vlls0_nopor_1
   \                     ??enter_vlls0_nopor_2: (+1)
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \                     ??enter_vlls0_nopor_1: (+1)
   \   00000028   0x28FF             CMP      R0,#+255
   \   0000002A   0xDA06             BGE      ??enter_vlls0_nopor_0
    554                 {
    555                 if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
   \   0000002C   0x....             LDR      R1,??DataTable11_2  ;; 0x4007e003
   \   0000002E   0x7809             LDRB     R1,[R1, #+0]
   \   00000030   0xB2C9             UXTB     R1,R1
   \   00000032   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   00000034   0x0E49             LSRS     R1,R1,#+25
   \   00000036   0x2901             CMP      R1,#+1
   \   00000038   0xD1F5             BNE      ??enter_vlls0_nopor_2
    556              	 break;
    557                 }
    558            }
    559            /* Set the STOPM field to 0b100 for VLLS0 mode */
    560            SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \                     ??enter_vlls0_nopor_0: (+1)
   \   0000003A   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x21F8             MOVS     R1,#+248
   \   00000040   0x4001             ANDS     R1,R1,R0
   \   00000042   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    561            SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
   \   00000046   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x2104             MOVS     R1,#+4
   \   0000004C   0x4301             ORRS     R1,R1,R0
   \   0000004E   0x....             LDR      R0,??DataTable11_1  ;; 0x4007e001
   \   00000050   0x7001             STRB     R1,[R0, #+0]
    562            /* set VLLSM = 00 * and PORPO = 1 */
    563            SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
   \   00000052   0x....             LDR      R0,??DataTable11_6  ;; 0x4007e002
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x21F8             MOVS     R1,#+248
   \   00000058   0x4001             ANDS     R1,R1,R0
   \   0000005A   0x....             LDR      R0,??DataTable11_6  ;; 0x4007e002
   \   0000005C   0x7001             STRB     R1,[R0, #+0]
    564            SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(0) | SMC_STOPCTRL_PORPO_MASK;  
   \   0000005E   0x2020             MOVS     R0,#+32
   \   00000060   0x....             LDR      R1,??DataTable11_6  ;; 0x4007e002
   \   00000062   0x7008             STRB     R0,[R1, #+0]
    565            /*wait for write to complete to SMC before stopping core */  
    566            dummyread = SMC_STOPCTRL;
   \   00000064   0x....             LDR      R0,??DataTable11_6  ;; 0x4007e002
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0xB2C0             UXTB     R0,R0
   \   0000006A   0x9000             STR      R0,[SP, #+0]
    567            dummyread++;
   \   0000006C   0x9800             LDR      R0,[SP, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x9000             STR      R0,[SP, #+0]
    568            /* Now execute the stop instruction to go into VLLS0 */
    569            #ifdef CMSIS
    570            /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
    571            SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    572            __wfi();
    573          #else
    574            stop();
   \   00000072   0x.... 0x....      BL       stop
    575          #endif
    576          }
   \   00000076   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x4007E002         DC32     0x4007e002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x4007E003         DC32     0x4007e003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x4007D002         DC32     0x4007d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x4007E000         DC32     0x4007e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x4007E002         DC32     0x4007e002
    577          
    578          
    579          /********************************************************************/
    580          /********************End of Functions *******************************/
    581          /********************************************************************/
    582          
    583          
    584          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   deepsleep
       8   enter_lls
         8   -> stop
       8   enter_stop
         8   -> stop
       8   enter_vlls0
         8   -> stop
       8   enter_vlls0_nopor
         8   -> stop
       8   enter_vlls1
         8   -> stop
       8   enter_vlls2
         8   -> stop
       8   enter_vlls3
         8   -> stop
       4   enter_vlpr
       8   enter_vlps
         8   -> stop
       8   enter_wait
         8   -> wait
       4   exit_vlpr
       0   sleep


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
      16  deepsleep
      52  enter_lls
      60  enter_stop
     130  enter_vlls0
     120  enter_vlls0_nopor
      58  enter_vlls1
      58  enter_vlls2
      58  enter_vlls3
     106  enter_vlpr
      52  enter_vlps
       8  enter_wait
      64  exit_vlpr
      16  sleep

 
 838 bytes in section .text
 
 838 bytes of CODE memory

Errors: none
Warnings: none
