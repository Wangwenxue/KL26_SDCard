###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        18/Feb/2016  22:52:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\fsl_sdspi_disk.c
#    Command line =  
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\fsl_sdspi_disk.c"
#        -D IAR -D FREEDOM -D SD_DISK_ENABLE -lCN "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -lB "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -o "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\common\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\i2c\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\platforms\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\" -I
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\inc\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack
#        MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB
#        Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\SPI_SDCard\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\"
#        -Ol
#    List file    =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\fsl_sdspi_disk.lst
#    Object file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\fsl_sdspi_disk.o
#
###############################################################################

D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\fsl_sdspi_disk.c
      1          /*
      2           * Copyright (c) 2014, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          #include <assert.h>
     32          #include <stdio.h>
     33          #include <string.h>
     34          #include <stdint.h>
     35          #include "diskio.h"
     36          
     37          #include "fsl_sdcard_spi.h"
     38          

   \                                 In section .bss, align 4
     39          uint32_t g_card_initialized = 0;
   \                     g_card_initialized:
   \   00000000                      DS8 4
     40          extern sdspi_card_t g_card;
     41          
     42          
     43          #if _USE_WRITE

   \                                 In section .text, align 2, keep-with-next
     44          DRESULT sdcard_disk_write(uint8_t pdrv, const uint8_t *buff, uint32_t sector, uint8_t count)
     45          {
   \                     sdcard_disk_write: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     46              if (pdrv != SD)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD001             BEQ      ??sdcard_disk_write_0
     47              {
     48                  return RES_PARERR;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xE012             B        ??sdcard_disk_write_1
     49              }
     50              if (g_card.cardType == 0 || g_card.cardType == kCardTypeUnknown)
   \                     ??sdcard_disk_write_0: (+1)
   \   0000000C   0x....             LDR      R0,??DataTable4
   \   0000000E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ      ??sdcard_disk_write_2
   \   00000014   0x....             LDR      R0,??DataTable4
   \   00000016   0x7B00             LDRB     R0,[R0, #+12]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE      ??sdcard_disk_write_3
     51              {
     52                  return RES_NOTRDY;
   \                     ??sdcard_disk_write_2: (+1)
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE008             B        ??sdcard_disk_write_1
     53              }
     54              if (kStatus_SDSPI_NoError != SDSPI_DRV_WriteBlocks(&g_card, (uint8_t *)buff, sector, count))
   \                     ??sdcard_disk_write_3: (+1)
   \   00000020   0xB2DB             UXTB     R3,R3
   \   00000022   0x....             LDR      R0,??DataTable4
   \   00000024   0x.... 0x....      BL       SDSPI_DRV_WriteBlocks
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ      ??sdcard_disk_write_4
     55              {
     56                  return RES_ERROR;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B        ??sdcard_disk_write_1
     57              }
     58              return RES_OK;
   \                     ??sdcard_disk_write_4: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??sdcard_disk_write_1: (+1)
   \   00000032   0xBD02             POP      {R1,PC}          ;; return
     59          }
     60          #endif
     61          

   \                                 In section .text, align 2, keep-with-next
     62          DRESULT sdcard_disk_read(uint8_t pdrv, uint8_t *buff, uint32_t sector, uint8_t count)
     63          {
   \                     sdcard_disk_read: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     64              if (pdrv != SD)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD001             BEQ      ??sdcard_disk_read_0
     65              {
     66                  return RES_PARERR;
   \   00000008   0x2004             MOVS     R0,#+4
   \   0000000A   0xE012             B        ??sdcard_disk_read_1
     67              }
     68          
     69              if (g_card.cardType == 0 || g_card.cardType == kCardTypeUnknown)
   \                     ??sdcard_disk_read_0: (+1)
   \   0000000C   0x....             LDR      R0,??DataTable4
   \   0000000E   0x7B00             LDRB     R0,[R0, #+12]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD003             BEQ      ??sdcard_disk_read_2
   \   00000014   0x....             LDR      R0,??DataTable4
   \   00000016   0x7B00             LDRB     R0,[R0, #+12]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE      ??sdcard_disk_read_3
     70              {
     71                  return RES_NOTRDY;
   \                     ??sdcard_disk_read_2: (+1)
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xE008             B        ??sdcard_disk_read_1
     72              }
     73              if (kStatus_SDSPI_NoError != SDSPI_DRV_ReadBlocks(&g_card, buff, sector, count))
   \                     ??sdcard_disk_read_3: (+1)
   \   00000020   0xB2DB             UXTB     R3,R3
   \   00000022   0x....             LDR      R0,??DataTable4
   \   00000024   0x.... 0x....      BL       SDSPI_DRV_ReadBlocks
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ      ??sdcard_disk_read_4
     74              {
     75                  return RES_ERROR;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B        ??sdcard_disk_read_1
     76              }
     77              return RES_OK;
   \                     ??sdcard_disk_read_4: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??sdcard_disk_read_1: (+1)
   \   00000032   0xBD02             POP      {R1,PC}          ;; return
     78          }
     79          
     80          #if _USE_IOCTL

   \                                 In section .text, align 2, keep-with-next
     81          DRESULT sdcard_disk_ioctl(uint8_t pdrv, uint8_t cmd, void *buff)
     82          {
   \                     sdcard_disk_ioctl: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0015             MOVS     R5,R2
     83              DRESULT res = RES_OK;
   \   00000004   0x2400             MOVS     R4,#+0
     84          
     85              if (pdrv != SD)
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ      ??sdcard_disk_ioctl_0
     86              {
     87                  return RES_PARERR;
   \   0000000C   0x2004             MOVS     R0,#+4
   \   0000000E   0xE083             B        ??sdcard_disk_ioctl_1
     88              }
     89          
     90              switch(cmd)
   \                     ??sdcard_disk_ioctl_0: (+1)
   \   00000010   0xB2C9             UXTB     R1,R1
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD03C             BEQ      ??sdcard_disk_ioctl_2
   \   00000016   0x2901             CMP      R1,#+1
   \   00000018   0xD00C             BEQ      ??sdcard_disk_ioctl_3
   \   0000001A   0x2902             CMP      R1,#+2
   \   0000001C   0xD012             BEQ      ??sdcard_disk_ioctl_4
   \   0000001E   0x2903             CMP      R1,#+3
   \   00000020   0xD018             BEQ      ??sdcard_disk_ioctl_5
   \   00000022   0x290A             CMP      R1,#+10
   \   00000024   0xD036             BEQ      ??sdcard_disk_ioctl_6
   \   00000026   0x290B             CMP      R1,#+11
   \   00000028   0xD057             BEQ      ??sdcard_disk_ioctl_7
   \   0000002A   0x290C             CMP      R1,#+12
   \   0000002C   0xD05F             BEQ      ??sdcard_disk_ioctl_8
   \   0000002E   0x290D             CMP      R1,#+13
   \   00000030   0xD067             BEQ      ??sdcard_disk_ioctl_9
   \   00000032   0xE06E             B        ??sdcard_disk_ioctl_10
     91              {
     92                  case GET_SECTOR_COUNT:
     93                      if (buff)
   \                     ??sdcard_disk_ioctl_3: (+1)
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD003             BEQ      ??sdcard_disk_ioctl_11
     94                      {
     95                          *(uint32_t *)buff = g_card.blockCount;
   \   00000038   0x....             LDR      R0,??DataTable4
   \   0000003A   0x6BC0             LDR      R0,[R0, #+60]
   \   0000003C   0x6028             STR      R0,[R5, #+0]
   \   0000003E   0xE000             B        ??sdcard_disk_ioctl_12
     96                      }
     97                      else
     98                      {
     99                          res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_11: (+1)
   \   00000040   0x2404             MOVS     R4,#+4
    100                      }
    101                      break;
   \                     ??sdcard_disk_ioctl_12: (+1)
   \   00000042   0xE067             B        ??sdcard_disk_ioctl_13
    102                  case GET_SECTOR_SIZE:
    103                      if (buff)
   \                     ??sdcard_disk_ioctl_4: (+1)
   \   00000044   0x2D00             CMP      R5,#+0
   \   00000046   0xD003             BEQ      ??sdcard_disk_ioctl_14
    104                      {
    105                          *(uint32_t *)buff = g_card.blockSize;
   \   00000048   0x....             LDR      R0,??DataTable4
   \   0000004A   0x6C00             LDR      R0,[R0, #+64]
   \   0000004C   0x6028             STR      R0,[R5, #+0]
   \   0000004E   0xE000             B        ??sdcard_disk_ioctl_15
    106                      }
    107                      else
    108                      {
    109                          res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_14: (+1)
   \   00000050   0x2404             MOVS     R4,#+4
    110                      }
    111                      break;
   \                     ??sdcard_disk_ioctl_15: (+1)
   \   00000052   0xE05F             B        ??sdcard_disk_ioctl_13
    112                  case GET_BLOCK_SIZE:
    113                      if (buff)
   \                     ??sdcard_disk_ioctl_5: (+1)
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD019             BEQ      ??sdcard_disk_ioctl_16
    114                      {
    115                          if (IS_SD_CARD(&g_card))
   \   00000058   0x....             LDR      R0,??DataTable4
   \   0000005A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD113             BNE      ??sdcard_disk_ioctl_17
    116                          {
    117                              if (g_card.version == kSdCardVersion_1_x)
   \   00000060   0x....             LDR      R0,??DataTable4
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD10C             BNE      ??sdcard_disk_ioctl_18
    118                              {
    119                                  *(uint32_t *)buff = SD_CSD_SECTOR_SIZE(g_card.rawCsd);
   \   00000068   0x....             LDR      R0,??DataTable4
   \   0000006A   0x7DC0             LDRB     R0,[R0, #+23]
   \   0000006C   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   0000006E   0x0E80             LSRS     R0,R0,#+26
   \   00000070   0x0040             LSLS     R0,R0,#+1
   \   00000072   0x....             LDR      R1,??DataTable4
   \   00000074   0x7E09             LDRB     R1,[R1, #+24]
   \   00000076   0xB2C9             UXTB     R1,R1
   \   00000078   0x09C9             LSRS     R1,R1,#+7
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x4301             ORRS     R1,R1,R0
   \   0000007E   0x6029             STR      R1,[R5, #+0]
   \   00000080   0xE005             B        ??sdcard_disk_ioctl_19
    120                              }
    121                              else
    122                              {
    123                                  *(uint32_t *)buff = SDV20_CSD_SECTOR_SIZE(g_card.rawCsd);
   \                     ??sdcard_disk_ioctl_18: (+1)
   \   00000082   0x207F             MOVS     R0,#+127
   \   00000084   0x6028             STR      R0,[R5, #+0]
   \   00000086   0xE002             B        ??sdcard_disk_ioctl_19
    124                              }
    125                          }
    126                          else
    127                          {
    128                              res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_17: (+1)
   \   00000088   0x2404             MOVS     R4,#+4
   \   0000008A   0xE000             B        ??sdcard_disk_ioctl_19
    129                          }
    130                      }
    131                      else
    132                      {
    133                          res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_16: (+1)
   \   0000008C   0x2404             MOVS     R4,#+4
    134                      }
    135                      break;
   \                     ??sdcard_disk_ioctl_19: (+1)
   \   0000008E   0xE041             B        ??sdcard_disk_ioctl_13
    136                  case CTRL_SYNC:
    137                      res = RES_OK;
   \                     ??sdcard_disk_ioctl_2: (+1)
   \   00000090   0x2400             MOVS     R4,#+0
    138                      break;
   \   00000092   0xE03F             B        ??sdcard_disk_ioctl_13
    139                  case MMC_GET_TYPE:
    140                      if (buff)
   \                     ??sdcard_disk_ioctl_6: (+1)
   \   00000094   0x2D00             CMP      R5,#+0
   \   00000096   0xD01E             BEQ      ??sdcard_disk_ioctl_20
    141                      {
    142                          switch (g_card.cardType)
   \   00000098   0x....             LDR      R0,??DataTable4
   \   0000009A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000009C   0x2802             CMP      R0,#+2
   \   0000009E   0xD004             BEQ      ??sdcard_disk_ioctl_21
   \   000000A0   0x2803             CMP      R0,#+3
   \   000000A2   0xD116             BNE      ??sdcard_disk_ioctl_22
    143                          {
    144                              case kCardTypeMmc:
    145                                  *(uint32_t *)buff = CT_MMC;
   \                     ??sdcard_disk_ioctl_23: (+1)
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x6028             STR      R0,[R5, #+0]
    146                                  break;
   \   000000A8   0xE016             B        ??sdcard_disk_ioctl_24
    147                              case kCardTypeSd:
    148                                  if (g_card.version == kSdCardVersion_1_x)
   \                     ??sdcard_disk_ioctl_21: (+1)
   \   000000AA   0x....             LDR      R0,??DataTable4
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD102             BNE      ??sdcard_disk_ioctl_25
    149                                  {
    150                                  *(uint32_t *)buff = CT_SD1;
   \   000000B2   0x2002             MOVS     R0,#+2
   \   000000B4   0x6028             STR      R0,[R5, #+0]
   \   000000B6   0xE00B             B        ??sdcard_disk_ioctl_26
    151                                  }
    152                                  else
    153                                  {
    154                                      *(uint32_t *)buff = CT_SD2;
   \                     ??sdcard_disk_ioctl_25: (+1)
   \   000000B8   0x2004             MOVS     R0,#+4
   \   000000BA   0x6028             STR      R0,[R5, #+0]
    155                                      if ((g_card.caps & SDSPI_CAPS_SDHC) ||
    156                                          (g_card.caps & SDSPI_CAPS_SDXC))
   \   000000BC   0x....             LDR      R0,??DataTable4
   \   000000BE   0x7900             LDRB     R0,[R0, #+4]
   \   000000C0   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000C2   0x0F80             LSRS     R0,R0,#+30
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD003             BEQ      ??sdcard_disk_ioctl_26
    157                                      {
    158                                          *(uint32_t *)buff |= CT_BLOCK;
   \   000000C8   0x6828             LDR      R0,[R5, #+0]
   \   000000CA   0x2108             MOVS     R1,#+8
   \   000000CC   0x4301             ORRS     R1,R1,R0
   \   000000CE   0x6029             STR      R1,[R5, #+0]
    159                                      }
    160                                  }
    161                                  break;
   \                     ??sdcard_disk_ioctl_26: (+1)
   \   000000D0   0xE002             B        ??sdcard_disk_ioctl_24
    162                              default:
    163                                  res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_22: (+1)
   \   000000D2   0x2404             MOVS     R4,#+4
    164                                  break;
   \   000000D4   0xE000             B        ??sdcard_disk_ioctl_24
    165                          }
    166                      }
    167                      else
    168                      {
    169                          res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_20: (+1)
   \   000000D6   0x2404             MOVS     R4,#+4
    170                      }
    171                      break;
   \                     ??sdcard_disk_ioctl_24: (+1)
   \   000000D8   0xE01C             B        ??sdcard_disk_ioctl_13
    172                  case MMC_GET_CSD:
    173                      if (buff)
   \                     ??sdcard_disk_ioctl_7: (+1)
   \   000000DA   0x2D00             CMP      R5,#+0
   \   000000DC   0xD005             BEQ      ??sdcard_disk_ioctl_27
    174                      {
    175                          memcpy(buff, g_card.rawCsd, sizeof(g_card.rawCsd));
   \   000000DE   0x2210             MOVS     R2,#+16
   \   000000E0   0x....             LDR      R1,??DataTable4_1
   \   000000E2   0x0028             MOVS     R0,R5
   \   000000E4   0x.... 0x....      BL       __aeabi_memcpy
    176                      }
   \   000000E8   0xE000             B        ??sdcard_disk_ioctl_28
    177                      else
    178                      {
    179                          res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_27: (+1)
   \   000000EA   0x2404             MOVS     R4,#+4
    180                      }
    181                      break;
   \                     ??sdcard_disk_ioctl_28: (+1)
   \   000000EC   0xE012             B        ??sdcard_disk_ioctl_13
    182                  case MMC_GET_CID:
    183                      if (buff)
   \                     ??sdcard_disk_ioctl_8: (+1)
   \   000000EE   0x2D00             CMP      R5,#+0
   \   000000F0   0xD005             BEQ      ??sdcard_disk_ioctl_29
    184                      {
    185                          memcpy(buff, g_card.rawCid, sizeof(g_card.rawCid));
   \   000000F2   0x2210             MOVS     R2,#+16
   \   000000F4   0x....             LDR      R1,??DataTable4_2
   \   000000F6   0x0028             MOVS     R0,R5
   \   000000F8   0x.... 0x....      BL       __aeabi_memcpy
    186                      }
   \   000000FC   0xE000             B        ??sdcard_disk_ioctl_30
    187                      else
    188                      {
    189                          res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_29: (+1)
   \   000000FE   0x2404             MOVS     R4,#+4
    190                      }
    191                      break;
   \                     ??sdcard_disk_ioctl_30: (+1)
   \   00000100   0xE008             B        ??sdcard_disk_ioctl_13
    192                  case MMC_GET_OCR:
    193                      if (buff)
   \                     ??sdcard_disk_ioctl_9: (+1)
   \   00000102   0x2D00             CMP      R5,#+0
   \   00000104   0xD003             BEQ      ??sdcard_disk_ioctl_31
    194                      {
    195                          *(uint32_t *)buff = g_card.ocr;
   \   00000106   0x....             LDR      R0,??DataTable4
   \   00000108   0x6B80             LDR      R0,[R0, #+56]
   \   0000010A   0x6028             STR      R0,[R5, #+0]
   \   0000010C   0xE000             B        ??sdcard_disk_ioctl_32
    196                      }
    197                      else
    198                      {
    199                          res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_31: (+1)
   \   0000010E   0x2404             MOVS     R4,#+4
    200                      }
    201                      break;
   \                     ??sdcard_disk_ioctl_32: (+1)
   \   00000110   0xE000             B        ??sdcard_disk_ioctl_13
    202                  default:
    203                      res = RES_PARERR;
   \                     ??sdcard_disk_ioctl_10: (+1)
   \   00000112   0x2404             MOVS     R4,#+4
    204                      break;
    205          
    206              }
    207          
    208              return res;
   \                     ??sdcard_disk_ioctl_13: (+1)
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0xB2C0             UXTB     R0,R0
   \                     ??sdcard_disk_ioctl_1: (+1)
   \   00000118   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    209          }
    210          #endif
    211          

   \                                 In section .text, align 2, keep-with-next
    212          DSTATUS sdcard_disk_status(uint8_t pdrv)
    213          {
   \                     sdcard_disk_status: (+1)
   \   00000000   0xB500             PUSH     {LR}
    214              if (pdrv != SD)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD001             BEQ      ??sdcard_disk_status_0
    215              {
    216                  return STA_NOINIT;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE000             B        ??sdcard_disk_status_1
    217              }
    218          
    219              return 0;
   \                     ??sdcard_disk_status_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??sdcard_disk_status_1: (+1)
   \   0000000E   0xBD00             POP      {PC}             ;; return
    220          }
    221          

   \                                 In section .text, align 2, keep-with-next
    222          static void reset_all_states()
    223          {
    224              //SDSPI_DRV_Shutdown(&g_card);
    225          
    226              g_card_initialized = 0;
   \                     reset_all_states: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable4_3
   \   00000004   0x6008             STR      R0,[R1, #+0]
    227          }
   \   00000006   0x4770             BX       LR               ;; return
    228          

   \                                 In section .text, align 2, keep-with-next
    229          DSTATUS sdcard_disk_initialize(uint8_t pdrv)
    230          {
   \                     sdcard_disk_initialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    231          
    232              if (pdrv != SD)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD001             BEQ      ??sdcard_disk_initialize_0
    233              {
    234                  return STA_NOINIT;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xE016             B        ??sdcard_disk_initialize_1
    235              }
    236          
    237              if (g_card_initialized)
   \                     ??sdcard_disk_initialize_0: (+1)
   \   0000000C   0x....             LDR      R0,??DataTable4_3
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ      ??sdcard_disk_initialize_2
    238              {
    239                  reset_all_states();
   \   00000014   0x.... 0x....      BL       reset_all_states
    240              }
    241          
    242              /* Begin test SD card. */
    243              memset(&g_card, 0, sizeof(g_card));
   \                     ??sdcard_disk_initialize_2: (+1)
   \   00000018   0x2144             MOVS     R1,#+68
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x....             LDR      R4,??DataTable4
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       __aeabi_memset
    244              if (kStatus_SDSPI_NoError != SDSPI_DRV_Init(&g_card))
   \   00000024   0x....             LDR      R0,??DataTable4
   \   00000026   0x.... 0x....      BL       SDSPI_DRV_Init
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD001             BEQ      ??sdcard_disk_initialize_3
    245              {
    246                  //SDSPI_DRV_Shutdown(&g_card);
    247                  return STA_NOINIT;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE003             B        ??sdcard_disk_initialize_1
    248              }
    249          
    250              g_card_initialized = 1;
   \                     ??sdcard_disk_initialize_3: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x....             LDR      R1,??DataTable4_3
   \   00000036   0x6008             STR      R0,[R1, #+0]
    251              return 0;//SDCardInit();
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??sdcard_disk_initialize_1: (+1)
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    252          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     g_card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     g_card+0xD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     g_card+0x1D

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     g_card_initialized

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   reset_all_states
       8   sdcard_disk_initialize
         8   -> SDSPI_DRV_Init
         8   -> __aeabi_memset
         8   -> reset_all_states
      16   sdcard_disk_ioctl
        16   -> __aeabi_memcpy
       8   sdcard_disk_read
         8   -> SDSPI_DRV_ReadBlocks
       4   sdcard_disk_status
       8   sdcard_disk_write
         8   -> SDSPI_DRV_WriteBlocks


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  g_card_initialized
       8  reset_all_states
      60  sdcard_disk_initialize
     282  sdcard_disk_ioctl
      52  sdcard_disk_read
      16  sdcard_disk_status
      52  sdcard_disk_write

 
   4 bytes in section .bss
 486 bytes in section .text
 
 486 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: 1
