###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        18/Feb/2016  22:52:43
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\FATFS\ff.c
#    Command line =  
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\FATFS\ff.c"
#        -D IAR -D FREEDOM -D SD_DISK_ENABLE -lCN "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -lB "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -o "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\common\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\i2c\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\platforms\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\" -I
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\inc\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack
#        MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB
#        Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\SPI_SDCard\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\"
#        -Ol
#    List file    =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\ff.lst
#    Object file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\ff.o
#
###############################################################################

D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\FATFS\ff.c
      1          /*
      2           * Copyright (c) 2013 - 2014, Freescale Semiconductor, Inc.
      3           * All rights reserved.
      4           *
      5           * Redistribution and use in source and binary forms, with or without modification,
      6           * are permitted provided that the following conditions are met:
      7           *
      8           * o Redistributions of source code must retain the above copyright notice, this list
      9           *   of conditions and the following disclaimer.
     10           *
     11           * o Redistributions in binary form must reproduce the above copyright notice, this
     12           *   list of conditions and the following disclaimer in the documentation and/or
     13           *   other materials provided with the distribution.
     14           *
     15           * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
     16           *   contributors may be used to endorse or promote products derived from this
     17           *   software without specific prior written permission.
     18           *
     19           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
     20           * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
     21           * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     22           * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
     23           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
     24           * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
     25           * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
     26           * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     27           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     28           * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     29           */
     30          
     31          /*----------------------------------------------------------------------------/
     32          /  FatFs - FAT file system module  R0.09b                 (C)ChaN, 2013
     33          /-----------------------------------------------------------------------------/
     34          / FatFs module is a generic FAT file system module for small embedded systems.
     35          / This is a free software that opened for education, research and commercial
     36          / developments under license policy of following terms.
     37          /
     38          /  Copyright (C) 2013, ChaN, all right reserved.
     39          /
     40          / * The FatFs module is a free software and there is NO WARRANTY.
     41          / * No restriction on use. You can use, modify and redistribute it for
     42          /   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
     43          / * Redistributions of source code must retain the above copyright notice.
     44          /
     45          /-----------------------------------------------------------------------------/
     46          / Feb 26,'06 R0.00  Prototype.
     47          /
     48          / Apr 29,'06 R0.01  First stable version.
     49          /
     50          / Jun 01,'06 R0.02  Added FAT12 support.
     51          /                   Removed unbuffered mode.
     52          /                   Fixed a problem on small (<32M) partition.
     53          / Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
     54          /
     55          / Sep 22,'06 R0.03  Added f_rename().
     56          /                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
     57          / Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
     58          /                   Fixed f_mkdir() creates incorrect directory on FAT32.
     59          /
     60          / Feb 04,'07 R0.04  Supported multiple drive system.
     61          /                   Changed some interfaces for multiple drive system.
     62          /                   Changed f_mountdrv() to f_mount().
     63          /                   Added f_mkfs().
     64          / Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
     65          /                   Added a capability of extending file size to f_lseek().
     66          /                   Added minimization level 3.
     67          /                   Fixed an endian sensitive code in f_mkfs().
     68          / May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
     69          /                   Added FSInfo support.
     70          /                   Fixed DBCS name can result FR_INVALID_NAME.
     71          /                   Fixed short seek (<= csize) collapses the file object.
     72          /
     73          / Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
     74          /                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
     75          /                   Fixed f_mkdir() on FAT32 creates incorrect directory.
     76          / Feb 03,'08 R0.05a Added f_truncate() and f_utime().
     77          /                   Fixed off by one error at FAT sub-type determination.
     78          /                   Fixed btr in f_read() can be mistruncated.
     79          /                   Fixed cached sector is not flushed when create and close without write.
     80          /
     81          / Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
     82          /                   Improved performance of f_lseek() on moving to the same or following cluster.
     83          /
     84          / Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
     85          /                   Added long file name feature.
     86          /                   Added multiple code page feature.
     87          /                   Added re-entrancy for multitask operation.
     88          /                   Added auto cluster size selection to f_mkfs().
     89          /                   Added rewind option to f_readdir().
     90          /                   Changed result code of critical errors.
     91          /                   Renamed string functions to avoid name collision.
     92          / Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
     93          /                   Added multiple sector size feature.
     94          / Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
     95          /                   Fixed wrong cache control in f_lseek().
     96          /                   Added relative path feature.
     97          /                   Added f_chdir() and f_chdrive().
     98          /                   Added proper case conversion to extended char.
     99          / Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
    100          /                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
    101          /                   Fixed name matching error on the 13 char boundary.
    102          /                   Added a configuration option, _LFN_UNICODE.
    103          /                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
    104          /
    105          / May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
    106          /                   Added file lock feature. (_FS_SHARE)
    107          /                   Added fast seek feature. (_USE_FASTSEEK)
    108          /                   Changed some types on the API, XCHAR->TCHAR.
    109          /                   Changed fname member in the FILINFO structure on Unicode cfg.
    110          /                   String functions support UTF-8 encoding files on Unicode cfg.
    111          / Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
    112          /                   Added sector erase feature. (_USE_ERASE)
    113          /                   Moved file lock semaphore table from fs object to the bss.
    114          /                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
    115          /                   Fixed f_mkfs() creates wrong FAT32 volume.
    116          / Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
    117          /                   f_lseek() reports required table size on creating CLMP.
    118          /                   Extended format syntax of f_printf function.
    119          /                   Ignores duplicated directory separators in given path name.
    120          /
    121          / Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
    122          /                   Added f_fdisk(). (_MULTI_PARTITION = 2)
    123          / Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
    124          /                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
    125          /                   Changed option name _FS_SHARE to _FS_LOCK.
    126          / Jan 24,'13 R0.09b Added f_setlabel() and f_getlabel(). (_USE_LABEL = 1)
    127          / Feb 24,'14 R0.09b f_printf() function writes a wrong string to the file. If a signed decimal with zero
    128          /                   padded, such as "%06d", is specified by format string and the value -123 is given, the
    129          /                   output must be "-00123" but "00-123" is written to the file.
    130          /                   To avoid this problem, do not use this format for a negative value.
    131          /---------------------------------------------------------------------------*/
    132          
    133          #include "ff.h"			/* FatFs configurations and declarations */
    134          #include "diskio.h"		/* Declarations of low level disk I/O functions */
    135          
    136          
    137          /*--------------------------------------------------------------------------
    138          
    139             Module Private Definitions
    140          
    141          ---------------------------------------------------------------------------*/
    142          
    143          #if _FATFS != 82786	/* Revision ID */
    144          #error Wrong include file (ff.h).
    145          #endif
    146          
    147          
    148          /* Definitions on sector size */
    149          #if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
    150          #error Wrong sector size.
    151          #endif
    152          #if _MAX_SS != 512
    153          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
    154          #else
    155          #define	SS(fs)	512U			/* Fixed sector size */
    156          #endif
    157          
    158          
    159          /* Reentrancy related */
    160          #if _FS_REENTRANT
    161          #if _USE_LFN == 1
    162          #error Static LFN work area must not be used in re-entrant configuration.
    163          #endif
    164          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
    165          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
    166          #else
    167          #define	ENTER_FF(fs)
    168          #define LEAVE_FF(fs, res)	return res
    169          #endif
    170          
    171          #define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
    172          
    173          
    174          /* File access control feature */
    175          #if _FS_LOCK
    176          #if _FS_READONLY
    177          #error _FS_LOCK must be 0 on read-only cfg.
    178          #endif
    179          typedef struct {
    180          	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
    181          	uint32_t clu;				/* File ID 2, directory */
    182          	uint16_t idx;				/* File ID 3, directory index */
    183          	uint16_t ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
    184          } FILESEM;
    185          #endif
    186          
    187          
    188          
    189          /* DBCS code ranges and SBCS extend char conversion table */
    190          
    191          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
    192          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
    193          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
    194          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
    195          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
    196          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
    197          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
    198          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
    199          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
    200          
    201          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
    202          #define _DF1S	0x81
    203          #define _DF1E	0xFE
    204          #define _DS1S	0x40
    205          #define _DS1E	0x7E
    206          #define _DS2S	0x80
    207          #define _DS2E	0xFE
    208          
    209          #elif _CODE_PAGE == 949	/* Korean */
    210          #define _DF1S	0x81
    211          #define _DF1E	0xFE
    212          #define _DS1S	0x41
    213          #define _DS1E	0x5A
    214          #define _DS2S	0x61
    215          #define _DS2E	0x7A
    216          #define _DS3S	0x81
    217          #define _DS3E	0xFE
    218          
    219          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    220          #define _DF1S	0x81
    221          #define _DF1E	0xFE
    222          #define _DS1S	0x40
    223          #define _DS1E	0x7E
    224          #define _DS2S	0xA1
    225          #define _DS2E	0xFE
    226          
    227          #elif _CODE_PAGE == 437	/* U.S. (OEM) */
    228          #define _DF1S	0
    229          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    230          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    231          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    232          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    233          
    234          #elif _CODE_PAGE == 720	/* Arabic (OEM) */
    235          #define _DF1S	0
    236          #define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    237          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    238          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    239          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    240          
    241          #elif _CODE_PAGE == 737	/* Greek (OEM) */
    242          #define _DF1S	0
    243          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    244          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    245          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    246          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    247          
    248          #elif _CODE_PAGE == 775	/* Baltic (OEM) */
    249          #define _DF1S	0
    250          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    251          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    252          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    253          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    254          
    255          #elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
    256          #define _DF1S	0
    257          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    258          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    259          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    260          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    261          
    262          #elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
    263          #define _DF1S	0
    264          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
    265          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    266          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    267          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    268          
    269          #elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
    270          #define _DF1S	0
    271          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    272          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    273          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    274          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    275          
    276          #elif _CODE_PAGE == 857	/* Turkish (OEM) */
    277          #define _DF1S	0
    278          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    279          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    280          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    281          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    282          
    283          #elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
    284          #define _DF1S	0
    285          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    286          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    287          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    288          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    289          
    290          #elif _CODE_PAGE == 862	/* Hebrew (OEM) */
    291          #define _DF1S	0
    292          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    293          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    294          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    295          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    296          
    297          #elif _CODE_PAGE == 866	/* Russian (OEM) */
    298          #define _DF1S	0
    299          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    300          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    301          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    302          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    303          
    304          #elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
    305          #define _DF1S	0
    306          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    307          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    308          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    309          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    310          
    311          #elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
    312          #define _DF1S	0
    313          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    314          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
    315          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    316          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    317          
    318          #elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
    319          #define _DF1S	0
    320          #define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
    321          				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
    322          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    323          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
    324          
    325          #elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
    326          #define _DF1S	0
    327          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
    328          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    329          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    330          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    331          
    332          #elif _CODE_PAGE == 1253 /* Greek (Windows) */
    333          #define _DF1S	0
    334          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    335          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    336          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
    337          				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
    338          
    339          #elif _CODE_PAGE == 1254 /* Turkish (Windows) */
    340          #define _DF1S	0
    341          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    342          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    343          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    344          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
    345          
    346          #elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
    347          #define _DF1S	0
    348          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    349          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    350          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    351          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    352          
    353          #elif _CODE_PAGE == 1256 /* Arabic (Windows) */
    354          #define _DF1S	0
    355          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
    356          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    357          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    358          				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
    359          
    360          #elif _CODE_PAGE == 1257 /* Baltic (Windows) */
    361          #define _DF1S	0
    362          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    363          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
    364          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    365          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
    366          
    367          #elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
    368          #define _DF1S	0
    369          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
    370          				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    371          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    372          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
    373          
    374          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    375          #if _USE_LFN
    376          #error Cannot use LFN feature without valid code page.
    377          #endif
    378          #define _DF1S	0
    379          
    380          #else
    381          #error Unknown code page
    382          
    383          #endif
    384          
    385          
    386          /* Character code support macros */
    387          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    388          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    389          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    390          
    391          #if _DF1S		/* Code page is DBCS */
    392          
    393          #ifdef _DF2S	/* Two 1st byte areas */
    394          #define IsDBCS1(c)	(((uint8_t)(c) >= _DF1S && (uint8_t)(c) <= _DF1E) || ((uint8_t)(c) >= _DF2S && (uint8_t)(c) <= _DF2E))
    395          #else			/* One 1st byte area */
    396          #define IsDBCS1(c)	((uint8_t)(c) >= _DF1S && (uint8_t)(c) <= _DF1E)
    397          #endif
    398          
    399          #ifdef _DS3S	/* Three 2nd byte areas */
    400          #define IsDBCS2(c)	(((uint8_t)(c) >= _DS1S && (uint8_t)(c) <= _DS1E) || ((uint8_t)(c) >= _DS2S && (uint8_t)(c) <= _DS2E) || ((uint8_t)(c) >= _DS3S && (uint8_t)(c) <= _DS3E))
    401          #else			/* Two 2nd byte areas */
    402          #define IsDBCS2(c)	(((uint8_t)(c) >= _DS1S && (uint8_t)(c) <= _DS1E) || ((uint8_t)(c) >= _DS2S && (uint8_t)(c) <= _DS2E))
    403          #endif
    404          
    405          #else			/* Code page is SBCS */
    406          
    407          #define IsDBCS1(c)	0
    408          #define IsDBCS2(c)	0
    409          
    410          #endif /* _DF1S */
    411          
    412          
    413          /* Name status flags */
    414          #define NS			11		/* Index of name status byte in fn[] */
    415          #define NS_LOSS		0x01	/* Out of 8.3 format */
    416          #define NS_LFN		0x02	/* Force to create LFN entry */
    417          #define NS_LAST		0x04	/* Last segment */
    418          #define NS_BODY		0x08	/* Lower case flag (body) */
    419          #define NS_EXT		0x10	/* Lower case flag (ext) */
    420          #define NS_DOT		0x20	/* Dot entry */
    421          
    422          
    423          /* FAT sub-type boundaries */
    424          /* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
    425          #define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
    426          #define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
    427          
    428          
    429          /* FatFs refers the members in the FAT structures as byte array instead of
    430          / structure member because the structure is not binary compatible between
    431          / different platforms */
    432          
    433          #define BS_jmpBoot			0	/* Jump instruction (3) */
    434          #define BS_OEMName			3	/* OEM name (8) */
    435          #define BPB_BytsPerSec		11	/* Sector size [byte] (2) */
    436          #define BPB_SecPerClus		13	/* Cluster size [sector] (1) */
    437          #define BPB_RsvdSecCnt		14	/* Size of reserved area [sector] (2) */
    438          #define BPB_NumFATs			16	/* Number of FAT copies (1) */
    439          #define BPB_RootEntCnt		17	/* Number of root dir entries for FAT12/16 (2) */
    440          #define BPB_TotSec16		19	/* Volume size [sector] (2) */
    441          #define BPB_Media			21	/* Media descriptor (1) */
    442          #define BPB_FATSz16			22	/* FAT size [sector] (2) */
    443          #define BPB_SecPerTrk		24	/* Track size [sector] (2) */
    444          #define BPB_NumHeads		26	/* Number of heads (2) */
    445          #define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
    446          #define BPB_TotSec32		32	/* Volume size [sector] (4) */
    447          #define BS_DrvNum			36	/* Physical drive number (2) */
    448          #define BS_BootSig			38	/* Extended boot signature (1) */
    449          #define BS_VolID			39	/* Volume serial number (4) */
    450          #define BS_VolLab			43	/* Volume label (8) */
    451          #define BS_FilSysType		54	/* File system type (1) */
    452          #define BPB_FATSz32			36	/* FAT size [sector] (4) */
    453          #define BPB_ExtFlags		40	/* Extended flags (2) */
    454          #define BPB_FSVer			42	/* File system version (2) */
    455          #define BPB_RootClus		44	/* Root dir first cluster (4) */
    456          #define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
    457          #define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
    458          #define BS_DrvNum32			64	/* Physical drive number (2) */
    459          #define BS_BootSig32		66	/* Extended boot signature (1) */
    460          #define BS_VolID32			67	/* Volume serial number (4) */
    461          #define BS_VolLab32			71	/* Volume label (8) */
    462          #define BS_FilSysType32		82	/* File system type (1) */
    463          #define	FSI_LeadSig			0	/* FSI: Leading signature (4) */
    464          #define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
    465          #define	FSI_Free_Count		488	/* FSI: Number of free clusters (4) */
    466          #define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
    467          #define MBR_Table			446	/* MBR: Partition table offset (2) */
    468          #define	SZ_PTE				16	/* MBR: Size of a partition table entry */
    469          #define BS_55AA				510	/* Boot sector signature (2) */
    470          
    471          #define	DIR_Name			0	/* Short file name (11) */
    472          #define	DIR_Attr			11	/* Attribute (1) */
    473          #define	DIR_NTres			12	/* NT flag (1) */
    474          #define DIR_CrtTimeTenth	13	/* Created time sub-second (1) */
    475          #define	DIR_CrtTime			14	/* Created time (2) */
    476          #define	DIR_CrtDate			16	/* Created date (2) */
    477          #define DIR_LstAccDate		18	/* Last accessed date (2) */
    478          #define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
    479          #define	DIR_WrtTime			22	/* Modified time (2) */
    480          #define	DIR_WrtDate			24	/* Modified date (2) */
    481          #define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
    482          #define	DIR_FileSize		28	/* File size (4) */
    483          #define	LDIR_Ord			0	/* LFN entry order and LLE flag (1) */
    484          #define	LDIR_Attr			11	/* LFN attribute (1) */
    485          #define	LDIR_Type			12	/* LFN type (1) */
    486          #define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
    487          #define	LDIR_FstClusLO		26	/* Filled by zero (0) */
    488          #define	SZ_DIR				32		/* Size of a directory entry */
    489          #define	LLE					0x40	/* Last long entry flag in LDIR_Ord */
    490          #define	DDE					0xE5	/* Deleted directory entry mark in DIR_Name[0] */
    491          #define	NDDE				0x05	/* Replacement of the character collides with DDE */
    492          
    493          
    494          /*------------------------------------------------------------*/
    495          /* Module private work area                                   */
    496          /*------------------------------------------------------------*/
    497          /* Note that uninitialized variables with static duration are
    498          /  zeroed/nulled at start-up. If not, the compiler or start-up
    499          /  routine is out of ANSI-C standard.
    500          */
    501          
    502          #if _VOLUMES
    503          static

   \                                 In section .bss, align 4
    504          FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
   \                     FatFs:
   \   00000000                      DS8 8
    505          #else
    506          #error Number of volumes must not be 0.
    507          #endif
    508          
    509          static

   \                                 In section .bss, align 2
    510          uint16_t Fsid;				/* File system mount ID */
   \                     Fsid:
   \   00000000                      DS8 2
    511          
    512          #if _FS_RPATH
    513          static

   \                                 In section .bss, align 1
    514          uint8_t CurrVol;			/* Current drive */
   \                     CurrVol:
   \   00000000                      DS8 1
    515          #endif
    516          
    517          #if _FS_LOCK
    518          static
    519          FILESEM	Files[_FS_LOCK];	/* File lock semaphores */
    520          #endif
    521          
    522          #if _USE_LFN == 0			/* No LFN feature */
    523          #define	DEF_NAMEBUF			uint8_t sfn[12]
    524          #define INIT_BUF(dobj)		(dobj).fn = sfn
    525          #define	FREE_BUF()
    526          
    527          #elif _USE_LFN == 1			/* LFN feature with static working buffer */
    528          static uint16_t LfnBuf[_MAX_LFN+1];
    529          #define	DEF_NAMEBUF			uint8_t sfn[12]
    530          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
    531          #define	FREE_BUF()
    532          
    533          #elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
    534          #define	DEF_NAMEBUF			uint8_t sfn[12]; uint16_t lbuf[_MAX_LFN+1]
    535          #define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
    536          #define	FREE_BUF()
    537          
    538          #elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
    539          #define	DEF_NAMEBUF			uint8_t sfn[12]; uint16_t *lfn
    540          #define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
    541          							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
    542          							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
    543          #define	FREE_BUF()			ff_memfree(lfn)
    544          
    545          #else
    546          #error Wrong LFN configuration.
    547          #endif
    548          
    549          
    550          #ifdef _EXCVT
    551          static

   \                                 In section .rodata, align 4
    552          const uint8_t ExCvt[] = _EXCVT;	/* Upper conversion table for extended chars */
   \                     ExCvt:
   \   00000000   0x80 0x81          DC8 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140
   \              0x82 0x83    
   \              0x84 0x85    
   \              0x86 0x87    
   \              0x88 0x89    
   \              0x8A 0x8B    
   \              0x8C         
   \   0000000D   0x8D 0x8E          DC8 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153
   \              0x8F 0x90    
   \              0x91 0x92    
   \              0x93 0x94    
   \              0x95 0x96    
   \              0x97 0x98    
   \              0x99         
   \   0000001A   0x9A 0x9B          DC8 154, 155, 172, 157, 158, 159, 160, 33, 162, 163, 164, 165, 166, 167
   \              0xAC 0x9D    
   \              0x9E 0x9F    
   \              0xA0 0x21    
   \              0xA2 0xA3    
   \              0xA4 0xA5    
   \              0xA6 0xA7    
   \   00000028   0xA8 0xA9          DC8 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180
   \              0xAA 0xAB    
   \              0xAC 0xAD    
   \              0xAE 0xAF    
   \              0xB0 0xB1    
   \              0xB2 0xB3    
   \              0xB4         
   \   00000035   0xB5 0xB6          DC8 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193
   \              0xB7 0xB8    
   \              0xB9 0xBA    
   \              0xBB 0xBC    
   \              0xBD 0xBE    
   \              0xBF 0xC0    
   \              0xC1         
   \   00000042   0xC2 0xC3          DC8 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206
   \              0xC4 0xC5    
   \              0xC6 0xC7    
   \              0xC8 0xC9    
   \              0xCA 0xCB    
   \              0xCC 0xCD    
   \              0xCE         
   \   0000004F   0xCF 0xD0          DC8 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219
   \              0xD1 0xD2    
   \              0xD3 0xD4    
   \              0xD5 0xD6    
   \              0xD7 0xD8    
   \              0xD9 0xDA    
   \              0xDB         
   \   0000005C   0xDC 0xDD          DC8 220, 221, 222, 223, 192, 193, 194, 195, 196, 197, 198, 199, 200
   \              0xDE 0xDF    
   \              0xC0 0xC1    
   \              0xC2 0xC3    
   \              0xC4 0xC5    
   \              0xC6 0xC7    
   \              0xC8         
   \   00000069   0xC9 0xCA          DC8 201, 202, 203, 236, 205, 206, 207, 208, 209, 242, 211, 212, 213
   \              0xCB 0xEC    
   \              0xCD 0xCE    
   \              0xCF 0xD0    
   \              0xD1 0xF2    
   \              0xD3 0xD4    
   \              0xD5         
   \   00000076   0xD6 0xF7          DC8 214, 247, 216, 217, 218, 219, 220, 221, 254, 159
   \              0xD8 0xD9    
   \              0xDA 0xDB    
   \              0xDC 0xDD    
   \              0xFE 0x9F    
    553          #endif
    554          
    555          
    556          /*--------------------------------------------------------------------------
    557          
    558             Module Private Functions
    559          
    560          ---------------------------------------------------------------------------*/
    561          
    562          /*FUNCTION*-------------------------------------------------------------------
    563          *
    564          * Function Name    : mem_cpy
    565          * Returned Value   : void
    566          * Comments         : Copy memory to memory
    567          *   
    568          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    569          static void mem_cpy 
    570            (
    571              /* [IN] destination address  */
    572              void* dst,
    573              /* [IN] source address */
    574              const void* src,
    575              /* [IN] number of bytes to be copied */
    576              uint32_t cnt
    577            ) 
    578          {
   \                     mem_cpy: (+1)
   \   00000000   0xB500             PUSH     {LR}
    579          	uint8_t *d = (uint8_t*)dst;
    580          	const uint8_t *s = (const uint8_t*)src;
   \   00000002   0xE003             B        ??mem_cpy_0
    581          
    582          #if _WORD_ACCESS == 1
    583          	while (cnt >= sizeof (int)) {
    584          		*(int*)d = *(int*)s;
    585          		d += sizeof (int); s += sizeof (int);
    586          		cnt -= sizeof (int);
    587          	}
    588          #endif
    589          	while (cnt--)
    590          		*d++ = *s++;
   \                     ??mem_cpy_1: (+1)
   \   00000004   0x780B             LDRB     R3,[R1, #+0]
   \   00000006   0x7003             STRB     R3,[R0, #+0]
   \   00000008   0x1C49             ADDS     R1,R1,#+1
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_cpy_0: (+1)
   \   0000000C   0x0013             MOVS     R3,R2
   \   0000000E   0x1E5A             SUBS     R2,R3,#+1
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD1F7             BNE      ??mem_cpy_1
    591          }
   \   00000014   0xBD00             POP      {PC}             ;; return
    592          
    593          /*FUNCTION*-------------------------------------------------------------------
    594          *
    595          * Function Name    : mem_set
    596          * Returned Value   : void
    597          * Comments         : Fill memory
    598          *   
    599          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    600          static void mem_set
    601            (
    602              /* [IN] destination adress */
    603              void* dst,
    604              /* [IN] value to set */
    605              int val,
    606              /* number of bytes to be set */
    607              uint32_t cnt
    608            ) 
    609          {
   \                     mem_set: (+1)
   \   00000000   0xB500             PUSH     {LR}
    610          	uint8_t *d = (uint8_t*)dst;
   \   00000002   0xE002             B        ??mem_set_0
    611          
    612          	while (cnt--)
    613          		*d++ = (uint8_t)val;
   \                     ??mem_set_1: (+1)
   \   00000004   0x000B             MOVS     R3,R1
   \   00000006   0x7003             STRB     R3,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \                     ??mem_set_0: (+1)
   \   0000000A   0x0013             MOVS     R3,R2
   \   0000000C   0x1E5A             SUBS     R2,R3,#+1
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD1F8             BNE      ??mem_set_1
    614          }
   \   00000012   0xBD00             POP      {PC}             ;; return
    615          
    616          /*FUNCTION*-------------------------------------------------------------------
    617          *
    618          * Function Name    : mem_cmp
    619          * Returned Value   : 0 if source and dest values are the same
    620          * Comments         : Compare memory to memory
    621          *   
    622          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    623          static int mem_cmp
    624            (
    625              /* destination address */
    626              const void* dst,
    627              /* source address */
    628              const void* src,
    629              /* number of bytes to be compared */
    630              uint32_t cnt
    631             ) 
    632          {
   \                     mem_cmp: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0003             MOVS     R3,R0
    633          	const uint8_t *d = (const uint8_t *)dst, *s = (const uint8_t *)src;
    634          	int r = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    635          
    636          	while (cnt-- && (r = *d++ - *s++) == 0) ;
   \                     ??mem_cmp_0: (+1)
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x1E62             SUBS     R2,R4,#+1
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD006             BEQ      ??mem_cmp_1
   \   0000000E   0x7818             LDRB     R0,[R3, #+0]
   \   00000010   0x780C             LDRB     R4,[R1, #+0]
   \   00000012   0x1B00             SUBS     R0,R0,R4
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x1C5B             ADDS     R3,R3,#+1
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD0F4             BEQ      ??mem_cmp_0
    637          	return r;
   \                     ??mem_cmp_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    638          }
    639          
    640          
    641          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION

   \                                 In section .text, align 2, keep-with-next
    642          uint8_t* convert_ptr(FATFS* fs, uint8_t* orignptr)
    643          {
   \                     convert_ptr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    644              if(orignptr == 0)
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE      ??convert_ptr_0
    645                  return 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xE007             B        ??convert_ptr_1
    646              return ((orignptr - fs->winprev) % SS(fs)) + fs->win;
   \                     ??convert_ptr_0: (+1)
   \   0000000A   0x6C44             LDR      R4,[R0, #+68]
   \   0000000C   0x3048             ADDS     R0,R0,#+72
   \   0000000E   0x1A08             SUBS     R0,R1,R0
   \   00000010   0x2180             MOVS     R1,#+128
   \   00000012   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000014   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000018   0x1860             ADDS     R0,R4,R1
   \                     ??convert_ptr_1: (+1)
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    647          }
    648          

   \                                 In section .bss, align 4
    649          uint32_t entry_start_clust = 0;
   \                     entry_start_clust:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    650          uint16_t entry_start_free_index = 0;
   \                     entry_start_free_index:
   \   00000000                      DS8 2
    651          #endif
    652          
    653          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 1
    654          #if WIN_SECTOR_NUM != 2
    655          #error WIN_SECTOR_NUM must be 2
    656          #endif

   \                                 In section .text, align 2, keep-with-next
    657          uint8_t buff_validation(FATFS *fs, uint32_t sect)
    658          {
   \                     buff_validation: (+1)
   \   00000000   0xB500             PUSH     {LR}
    659              uint8_t i = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    660              if(sect == 0)
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD102             BNE      ??buff_validation_0
    661                  return 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE01C             B        ??buff_validation_1
    662              for (; i < WIN_SECTOR_NUM; ++i)
   \                     ??buff_validation_2: (+1)
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   \                     ??buff_validation_0: (+1)
   \   0000000E   0xB2D2             UXTB     R2,R2
   \   00000010   0x2A02             CMP      R2,#+2
   \   00000012   0xDA17             BGE      ??buff_validation_3
    663              {
    664                  if (fs->winsectprev[i] != 0 && fs->winsectprev[i] == sect)
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x2304             MOVS     R3,#+4
   \   00000018   0x4353             MULS     R3,R2,R3
   \   0000001A   0x18C3             ADDS     R3,R0,R3
   \   0000001C   0x6B9B             LDR      R3,[R3, #+56]
   \   0000001E   0x2B00             CMP      R3,#+0
   \   00000020   0xD0F4             BEQ      ??buff_validation_2
   \   00000022   0xB2D2             UXTB     R2,R2
   \   00000024   0x2304             MOVS     R3,#+4
   \   00000026   0x4353             MULS     R3,R2,R3
   \   00000028   0x18C3             ADDS     R3,R0,R3
   \   0000002A   0x6B9B             LDR      R3,[R3, #+56]
   \   0000002C   0x428B             CMP      R3,R1
   \   0000002E   0xD1ED             BNE      ??buff_validation_2
    665                  {
    666                    fs->winsect = sect;
   \   00000030   0x6341             STR      R1,[R0, #+52]
    667                    fs->win = fs->winprev + SS(fs) * i;
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000038   0x434A             MULS     R2,R1,R2
   \   0000003A   0x1881             ADDS     R1,R0,R2
   \   0000003C   0x3148             ADDS     R1,R1,#+72
   \   0000003E   0x6441             STR      R1,[R0, #+68]
    668                    return 1;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B        ??buff_validation_1
    669                  }
    670              }
    671              return 0;
   \                     ??buff_validation_3: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??buff_validation_1: (+1)
   \   00000046   0xBD00             POP      {PC}             ;; return
    672          }
    673          

   \                                 In section .text, align 2, keep-with-next
    674          void clear_buff(FATFS* fs)
    675          {
   \                     clear_buff: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    676              mem_set(fs->winsectprev, 0, WIN_SECTOR_NUM * sizeof(uint32_t));
   \   00000004   0x2208             MOVS     R2,#+8
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x3038             ADDS     R0,R0,#+56
   \   0000000C   0x.... 0x....      BL       mem_set
    677              fs->win = fs->winprev;
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x3048             ADDS     R0,R0,#+72
   \   00000014   0x6460             STR      R0,[R4, #+68]
    678              fs->winsect = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6360             STR      R0,[R4, #+52]
    679              fs->winlastindex = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x3440             ADDS     R4,R4,#+64
   \   0000001E   0x7020             STRB     R0,[R4, #+0]
    680          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    681          

   \                                 In section .text, align 2, keep-with-next
    682          uint32_t get_sectorprev(FATFS* fs, uint8_t index)
    683          {
    684              return fs->winsectprev[index];
   \                     get_sectorprev: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1
   \   00000002   0x2204             MOVS     R2,#+4
   \   00000004   0x4351             MULS     R1,R2,R1
   \   00000006   0x1840             ADDS     R0,R0,R1
   \   00000008   0x6B80             LDR      R0,[R0, #+56]
   \   0000000A   0x4770             BX       LR               ;; return
    685          }
    686          

   \                                 In section .text, align 2, keep-with-next
    687          void clear_dirty2(FATFS* fs, uint32_t index)
    688          {
    689              fs->wflag &= ~(0x01 << index);
   \                     clear_dirty2: (+1)
   \   00000000   0x7902             LDRB     R2,[R0, #+4]
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0x408B             LSLS     R3,R3,R1
   \   00000006   0x439A             BICS     R2,R2,R3
   \   00000008   0x7102             STRB     R2,[R0, #+4]
    690          }
   \   0000000A   0x4770             BX       LR               ;; return
    691          

   \                                 In section .text, align 2, keep-with-next
    692          void set_sectorprev(FATFS* fs, uint32_t sector)//called after sync_fs is called.
    693          {
   \                     set_sectorprev: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    694              fs->winsect = sector;
   \   00000002   0x6351             STR      R1,[R2, #+52]
    695              fs->winsectprev[(fs->win - fs->winprev) / SS(fs)] = sector;
   \   00000004   0x6C53             LDR      R3,[R2, #+68]
   \   00000006   0x0010             MOVS     R0,R2
   \   00000008   0x3048             ADDS     R0,R0,#+72
   \   0000000A   0x1A18             SUBS     R0,R3,R0
   \   0000000C   0x0A40             LSRS     R0,R0,#+9
   \   0000000E   0x2304             MOVS     R3,#+4
   \   00000010   0x4358             MULS     R0,R3,R0
   \   00000012   0x1810             ADDS     R0,R2,R0
   \   00000014   0x6381             STR      R1,[R0, #+56]
    696          }
   \   00000016   0x4770             BX       LR               ;; return
    697          

   \                                 In section .text, align 2, keep-with-next
    698          void set_dirty(FATFS* fs)
    699          {
   \                     set_dirty: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    700              fs->wflag |= (0x01 << ((fs->win - fs->winprev) / SS(fs)));
   \   00000004   0x790A             LDRB     R2,[R1, #+4]
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x6C4C             LDR      R4,[R1, #+68]
   \   0000000A   0x0008             MOVS     R0,R1
   \   0000000C   0x3048             ADDS     R0,R0,#+72
   \   0000000E   0x1A20             SUBS     R0,R4,R0
   \   00000010   0x0A40             LSRS     R0,R0,#+9
   \   00000012   0x4083             LSLS     R3,R3,R0
   \   00000014   0x4313             ORRS     R3,R3,R2
   \   00000016   0x710B             STRB     R3,[R1, #+4]
    701          }
   \   00000018   0xBC10             POP      {R4}
   \   0000001A   0x4770             BX       LR               ;; return
    702          #elif _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 2
    703          uint8_t buff_validation(FATFS *fs, uint32_t sect)
    704          {
    705              if(fs->winsect == 0 || fs->winsectprev == 0)
    706                  return 0;
    707              if (sect >= fs->winsectprev && sect < fs->winsectprev + fs->winnum)
    708              {
    709                  fs->win = fs->winprev + SS(fs) * (sect - fs->winsectprev);
    710                  fs->winsect = sect;
    711                  return 1;
    712              }
    713              return 0;
    714          }
    715          
    716          void clear_buff(FATFS* fs)
    717          {
    718              fs->winnum = 0;
    719              fs->winsectprev = 0;
    720              fs->win = fs->winprev;
    721          }
    722          
    723          void set_sectorprev(FATFS* fs, uint32_t sector)//called after sync_fs is called.
    724          {
    725              fs->win = fs->winprev;
    726              fs->winnum = 1;
    727              fs->winsect = sector;
    728              fs->winsectprev = sector;
    729          }
    730          
    731          uint32_t get_sectorprev(FATFS* fs, uint8_t index)
    732          {
    733              if (fs->winsect == 0 || fs->winsectprev == 0)
    734                  return 0;
    735              if (index >= fs->winnum)
    736                  return 0;
    737              return fs->winsectprev + index;
    738          }
    739          
    740          void set_dirty(FATFS* fs)
    741          {
    742              fs->wflag = 1;
    743          }
    744          #else
    745          #define convert_ptr(fs, orignptr)       orignptr
    746          
    747          void set_dirty(FATFS* fs)
    748          {
    749              fs->wflag = 1;
    750          }
    751          #endif
    752          
    753          #define clear_alldirty(fs)      (((fs)->wflag) = 0)
    754          #define judge_alldirty(fs)      (((fs)->wflag) != 0)
    755          
    756          /*FUNCTION*-------------------------------------------------------------------
    757          *
    758          * Function Name    : chk_chr
    759          * Returned Value   : character chr if the string contain, or null if not
    760          * Comments         : Check if character chr is contained in the string
    761          *   
    762          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    763          static int chk_chr
    764            (
    765              /* [IN] pointer to string buffer */
    766              const char* str,
    767              /* [IN] character to check */
    768              int chr
    769            ) 
    770          {
   \                     chk_chr: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xE000             B        ??chk_chr_0
    771          	while (*str && *str != chr) str++;
   \                     ??chk_chr_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??chk_chr_0: (+1)
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD002             BEQ      ??chk_chr_2
   \   0000000C   0x7802             LDRB     R2,[R0, #+0]
   \   0000000E   0x428A             CMP      R2,R1
   \   00000010   0xD1F8             BNE      ??chk_chr_1
    772          	return *str;
   \                     ??chk_chr_2: (+1)
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0xBD00             POP      {PC}             ;; return
    773          }
    774          
    775          
    776          
    777          /*-----------------------------------------------------------------------*/
    778          /* Request/Release grant to access the volume                            */
    779          /*-----------------------------------------------------------------------*/
    780          #if _FS_REENTRANT
    781          
    782          static
    783          int lock_fs (
    784          	FATFS *fs		/* File system object */
    785          )
    786          {
    787          	return ff_req_grant(fs->sobj);
    788          }
    789          
    790          
    791          static
    792          void unlock_fs (
    793          	FATFS *fs,		/* File system object */
    794          	FRESULT res		/* Result code to be returned */
    795          )
    796          {
    797          	if (fs &&
    798          		res != FR_NOT_ENABLED &&
    799          		res != FR_INVALID_DRIVE &&
    800          		res != FR_INVALID_OBJECT &&
    801          		res != FR_TIMEOUT) {
    802          		ff_rel_grant(fs->sobj);
    803          	}
    804          }
    805          #endif
    806          
    807          
    808          
    809          /*-----------------------------------------------------------------------*/
    810          /* File lock control functions                                           */
    811          /*-----------------------------------------------------------------------*/
    812          #if _FS_LOCK
    813          
    814          /*FUNCTION*-------------------------------------------------------------------
    815          *
    816          * Function Name    : chk_lock
    817          * Returned Value   : FR_OK: the file can be accessed
    818          *                    FR_TOO_MANY_OPEN_FILE: there is no blank entry for new file
    819          *                    FR_LOCKED:The file has been opened. Reject any open against
    820          *                              writing file and all write mode open 
    821          * Comments         : Check if the file can be accessed
    822          *   
    823          *END*----------------------------------------------------------------------*/
    824          static FRESULT chk_lock 
    825            (
    826              /* [IN] Directory object pointing the file to be checked */
    827          	  DIR* dj,
    828          	  /* [IN] Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    829          	  int acc			
    830            )
    831          {
    832          	uint32_t i, be;
    833          
    834          	/* Search file semaphore table */
    835          	for (i = be = 0; i < _FS_LOCK; i++) {
    836          		if (Files[i].fs) {	/* Existing entry */
    837          			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
    838          				Files[i].clu == dj->sclust &&
    839          				Files[i].idx == dj->index) break;
    840          		} else {			/* Blank entry */
    841          			be++;
    842          		}
    843          	}
    844          	if (i == _FS_LOCK)	/* The file is not opened */
    845          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
    846          
    847          	/* The file has been opened. Reject any open against writing file and all write mode open */
    848          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    849          }
    850          
    851          /*FUNCTION*-------------------------------------------------------------------
    852          *
    853          * Function Name    : enq_lock
    854          * Returned Value   : 1 - the file can be accessed
    855          *                    0 - the file can NOT be accessed
    856          * Comments         :  Check if an entry is available for a new file
    857          *   
    858          *END*----------------------------------------------------------------------*/
    859          static int enq_lock
    860            (
    861             void
    862            )
    863          {
    864          	uint32_t i;
    865          
    866          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    867          	return (i == _FS_LOCK) ? 0 : 1;
    868          }
    869          
    870          /*FUNCTION*-------------------------------------------------------------------
    871          *
    872          * Function Name    : inc_lock
    873          * Returned Value   : its index - if successful
    874          *                    0 - No space to register (int err) or Access violation (int err)
    875          * Comments         : Increment file open counter and returns its index (0:int error)
    876          *   
    877          *END*----------------------------------------------------------------------*/
    878          static uint32_t inc_lock 
    879            (
    880              /* [IN] Directory object pointing the file to register or increment */
    881          	  DIR* dj,	
    882          	  /* [IN] Desired access mode (0:Read, !0:Write) */
    883          	  int acc		
    884            )
    885          {
    886          	uint32_t i;
    887          
    888          
    889          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
    890          		if (Files[i].fs == dj->fs &&
    891          			Files[i].clu == dj->sclust &&
    892          			Files[i].idx == dj->index) break;
    893          	}
    894          
    895          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
    896          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    897          		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
    898          		Files[i].fs = dj->fs;
    899          		Files[i].clu = dj->sclust;
    900          		Files[i].idx = dj->index;
    901          		Files[i].ctr = 0;
    902          	}
    903          
    904          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    905          
    906          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    907          
    908          	return i + 1;
    909          }
    910          
    911          /*FUNCTION*-------------------------------------------------------------------
    912          *
    913          * Function Name    : dec_lock
    914          * Returned Value   : FR_OK: if successfully
    915          *                    FR_INT_ERR: invalid semaphore index
    916          * Comments         : Decrement file open counter
    917          *   
    918          *END*----------------------------------------------------------------------*/
    919          static FRESULT dec_lock 
    920            (
    921              /* [IN] Semaphore index */
    922          	  uint32_t i			
    923            )
    924          {
    925          	uint16_t n;
    926          	FRESULT res;
    927          
    928          
    929          	if (--i < _FS_LOCK) {
    930          		n = Files[i].ctr;
    931          		if (n == 0x100) n = 0;
    932          		if (n) n--;
    933          		Files[i].ctr = n;
    934          		if (!n) Files[i].fs = 0;
    935          		res = FR_OK;
    936          	} else {
    937          		res = FR_INT_ERR;
    938          	}
    939          	return res;
    940          }
    941          
    942          /*FUNCTION*-------------------------------------------------------------------
    943          *
    944          * Function Name    : clear_lock
    945          * Returned Value   : None
    946          * Comments         : Clear lock entries of the volume
    947          *   
    948          *END*----------------------------------------------------------------------*/
    949          
    950          static void clear_lock
    951            (
    952              /* [IN] pointer to file system object */
    953          	  FATFS *fs
    954            )
    955          {
    956          	uint32_t i;
    957          
    958          	for (i = 0; i < _FS_LOCK; i++) {
    959          		if (Files[i].fs == fs) Files[i].fs = 0;
    960          	}
    961          }
    962          #endif
    963          
    964          
    965          
    966          /*-----------------------------------------------------------------------*/
    967          /* Move/Flush disk access window                                         */
    968          /*-----------------------------------------------------------------------*/
    969          
    970          #if !_FS_READONLY
    971          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 1
    972          #define WIN_INDEX(fs)   (((fs)->win == (fs)->winprev) ? 0 : 1)
    973          

   \                                 In section .text, align 2, keep-with-next
    974          static
    975          FRESULT sync_winindex(FATFS *fs, uint8_t index)
    976          {
   \                     sync_winindex: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0005             MOVS     R5,R0
    977              	uint32_t wsect;
    978          	uint32_t nf;
    979                  uint8_t index2 = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    980                  uint8_t num = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    981          
    982                  if(index >= WIN_SECTOR_NUM || fs->winsectprev[index] == 0)
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x7A00             LDRB     R0,[R0, #+8]
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xDA07             BGE      ??sync_winindex_0
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x7A00             LDRB     R0,[R0, #+8]
   \   0000001A   0x2104             MOVS     R1,#+4
   \   0000001C   0x4348             MULS     R0,R1,R0
   \   0000001E   0x1828             ADDS     R0,R5,R0
   \   00000020   0x6B80             LDR      R0,[R0, #+56]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD101             BNE      ??sync_winindex_1
    983                      return FR_OK;
   \                     ??sync_winindex_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE0A9             B        ??sync_winindex_2
    984                  if ((fs->wflag & (0x01 << index))) {    /* dirty judgement for index */
   \                     ??sync_winindex_1: (+1)
   \   0000002A   0x7928             LDRB     R0,[R5, #+4]
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x466A             MOV      R2,SP
   \   00000030   0x7A12             LDRB     R2,[R2, #+8]
   \   00000032   0x4091             LSLS     R1,R1,R2
   \   00000034   0x4208             TST      R0,R1
   \   00000036   0xD100             BNE      .+4
   \   00000038   0xE0A0             B        ??sync_winindex_3
    985                          if (fs->winlastindex == index)  /* another buffer sector should be write back firstly */
   \   0000003A   0x2040             MOVS     R0,#+64
   \   0000003C   0x5C28             LDRB     R0,[R5, R0]
   \   0000003E   0x4669             MOV      R1,SP
   \   00000040   0x7A09             LDRB     R1,[R1, #+8]
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD162             BNE      ??sync_winindex_4
    986                          {
    987                              index2 = index == 0 ? 1 : 0;
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x7A00             LDRB     R0,[R0, #+8]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD103             BNE      ??sync_winindex_5
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x7008             STRB     R0,[R1, #+0]
   \   00000054   0xE002             B        ??sync_winindex_6
   \                     ??sync_winindex_5: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0x7008             STRB     R0,[R1, #+0]
    988                              if (fs->wflag & (0x01 << index2))   /* another need write back */
   \                     ??sync_winindex_6: (+1)
   \   0000005C   0x7928             LDRB     R0,[R5, #+4]
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x466A             MOV      R2,SP
   \   00000062   0x7812             LDRB     R2,[R2, #+0]
   \   00000064   0x4091             LSLS     R1,R1,R2
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0xD050             BEQ      ??sync_winindex_4
    989                              {
    990                                  if (fs->winsectprev[0] + 1 == fs->winsectprev[1])/* two buffer sectors is continuous */
   \   0000006A   0x6BA8             LDR      R0,[R5, #+56]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0x6BE9             LDR      R1,[R5, #+60]
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD105             BNE      ??sync_winindex_7
    991                                  {
    992                                      wsect = fs->winsectprev[0];
   \   00000074   0x6BAC             LDR      R4,[R5, #+56]
    993                                      num = WIN_SECTOR_NUM;
   \   00000076   0x2702             MOVS     R7,#+2
    994                                      index2 = 0;/* index2 is used to confirm the writting back position */
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0x4669             MOV      R1,SP
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
   \   0000007E   0xE006             B        ??sync_winindex_8
    995                                  }
    996                                  else
    997                                  {
    998                                      wsect = fs->winsectprev[index2];
   \                     ??sync_winindex_7: (+1)
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x2104             MOVS     R1,#+4
   \   00000086   0x4348             MULS     R0,R1,R0
   \   00000088   0x1828             ADDS     R0,R5,R0
   \   0000008A   0x6B84             LDR      R4,[R0, #+56]
    999                                      num = 1;
   \   0000008C   0x2701             MOVS     R7,#+1
   1000                                  }
   1001                                  if (disk_write(fs->drv, fs->winprev + SS(fs) * index2, wsect, num) != RES_OK)
   \                     ??sync_winindex_8: (+1)
   \   0000008E   0x003B             MOVS     R3,R7
   \   00000090   0xB2DB             UXTB     R3,R3
   \   00000092   0x0022             MOVS     R2,R4
   \   00000094   0x4668             MOV      R0,SP
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x2180             MOVS     R1,#+128
   \   0000009A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000009C   0x4348             MULS     R0,R1,R0
   \   0000009E   0x1829             ADDS     R1,R5,R0
   \   000000A0   0x3148             ADDS     R1,R1,#+72
   \   000000A2   0x7868             LDRB     R0,[R5, #+1]
   \   000000A4   0x.... 0x....      BL       disk_write
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD001             BEQ      ??sync_winindex_9
   1002                                      return FR_DISK_ERR;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0xE066             B        ??sync_winindex_2
   1003                                  if (num == WIN_SECTOR_NUM)
   \                     ??sync_winindex_9: (+1)
   \   000000B0   0xB2FF             UXTB     R7,R7
   \   000000B2   0x2F02             CMP      R7,#+2
   \   000000B4   0xD102             BNE      ??sync_winindex_10
   1004                                      fs->wflag = 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x7128             STRB     R0,[R5, #+4]
   \   000000BA   0xE006             B        ??sync_winindex_11
   1005                                  else
   1006                                      fs->wflag &= ~(0x01 << index2);
   \                     ??sync_winindex_10: (+1)
   \   000000BC   0x7928             LDRB     R0,[R5, #+4]
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x466A             MOV      R2,SP
   \   000000C2   0x7812             LDRB     R2,[R2, #+0]
   \   000000C4   0x4091             LSLS     R1,R1,R2
   \   000000C6   0x4388             BICS     R0,R0,R1
   \   000000C8   0x7128             STRB     R0,[R5, #+4]
   1007                                  if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize))      /* In FAT area? */
   \                     ??sync_winindex_11: (+1)
   \   000000CA   0x6AA8             LDR      R0,[R5, #+40]
   \   000000CC   0x4284             CMP      R4,R0
   \   000000CE   0xD318             BCC      ??sync_winindex_12
   \   000000D0   0x6AA8             LDR      R0,[R5, #+40]
   \   000000D2   0x6A29             LDR      R1,[R5, #+32]
   \   000000D4   0x1840             ADDS     R0,R0,R1
   \   000000D6   0x4284             CMP      R4,R0
   \   000000D8   0xD213             BCS      ??sync_winindex_12
   1008                                  {
   1009                                      for (nf = fs->n_fats; nf >= 2; nf--)
   \   000000DA   0x78EE             LDRB     R6,[R5, #+3]
   \   000000DC   0xE00F             B        ??sync_winindex_13
   1010                                      {
   1011                                          wsect += fs->fsize;
   \                     ??sync_winindex_14: (+1)
   \   000000DE   0x6A28             LDR      R0,[R5, #+32]
   \   000000E0   0x1824             ADDS     R4,R4,R0
   1012                                          disk_write(fs->drv, fs->winprev + SS(fs) * index2, wsect, num);
   \   000000E2   0x003B             MOVS     R3,R7
   \   000000E4   0xB2DB             UXTB     R3,R3
   \   000000E6   0x0022             MOVS     R2,R4
   \   000000E8   0x4668             MOV      R0,SP
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x2180             MOVS     R1,#+128
   \   000000EE   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000F0   0x4348             MULS     R0,R1,R0
   \   000000F2   0x1829             ADDS     R1,R5,R0
   \   000000F4   0x3148             ADDS     R1,R1,#+72
   \   000000F6   0x7868             LDRB     R0,[R5, #+1]
   \   000000F8   0x.... 0x....      BL       disk_write
   1013                                      }
   \   000000FC   0x1E76             SUBS     R6,R6,#+1
   \                     ??sync_winindex_13: (+1)
   \   000000FE   0x2E02             CMP      R6,#+2
   \   00000100   0xD2ED             BCS      ??sync_winindex_14
   1014                                  }
   1015                                  if (num == WIN_SECTOR_NUM)
   \                     ??sync_winindex_12: (+1)
   \   00000102   0xB2FF             UXTB     R7,R7
   \   00000104   0x2F02             CMP      R7,#+2
   \   00000106   0xD101             BNE      ??sync_winindex_4
   1016                                      return FR_OK;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE038             B        ??sync_winindex_2
   1017                              }
   1018                          }
   1019                          wsect = fs->winsectprev[index];	/* Current sector number */
   \                     ??sync_winindex_4: (+1)
   \   0000010C   0x4668             MOV      R0,SP
   \   0000010E   0x7A00             LDRB     R0,[R0, #+8]
   \   00000110   0x2104             MOVS     R1,#+4
   \   00000112   0x4348             MULS     R0,R1,R0
   \   00000114   0x1828             ADDS     R0,R5,R0
   \   00000116   0x6B84             LDR      R4,[R0, #+56]
   1020          		if (disk_write(fs->drv, fs->winprev + SS(fs) * index, wsect, 1) != RES_OK)
   \   00000118   0x2301             MOVS     R3,#+1
   \   0000011A   0x0022             MOVS     R2,R4
   \   0000011C   0x4668             MOV      R0,SP
   \   0000011E   0x7A00             LDRB     R0,[R0, #+8]
   \   00000120   0x2180             MOVS     R1,#+128
   \   00000122   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000124   0x4348             MULS     R0,R1,R0
   \   00000126   0x1829             ADDS     R1,R5,R0
   \   00000128   0x3148             ADDS     R1,R1,#+72
   \   0000012A   0x7868             LDRB     R0,[R5, #+1]
   \   0000012C   0x.... 0x....      BL       disk_write
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD001             BEQ      ??sync_winindex_15
   1021          			return FR_DISK_ERR;
   \   00000134   0x2001             MOVS     R0,#+1
   \   00000136   0xE022             B        ??sync_winindex_2
   1022                          fs->wflag &= ~(0x01 << index);  /* clear dirty for index */
   \                     ??sync_winindex_15: (+1)
   \   00000138   0x7928             LDRB     R0,[R5, #+4]
   \   0000013A   0x2101             MOVS     R1,#+1
   \   0000013C   0x466A             MOV      R2,SP
   \   0000013E   0x7A12             LDRB     R2,[R2, #+8]
   \   00000140   0x4091             LSLS     R1,R1,R2
   \   00000142   0x4388             BICS     R0,R0,R1
   \   00000144   0x7128             STRB     R0,[R5, #+4]
   1023          		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
   \   00000146   0x6AA8             LDR      R0,[R5, #+40]
   \   00000148   0x4284             CMP      R4,R0
   \   0000014A   0xD317             BCC      ??sync_winindex_3
   \   0000014C   0x6AA8             LDR      R0,[R5, #+40]
   \   0000014E   0x6A29             LDR      R1,[R5, #+32]
   \   00000150   0x1840             ADDS     R0,R0,R1
   \   00000152   0x4284             CMP      R4,R0
   \   00000154   0xD212             BCS      ??sync_winindex_3
   1024          			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   \   00000156   0x78EE             LDRB     R6,[R5, #+3]
   \   00000158   0xE00E             B        ??sync_winindex_16
   1025          				wsect += fs->fsize;
   \                     ??sync_winindex_17: (+1)
   \   0000015A   0x6A28             LDR      R0,[R5, #+32]
   \   0000015C   0x1824             ADDS     R4,R4,R0
   1026          				disk_write(fs->drv, fs->winprev + SS(fs) * index, wsect, 1);
   \   0000015E   0x2301             MOVS     R3,#+1
   \   00000160   0x0022             MOVS     R2,R4
   \   00000162   0x4668             MOV      R0,SP
   \   00000164   0x7A00             LDRB     R0,[R0, #+8]
   \   00000166   0x2180             MOVS     R1,#+128
   \   00000168   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000016A   0x4348             MULS     R0,R1,R0
   \   0000016C   0x1829             ADDS     R1,R5,R0
   \   0000016E   0x3148             ADDS     R1,R1,#+72
   \   00000170   0x7868             LDRB     R0,[R5, #+1]
   \   00000172   0x.... 0x....      BL       disk_write
   1027          			}
   \   00000176   0x1E76             SUBS     R6,R6,#+1
   \                     ??sync_winindex_16: (+1)
   \   00000178   0x2E02             CMP      R6,#+2
   \   0000017A   0xD2EE             BCS      ??sync_winindex_17
   1028          		}
   1029          	}
   1030          	return FR_OK;
   \                     ??sync_winindex_3: (+1)
   \   0000017C   0x2000             MOVS     R0,#+0
   \                     ??sync_winindex_2: (+1)
   \   0000017E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1031          }
   1032          #define sync_window(fs, sector) sync_winindex(fs, sector)
   1033          #elif _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 2
   1034          #define WIN_INDEX(fs)   (0)
   1035          static
   1036          FRESULT sync_windowprev (
   1037          	FATFS *fs		/* File system object */
   1038          )
   1039          {
   1040          	uint32_t wsect;
   1041          	uint32_t nf;
   1042                  uint32_t num = 0;
   1043          	
   1044          	if (fs->wflag) {	/* Write back the sector if it is dirty */
   1045          		wsect = fs->winsectprev;	/* Current sector number */
   1046                          if(fs->winnum == 0 && fs->winsectprev != 0)
   1047                              num = 1;
   1048                          else
   1049                              num = fs->winnum;
   1050                          if (disk_write(fs->drv, fs->winprev, wsect, num) != RES_OK)
   1051          			return FR_DISK_ERR;
   1052                          fs->wflag = 0;  /* clear dirty */
   1053                          fs->win = fs->winprev;
   1054                          fs->winsect = fs->winsectprev;
   1055          		if (wsect >= fs->fatbase && wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area? */
   1056          			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   1057          				wsect += fs->fsize;
   1058                                          disk_write(fs->drv, fs->winprev, wsect, num);
   1059          			}
   1060          		}
   1061          	}
   1062          	return FR_OK;
   1063          }
   1064          
   1065          #define sync_window(fs, sector) sync_windowprev(fs)
   1066          #else
   1067          #define WIN_INDEX(fs)   (0)
   1068          #define sync_window(fs, sector) sync_windowprev(fs)
   1069          
   1070          static
   1071          FRESULT sync_windowprev (
   1072          	FATFS *fs		/* File system object */
   1073          )
   1074          {
   1075          	uint32_t wsect;
   1076          	uint32_t nf;
   1077          
   1078          
   1079          	if (fs->wflag) {	/* Write back the sector if it is dirty */
   1080          		wsect = fs->winsect;	/* Current sector number */
   1081          		if (disk_write(fs->drv, fs->win, wsect, 1))
   1082          			return FR_DISK_ERR;
   1083          		fs->wflag = 0;
   1084          		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
   1085          			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
   1086          				wsect += fs->fsize;
   1087          				disk_write(fs->drv, fs->win, wsect, 1);
   1088          			}
   1089          		}
   1090          	}
   1091          	return FR_OK;
   1092          }
   1093          #endif
   1094          #endif
   1095          
   1096          /*FUNCTION*-------------------------------------------------------------------
   1097          *
   1098          * Function Name    : move_window
   1099          * Returned Value   : FR_OK: if successful
   1100          *                    FR_DISK_ERR: device error 
   1101          * Comments         : Change window offset
   1102          *   
   1103          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1104          static FRESULT move_window 
   1105            (
   1106          	  /* File system object */
   1107          	  FATFS *fs,		  
   1108          	  /* Sector number to make appearance in the fs->win[] */
   1109          	  uint32_t sector	
   1110            )/* Move to zero only writes back dirty window */	
   1111          {
   \                     move_window: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   1112          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1113              uint8_t index = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1114              if (!buff_validation(fs, sector)) {
   \   00000008   0x0031             MOVS     R1,R6
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       buff_validation
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD138             BNE      ??move_window_0
   1115          #else
   1116          	if (sector != fs->winsect) {	/* Changed current window */
   1117          #endif
   1118          #if !_FS_READONLY
   1119          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 1//sync one sector, other sync all sectors.
   1120                      if(fs->winsect != 0)
   \   00000014   0x6B60             LDR      R0,[R4, #+52]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD013             BEQ      ??move_window_1
   1121                      {
   1122          //                index = ((fs->win == fs->winprev) ? 1 : 0);
   1123                          index = fs->winlastindex == 0 ? 1 : 0;  /* select fist readed sector */
   \   0000001A   0x2040             MOVS     R0,#+64
   \   0000001C   0x5C20             LDRB     R0,[R4, R0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD101             BNE      ??move_window_2
   \   00000022   0x2501             MOVS     R5,#+1
   \   00000024   0xE000             B        ??move_window_3
   \                     ??move_window_2: (+1)
   \   00000026   0x2500             MOVS     R5,#+0
   1124                          fs->win = fs->winprev + index * SS(fs);
   \                     ??move_window_3: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5
   \   0000002A   0x2080             MOVS     R0,#+128
   \   0000002C   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   0000002E   0x4368             MULS     R0,R5,R0
   \   00000030   0x1820             ADDS     R0,R4,R0
   \   00000032   0x3048             ADDS     R0,R0,#+72
   \   00000034   0x6460             STR      R0,[R4, #+68]
   1125                          fs->winsect = fs->winsectprev[index];
   \   00000036   0xB2ED             UXTB     R5,R5
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0x4368             MULS     R0,R5,R0
   \   0000003C   0x1820             ADDS     R0,R4,R0
   \   0000003E   0x6B80             LDR      R0,[R0, #+56]
   \   00000040   0x6360             STR      R0,[R4, #+52]
   1126                      }
   1127          #endif
   1128                      if (sync_window(fs, WIN_INDEX(fs)) != FR_OK)
   \                     ??move_window_1: (+1)
   \   00000042   0x6C61             LDR      R1,[R4, #+68]
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x3048             ADDS     R0,R0,#+72
   \   00000048   0x4281             CMP      R1,R0
   \   0000004A   0xD101             BNE      ??move_window_4
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xE000             B        ??move_window_5
   \                     ??move_window_4: (+1)
   \   00000050   0x2101             MOVS     R1,#+1
   \                     ??move_window_5: (+1)
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x0020             MOVS     R0,R4
   \   00000056   0x.... 0x....      BL       sync_winindex
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ      ??move_window_6
   1129                          return FR_DISK_ERR;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE012             B        ??move_window_7
   1130          #endif
   1131          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 2        //read multi sectors.
   1132                      uint32_t count = 0;
   1133                      count = WIN_SECTOR_NUM;
   1134                      if (sector >= fs->fatbase && sector < (fs->fatbase + fs->fsize))/* In FAT area? */
   1135                      {
   1136                          if (sector + count > fs->fatbase + fs->fsize)
   1137                              count = fs->fatbase + fs->fsize - sector;
   1138                      }
   1139                      else if (sector + count < sector)//overflow  here can change
   1140                          count = 1;
   1141                      else if (sector >= fs->database) /* data */
   1142                      {
   1143                          //if ((sector - fs->database) / fs->csize != (sector - fs->database + count - 1) / fs->csize)//cluster
   1144                          if (count > fs->csize - ((fs->csize - 1) & (sector - fs->database)))
   1145                          {
   1146                              count = fs->csize - ((fs->csize - 1) & (sector - fs->database));
   1147                          }
   1148                      }
   1149                      if (disk_read(fs->drv, fs->winprev, sector, count) != RES_OK)
   1150                          return FR_DISK_ERR;
   1151          #else   //read one sector.
   1152                      if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
   \                     ??move_window_6: (+1)
   \   00000062   0x2301             MOVS     R3,#+1
   \   00000064   0x0032             MOVS     R2,R6
   \   00000066   0x6C61             LDR      R1,[R4, #+68]
   \   00000068   0x7860             LDRB     R0,[R4, #+1]
   \   0000006A   0x.... 0x....      BL       disk_read
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD001             BEQ      ??move_window_8
   1153                          return FR_DISK_ERR;
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE008             B        ??move_window_7
   1154                      fs->winsect = sector;
   \                     ??move_window_8: (+1)
   \   00000076   0x6366             STR      R6,[R4, #+52]
   1155          #endif
   1156          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 1
   1157                      fs->winsectprev[index] = sector;
   \   00000078   0xB2ED             UXTB     R5,R5
   \   0000007A   0x2004             MOVS     R0,#+4
   \   0000007C   0x4368             MULS     R0,R5,R0
   \   0000007E   0x1820             ADDS     R0,R4,R0
   \   00000080   0x6386             STR      R6,[R0, #+56]
   1158                      fs->winlastindex = index;
   \   00000082   0x3440             ADDS     R4,R4,#+64
   \   00000084   0x7025             STRB     R5,[R4, #+0]
   1159          #elif _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 2
   1160                      fs->winsectprev = sector;
   1161                      fs->win = fs->winprev;
   1162                      fs->winnum = count;
   1163          #endif
   1164          	}
   1165                  
   1166          	return FR_OK;
   \                     ??move_window_0: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??move_window_7: (+1)
   \   00000088   0xBD70             POP      {R4-R6,PC}       ;; return
   1167          }
   1168          
   1169          
   1170          
   1171          /*FUNCTION*-------------------------------------------------------------------
   1172          *
   1173          * Function Name    : sync_fs
   1174          * Returned Value   : FR_OK: successful
   1175          *                    FR_DISK_ERR: device failed 
   1176          * Comments         : Clean-up cached data 
   1177          *   
   1178          *END*----------------------------------------------------------------------*/
   1179          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1180          static
   1181          FRESULT sync_fs (
   1182              /* [IN] File system object */
   1183          	FATFS *fs
   1184          )
   1185          {
   \                     sync_fs: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1186          	FRESULT res;
   1187          	uint8_t index = 0;
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0xE000             B        ??sync_fs_0
   1188          
   1189          
   1190          	for(; index < WIN_SECTOR_NUM; ++index)
   \                     ??sync_fs_1: (+1)
   \   00000008   0x1C76             ADDS     R6,R6,#+1
   \                     ??sync_fs_0: (+1)
   \   0000000A   0xB2F6             UXTB     R6,R6
   \   0000000C   0x2E02             CMP      R6,#+2
   \   0000000E   0xDA08             BGE      ??sync_fs_2
   1191          	{
   1192                      res = sync_window(fs, index);
   \   00000010   0x0031             MOVS     R1,R6
   \   00000012   0xB2C9             UXTB     R1,R1
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       sync_winindex
   \   0000001A   0x0005             MOVS     R5,R0
   1193                      if(res != FR_OK)
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD0F2             BEQ      ??sync_fs_1
   1194                          break;
   1195          	}
   1196          	if (res == FR_OK) {
   \                     ??sync_fs_2: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD179             BNE      ??sync_fs_3
   1197          		/* Update FSInfo sector if needed */
   1198          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
   \   00000028   0x7820             LDRB     R0,[R4, #+0]
   \   0000002A   0x2803             CMP      R0,#+3
   \   0000002C   0xD16E             BNE      ??sync_fs_4
   \   0000002E   0x7960             LDRB     R0,[R4, #+5]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD06B             BEQ      ??sync_fs_4
   1199          			fs->winsect = 0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6360             STR      R0,[R4, #+52]
   1200          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1201                                  clear_buff(fs);
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x.... 0x....      BL       clear_buff
   1202          #endif
   1203          			/* Create FSInfo structure */
   1204          			mem_set(fs->win, 0, 512);
   \   0000003E   0x2280             MOVS     R2,#+128
   \   00000040   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x6C60             LDR      R0,[R4, #+68]
   \   00000046   0x.... 0x....      BL       mem_set
   1205          			ST_WORD(fs->win+BS_55AA, 0xAA55);
   \   0000004A   0x2055             MOVS     R0,#+85
   \   0000004C   0x6C61             LDR      R1,[R4, #+68]
   \   0000004E   0x22FF             MOVS     R2,#+255
   \   00000050   0x0052             LSLS     R2,R2,#+1        ;; #+510
   \   00000052   0x5488             STRB     R0,[R1, R2]
   \   00000054   0x20AA             MOVS     R0,#+170
   \   00000056   0x6C61             LDR      R1,[R4, #+68]
   \   00000058   0x....             LDR      R2,??DataTable0  ;; 0x1ff
   \   0000005A   0x5488             STRB     R0,[R1, R2]
   1206          			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
   \   0000005C   0x2052             MOVS     R0,#+82
   \   0000005E   0x6C61             LDR      R1,[R4, #+68]
   \   00000060   0x7008             STRB     R0,[R1, #+0]
   \   00000062   0x2052             MOVS     R0,#+82
   \   00000064   0x6C61             LDR      R1,[R4, #+68]
   \   00000066   0x7048             STRB     R0,[R1, #+1]
   \   00000068   0x2061             MOVS     R0,#+97
   \   0000006A   0x6C61             LDR      R1,[R4, #+68]
   \   0000006C   0x7088             STRB     R0,[R1, #+2]
   \   0000006E   0x2041             MOVS     R0,#+65
   \   00000070   0x6C61             LDR      R1,[R4, #+68]
   \   00000072   0x70C8             STRB     R0,[R1, #+3]
   1207          			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
   \   00000074   0x2072             MOVS     R0,#+114
   \   00000076   0x6C61             LDR      R1,[R4, #+68]
   \   00000078   0x22F2             MOVS     R2,#+242
   \   0000007A   0x0052             LSLS     R2,R2,#+1        ;; #+484
   \   0000007C   0x5488             STRB     R0,[R1, R2]
   \   0000007E   0x2072             MOVS     R0,#+114
   \   00000080   0x6C61             LDR      R1,[R4, #+68]
   \   00000082   0x22FF             MOVS     R2,#+255
   \   00000084   0x32E6             ADDS     R2,R2,#+230      ;; #+485
   \   00000086   0x5488             STRB     R0,[R1, R2]
   \   00000088   0x2041             MOVS     R0,#+65
   \   0000008A   0x6C61             LDR      R1,[R4, #+68]
   \   0000008C   0x22F3             MOVS     R2,#+243
   \   0000008E   0x0052             LSLS     R2,R2,#+1        ;; #+486
   \   00000090   0x5488             STRB     R0,[R1, R2]
   \   00000092   0x2061             MOVS     R0,#+97
   \   00000094   0x6C61             LDR      R1,[R4, #+68]
   \   00000096   0x22FF             MOVS     R2,#+255
   \   00000098   0x32E8             ADDS     R2,R2,#+232      ;; #+487
   \   0000009A   0x5488             STRB     R0,[R1, R2]
   1208          			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
   \   0000009C   0x6920             LDR      R0,[R4, #+16]
   \   0000009E   0x6C61             LDR      R1,[R4, #+68]
   \   000000A0   0x22F4             MOVS     R2,#+244
   \   000000A2   0x0052             LSLS     R2,R2,#+1        ;; #+488
   \   000000A4   0x5488             STRB     R0,[R1, R2]
   \   000000A6   0x6920             LDR      R0,[R4, #+16]
   \   000000A8   0xB280             UXTH     R0,R0
   \   000000AA   0x0A00             LSRS     R0,R0,#+8
   \   000000AC   0x6C61             LDR      R1,[R4, #+68]
   \   000000AE   0x22FF             MOVS     R2,#+255
   \   000000B0   0x32EA             ADDS     R2,R2,#+234      ;; #+489
   \   000000B2   0x5488             STRB     R0,[R1, R2]
   \   000000B4   0x6920             LDR      R0,[R4, #+16]
   \   000000B6   0x0C00             LSRS     R0,R0,#+16
   \   000000B8   0x6C61             LDR      R1,[R4, #+68]
   \   000000BA   0x22F5             MOVS     R2,#+245
   \   000000BC   0x0052             LSLS     R2,R2,#+1        ;; #+490
   \   000000BE   0x5488             STRB     R0,[R1, R2]
   \   000000C0   0x6920             LDR      R0,[R4, #+16]
   \   000000C2   0x0E00             LSRS     R0,R0,#+24
   \   000000C4   0x6C61             LDR      R1,[R4, #+68]
   \   000000C6   0x22FF             MOVS     R2,#+255
   \   000000C8   0x32EC             ADDS     R2,R2,#+236      ;; #+491
   \   000000CA   0x5488             STRB     R0,[R1, R2]
   1209          			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
   \   000000CC   0x68E0             LDR      R0,[R4, #+12]
   \   000000CE   0x6C61             LDR      R1,[R4, #+68]
   \   000000D0   0x22F6             MOVS     R2,#+246
   \   000000D2   0x0052             LSLS     R2,R2,#+1        ;; #+492
   \   000000D4   0x5488             STRB     R0,[R1, R2]
   \   000000D6   0x68E0             LDR      R0,[R4, #+12]
   \   000000D8   0xB280             UXTH     R0,R0
   \   000000DA   0x0A00             LSRS     R0,R0,#+8
   \   000000DC   0x6C61             LDR      R1,[R4, #+68]
   \   000000DE   0x22FF             MOVS     R2,#+255
   \   000000E0   0x32EE             ADDS     R2,R2,#+238      ;; #+493
   \   000000E2   0x5488             STRB     R0,[R1, R2]
   \   000000E4   0x68E0             LDR      R0,[R4, #+12]
   \   000000E6   0x0C00             LSRS     R0,R0,#+16
   \   000000E8   0x6C61             LDR      R1,[R4, #+68]
   \   000000EA   0x22F7             MOVS     R2,#+247
   \   000000EC   0x0052             LSLS     R2,R2,#+1        ;; #+494
   \   000000EE   0x5488             STRB     R0,[R1, R2]
   \   000000F0   0x68E0             LDR      R0,[R4, #+12]
   \   000000F2   0x0E00             LSRS     R0,R0,#+24
   \   000000F4   0x6C61             LDR      R1,[R4, #+68]
   \   000000F6   0x22FF             MOVS     R2,#+255
   \   000000F8   0x32F0             ADDS     R2,R2,#+240      ;; #+495
   \   000000FA   0x5488             STRB     R0,[R1, R2]
   1210          			/* Write it into the FSInfo sector */
   1211          			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
   \   000000FC   0x2301             MOVS     R3,#+1
   \   000000FE   0x6962             LDR      R2,[R4, #+20]
   \   00000100   0x6C61             LDR      R1,[R4, #+68]
   \   00000102   0x7860             LDRB     R0,[R4, #+1]
   \   00000104   0x.... 0x....      BL       disk_write
   1212          			fs->fsi_flag = 0;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x7160             STRB     R0,[R4, #+5]
   1213          		}
   1214          		/* Make sure that no pending write process in the physical drive */
   1215          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
   \                     ??sync_fs_4: (+1)
   \   0000010C   0x2200             MOVS     R2,#+0
   \   0000010E   0x2100             MOVS     R1,#+0
   \   00000110   0x7860             LDRB     R0,[R4, #+1]
   \   00000112   0x.... 0x....      BL       disk_ioctl
   \   00000116   0x2800             CMP      R0,#+0
   \   00000118   0xD000             BEQ      ??sync_fs_3
   1216          			res = FR_DISK_ERR;
   \   0000011A   0x2501             MOVS     R5,#+1
   1217          	}
   1218          
   1219          	return res;
   \                     ??sync_fs_3: (+1)
   \   0000011C   0x0028             MOVS     R0,R5
   \   0000011E   0xB2C0             UXTB     R0,R0
   \   00000120   0xBD70             POP      {R4-R6,PC}       ;; return
   1220          }
   1221          #endif
   1222          
   1223          
   1224          
   1225          /*FUNCTION*-------------------------------------------------------------------
   1226          *
   1227          * Function Name    : clust2sect
   1228          * Returned Value   : !=0: Sector number,
   1229          *                    0: Failed - invalid cluster
   1230          * Comments         : Get sector# from cluster#
   1231          *   
   1232          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1233          static uint32_t clust2sect
   1234            	(
   1235                /* [IN] File system object */  
   1236          	  FATFS *fs,		
   1237          	  /* [IN] Cluster# to be converted */
   1238          	  uint32_t clst	
   1239          	)
   1240          {
   \                     clust2sect: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1241          	clst -= 2;
   \   00000002   0x1E89             SUBS     R1,R1,#+2
   1242          	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
   \   00000004   0x69C2             LDR      R2,[R0, #+28]
   \   00000006   0x1E92             SUBS     R2,R2,#+2
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD301             BCC      ??clust2sect_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE003             B        ??clust2sect_1
   1243          	return clst * fs->csize + fs->database;
   \                     ??clust2sect_0: (+1)
   \   00000010   0x7882             LDRB     R2,[R0, #+2]
   \   00000012   0x4351             MULS     R1,R2,R1
   \   00000014   0x6B00             LDR      R0,[R0, #+48]
   \   00000016   0x1808             ADDS     R0,R1,R0
   \                     ??clust2sect_1: (+1)
   \   00000018   0xBD00             POP      {PC}             ;; return
   1244          }
   1245          
   1246          
   1247          /*FUNCTION*-------------------------------------------------------------------
   1248          *
   1249          * Function Name    : get_fat
   1250          * Returned Value   : 0xFFFFFFFF:Disk error
   1251          *                    1:Internal error
   1252          *                    Else:Cluster status
   1253          * Comments         : FAT access - Read value of a FAT entry
   1254          *   
   1255          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1256          static uint32_t get_fat
   1257            (
   1258              /* [IN] File system object */
   1259          	  FATFS *fs,	
   1260          	  /* [in] Cluster# to get the link information */
   1261          	  uint32_t clst	
   1262            )
   1263          {
   \                     get_fat: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1264          	uint32_t wc, bc;
   1265          	uint8_t *p;
   1266          
   1267          
   1268          	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
   \   00000006   0x2D02             CMP      R5,#+2
   \   00000008   0xD302             BCC      ??get_fat_0
   \   0000000A   0x69E0             LDR      R0,[R4, #+28]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD301             BCC      ??get_fat_1
   1269          		return 1;
   \                     ??get_fat_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xE016             B        ??get_fat_2
   1270          
   1271          	switch (fs->fs_type) {
   \                     ??get_fat_1: (+1)
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD004             BEQ      ??get_fat_3
   \   0000001A   0xD310             BCC      ??get_fat_4
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD04C             BEQ      ??get_fat_5
   \   00000020   0xD333             BCC      ??get_fat_6
   \   00000022   0xE00C             B        ??get_fat_4
   1272          	case FS_FAT12 :
   1273          		bc = (uint32_t)clst; bc += bc / 2;
   \                     ??get_fat_3: (+1)
   \   00000024   0x002F             MOVS     R7,R5
   \   00000026   0x0038             MOVS     R0,R7
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x183F             ADDS     R7,R7,R0
   1274          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   \   0000002C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000002E   0x0039             MOVS     R1,R7
   \   00000030   0x0A49             LSRS     R1,R1,#+9
   \   00000032   0x1841             ADDS     R1,R0,R1
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       move_window
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD002             BEQ      ??get_fat_7
   1275          		wc = fs->win[bc % SS(fs)]; bc++;
   1276          		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
   1277          		wc |= fs->win[bc % SS(fs)] << 8;
   1278          		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   1279          
   1280          	case FS_FAT16 :
   1281          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
   1282          		p = &fs->win[clst * 2 % SS(fs)];
   1283          		return LD_WORD(p);
   1284          
   1285          	case FS_FAT32 :
   1286          		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
   1287          		p = &fs->win[clst * 4 % SS(fs)];
   1288          		return LD_DWORD(p) & 0x0FFFFFFF;
   1289          	}
   1290          
   1291          	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
   \                     ??get_fat_4: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x43C0             MVNS     R0,R0            ;; #-1
   \                     ??get_fat_2: (+1)
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??get_fat_7: (+1)
   \   00000044   0x6C66             LDR      R6,[R4, #+68]
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000004C   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000050   0x5C76             LDRB     R6,[R6, R1]
   \   00000052   0x1C7F             ADDS     R7,R7,#+1
   \   00000054   0x6AA0             LDR      R0,[R4, #+40]
   \   00000056   0x0039             MOVS     R1,R7
   \   00000058   0x0A49             LSRS     R1,R1,#+9
   \   0000005A   0x1841             ADDS     R1,R0,R1
   \   0000005C   0x0020             MOVS     R0,R4
   \   0000005E   0x.... 0x....      BL       move_window
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD1EB             BNE      ??get_fat_4
   \                     ??get_fat_8: (+1)
   \   00000066   0x6C64             LDR      R4,[R4, #+68]
   \   00000068   0x0038             MOVS     R0,R7
   \   0000006A   0x2180             MOVS     R1,#+128
   \   0000006C   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000006E   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000072   0x5C60             LDRB     R0,[R4, R1]
   \   00000074   0x0200             LSLS     R0,R0,#+8
   \   00000076   0x4330             ORRS     R0,R0,R6
   \   00000078   0x0006             MOVS     R6,R0
   \   0000007A   0x07E8             LSLS     R0,R5,#+31
   \   0000007C   0xD502             BPL      ??get_fat_9
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0x0900             LSRS     R0,R0,#+4
   \   00000082   0xE001             B        ??get_fat_10
   \                     ??get_fat_9: (+1)
   \   00000084   0x0530             LSLS     R0,R6,#+20       ;; ZeroExtS R0,R6,#+20,#+20
   \   00000086   0x0D00             LSRS     R0,R0,#+20
   \                     ??get_fat_10: (+1)
   \   00000088   0xE7DB             B        ??get_fat_2
   \                     ??get_fat_6: (+1)
   \   0000008A   0x6AA0             LDR      R0,[R4, #+40]
   \   0000008C   0x0029             MOVS     R1,R5
   \   0000008E   0x0A09             LSRS     R1,R1,#+8
   \   00000090   0x1841             ADDS     R1,R0,R1
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       move_window
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD1D0             BNE      ??get_fat_4
   \                     ??get_fat_11: (+1)
   \   0000009C   0x6C64             LDR      R4,[R4, #+68]
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0x4345             MULS     R5,R0,R5
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0x2180             MOVS     R1,#+128
   \   000000A6   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000A8   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000AC   0x1861             ADDS     R1,R4,R1
   \   000000AE   0x7848             LDRB     R0,[R1, #+1]
   \   000000B0   0x0200             LSLS     R0,R0,#+8
   \   000000B2   0x7809             LDRB     R1,[R1, #+0]
   \   000000B4   0x4308             ORRS     R0,R0,R1
   \   000000B6   0xB280             UXTH     R0,R0
   \   000000B8   0xE7C3             B        ??get_fat_2
   \                     ??get_fat_5: (+1)
   \   000000BA   0x6AA0             LDR      R0,[R4, #+40]
   \   000000BC   0x0029             MOVS     R1,R5
   \   000000BE   0x09C9             LSRS     R1,R1,#+7
   \   000000C0   0x1841             ADDS     R1,R0,R1
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       move_window
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD1B8             BNE      ??get_fat_4
   \                     ??get_fat_12: (+1)
   \   000000CC   0x6C64             LDR      R4,[R4, #+68]
   \   000000CE   0x2004             MOVS     R0,#+4
   \   000000D0   0x4345             MULS     R5,R0,R5
   \   000000D2   0x0028             MOVS     R0,R5
   \   000000D4   0x2180             MOVS     R1,#+128
   \   000000D6   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000D8   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000DC   0x1861             ADDS     R1,R4,R1
   \   000000DE   0x78C8             LDRB     R0,[R1, #+3]
   \   000000E0   0x0600             LSLS     R0,R0,#+24
   \   000000E2   0x788A             LDRB     R2,[R1, #+2]
   \   000000E4   0x0412             LSLS     R2,R2,#+16
   \   000000E6   0x4302             ORRS     R2,R2,R0
   \   000000E8   0x7848             LDRB     R0,[R1, #+1]
   \   000000EA   0x0200             LSLS     R0,R0,#+8
   \   000000EC   0x4310             ORRS     R0,R0,R2
   \   000000EE   0x7809             LDRB     R1,[R1, #+0]
   \   000000F0   0x4301             ORRS     R1,R1,R0
   \   000000F2   0x0108             LSLS     R0,R1,#+4        ;; ZeroExtS R0,R1,#+4,#+4
   \   000000F4   0x0900             LSRS     R0,R0,#+4
   \   000000F6   0xE7A4             B        ??get_fat_2
   1292          }
   1293          
   1294          /*FUNCTION*-------------------------------------------------------------------
   1295          *
   1296          * Function Name    : put_fat
   1297          * Returned Value   : FR_INT_ERR:invalie class cluster number or internal error
   1298          *                    FR_OK:successful
   1299          *                    FR_DISK_ERR:disk error
   1300          * Comments         : FAT access - Change value of a FAT entry
   1301          *   
   1302          *END*----------------------------------------------------------------------*/
   1303          #if !_FS_READONLY
   1304          

   \                                 In section .text, align 2, keep-with-next
   1305          static FRESULT put_fat 
   1306            (
   1307              /* [IN] File system object */
   1308            	FATFS *fs,
   1309            	/* [IN] Cluster# to be changed in range of 2 to fs->n_fatent - 1 */	
   1310          	  uint32_t clst,	
   1311          	  /* [IN] New value to mark the cluster */
   1312          	  uint32_t val	
   1313            )
   1314          {
   \                     put_fat: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0014             MOVS     R4,R2
   1315          	uint32_t bc;
   1316          	uint8_t *p;
   1317          	FRESULT res;
   1318          
   1319          
   1320          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000008   0x2E02             CMP      R6,#+2
   \   0000000A   0xD303             BCC      ??put_fat_0
   \   0000000C   0x9802             LDR      R0,[SP, #+8]
   \   0000000E   0x69C0             LDR      R0,[R0, #+28]
   \   00000010   0x4286             CMP      R6,R0
   \   00000012   0xD301             BCC      ??put_fat_1
   1321          		res = FR_INT_ERR;
   \                     ??put_fat_0: (+1)
   \   00000014   0x2502             MOVS     R5,#+2
   \   00000016   0xE0A0             B        ??put_fat_2
   1322          
   1323          	} else {
   1324          		switch (fs->fs_type) {
   \                     ??put_fat_1: (+1)
   \   00000018   0x9802             LDR      R0,[SP, #+8]
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD005             BEQ      ??put_fat_3
   \   00000020   0xD200             BCS      .+4
   \   00000022   0xE096             B        ??put_fat_4
   \   00000024   0x2803             CMP      R0,#+3
   \   00000026   0xD06B             BEQ      ??put_fat_5
   \   00000028   0xD34D             BCC      ??put_fat_6
   \   0000002A   0xE092             B        ??put_fat_4
   1325          		case FS_FAT12 :
   1326          			bc = (uint32_t)clst; bc += bc / 2;
   \                     ??put_fat_3: (+1)
   \   0000002C   0x0037             MOVS     R7,R6
   \   0000002E   0x0038             MOVS     R0,R7
   \   00000030   0x0840             LSRS     R0,R0,#+1
   \   00000032   0x183F             ADDS     R7,R7,R0
   1327          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   00000034   0x9802             LDR      R0,[SP, #+8]
   \   00000036   0x6A80             LDR      R0,[R0, #+40]
   \   00000038   0x0039             MOVS     R1,R7
   \   0000003A   0x0A49             LSRS     R1,R1,#+9
   \   0000003C   0x1841             ADDS     R1,R0,R1
   \   0000003E   0x9802             LDR      R0,[SP, #+8]
   \   00000040   0x.... 0x....      BL       move_window
   \   00000044   0x0005             MOVS     R5,R0
   1328          			if (res != FR_OK) break;
   \   00000046   0xB2ED             UXTB     R5,R5
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD000             BEQ      .+4
   \   0000004C   0xE082             B        ??put_fat_7
   1329          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_8: (+1)
   \   0000004E   0x9802             LDR      R0,[SP, #+8]
   \   00000050   0x6C45             LDR      R5,[R0, #+68]
   \   00000052   0x0038             MOVS     R0,R7
   \   00000054   0x2180             MOVS     R1,#+128
   \   00000056   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000058   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000005C   0x1869             ADDS     R1,R5,R1
   1330          			*p = (clst & 1) ? ((*p & 0x0F) | ((uint8_t)val << 4)) : (uint8_t)val;
   \   0000005E   0x07F0             LSLS     R0,R6,#+31
   \   00000060   0xD506             BPL      ??put_fat_9
   \   00000062   0x7808             LDRB     R0,[R1, #+0]
   \   00000064   0x0702             LSLS     R2,R0,#+28       ;; ZeroExtS R2,R0,#+28,#+28
   \   00000066   0x0F12             LSRS     R2,R2,#+28
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x0100             LSLS     R0,R0,#+4
   \   0000006C   0x4310             ORRS     R0,R0,R2
   \   0000006E   0xE000             B        ??put_fat_10
   \                     ??put_fat_9: (+1)
   \   00000070   0x0020             MOVS     R0,R4
   \                     ??put_fat_10: (+1)
   \   00000072   0x7008             STRB     R0,[R1, #+0]
   1331          			bc++;
   \   00000074   0x1C7F             ADDS     R7,R7,#+1
   1332          			set_dirty(fs);
   \   00000076   0x9802             LDR      R0,[SP, #+8]
   \   00000078   0x.... 0x....      BL       set_dirty
   1333          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   \   0000007C   0x9802             LDR      R0,[SP, #+8]
   \   0000007E   0x6A80             LDR      R0,[R0, #+40]
   \   00000080   0x0039             MOVS     R1,R7
   \   00000082   0x0A49             LSRS     R1,R1,#+9
   \   00000084   0x1841             ADDS     R1,R0,R1
   \   00000086   0x9802             LDR      R0,[SP, #+8]
   \   00000088   0x.... 0x....      BL       move_window
   \   0000008C   0x0005             MOVS     R5,R0
   1334          			if (res != FR_OK) break;
   \   0000008E   0xB2ED             UXTB     R5,R5
   \   00000090   0x2D00             CMP      R5,#+0
   \   00000092   0xD15F             BNE      ??put_fat_7
   1335          			p = &fs->win[bc % SS(fs)];
   \                     ??put_fat_11: (+1)
   \   00000094   0x9802             LDR      R0,[SP, #+8]
   \   00000096   0x6C40             LDR      R0,[R0, #+68]
   \   00000098   0x9000             STR      R0,[SP, #+0]
   \   0000009A   0x0038             MOVS     R0,R7
   \   0000009C   0x2180             MOVS     R1,#+128
   \   0000009E   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000A0   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000A4   0x9800             LDR      R0,[SP, #+0]
   \   000000A6   0x1841             ADDS     R1,R0,R1
   1336          			*p = (clst & 1) ? (uint8_t)(val >> 4) : ((*p & 0xF0) | ((uint8_t)(val >> 8) & 0x0F));
   \   000000A8   0x07F0             LSLS     R0,R6,#+31
   \   000000AA   0xD502             BPL      ??put_fat_12
   \   000000AC   0x0020             MOVS     R0,R4
   \   000000AE   0x0900             LSRS     R0,R0,#+4
   \   000000B0   0xE007             B        ??put_fat_13
   \                     ??put_fat_12: (+1)
   \   000000B2   0x7808             LDRB     R0,[R1, #+0]
   \   000000B4   0x22F0             MOVS     R2,#+240
   \   000000B6   0x4002             ANDS     R2,R2,R0
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x0A00             LSRS     R0,R0,#+8
   \   000000BC   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   000000BE   0x0F00             LSRS     R0,R0,#+28
   \   000000C0   0x4310             ORRS     R0,R0,R2
   \                     ??put_fat_13: (+1)
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
   1337          			break;
   \   000000C4   0xE046             B        ??put_fat_7
   1338          
   1339          		case FS_FAT16 :
   1340          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   \                     ??put_fat_6: (+1)
   \   000000C6   0x9802             LDR      R0,[SP, #+8]
   \   000000C8   0x6A80             LDR      R0,[R0, #+40]
   \   000000CA   0x0031             MOVS     R1,R6
   \   000000CC   0x0A09             LSRS     R1,R1,#+8
   \   000000CE   0x1841             ADDS     R1,R0,R1
   \   000000D0   0x9802             LDR      R0,[SP, #+8]
   \   000000D2   0x.... 0x....      BL       move_window
   \   000000D6   0x0005             MOVS     R5,R0
   1341          			if (res != FR_OK) break;
   \   000000D8   0xB2ED             UXTB     R5,R5
   \   000000DA   0x2D00             CMP      R5,#+0
   \   000000DC   0xD13A             BNE      ??put_fat_7
   1342          			p = &fs->win[clst * 2 % SS(fs)];
   \                     ??put_fat_14: (+1)
   \   000000DE   0x9802             LDR      R0,[SP, #+8]
   \   000000E0   0x6C47             LDR      R7,[R0, #+68]
   \   000000E2   0x2002             MOVS     R0,#+2
   \   000000E4   0x4346             MULS     R6,R0,R6
   \   000000E6   0x0030             MOVS     R0,R6
   \   000000E8   0x2180             MOVS     R1,#+128
   \   000000EA   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000EC   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000F0   0x1879             ADDS     R1,R7,R1
   1343          			ST_WORD(p, (uint16_t)val);
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
   \   000000F6   0x0020             MOVS     R0,R4
   \   000000F8   0xB280             UXTH     R0,R0
   \   000000FA   0x0A00             LSRS     R0,R0,#+8
   \   000000FC   0x7048             STRB     R0,[R1, #+1]
   1344          			break;
   \   000000FE   0xE029             B        ??put_fat_7
   1345          
   1346          		case FS_FAT32 :
   1347          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   \                     ??put_fat_5: (+1)
   \   00000100   0x9802             LDR      R0,[SP, #+8]
   \   00000102   0x6A80             LDR      R0,[R0, #+40]
   \   00000104   0x0031             MOVS     R1,R6
   \   00000106   0x09C9             LSRS     R1,R1,#+7
   \   00000108   0x1841             ADDS     R1,R0,R1
   \   0000010A   0x9802             LDR      R0,[SP, #+8]
   \   0000010C   0x.... 0x....      BL       move_window
   \   00000110   0x0005             MOVS     R5,R0
   1348          			if (res != FR_OK) break;
   \   00000112   0xB2ED             UXTB     R5,R5
   \   00000114   0x2D00             CMP      R5,#+0
   \   00000116   0xD11D             BNE      ??put_fat_7
   1349          			p = &fs->win[clst * 4 % SS(fs)];
   \                     ??put_fat_15: (+1)
   \   00000118   0x9802             LDR      R0,[SP, #+8]
   \   0000011A   0x6C47             LDR      R7,[R0, #+68]
   \   0000011C   0x2004             MOVS     R0,#+4
   \   0000011E   0x4346             MULS     R6,R0,R6
   \   00000120   0x0030             MOVS     R0,R6
   \   00000122   0x2180             MOVS     R1,#+128
   \   00000124   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000126   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000012A   0x1879             ADDS     R1,R7,R1
   1350          			val |= LD_DWORD(p) & 0xF0000000;
   \   0000012C   0x78C8             LDRB     R0,[R1, #+3]
   \   0000012E   0x0600             LSLS     R0,R0,#+24
   \   00000130   0x0F00             LSRS     R0,R0,#+28
   \   00000132   0x0700             LSLS     R0,R0,#+28
   \   00000134   0x4320             ORRS     R0,R0,R4
   \   00000136   0x0004             MOVS     R4,R0
   1351          			ST_DWORD(p, val);
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0x7008             STRB     R0,[R1, #+0]
   \   0000013C   0x0020             MOVS     R0,R4
   \   0000013E   0xB280             UXTH     R0,R0
   \   00000140   0x0A00             LSRS     R0,R0,#+8
   \   00000142   0x7048             STRB     R0,[R1, #+1]
   \   00000144   0x0020             MOVS     R0,R4
   \   00000146   0x0C00             LSRS     R0,R0,#+16
   \   00000148   0x7088             STRB     R0,[R1, #+2]
   \   0000014A   0x0020             MOVS     R0,R4
   \   0000014C   0x0E00             LSRS     R0,R0,#+24
   \   0000014E   0x70C8             STRB     R0,[R1, #+3]
   1352          			break;
   \   00000150   0xE000             B        ??put_fat_7
   1353          
   1354          		default :
   1355          			res = FR_INT_ERR;
   \                     ??put_fat_4: (+1)
   \   00000152   0x2502             MOVS     R5,#+2
   1356          		}
   1357          		set_dirty(fs);
   \                     ??put_fat_7: (+1)
   \   00000154   0x9802             LDR      R0,[SP, #+8]
   \   00000156   0x.... 0x....      BL       set_dirty
   1358          	}
   1359          
   1360          	return res;
   \                     ??put_fat_2: (+1)
   \   0000015A   0x0028             MOVS     R0,R5
   \   0000015C   0xB2C0             UXTB     R0,R0
   \   0000015E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1361          }
   1362          #endif /* !_FS_READONLY */
   1363          
   1364          
   1365          /*FUNCTION*-------------------------------------------------------------------
   1366          *
   1367          * Function Name    : remove_chain
   1368          * Returned Value   : FR_OK: sucessful
   1369          *                    FR_INT_ERR:Internal error
   1370          *                    FR_DISK_ERR:Disk error
   1371          * Comments         : FAT handling - Remove a cluster chain 
   1372          *   
   1373          *END*----------------------------------------------------------------------*/
   1374          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1375          static FRESULT remove_chain
   1376            (
   1377          	  /* [IN] File system object */
   1378          	  FATFS *fs,			
   1379          	  /* [IN] Cluster# to remove a chain from */
   1380          	  uint32_t clst			
   1381            )
   1382          {
   \                     remove_chain: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000C             MOVS     R4,R1
   1383          	FRESULT res;
   1384          	uint32_t nxt;
   1385          #if _USE_ERASE
   1386          	uint32_t scl = clst, ecl = clst, rt[2];
   1387          #endif
   1388          
   1389          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
   \   00000006   0x2C02             CMP      R4,#+2
   \   00000008   0xD302             BCC      ??remove_chain_0
   \   0000000A   0x69F8             LDR      R0,[R7, #+28]
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD301             BCC      ??remove_chain_1
   1390          		res = FR_INT_ERR;
   \                     ??remove_chain_0: (+1)
   \   00000010   0x2502             MOVS     R5,#+2
   \   00000012   0xE029             B        ??remove_chain_2
   1391          
   1392          	} else {
   1393          		res = FR_OK;
   \                     ??remove_chain_1: (+1)
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0xE00A             B        ??remove_chain_3
   1394          		while (clst < fs->n_fatent) {			/* Not a last link? */
   1395          			nxt = get_fat(fs, clst);			/* Get cluster status */
   1396          			if (nxt == 0) break;				/* Empty cluster? */
   1397          			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
   1398          			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
   1399          			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
   1400          			if (res != FR_OK) break;
   1401          			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
   \                     ??remove_chain_4: (+1)
   \   00000018   0x6938             LDR      R0,[R7, #+16]
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD004             BEQ      ??remove_chain_5
   1402          				fs->free_clust++;
   \   00000022   0x6938             LDR      R0,[R7, #+16]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x6138             STR      R0,[R7, #+16]
   1403          				fs->fsi_flag = 1;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x7178             STRB     R0,[R7, #+5]
   1404          			}
   1405          #if _USE_ERASE
   1406          			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
   1407          				ecl = nxt;
   1408          			} else {				/* End of contiguous clusters */ 
   1409          				rt[0] = clust2sect(fs, scl);					/* Start sector */
   1410          				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
   1411          				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
   1412          				scl = ecl = nxt;
   1413          			}
   1414          #endif
   1415          			clst = nxt;	/* Next cluster */
   \                     ??remove_chain_5: (+1)
   \   0000002C   0x0034             MOVS     R4,R6
   \                     ??remove_chain_3: (+1)
   \   0000002E   0x69F8             LDR      R0,[R7, #+28]
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD219             BCS      ??remove_chain_2
   \   00000034   0x0021             MOVS     R1,R4
   \   00000036   0x0038             MOVS     R0,R7
   \   00000038   0x.... 0x....      BL       get_fat
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0x2E00             CMP      R6,#+0
   \   00000040   0xD012             BEQ      ??remove_chain_2
   \                     ??remove_chain_6: (+1)
   \   00000042   0x2E01             CMP      R6,#+1
   \   00000044   0xD101             BNE      ??remove_chain_7
   \   00000046   0x2502             MOVS     R5,#+2
   \   00000048   0xE00E             B        ??remove_chain_2
   \                     ??remove_chain_7: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xD101             BNE      ??remove_chain_8
   \   00000052   0x2501             MOVS     R5,#+1
   \   00000054   0xE008             B        ??remove_chain_2
   \                     ??remove_chain_8: (+1)
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x0021             MOVS     R1,R4
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0x.... 0x....      BL       put_fat
   \   00000060   0x0005             MOVS     R5,R0
   \   00000062   0xB2ED             UXTB     R5,R5
   \   00000064   0x2D00             CMP      R5,#+0
   \   00000066   0xD0D7             BEQ      ??remove_chain_4
   1416          		}
   1417          	}
   1418          
   1419          	return res;
   \                     ??remove_chain_2: (+1)
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1420          }
   1421          #endif
   1422          
   1423          
   1424          /*FUNCTION*-------------------------------------------------------------------
   1425          *
   1426          * Function Name    : create_chain
   1427          * Returned Value   : 0: No free cluster
   1428          *                    1: Internal error
   1429          *                    0xFFFFFFFF: Disk error
   1430          *                    >= 2:New cluster number
   1431          * Comments         : FAT handling - Stretch or Create a cluster chain 
   1432          *   
   1433          *END*----------------------------------------------------------------------*/
   1434          
   1435          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1436          static uint32_t create_chain
   1437            (
   1438              /* [IN] File system object */
   1439          	  FATFS *fs,		
   1440          	  /* [IN] Cluster# to stretch. 0 means create a new chain. */
   1441          	  uint32_t clst			
   1442            )
   1443          {
   \                     create_chain: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000F             MOVS     R7,R1
   1444          	uint32_t cs, ncl, scl;
   1445          	FRESULT res;
   1446          
   1447          
   1448          	if (clst == 0) {		/* Create a new chain */
   \   00000006   0x2F00             CMP      R7,#+0
   \   00000008   0xD107             BNE      ??create_chain_0
   1449          		scl = fs->last_clust;			/* Get suggested start point */
   \   0000000A   0x68EE             LDR      R6,[R5, #+12]
   1450          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD002             BEQ      ??create_chain_1
   \   00000010   0x69E8             LDR      R0,[R5, #+28]
   \   00000012   0x4286             CMP      R6,R0
   \   00000014   0xD30D             BCC      ??create_chain_2
   \                     ??create_chain_1: (+1)
   \   00000016   0x2601             MOVS     R6,#+1
   \   00000018   0xE00B             B        ??create_chain_2
   1451          	}
   1452          	else {					/* Stretch the current chain */
   1453          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_0: (+1)
   \   0000001A   0x0039             MOVS     R1,R7
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0x.... 0x....      BL       get_fat
   1454          		if (cs < 2) return 1;			/* It is an invalid cluster *///2
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD201             BCS      ??create_chain_3
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE044             B        ??create_chain_4
   1455          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   \                     ??create_chain_3: (+1)
   \   0000002A   0x69E9             LDR      R1,[R5, #+28]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD341             BCC      ??create_chain_4
   1456          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1457                          scl = fs->last_clust;
   \                     ??create_chain_5: (+1)
   \   00000030   0x68EE             LDR      R6,[R5, #+12]
   1458          #else
   1459          		scl = clst;
   1460          #endif
   1461          	}
   1462          
   1463          	ncl = scl;//ncl		/* Start cluster */
   \                     ??create_chain_2: (+1)
   \   00000032   0x0034             MOVS     R4,R6
   1464          	for (;;) {
   1465          		ncl++;							/* Next cluster */
   \                     ??create_chain_6: (+1)
   \   00000034   0x1C64             ADDS     R4,R4,#+1
   1466          		if (ncl >= fs->n_fatent) {		/* Wrap around */
   \   00000036   0x69E8             LDR      R0,[R5, #+28]
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD304             BCC      ??create_chain_7
   1467          			ncl = 2;
   \   0000003C   0x2402             MOVS     R4,#+2
   1468          			if (ncl > scl) return 0;	/* No free cluster */
   \   0000003E   0x42A6             CMP      R6,R4
   \   00000040   0xD201             BCS      ??create_chain_7
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xE036             B        ??create_chain_4
   1469          		}
   1470          		cs = get_fat(fs, ncl);			/* Get the cluster status */
   \                     ??create_chain_7: (+1)
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x0028             MOVS     R0,R5
   \   0000004A   0x.... 0x....      BL       get_fat
   1471          		if (cs == 0) break;				/* Found a free cluster */
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD11D             BNE      ??create_chain_8
   1472          		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   1473          			return cs;
   1474          		if (ncl == scl) return 0;		/* No free cluster */
   1475          	}
   1476          
   1477          	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
   \   00000052   0x....             LDR      R2,??DataTable2  ;; 0xfffffff
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x0028             MOVS     R0,R5
   \   00000058   0x.... 0x....      BL       put_fat
   1478          	if (res == FR_OK && clst != 0) {
   \   0000005C   0xB2C0             UXTB     R0,R0
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD106             BNE      ??create_chain_9
   \   00000062   0x2F00             CMP      R7,#+0
   \   00000064   0xD004             BEQ      ??create_chain_9
   1479          		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
   \   00000066   0x0022             MOVS     R2,R4
   \   00000068   0x0039             MOVS     R1,R7
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0x.... 0x....      BL       put_fat
   1480          	}
   1481          	if (res == FR_OK) {
   \                     ??create_chain_9: (+1)
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD116             BNE      ??create_chain_10
   1482          		fs->last_clust = ncl;			/* Update FSINFO */
   \   00000076   0x60EC             STR      R4,[R5, #+12]
   1483          		if (fs->free_clust != 0xFFFFFFFF) {
   \   00000078   0x6928             LDR      R0,[R5, #+16]
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD017             BEQ      ??create_chain_11
   1484          			fs->free_clust--;
   \   00000082   0x6928             LDR      R0,[R5, #+16]
   \   00000084   0x1E40             SUBS     R0,R0,#+1
   \   00000086   0x6128             STR      R0,[R5, #+16]
   1485          			fs->fsi_flag = 1;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x7168             STRB     R0,[R5, #+5]
   \   0000008C   0xE011             B        ??create_chain_11
   1486          		}
   1487          	} else {
   \                     ??create_chain_8: (+1)
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xD001             BEQ      ??create_chain_12
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD100             BNE      ??create_chain_13
   \                     ??create_chain_12: (+1)
   \   0000009A   0xE00B             B        ??create_chain_4
   \                     ??create_chain_13: (+1)
   \   0000009C   0x42B4             CMP      R4,R6
   \   0000009E   0xD1C9             BNE      ??create_chain_6
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0xE007             B        ??create_chain_4
   1488          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_10: (+1)
   \   000000A4   0xB2C0             UXTB     R0,R0
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD102             BNE      ??create_chain_14
   \   000000AA   0x2400             MOVS     R4,#+0
   \   000000AC   0x43E4             MVNS     R4,R4            ;; #-1
   \   000000AE   0xE000             B        ??create_chain_11
   \                     ??create_chain_14: (+1)
   \   000000B0   0x2401             MOVS     R4,#+1
   1489          	}
   1490          
   1491          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_11: (+1)
   \   000000B2   0x0020             MOVS     R0,R4
   \                     ??create_chain_4: (+1)
   \   000000B4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1492          }
   1493          
   1494          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION

   \                                 In section .text, align 2, keep-with-next
   1495          static uint32_t create_chain_for_clusts
   1496            (
   1497              /* [IN] File system object */
   1498          	  FATFS *fs,		
   1499          	  /* [IN] Cluster# to stretch. 0 means create a new chain. */
   1500          	  uint32_t clst,
   1501                    /* [IN] Desired continuous num clusters*/
   1502                    uint32_t for_num,
   1503                    /* [OUT] Searched continuous num clusters */
   1504                    uint32_t *get_num
   1505            )
   1506          {
   \                     create_chain_for_clusts: (+1)
   \   00000000   0xB5FD             PUSH     {R0,R2-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x000F             MOVS     R7,R1
   1507          	uint32_t cs, ncl, scl;
   1508          	FRESULT res;
   1509                  uint32_t num = 0, try = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2600             MOVS     R6,#+0
   1510                  uint32_t i = 0;
   \   0000000A   0x2600             MOVS     R6,#+0
   1511                  uint32_t first_idle = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   1512                  uint32_t first_num = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9002             STR      R0,[SP, #+8]
   1513          //        uint32_t fat_sector;
   1514          
   1515          
   1516          	if (clst == 0) {		/* Create a new chain */
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD10D             BNE      ??create_chain_for_clusts_0
   1517          		scl = fs->last_clust;			/* Get suggested start point */
   \   00000018   0x9804             LDR      R0,[SP, #+16]
   \   0000001A   0x68C0             LDR      R0,[R0, #+12]
   \   0000001C   0x9000             STR      R0,[SP, #+0]
   1518          		if (!scl || scl >= fs->n_fatent) scl = 1;
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD004             BEQ      ??create_chain_for_clusts_1
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x9904             LDR      R1,[SP, #+16]
   \   00000028   0x69C9             LDR      R1,[R1, #+28]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD330             BCC      ??create_chain_for_clusts_2
   \                     ??create_chain_for_clusts_1: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x9000             STR      R0,[SP, #+0]
   \   00000032   0xE02D             B        ??create_chain_for_clusts_2
   1519          	}
   1520          	else {					/* Stretch the current chain */
   1521          		cs = get_fat(fs, clst);			/* Check the cluster status */
   \                     ??create_chain_for_clusts_0: (+1)
   \   00000034   0x0039             MOVS     R1,R7
   \   00000036   0x9804             LDR      R0,[SP, #+16]
   \   00000038   0x.... 0x....      BL       get_fat
   1522          		if (cs < 2) return 1;			/* It is an invalid cluster *///2
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD201             BCS      ??create_chain_for_clusts_3
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE0D0             B        ??create_chain_for_clusts_4
   1523          		if (cs < fs->n_fatent)
   \                     ??create_chain_for_clusts_3: (+1)
   \   00000044   0x9904             LDR      R1,[SP, #+16]
   \   00000046   0x69C9             LDR      R1,[R1, #+28]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD21E             BCS      ??create_chain_for_clusts_5
   1524                          {
   1525          				    num = 1;
   \   0000004C   0x2401             MOVS     R4,#+1
   1526          					ncl = cs;
   \   0000004E   0x0005             MOVS     R5,R0
   1527          					clst = cs;
   \   00000050   0x0007             MOVS     R7,R0
   1528          					do
   1529          					{
   1530          					    cs = get_fat(fs, clst);
   \                     ??create_chain_for_clusts_6: (+1)
   \   00000052   0x0039             MOVS     R1,R7
   \   00000054   0x9804             LDR      R0,[SP, #+16]
   \   00000056   0x.... 0x....      BL       get_fat
   1531          						if (cs < 2) return 1;
   \   0000005A   0x2802             CMP      R0,#+2
   \   0000005C   0xD201             BCS      ??create_chain_for_clusts_7
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE0C1             B        ??create_chain_for_clusts_4
   1532          						if (cs < fs->n_fatent && cs == clst + 1)//continuous
   \                     ??create_chain_for_clusts_7: (+1)
   \   00000062   0x9904             LDR      R1,[SP, #+16]
   \   00000064   0x69C9             LDR      R1,[R1, #+28]
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD20B             BCS      ??create_chain_for_clusts_8
   \   0000006A   0x1C7F             ADDS     R7,R7,#+1
   \   0000006C   0x42B8             CMP      R0,R7
   \   0000006E   0xD108             BNE      ??create_chain_for_clusts_8
   1533          						{
   1534          							num++;
   \   00000070   0x1C64             ADDS     R4,R4,#+1
   1535          							if (num == for_num)
   \   00000072   0x9905             LDR      R1,[SP, #+20]
   \   00000074   0x428C             CMP      R4,R1
   \   00000076   0xD004             BEQ      ??create_chain_for_clusts_9
   1536          							    break;
   1537          						}
   1538          						else//not continuous
   1539          						    break;
   1540          						clst = cs;
   \                     ??create_chain_for_clusts_10: (+1)
   \   00000078   0x0007             MOVS     R7,R0
   1541          					} while (cs != 0x0FFFFFFF);
   \   0000007A   0x....             LDR      R1,??DataTable2  ;; 0xfffffff
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD1E8             BNE      ??create_chain_for_clusts_6
   \   00000080   0xE7FF             B        ??create_chain_for_clusts_9
   1542                              *get_num = num;
   \                     ??create_chain_for_clusts_8: (+1)
   \                     ??create_chain_for_clusts_9: (+1)
   \   00000082   0x9806             LDR      R0,[SP, #+24]
   \   00000084   0x6004             STR      R4,[R0, #+0]
   1543          					return ncl;
   \   00000086   0x0028             MOVS     R0,R5
   \   00000088   0xE0AD             B        ??create_chain_for_clusts_4
   1544                          }
   1545          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1546                          scl = fs->last_clust;
   \                     ??create_chain_for_clusts_5: (+1)
   \   0000008A   0x9804             LDR      R0,[SP, #+16]
   \   0000008C   0x68C0             LDR      R0,[R0, #+12]
   \   0000008E   0x9000             STR      R0,[SP, #+0]
   1547          #else				
   1548          		        scl = clst;
   1549          #endif
   1550          	}
   1551                  
   1552                  ncl = scl;
   \                     ??create_chain_for_clusts_2: (+1)
   \   00000090   0x9D00             LDR      R5,[SP, #+0]
   1553                  num = 0;
   \   00000092   0x2400             MOVS     R4,#+0
   1554                  try = 0;
   \   00000094   0x2600             MOVS     R6,#+0
   1555                  do
   1556                  {
   1557                          ++ncl;
   \                     ??create_chain_for_clusts_11: (+1)
   \   00000096   0x1C6D             ADDS     R5,R5,#+1
   1558                          if(ncl >= fs->n_fatent)/* Wrap around*/
   \   00000098   0x9804             LDR      R0,[SP, #+16]
   \   0000009A   0x69C0             LDR      R0,[R0, #+28]
   \   0000009C   0x4285             CMP      R5,R0
   \   0000009E   0xD30A             BCC      ??create_chain_for_clusts_12
   1559                          {
   1560          //                    USB_PRINTF("wrap around\n");
   1561                              ncl = 2;
   \   000000A0   0x2502             MOVS     R5,#+2
   1562                              num = 0;
   \   000000A2   0x2400             MOVS     R4,#+0
   1563                              ++try;
   \   000000A4   0x1C76             ADDS     R6,R6,#+1
   1564                              if(ncl > scl)
   \   000000A6   0x9800             LDR      R0,[SP, #+0]
   \   000000A8   0x42A8             CMP      R0,R5
   \   000000AA   0xD204             BCS      ??create_chain_for_clusts_12
   1565                              {
   1566                                  *get_num = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x9906             LDR      R1,[SP, #+24]
   \   000000B0   0x6008             STR      R0,[R1, #+0]
   1567                                  return 0;  /*No free cluster*/
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE097             B        ??create_chain_for_clusts_4
   1568                              }
   1569                          }
   1570                          cs = get_fat(fs, ncl);
   \                     ??create_chain_for_clusts_12: (+1)
   \   000000B6   0x0029             MOVS     R1,R5
   \   000000B8   0x9804             LDR      R0,[SP, #+16]
   \   000000BA   0x.... 0x....      BL       get_fat
   1571                          if(cs == 0)//found one
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD105             BNE      ??create_chain_for_clusts_13
   1572                          {
   1573                              if(first_idle == 0)
   \   000000C2   0x9801             LDR      R0,[SP, #+4]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD100             BNE      ??create_chain_for_clusts_14
   1574                                  first_idle = ncl;
   \   000000C8   0x9501             STR      R5,[SP, #+4]
   1575                              ++num;
   \                     ??create_chain_for_clusts_14: (+1)
   \   000000CA   0x1C64             ADDS     R4,R4,#+1
   \   000000CC   0xE016             B        ??create_chain_for_clusts_15
   1576                          }
   1577                          else if(cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
   \                     ??create_chain_for_clusts_13: (+1)
   \   000000CE   0x2100             MOVS     R1,#+0
   \   000000D0   0x43C9             MVNS     R1,R1            ;; #-1
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD001             BEQ      ??create_chain_for_clusts_16
   \   000000D6   0x2801             CMP      R0,#+1
   \   000000D8   0xD103             BNE      ??create_chain_for_clusts_17
   1578                          {
   1579                              *get_num = 0;
   \                     ??create_chain_for_clusts_16: (+1)
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0x9A06             LDR      R2,[SP, #+24]
   \   000000DE   0x6011             STR      R1,[R2, #+0]
   1580                              return cs;
   \   000000E0   0xE081             B        ??create_chain_for_clusts_4
   1581                          }
   1582                          else if(ncl == scl)/* No free cluster */
   \                     ??create_chain_for_clusts_17: (+1)
   \   000000E2   0x9800             LDR      R0,[SP, #+0]
   \   000000E4   0x4285             CMP      R5,R0
   \   000000E6   0xD104             BNE      ??create_chain_for_clusts_18
   1583                          {
   1584                              *get_num = 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x9906             LDR      R1,[SP, #+24]
   \   000000EC   0x6008             STR      R0,[R1, #+0]
   1585                              return 0;
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xE079             B        ??create_chain_for_clusts_4
   1586                          }
   1587                          else /* not continuous */
   1588                          {
   1589                              if (try == 0)//record first continuous free clusters.
   \                     ??create_chain_for_clusts_18: (+1)
   \   000000F2   0x2E00             CMP      R6,#+0
   \   000000F4   0xD100             BNE      ??create_chain_for_clusts_19
   1590                                  first_num = num;
   \   000000F6   0x9402             STR      R4,[SP, #+8]
   1591                              num = 0;
   \                     ??create_chain_for_clusts_19: (+1)
   \   000000F8   0x2400             MOVS     R4,#+0
   1592                              ++try;
   \   000000FA   0x1C76             ADDS     R6,R6,#+1
   1593                          }
   1594                  } while(num < for_num && try < MAX_TRIES_SEARCH_CONTINUOUS_CLUSTER);
   \                     ??create_chain_for_clusts_15: (+1)
   \   000000FC   0x9805             LDR      R0,[SP, #+20]
   \   000000FE   0x4284             CMP      R4,R0
   \   00000100   0xD201             BCS      ??create_chain_for_clusts_20
   \   00000102   0x2E02             CMP      R6,#+2
   \   00000104   0xD3C7             BCC      ??create_chain_for_clusts_11
   1595                  
   1596                  /* got some continuous free clusters but not enough*/
   1597                  if (num != for_num && first_num != 0 && first_idle != 0)
   \                     ??create_chain_for_clusts_20: (+1)
   \   00000106   0x9805             LDR      R0,[SP, #+20]
   \   00000108   0x4284             CMP      R4,R0
   \   0000010A   0xD00D             BEQ      ??create_chain_for_clusts_21
   \   0000010C   0x9802             LDR      R0,[SP, #+8]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD00A             BEQ      ??create_chain_for_clusts_21
   \   00000112   0x9801             LDR      R0,[SP, #+4]
   \   00000114   0x2800             CMP      R0,#+0
   \   00000116   0xD007             BEQ      ??create_chain_for_clusts_21
   1598                  {
   1599                      *get_num = first_num;
   \   00000118   0x9802             LDR      R0,[SP, #+8]
   \   0000011A   0x9906             LDR      R1,[SP, #+24]
   \   0000011C   0x6008             STR      R0,[R1, #+0]
   1600                      num = first_num;
   \   0000011E   0x9C02             LDR      R4,[SP, #+8]
   1601                      ncl = first_idle + (first_num - 1);
   \   00000120   0x9801             LDR      R0,[SP, #+4]
   \   00000122   0x9902             LDR      R1,[SP, #+8]
   \   00000124   0x1845             ADDS     R5,R0,R1
   \   00000126   0x1E6D             SUBS     R5,R5,#+1
   1602                  }
   1603                  if (num != 0)/* get some continuous free clusters in the most front */
   \                     ??create_chain_for_clusts_21: (+1)
   \   00000128   0x2C00             CMP      R4,#+0
   \   0000012A   0xD041             BEQ      ??create_chain_for_clusts_22
   1604                  {
   1605          //            USB_PRINTF("get desired clusters %d-%d\n", ncl, for_num);
   1606                      *get_num = num;
   \   0000012C   0x9806             LDR      R0,[SP, #+24]
   \   0000012E   0x6004             STR      R4,[R0, #+0]
   1607          //                if(clst != 0)
   1608          //                    res = put_fat(fs, clst, ncl - num + 1);
   1609          //                if(res == FR_OK)
   1610          //                {
   1611          //                  for (i = num - 1; i > 0; --i)
   1612          //                  {
   1613          //                    res = put_fat(fs, ncl - i, ncl - i + 1);
   1614          //                    if (res != FR_OK)
   1615          //                      break;
   1616          //                  }
   1617          //                }
   1618          //                res = put_fat(fs, ncl, 0x0FFFFFFF);
   1619          //                if(res == FR_OK)
   1620          //                {
   1621          //                    fs->last_clust = ncl;
   1622          //                    if(fs->free_clust != 0xFFFFFFFF)
   1623          //                    {
   1624          //                      fs->free_clust -= for_num;
   1625          //                      fs->fsi_flag = 1;
   1626          //                    }
   1627          //                    ncl -= (num - 1);
   1628          //                }
   1629          //                else
   1630          //                {
   1631          //                  ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   1632          //                }
   1633                          
   1634                          
   1635                          res = put_fat(fs, ncl, 0x0FFFFFFF);
   \   00000130   0x....             LDR      R2,??DataTable2  ;; 0xfffffff
   \   00000132   0x0029             MOVS     R1,R5
   \   00000134   0x9804             LDR      R0,[SP, #+16]
   \   00000136   0x.... 0x....      BL       put_fat
   1636                          if(res == FR_OK)
   \   0000013A   0xB2C0             UXTB     R0,R0
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD10D             BNE      ??create_chain_for_clusts_23
   1637                          {
   1638                              for(i = 1; i < num; ++i)
   \   00000140   0x2601             MOVS     R6,#+1
   \   00000142   0xE000             B        ??create_chain_for_clusts_24
   \                     ??create_chain_for_clusts_25: (+1)
   \   00000144   0x1C76             ADDS     R6,R6,#+1
   \                     ??create_chain_for_clusts_24: (+1)
   \   00000146   0x42A6             CMP      R6,R4
   \   00000148   0xD208             BCS      ??create_chain_for_clusts_23
   1639                              {
   1640                                  res = put_fat(fs, ncl - i, ncl - (i - 1));
   \   0000014A   0x1BAA             SUBS     R2,R5,R6
   \   0000014C   0x1C52             ADDS     R2,R2,#+1
   \   0000014E   0x1BA9             SUBS     R1,R5,R6
   \   00000150   0x9804             LDR      R0,[SP, #+16]
   \   00000152   0x.... 0x....      BL       put_fat
   1641                                  if(res != FR_OK)
   \   00000156   0xB2C0             UXTB     R0,R0
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD0F3             BEQ      ??create_chain_for_clusts_25
   1642                                      break;
   1643                              }
   1644                          }
   1645                          if(res == FR_OK && clst != 0)
   \                     ??create_chain_for_clusts_23: (+1)
   \   0000015C   0xB2C0             UXTB     R0,R0
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD107             BNE      ??create_chain_for_clusts_26
   \   00000162   0x2F00             CMP      R7,#+0
   \   00000164   0xD005             BEQ      ??create_chain_for_clusts_26
   1646                          {
   1647                              res = put_fat(fs, clst, ncl - num + 1);
   \   00000166   0x1B2A             SUBS     R2,R5,R4
   \   00000168   0x1C52             ADDS     R2,R2,#+1
   \   0000016A   0x0039             MOVS     R1,R7
   \   0000016C   0x9804             LDR      R0,[SP, #+16]
   \   0000016E   0x.... 0x....      BL       put_fat
   1648                          }
   1649                          if(res == FR_OK)
   \                     ??create_chain_for_clusts_26: (+1)
   \   00000172   0xB2C0             UXTB     R0,R0
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD113             BNE      ??create_chain_for_clusts_27
   1650                          {
   1651                              fs->last_clust = ncl;
   \   00000178   0x9804             LDR      R0,[SP, #+16]
   \   0000017A   0x60C5             STR      R5,[R0, #+12]
   1652                              if(fs->free_clust != 0xFFFFFFFF)
   \   0000017C   0x9804             LDR      R0,[SP, #+16]
   \   0000017E   0x6900             LDR      R0,[R0, #+16]
   \   00000180   0x2100             MOVS     R1,#+0
   \   00000182   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000184   0x4288             CMP      R0,R1
   \   00000186   0xD008             BEQ      ??create_chain_for_clusts_28
   1653                              {
   1654                                  fs->free_clust -= for_num;
   \   00000188   0x9804             LDR      R0,[SP, #+16]
   \   0000018A   0x6900             LDR      R0,[R0, #+16]
   \   0000018C   0x9905             LDR      R1,[SP, #+20]
   \   0000018E   0x1A40             SUBS     R0,R0,R1
   \   00000190   0x9904             LDR      R1,[SP, #+16]
   \   00000192   0x6108             STR      R0,[R1, #+16]
   1655                                  fs->fsi_flag = 1;
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0x9904             LDR      R1,[SP, #+16]
   \   00000198   0x7148             STRB     R0,[R1, #+5]
   1656                              }
   1657                              ncl -= (num - 1);
   \                     ??create_chain_for_clusts_28: (+1)
   \   0000019A   0x1B2D             SUBS     R5,R5,R4
   \   0000019C   0x1C6D             ADDS     R5,R5,#+1
   \   0000019E   0xE021             B        ??create_chain_for_clusts_29
   1658                          }
   1659                          else
   1660                          {
   1661                              ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
   \                     ??create_chain_for_clusts_27: (+1)
   \   000001A0   0xB2C0             UXTB     R0,R0
   \   000001A2   0x2801             CMP      R0,#+1
   \   000001A4   0xD102             BNE      ??create_chain_for_clusts_30
   \   000001A6   0x2500             MOVS     R5,#+0
   \   000001A8   0x43ED             MVNS     R5,R5            ;; #-1
   \   000001AA   0xE01B             B        ??create_chain_for_clusts_29
   \                     ??create_chain_for_clusts_30: (+1)
   \   000001AC   0x2501             MOVS     R5,#+1
   \   000001AE   0xE019             B        ??create_chain_for_clusts_29
   1662                          }
   1663                  }
   1664                  else
   1665                  {
   1666          //            USB_PRINTF("not get desired cluster\n");
   1667                          if(first_idle != 0)
   \                     ??create_chain_for_clusts_22: (+1)
   \   000001B0   0x9801             LDR      R0,[SP, #+4]
   \   000001B2   0x2800             CMP      R0,#+0
   \   000001B4   0xD002             BEQ      ??create_chain_for_clusts_31
   1668          				    fs->last_clust = first_idle;
   \   000001B6   0x9801             LDR      R0,[SP, #+4]
   \   000001B8   0x9904             LDR      R1,[SP, #+16]
   \   000001BA   0x60C8             STR      R0,[R1, #+12]
   1669                              ncl = create_chain(fs, clst);
   \                     ??create_chain_for_clusts_31: (+1)
   \   000001BC   0x0039             MOVS     R1,R7
   \   000001BE   0x9804             LDR      R0,[SP, #+16]
   \   000001C0   0x.... 0x....      BL       create_chain
   \   000001C4   0x0005             MOVS     R5,R0
   1670                          if (ncl != 0 && ncl != 1 && ncl != 0xFFFFFFFF)
   \   000001C6   0x2D00             CMP      R5,#+0
   \   000001C8   0xD009             BEQ      ??create_chain_for_clusts_32
   \   000001CA   0x2D01             CMP      R5,#+1
   \   000001CC   0xD007             BEQ      ??create_chain_for_clusts_32
   \   000001CE   0x2000             MOVS     R0,#+0
   \   000001D0   0x43C0             MVNS     R0,R0            ;; #-1
   \   000001D2   0x4285             CMP      R5,R0
   \   000001D4   0xD003             BEQ      ??create_chain_for_clusts_32
   1671                              *get_num = 1;
   \   000001D6   0x2001             MOVS     R0,#+1
   \   000001D8   0x9906             LDR      R1,[SP, #+24]
   \   000001DA   0x6008             STR      R0,[R1, #+0]
   \   000001DC   0xE002             B        ??create_chain_for_clusts_29
   1672                          else
   1673                              *get_num = 0;
   \                     ??create_chain_for_clusts_32: (+1)
   \   000001DE   0x2000             MOVS     R0,#+0
   \   000001E0   0x9906             LDR      R1,[SP, #+24]
   \   000001E2   0x6008             STR      R0,[R1, #+0]
   1674                  }
   1675          	return ncl;		/* Return new cluster number or error code */
   \                     ??create_chain_for_clusts_29: (+1)
   \   000001E4   0x0028             MOVS     R0,R5
   \                     ??create_chain_for_clusts_4: (+1)
   \   000001E6   0xB007             ADD      SP,SP,#+28
   \   000001E8   0xBDF0             POP      {R4-R7,PC}       ;; return
   1676          }
   1677          #endif
   1678          #endif /* !_FS_READONLY */
   1679          
   1680          
   1681          
   1682          /*-----------------------------------------------------------------------*/
   1683          /* FAT handling - Convert offset into cluster with link map table        */
   1684          /*-----------------------------------------------------------------------*/
   1685          
   1686          #if _USE_FASTSEEK
   1687          static
   1688          uint32_t clmt_clust (	/* <2:Error, >=2:Cluster number */
   1689          	FIL* fp,		/* Pointer to the file object */
   1690          	uint32_t ofs		/* File offset to be converted to cluster# */
   1691          )
   1692          {
   1693          	uint32_t cl, ncl, *tbl;
   1694          
   1695          
   1696          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1697          	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
   1698          	for (;;) {
   1699          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1700          		if (!ncl) return 0;		/* End of table? (error) */
   1701          		if (cl < ncl) break;	/* In this fragment? */
   1702          		cl -= ncl; tbl++;		/* Next fragment */
   1703          	}
   1704          	return cl + *tbl;	/* Return the cluster number */
   1705          }
   1706          #endif	/* _USE_FASTSEEK */
   1707          /*FUNCTION*-------------------------------------------------------------------
   1708          *
   1709          * Function Name    : dir_sdi
   1710          * Returned Value   : FR_OK: successful
   1711          *                    FR_INT_ERR: Internal error (invalid index range)
   1712          *                    FR_DISK_ERR: Disk error
   1713          * Comments         : Directory handling - Set directory index  
   1714          *   
   1715          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1716          static FRESULT dir_sdi
   1717            (
   1718              /* [IN] Pointer to directory object */
   1719          	  DIR *dj,	
   1720          	  /* Directory index number */	
   1721          	  uint16_t idx		
   1722            )
   1723          {
   \                     dir_sdi: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1724          	uint32_t clst;
   1725          	uint16_t ic;
   1726          
   1727          
   1728          	dj->index = idx;
   \   00000006   0x80E5             STRH     R5,[R4, #+6]
   1729          	clst = dj->sclust;
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   1730          	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD003             BEQ      ??dir_sdi_0
   \   0000000E   0x6821             LDR      R1,[R4, #+0]
   \   00000010   0x69C9             LDR      R1,[R1, #+28]
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD301             BCC      ??dir_sdi_1
   1731          		return FR_INT_ERR;
   \                     ??dir_sdi_0: (+1)
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE04B             B        ??dir_sdi_2
   1732          	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
   \                     ??dir_sdi_1: (+1)
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD105             BNE      ??dir_sdi_3
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x2903             CMP      R1,#+3
   \   00000024   0xD101             BNE      ??dir_sdi_3
   1733          		clst = dj->fs->dirbase;
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x6AC0             LDR      R0,[R0, #+44]
   1734          
   1735          	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
   \                     ??dir_sdi_3: (+1)
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD10F             BNE      ??dir_sdi_4
   1736          		dj->clust = clst;
   \   0000002E   0x60E0             STR      R0,[R4, #+12]
   1737          		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x8900             LDRH     R0,[R0, #+8]
   \   00000034   0xB2AD             UXTH     R5,R5
   \   00000036   0x4285             CMP      R5,R0
   \   00000038   0xD301             BCC      ??dir_sdi_5
   1738          			return FR_INT_ERR;
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0xE039             B        ??dir_sdi_2
   1739          		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \                     ??dir_sdi_5: (+1)
   \   0000003E   0x6820             LDR      R0,[R4, #+0]
   \   00000040   0x6AC0             LDR      R0,[R0, #+44]
   \   00000042   0xB2AD             UXTH     R5,R5
   \   00000044   0x0029             MOVS     R1,R5
   \   00000046   0x0909             LSRS     R1,R1,#+4
   \   00000048   0x1840             ADDS     R0,R0,R1
   \   0000004A   0x6120             STR      R0,[R4, #+16]
   \   0000004C   0xE025             B        ??dir_sdi_6
   1740          	}
   1741          	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
   1742          		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
   \                     ??dir_sdi_4: (+1)
   \   0000004E   0x6821             LDR      R1,[R4, #+0]
   \   00000050   0x7889             LDRB     R1,[R1, #+2]
   \   00000052   0x2610             MOVS     R6,#+16
   \   00000054   0x434E             MULS     R6,R1,R6
   \   00000056   0xE000             B        ??dir_sdi_7
   1743          		while (idx >= ic) {	/* Follow cluster chain */
   1744          			clst = get_fat(dj->fs, clst);				/* Get next cluster */
   1745          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1746          			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
   1747          				return FR_INT_ERR;
   1748          			idx -= ic;
   \                     ??dir_sdi_8: (+1)
   \   00000058   0x1BAD             SUBS     R5,R5,R6
   \                     ??dir_sdi_7: (+1)
   \   0000005A   0xB2AD             UXTH     R5,R5
   \   0000005C   0xB2B6             UXTH     R6,R6
   \   0000005E   0x42B5             CMP      R5,R6
   \   00000060   0xD311             BCC      ??dir_sdi_9
   \   00000062   0x0001             MOVS     R1,R0
   \   00000064   0x6820             LDR      R0,[R4, #+0]
   \   00000066   0x.... 0x....      BL       get_fat
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD101             BNE      ??dir_sdi_10
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE01D             B        ??dir_sdi_2
   \                     ??dir_sdi_10: (+1)
   \   00000076   0x2802             CMP      R0,#+2
   \   00000078   0xD303             BCC      ??dir_sdi_11
   \   0000007A   0x6821             LDR      R1,[R4, #+0]
   \   0000007C   0x69C9             LDR      R1,[R1, #+28]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD3EA             BCC      ??dir_sdi_8
   \                     ??dir_sdi_11: (+1)
   \   00000082   0x2002             MOVS     R0,#+2
   \   00000084   0xE015             B        ??dir_sdi_2
   1749          		}
   1750          		dj->clust = clst;
   \                     ??dir_sdi_9: (+1)
   \   00000086   0x60E0             STR      R0,[R4, #+12]
   1751          		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
   \   00000088   0x0001             MOVS     R1,R0
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x.... 0x....      BL       clust2sect
   \   00000090   0xB2AD             UXTH     R5,R5
   \   00000092   0x0029             MOVS     R1,R5
   \   00000094   0x0909             LSRS     R1,R1,#+4
   \   00000096   0x1840             ADDS     R0,R0,R1
   \   00000098   0x6120             STR      R0,[R4, #+16]
   1752          	}
   1753          
   1754          	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
   \                     ??dir_sdi_6: (+1)
   \   0000009A   0x6820             LDR      R0,[R4, #+0]
   \   0000009C   0x6C46             LDR      R6,[R0, #+68]
   \   0000009E   0xB2AD             UXTH     R5,R5
   \   000000A0   0x0028             MOVS     R0,R5
   \   000000A2   0x2110             MOVS     R1,#+16
   \   000000A4   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000A8   0x2020             MOVS     R0,#+32
   \   000000AA   0x4341             MULS     R1,R0,R1
   \   000000AC   0x1870             ADDS     R0,R6,R1
   \   000000AE   0x6160             STR      R0,[R4, #+20]
   1755          
   1756          	return FR_OK;	/* Seek succeeded */
   \   000000B0   0x2000             MOVS     R0,#+0
   \                     ??dir_sdi_2: (+1)
   \   000000B2   0xBD70             POP      {R4-R6,PC}       ;; return
   1757          }
   1758          
   1759          /*FUNCTION*-------------------------------------------------------------------
   1760          *
   1761          * Function Name    : dir_next
   1762          * Returned Value   : FR_OK: successful
   1763          *                    FR_INT_ERR: Internal error (invalid index range)
   1764          *                    FR_DISK_ERR: Disk error
   1765          *                    FR_NO_FILE: End of table
   1766          *                    FR_DENIED: No free cluster
   1767          * Comments         : Directory handling - Move directory index next 
   1768          *   
   1769          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1770          static FRESULT dir_next
   1771            (
   1772              /* [IN] Pointer to directory object */
   1773          	  DIR *dj,
   1774          	  /* [IN] 0: Do not stretch table, 1: Stretch table if needed */		
   1775          	  int stretch		
   1776            )
   1777          {
   \                     dir_next: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1778          	uint32_t clst;
   1779          	uint16_t i;
   1780          
   1781          
   1782          	stretch = stretch;		/* To suppress warning on read-only cfg. */
   1783          	i = dj->index + 1;
   \   00000006   0x88E7             LDRH     R7,[R4, #+6]
   \   00000008   0x1C7F             ADDS     R7,R7,#+1
   1784          	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
   \   0000000A   0xB2BF             UXTH     R7,R7
   \   0000000C   0x2F00             CMP      R7,#+0
   \   0000000E   0xD002             BEQ      ??dir_next_0
   \   00000010   0x6920             LDR      R0,[R4, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE      ??dir_next_1
   1785          		return FR_NO_FILE;
   \                     ??dir_next_0: (+1)
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0xE0B0             B        ??dir_next_2
   1786          
   1787          	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
   \                     ??dir_next_1: (+1)
   \   0000001A   0xB2BF             UXTH     R7,R7
   \   0000001C   0x0038             MOVS     R0,R7
   \   0000001E   0x2110             MOVS     R1,#+16
   \   00000020   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD000             BEQ      .+4
   \   00000028   0xE09B             B        ??dir_next_3
   1788          		dj->sect++;					/* Next sector */
   \   0000002A   0x6920             LDR      R0,[R4, #+16]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x6120             STR      R0,[R4, #+16]
   1789          
   1790          		if (dj->clust == 0) {	/* Static table */
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD107             BNE      ??dir_next_4
   1791          			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x8900             LDRH     R0,[R0, #+8]
   \   0000003A   0xB2BF             UXTH     R7,R7
   \   0000003C   0x4287             CMP      R7,R0
   \   0000003E   0xD200             BCS      .+4
   \   00000040   0xE08F             B        ??dir_next_3
   1792          				return FR_NO_FILE;
   \   00000042   0x2004             MOVS     R0,#+4
   \   00000044   0xE09A             B        ??dir_next_2
   1793          		}
   1794          		else {					/* Dynamic table */
   1795          			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
   \                     ??dir_next_4: (+1)
   \   00000046   0xB2BF             UXTH     R7,R7
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0x0900             LSRS     R0,R0,#+4
   \   0000004C   0x6821             LDR      R1,[R4, #+0]
   \   0000004E   0x7889             LDRB     R1,[R1, #+2]
   \   00000050   0x1E49             SUBS     R1,R1,#+1
   \   00000052   0x4001             ANDS     R1,R1,R0
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD000             BEQ      .+4
   \   00000058   0xE083             B        ??dir_next_3
   1796          				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
   \   0000005A   0x68E1             LDR      R1,[R4, #+12]
   \   0000005C   0x6820             LDR      R0,[R4, #+0]
   \   0000005E   0x.... 0x....      BL       get_fat
   \   00000062   0x0006             MOVS     R6,R0
   1797          				if (clst <= 1) return FR_INT_ERR;
   \   00000064   0x2E02             CMP      R6,#+2
   \   00000066   0xD201             BCS      ??dir_next_5
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0xE087             B        ??dir_next_2
   1798          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_5: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000070   0x4286             CMP      R6,R0
   \   00000072   0xD101             BNE      ??dir_next_6
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE081             B        ??dir_next_2
   1799          				if (clst >= dj->fs->n_fatent) {//0x0FFFFFFF	/* When it reached end of dynamic table */
   \                     ??dir_next_6: (+1)
   \   00000078   0x6820             LDR      R0,[R4, #+0]
   \   0000007A   0x69C0             LDR      R0,[R0, #+28]
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xD36A             BCC      ??dir_next_7
   1800          #if !_FS_READONLY
   1801          					uint8_t c;
   1802          					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
   \   00000080   0x2D00             CMP      R5,#+0
   \   00000082   0xD101             BNE      ??dir_next_8
   \   00000084   0x2004             MOVS     R0,#+4
   \   00000086   0xE079             B        ??dir_next_2
   1803          					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
   \                     ??dir_next_8: (+1)
   \   00000088   0x68E1             LDR      R1,[R4, #+12]
   \   0000008A   0x6820             LDR      R0,[R4, #+0]
   \   0000008C   0x.... 0x....      BL       create_chain
   \   00000090   0x0006             MOVS     R6,R0
   1804          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xD101             BNE      ??dir_next_9
   \   00000096   0x2007             MOVS     R0,#+7
   \   00000098   0xE070             B        ??dir_next_2
   1805          					if (clst == 1) return FR_INT_ERR;
   \                     ??dir_next_9: (+1)
   \   0000009A   0x2E01             CMP      R6,#+1
   \   0000009C   0xD101             BNE      ??dir_next_10
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0xE06C             B        ??dir_next_2
   1806          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   \                     ??dir_next_10: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000A6   0x4286             CMP      R6,R0
   \   000000A8   0xD101             BNE      ??dir_next_11
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0xE066             B        ??dir_next_2
   1807          					/* Clean-up stretched table */
   1808          					if (sync_window(dj->fs, WIN_INDEX(dj->fs))) return FR_DISK_ERR;	/* Flush active window */
   \                     ??dir_next_11: (+1)
   \   000000AE   0x6820             LDR      R0,[R4, #+0]
   \   000000B0   0x6C40             LDR      R0,[R0, #+68]
   \   000000B2   0x6821             LDR      R1,[R4, #+0]
   \   000000B4   0x3148             ADDS     R1,R1,#+72
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD101             BNE      ??dir_next_12
   \   000000BA   0x2100             MOVS     R1,#+0
   \   000000BC   0xE000             B        ??dir_next_13
   \                     ??dir_next_12: (+1)
   \   000000BE   0x2101             MOVS     R1,#+1
   \                     ??dir_next_13: (+1)
   \   000000C0   0xB2C9             UXTB     R1,R1
   \   000000C2   0x6820             LDR      R0,[R4, #+0]
   \   000000C4   0x.... 0x....      BL       sync_winindex
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD001             BEQ      ??dir_next_14
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xE055             B        ??dir_next_2
   1809          					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
   \                     ??dir_next_14: (+1)
   \   000000D0   0x2280             MOVS     R2,#+128
   \   000000D2   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x6820             LDR      R0,[R4, #+0]
   \   000000D8   0x6C40             LDR      R0,[R0, #+68]
   \   000000DA   0x.... 0x....      BL       mem_set
   1810          					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
   \   000000DE   0x0031             MOVS     R1,R6
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0x.... 0x....      BL       clust2sect
   \   000000E6   0x6821             LDR      R1,[R4, #+0]
   \   000000E8   0x6348             STR      R0,[R1, #+52]
   1811          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1812                                                  set_sectorprev(dj->fs, dj->fs->winsect);
   \   000000EA   0x6820             LDR      R0,[R4, #+0]
   \   000000EC   0x6B41             LDR      R1,[R0, #+52]
   \   000000EE   0x6820             LDR      R0,[R4, #+0]
   \   000000F0   0x.... 0x....      BL       set_sectorprev
   1813          #endif                                        
   1814          					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
   \   000000F4   0x2500             MOVS     R5,#+0
   \   000000F6   0xE00A             B        ??dir_next_15
   1815          						set_dirty(dj->fs);
   1816          						if (sync_window(dj->fs, WIN_INDEX(dj->fs))) return FR_DISK_ERR;
   1817          						dj->fs->winsect++;
   \                     ??dir_next_16: (+1)
   \   000000F8   0x6820             LDR      R0,[R4, #+0]
   \   000000FA   0x6B40             LDR      R0,[R0, #+52]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \   000000FE   0x6821             LDR      R1,[R4, #+0]
   \   00000100   0x6348             STR      R0,[R1, #+52]
   1818          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1819                                                          set_sectorprev(dj->fs, dj->fs->winsect);
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x6B41             LDR      R1,[R0, #+52]
   \   00000106   0x6820             LDR      R0,[R4, #+0]
   \   00000108   0x.... 0x....      BL       set_sectorprev
   \   0000010C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dir_next_15: (+1)
   \   0000010E   0x6820             LDR      R0,[R4, #+0]
   \   00000110   0x7880             LDRB     R0,[R0, #+2]
   \   00000112   0xB2ED             UXTB     R5,R5
   \   00000114   0x4285             CMP      R5,R0
   \   00000116   0xD213             BCS      ??dir_next_17
   \   00000118   0x6820             LDR      R0,[R4, #+0]
   \   0000011A   0x.... 0x....      BL       set_dirty
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x6C40             LDR      R0,[R0, #+68]
   \   00000122   0x6821             LDR      R1,[R4, #+0]
   \   00000124   0x3148             ADDS     R1,R1,#+72
   \   00000126   0x4288             CMP      R0,R1
   \   00000128   0xD101             BNE      ??dir_next_18
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0xE000             B        ??dir_next_19
   \                     ??dir_next_18: (+1)
   \   0000012E   0x2101             MOVS     R1,#+1
   \                     ??dir_next_19: (+1)
   \   00000130   0xB2C9             UXTB     R1,R1
   \   00000132   0x6820             LDR      R0,[R4, #+0]
   \   00000134   0x.... 0x....      BL       sync_winindex
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD0DD             BEQ      ??dir_next_16
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0xE01D             B        ??dir_next_2
   1820          #endif
   1821          					}
   1822          					dj->fs->winsect -= c;						/* Rewind window address */
   \                     ??dir_next_17: (+1)
   \   00000140   0x6820             LDR      R0,[R4, #+0]
   \   00000142   0x6B40             LDR      R0,[R0, #+52]
   \   00000144   0xB2ED             UXTB     R5,R5
   \   00000146   0x1B40             SUBS     R0,R0,R5
   \   00000148   0x6821             LDR      R1,[R4, #+0]
   \   0000014A   0x6348             STR      R0,[R1, #+52]
   1823          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1824                                                  set_sectorprev(dj->fs, dj->fs->winsect);
   \   0000014C   0x6820             LDR      R0,[R4, #+0]
   \   0000014E   0x6B41             LDR      R1,[R0, #+52]
   \   00000150   0x6820             LDR      R0,[R4, #+0]
   \   00000152   0x.... 0x....      BL       set_sectorprev
   1825          #endif
   1826          #else
   1827          					return FR_NO_FILE;			/* Report EOT */
   1828          #endif
   1829          				}
   1830          				dj->clust = clst;				/* Initialize data for new cluster */
   \                     ??dir_next_7: (+1)
   \   00000156   0x60E6             STR      R6,[R4, #+12]
   1831          				dj->sect = clust2sect(dj->fs, clst);
   \   00000158   0x0031             MOVS     R1,R6
   \   0000015A   0x6820             LDR      R0,[R4, #+0]
   \   0000015C   0x.... 0x....      BL       clust2sect
   \   00000160   0x6120             STR      R0,[R4, #+16]
   1832          			}
   1833          		}
   1834          	}
   1835          
   1836          	dj->index = i;
   \                     ??dir_next_3: (+1)
   \   00000162   0x80E7             STRH     R7,[R4, #+6]
   1837          	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
   \   00000164   0x6820             LDR      R0,[R4, #+0]
   \   00000166   0x6C45             LDR      R5,[R0, #+68]
   \   00000168   0xB2BF             UXTH     R7,R7
   \   0000016A   0x0038             MOVS     R0,R7
   \   0000016C   0x2110             MOVS     R1,#+16
   \   0000016E   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000172   0x2020             MOVS     R0,#+32
   \   00000174   0x4341             MULS     R1,R0,R1
   \   00000176   0x1868             ADDS     R0,R5,R1
   \   00000178   0x6160             STR      R0,[R4, #+20]
   1838          
   1839          	return FR_OK;
   \   0000017A   0x2000             MOVS     R0,#+0
   \                     ??dir_next_2: (+1)
   \   0000017C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1840          }
   1841          
   1842          
   1843          
   1844          
   1845          /*-----------------------------------------------------------------------*/
   1846          /* Directory handling - Reserve directory entry                          */
   1847          /*-----------------------------------------------------------------------*/
   1848          
   1849          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1850          static
   1851          FRESULT dir_alloc (
   1852          	DIR* dj,	/* Pointer to the directory object */
   1853          	uint32_t nent	/* Number of contiguous entries to allocate (1-21) */
   1854          )
   1855          {
   \                     dir_alloc: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
   1856          	FRESULT res;
   1857          	uint32_t n;
   1858          
   1859          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   1860                  if (entry_start_clust == dj->sclust)
   \   00000006   0x....             LDR      R0,??DataTable6
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x68B1             LDR      R1,[R6, #+8]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD106             BNE      ??dir_alloc_0
   1861                      res = dir_sdi(dj, entry_start_free_index);
   \   00000010   0x....             LDR      R0,??DataTable6_1
   \   00000012   0x8801             LDRH     R1,[R0, #+0]
   \   00000014   0x0030             MOVS     R0,R6
   \   00000016   0x.... 0x....      BL       dir_sdi
   \   0000001A   0x0004             MOVS     R4,R0
   \   0000001C   0xE004             B        ??dir_alloc_1
   1862                  else
   1863                      res = dir_sdi(dj, 0);
   \                     ??dir_alloc_0: (+1)
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x.... 0x....      BL       dir_sdi
   \   00000026   0x0004             MOVS     R4,R0
   1864          #else
   1865          	res = dir_sdi(dj, 0);
   1866          #endif
   1867          	if (res == FR_OK) {
   \                     ??dir_alloc_1: (+1)
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD123             BNE      ??dir_alloc_2
   1868          		n = 0;
   \   0000002E   0x2500             MOVS     R5,#+0
   1869          		do {
   1870          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_alloc_3: (+1)
   \   00000030   0x6931             LDR      R1,[R6, #+16]
   \   00000032   0x6830             LDR      R0,[R6, #+0]
   \   00000034   0x.... 0x....      BL       move_window
   \   00000038   0x0004             MOVS     R4,R0
   1871          			if (res != FR_OK) break;
   \   0000003A   0xB2E4             UXTB     R4,R4
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD11A             BNE      ??dir_alloc_2
   1872          			if (convert_ptr(dj->fs, dj->dir)[0] == DDE || convert_ptr(dj->fs, dj->dir)[0] == 0) {	/* Is it a blank entry? */
   \                     ??dir_alloc_4: (+1)
   \   00000040   0x6971             LDR      R1,[R6, #+20]
   \   00000042   0x6830             LDR      R0,[R6, #+0]
   \   00000044   0x.... 0x....      BL       convert_ptr
   \   00000048   0x7800             LDRB     R0,[R0, #+0]
   \   0000004A   0x28E5             CMP      R0,#+229
   \   0000004C   0xD006             BEQ      ??dir_alloc_5
   \   0000004E   0x6971             LDR      R1,[R6, #+20]
   \   00000050   0x6830             LDR      R0,[R6, #+0]
   \   00000052   0x.... 0x....      BL       convert_ptr
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD103             BNE      ??dir_alloc_6
   1873          				if (++n == nent) break;	/* A block of contiguous entry is found */
   \                     ??dir_alloc_5: (+1)
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
   \   0000005E   0x42BD             CMP      R5,R7
   \   00000060   0xD101             BNE      ??dir_alloc_7
   \   00000062   0xE008             B        ??dir_alloc_2
   1874          			} else {
   1875          				n = 0;					/* Not a blank entry. Restart to search */
   \                     ??dir_alloc_6: (+1)
   \   00000064   0x2500             MOVS     R5,#+0
   1876          			}
   1877          			res = dir_next(dj, 1);		/* Next entry with table stretch enabled */
   \                     ??dir_alloc_7: (+1)
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0x0030             MOVS     R0,R6
   \   0000006A   0x.... 0x....      BL       dir_next
   \   0000006E   0x0004             MOVS     R4,R0
   1878          		} while (res == FR_OK);
   \   00000070   0xB2E4             UXTB     R4,R4
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD0DC             BEQ      ??dir_alloc_3
   1879          	}
   1880          	return res;
   \                     ??dir_alloc_2: (+1)
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1881          }
   1882          #endif
   1883          
   1884          
   1885          
   1886          /*-----------------------------------------------------------------------*/
   1887          /* Directory handling - Load/Store start cluster number                  */
   1888          /*-----------------------------------------------------------------------*/
   1889          

   \                                 In section .text, align 2, keep-with-next
   1890          static
   1891          uint32_t ld_clust (
   1892          	FATFS *fs,	/* Pointer to the fs object */
   1893          	uint8_t *dir	/* Pointer to the directory entry */
   1894          )
   1895          {
   \                     ld_clust: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0002             MOVS     R2,R0
   1896          	uint32_t cl;
   1897          
   1898          	cl = LD_WORD(dir+DIR_FstClusLO);
   \   00000004   0x7EC8             LDRB     R0,[R1, #+27]
   \   00000006   0x0200             LSLS     R0,R0,#+8
   \   00000008   0x7E8B             LDRB     R3,[R1, #+26]
   \   0000000A   0x4318             ORRS     R0,R0,R3
   \   0000000C   0xB280             UXTH     R0,R0
   1899          	if (fs->fs_type == FS_FAT32)
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0x2A03             CMP      R2,#+3
   \   00000012   0xD106             BNE      ??ld_clust_0
   1900          		cl |= (uint32_t)LD_WORD(dir+DIR_FstClusHI) << 16;
   \   00000014   0x0002             MOVS     R2,R0
   \   00000016   0x7D48             LDRB     R0,[R1, #+21]
   \   00000018   0x0200             LSLS     R0,R0,#+8
   \   0000001A   0x7D09             LDRB     R1,[R1, #+20]
   \   0000001C   0x4308             ORRS     R0,R0,R1
   \   0000001E   0x0400             LSLS     R0,R0,#+16
   \   00000020   0x4310             ORRS     R0,R0,R2
   1901          
   1902          	return cl;
   \                     ??ld_clust_0: (+1)
   \   00000022   0xBD00             POP      {PC}             ;; return
   1903          }
   1904          
   1905          
   1906          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   1907          static
   1908          void st_clust (
   1909          	uint8_t *dir,	/* Pointer to the directory entry */
   1910          	uint32_t cl	/* Value to be set */
   1911          )
   1912          {
   1913          	ST_WORD(dir+DIR_FstClusLO, cl);
   \                     st_clust: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0x7682             STRB     R2,[R0, #+26]
   \   00000004   0x000A             MOVS     R2,R1
   \   00000006   0xB292             UXTH     R2,R2
   \   00000008   0x0A12             LSRS     R2,R2,#+8
   \   0000000A   0x76C2             STRB     R2,[R0, #+27]
   1914          	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   \   0000000C   0x000A             MOVS     R2,R1
   \   0000000E   0x0C12             LSRS     R2,R2,#+16
   \   00000010   0x7502             STRB     R2,[R0, #+20]
   \   00000012   0x0C09             LSRS     R1,R1,#+16
   \   00000014   0xB289             UXTH     R1,R1
   \   00000016   0x0A09             LSRS     R1,R1,#+8
   \   00000018   0x7541             STRB     R1,[R0, #+21]
   1915          }
   \   0000001A   0x4770             BX       LR               ;; return
   1916          #endif
   1917          
   1918          
   1919          
   1920          /*-----------------------------------------------------------------------*/
   1921          /* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
   1922          /*-----------------------------------------------------------------------*/
   1923          #if _USE_LFN
   1924          /* Offset of LFN chars in the directory entry */

   \                                 In section .rodata, align 4
   1925          static const uint8_t LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};
   \                     LfnOfs:
   \   00000000   0x01 0x03          DC8 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30, 0, 0, 0
   \              0x05 0x07    
   \              0x09 0x0E    
   \              0x10 0x12    
   \              0x14 0x16    
   \              0x18 0x1C    
   \              0x1E 0x00    
   \              0x00 0x00    
   1926          
   1927          /*FUNCTION*-------------------------------------------------------------------
   1928          *
   1929          * Function Name    : cmp_lfn
   1930          * Returned Value   : 1:Matched
   1931          *                    0:Not matched
   1932          * Comments         : LFN handling - Test an LFN segment
   1933          *   
   1934          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1935          static int cmp_lfn 
   1936            (
   1937              /* [IN] Pointer to the LFN to be compared */
   1938          	  uint16_t *lfnbuf,		
   1939          	  /* [IN] Pointer to the directory entry containing a part of LFN */
   1940          	  uint8_t *dir			
   1941            )
   1942          {
   \                     cmp_lfn: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   1943          	uint32_t i, s;
   1944          	uint16_t wc, uc;
   1945          
   1946          
   1947          	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
   \   00000004   0x9800             LDR      R0,[SP, #+0]
   \   00000006   0x7804             LDRB     R4,[R0, #+0]
   \   00000008   0x2040             MOVS     R0,#+64
   \   0000000A   0x4384             BICS     R4,R4,R0
   \   0000000C   0x1E64             SUBS     R4,R4,#+1
   \   0000000E   0x200D             MOVS     R0,#+13
   \   00000010   0x4344             MULS     R4,R0,R4
   1948          	s = 0; wc = 1;
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0x2601             MOVS     R6,#+1
   1949          	do {
   1950          		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
   \                     ??cmp_lfn_0: (+1)
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x....             LDR      R1,??DataTable6_2
   \   0000001A   0x5D49             LDRB     R1,[R1, R5]
   \   0000001C   0x1840             ADDS     R0,R0,R1
   \   0000001E   0x7840             LDRB     R0,[R0, #+1]
   \   00000020   0x0200             LSLS     R0,R0,#+8
   \   00000022   0x9900             LDR      R1,[SP, #+0]
   \   00000024   0x....             LDR      R2,??DataTable6_2
   \   00000026   0x5D52             LDRB     R2,[R2, R5]
   \   00000028   0x5C89             LDRB     R1,[R1, R2]
   \   0000002A   0x4308             ORRS     R0,R0,R1
   1951          		if (wc) {	/* Last char has not been processed */
   \   0000002C   0xB2B6             UXTH     R6,R6
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD011             BEQ      ??cmp_lfn_1
   1952          			wc = ff_wtoupper(uc);		/* Convert it to upper case */
   \   00000032   0xB280             UXTH     R0,R0
   \   00000034   0x.... 0x....      BL       ff_wtoupper
   \   00000038   0x0006             MOVS     R6,R0
   1953          			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
   \   0000003A   0x2CFF             CMP      R4,#+255
   \   0000003C   0xD209             BCS      ??cmp_lfn_2
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x4360             MULS     R0,R4,R0
   \   00000042   0x5A38             LDRH     R0,[R7, R0]
   \   00000044   0x.... 0x....      BL       ff_wtoupper
   \   00000048   0x1C64             ADDS     R4,R4,#+1
   \   0000004A   0xB2B6             UXTH     R6,R6
   \   0000004C   0xB280             UXTH     R0,R0
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xD007             BEQ      ??cmp_lfn_3
   1954          				return 0;				/* Not matched */
   \                     ??cmp_lfn_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE017             B        ??cmp_lfn_4
   1955          		} else {
   1956          			if (uc != 0xFFFF) return 0;	/* Check filler */
   \                     ??cmp_lfn_1: (+1)
   \   00000056   0xB280             UXTH     R0,R0
   \   00000058   0x....             LDR      R1,??DataTable6_3  ;; 0xffff
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xD001             BEQ      ??cmp_lfn_3
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE011             B        ??cmp_lfn_4
   1957          		}
   1958          	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
   \                     ??cmp_lfn_3: (+1)
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
   \   00000064   0x2D0D             CMP      R5,#+13
   \   00000066   0xD3D6             BCC      ??cmp_lfn_0
   1959          
   1960          	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
   \   00000068   0x9800             LDR      R0,[SP, #+0]
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x0640             LSLS     R0,R0,#+25
   \   0000006E   0xD509             BPL      ??cmp_lfn_5
   \   00000070   0xB2B6             UXTH     R6,R6
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD006             BEQ      ??cmp_lfn_5
   \   00000076   0x2002             MOVS     R0,#+2
   \   00000078   0x4344             MULS     R4,R0,R4
   \   0000007A   0x5B38             LDRH     R0,[R7, R4]
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD001             BEQ      ??cmp_lfn_5
   1961          		return 0;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0xE000             B        ??cmp_lfn_4
   1962          
   1963          	return 1;						/* The part of LFN matched */
   \                     ??cmp_lfn_5: (+1)
   \   00000084   0x2001             MOVS     R0,#+1
   \                     ??cmp_lfn_4: (+1)
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1964          }
   1965          
   1966          /*FUNCTION*-------------------------------------------------------------------
   1967          *
   1968          * Function Name    : pick_lfn
   1969          * Returned Value   : 1:Succeeded
   1970          *                    0:Buffer overflow)
   1971          * Comments         : LFN handling - Pick an LFN segment from directory entry
   1972          *   
   1973          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1974          static int pick_lfn 
   1975            (
   1976            	/* [OUT] Pointer to the Unicode-LFN buffer */
   1977          	  uint16_t *lfnbuf,
   1978          	  /* [IN] Pointer to the directory entry */
   1979          	  uint8_t *dir			
   1980            )
   1981          {
   \                     pick_lfn: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1982          	uint32_t i, s;
   1983          	uint16_t wc, uc;
   1984          
   1985          
   1986          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   \   00000002   0x780A             LDRB     R2,[R1, #+0]
   \   00000004   0x0692             LSLS     R2,R2,#+26       ;; ZeroExtS R2,R2,#+26,#+26
   \   00000006   0x0E92             LSRS     R2,R2,#+26
   \   00000008   0x1E52             SUBS     R2,R2,#+1
   \   0000000A   0x230D             MOVS     R3,#+13
   \   0000000C   0x435A             MULS     R2,R3,R2
   1987          
   1988          	s = 0; wc = 1;
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2401             MOVS     R4,#+1
   1989          	do {
   1990          		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
   \                     ??pick_lfn_0: (+1)
   \   00000012   0x....             LDR      R5,??DataTable6_2
   \   00000014   0x5CED             LDRB     R5,[R5, R3]
   \   00000016   0x194D             ADDS     R5,R1,R5
   \   00000018   0x786D             LDRB     R5,[R5, #+1]
   \   0000001A   0x022D             LSLS     R5,R5,#+8
   \   0000001C   0x....             LDR      R6,??DataTable6_2
   \   0000001E   0x5CF6             LDRB     R6,[R6, R3]
   \   00000020   0x5D8E             LDRB     R6,[R1, R6]
   \   00000022   0x4335             ORRS     R5,R5,R6
   1991          		if (wc) {	/* Last char has not been processed */
   \   00000024   0xB2A4             UXTH     R4,R4
   \   00000026   0x2C00             CMP      R4,#+0
   \   00000028   0xD012             BEQ      ??pick_lfn_1
   1992          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   \   0000002A   0x2AFF             CMP      R2,#+255
   \   0000002C   0xD301             BCC      ??pick_lfn_2
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE019             B        ??pick_lfn_3
   1993          			lfnbuf[i++] = wc = uc;			/* Store it */
   \                     ??pick_lfn_2: (+1)
   \   00000032   0x002C             MOVS     R4,R5
   \   00000034   0x2502             MOVS     R5,#+2
   \   00000036   0x4355             MULS     R5,R2,R5
   \   00000038   0x5344             STRH     R4,[R0, R5]
   \   0000003A   0x1C52             ADDS     R2,R2,#+1
   1994          		} else {
   1995          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1996          		}
   1997          	} while (++s < 13);						/* Read all character in the entry */
   \                     ??pick_lfn_4: (+1)
   \   0000003C   0x1C5B             ADDS     R3,R3,#+1
   \   0000003E   0x2B0D             CMP      R3,#+13
   \   00000040   0xD3E7             BCC      ??pick_lfn_0
   1998          
   1999          	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x0649             LSLS     R1,R1,#+25
   \   00000046   0xD50D             BPL      ??pick_lfn_5
   2000          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   \   00000048   0x2AFF             CMP      R2,#+255
   \   0000004A   0xD307             BCC      ??pick_lfn_6
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE00A             B        ??pick_lfn_3
   \                     ??pick_lfn_1: (+1)
   \   00000050   0xB2AD             UXTH     R5,R5
   \   00000052   0x....             LDR      R6,??DataTable6_3  ;; 0xffff
   \   00000054   0x42B5             CMP      R5,R6
   \   00000056   0xD0F1             BEQ      ??pick_lfn_4
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xE004             B        ??pick_lfn_3
   2001          		lfnbuf[i] = 0;
   \                     ??pick_lfn_6: (+1)
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x2302             MOVS     R3,#+2
   \   00000060   0x435A             MULS     R2,R3,R2
   \   00000062   0x5281             STRH     R1,[R0, R2]
   2002          	}
   2003          
   2004          	return 1;
   \                     ??pick_lfn_5: (+1)
   \   00000064   0x2001             MOVS     R0,#+1
   \                     ??pick_lfn_3: (+1)
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
   2005          }
   2006          
   2007          /*FUNCTION*-------------------------------------------------------------------
   2008          *
   2009          * Function Name    : fit_lfn
   2010          * Returned Value   : None
   2011          * Comments         : LFN handling - Fit an LFN segment to directory entry
   2012          *   
   2013          *END*----------------------------------------------------------------------*/
   2014          
   2015          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   2016          static void fit_lfn 
   2017            (
   2018                /* [IN] Pointer to the LFN buffer */
   2019          	  const uint16_t *lfnbuf,
   2020          	  /* [IN] Pointer to the directory entry */	
   2021          	  uint8_t *dir,
   2022          	  /* [IN] LFN order (1-20) */				
   2023            	  uint8_t ord,
   2024                /* [IN] SFN sum */				
   2025                uint8_t sum				
   2026            )
   2027          {
   \                     fit_lfn: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   2028          	uint32_t i, s;
   2029          	uint16_t wc;
   2030          
   2031          
   2032          	dir[LDIR_Chksum] = sum;			/* Set check sum */
   \   00000002   0x734B             STRB     R3,[R1, #+13]
   2033          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   \   00000004   0x230F             MOVS     R3,#+15
   \   00000006   0x72CB             STRB     R3,[R1, #+11]
   2034          	dir[LDIR_Type] = 0;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x730B             STRB     R3,[R1, #+12]
   2035          	ST_WORD(dir+LDIR_FstClusLO, 0);
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x768B             STRB     R3,[R1, #+26]
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x76CB             STRB     R3,[R1, #+27]
   2036          
   2037          	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
   \   00000014   0xB2D2             UXTB     R2,R2
   \   00000016   0x1E53             SUBS     R3,R2,#+1
   \   00000018   0x240D             MOVS     R4,#+13
   \   0000001A   0x4363             MULS     R3,R4,R3
   2038          	s = wc = 0;
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0xB2A4             UXTH     R4,R4
   \   00000020   0x0025             MOVS     R5,R4
   2039          	do {
   2040          		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
   \                     ??fit_lfn_0: (+1)
   \   00000022   0xB2A4             UXTH     R4,R4
   \   00000024   0x....             LDR      R6,??DataTable6_3  ;; 0xffff
   \   00000026   0x42B4             CMP      R4,R6
   \   00000028   0xD003             BEQ      ??fit_lfn_1
   \   0000002A   0x2402             MOVS     R4,#+2
   \   0000002C   0x435C             MULS     R4,R3,R4
   \   0000002E   0x5B04             LDRH     R4,[R0, R4]
   \   00000030   0x1C5B             ADDS     R3,R3,#+1
   2041          		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
   \                     ??fit_lfn_1: (+1)
   \   00000032   0x0026             MOVS     R6,R4
   \   00000034   0x....             LDR      R7,??DataTable6_2
   \   00000036   0x5D7F             LDRB     R7,[R7, R5]
   \   00000038   0x55CE             STRB     R6,[R1, R7]
   \   0000003A   0x0026             MOVS     R6,R4
   \   0000003C   0xB2B6             UXTH     R6,R6
   \   0000003E   0x0A36             LSRS     R6,R6,#+8
   \   00000040   0x....             LDR      R7,??DataTable6_2
   \   00000042   0x5D7F             LDRB     R7,[R7, R5]
   \   00000044   0x19CF             ADDS     R7,R1,R7
   \   00000046   0x707E             STRB     R6,[R7, #+1]
   2042          		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
   \   00000048   0xB2A4             UXTH     R4,R4
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD100             BNE      ??fit_lfn_2
   \   0000004E   0x....             LDR      R4,??DataTable6_3  ;; 0xffff
   2043          	} while (++s < 13);
   \                     ??fit_lfn_2: (+1)
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \   00000052   0x2D0D             CMP      R5,#+13
   \   00000054   0xD3E5             BCC      ??fit_lfn_0
   2044          	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
   \   00000056   0xB2A4             UXTH     R4,R4
   \   00000058   0x....             LDR      R5,??DataTable6_3  ;; 0xffff
   \   0000005A   0x42AC             CMP      R4,R5
   \   0000005C   0xD004             BEQ      ??fit_lfn_3
   \   0000005E   0x2402             MOVS     R4,#+2
   \   00000060   0x4363             MULS     R3,R4,R3
   \   00000062   0x5AC0             LDRH     R0,[R0, R3]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD102             BNE      ??fit_lfn_4
   \                     ??fit_lfn_3: (+1)
   \   00000068   0x0010             MOVS     R0,R2
   \   0000006A   0x2240             MOVS     R2,#+64
   \   0000006C   0x4302             ORRS     R2,R2,R0
   2045          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   \                     ??fit_lfn_4: (+1)
   \   0000006E   0x700A             STRB     R2,[R1, #+0]
   2046          }
   \   00000070   0xBDF0             POP      {R4-R7,PC}       ;; return
   2047          
   2048          #endif
   2049          #endif
   2050          
   2051          /*FUNCTION*-------------------------------------------------------------------
   2052          *
   2053          * Function Name    : gen_numname
   2054          * Returned Value   : None
   2055          * Comments         : Create numbered name
   2056          *   
   2057          *END*----------------------------------------------------------------------*/
   2058          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   2059          static void gen_numname 
   2060            (
   2061              /* [OUT] Pointer to generated SFN */
   2062            	uint8_t *dst,		
   2063            	/* [IN] Pointer to source SFN to be modified */	
   2064            	const uint8_t *src,
   2065            	/* [IN] Pointer to LFN */	
   2066            	const uint16_t *lfn,	
   2067            	/* [IN] Sequence number */
   2068            	uint16_t seq			
   2069            )
   2070          {
   \                     gen_numname: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001C             MOVS     R4,R3
   2071          	uint8_t ns[8], c;
   2072          	uint32_t i, j;
   2073          
   2074          
   2075          	mem_cpy(dst, src, 11);
   \   00000008   0x220B             MOVS     R2,#+11
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0x.... 0x....      BL       mem_cpy
   2076          
   2077          	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
   \   00000010   0xB2A4             UXTH     R4,R4
   \   00000012   0x2C06             CMP      R4,#+6
   \   00000014   0xDB0A             BLT      ??gen_numname_0
   2078          		do seq = (seq >> 1) + (seq << 15) + (uint16_t)*lfn++; while (*lfn);
   \                     ??gen_numname_1: (+1)
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB280             UXTH     R0,R0
   \   0000001A   0x0840             LSRS     R0,R0,#+1
   \   0000001C   0x03E1             LSLS     R1,R4,#+15
   \   0000001E   0x1840             ADDS     R0,R0,R1
   \   00000020   0x8829             LDRH     R1,[R5, #+0]
   \   00000022   0x1844             ADDS     R4,R0,R1
   \   00000024   0x1CAD             ADDS     R5,R5,#+2
   \   00000026   0x8828             LDRH     R0,[R5, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1F4             BNE      ??gen_numname_1
   2079          	}
   2080          
   2081          	/* itoa (hexdecimal) */
   2082          	i = 7;
   \                     ??gen_numname_0: (+1)
   \   0000002C   0x2507             MOVS     R5,#+7
   2083          	do {
   2084          		c = (seq % 16) + '0';
   \                     ??gen_numname_2: (+1)
   \   0000002E   0xB2A4             UXTH     R4,R4
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x2110             MOVS     R1,#+16
   \   00000034   0x.... 0x....      BL       __aeabi_idivmod
   \   00000038   0x3130             ADDS     R1,R1,#+48
   2085          		if (c > '9') c += 7;
   \   0000003A   0xB2C9             UXTB     R1,R1
   \   0000003C   0x293A             CMP      R1,#+58
   \   0000003E   0xDB00             BLT      ??gen_numname_3
   \   00000040   0x1DC9             ADDS     R1,R1,#+7
   2086          		ns[i--] = c;
   \                     ??gen_numname_3: (+1)
   \   00000042   0x4668             MOV      R0,SP
   \   00000044   0x5541             STRB     R1,[R0, R5]
   \   00000046   0x1E6D             SUBS     R5,R5,#+1
   2087          		seq /= 16;
   \   00000048   0xB2A4             UXTH     R4,R4
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x2110             MOVS     R1,#+16
   \   0000004E   0x.... 0x....      BL       __aeabi_idiv
   \   00000052   0x0004             MOVS     R4,R0
   2088          	} while (seq);
   \   00000054   0xB2A4             UXTH     R4,R4
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD1E9             BNE      ??gen_numname_2
   2089          	ns[i] = '~';
   \   0000005A   0x207E             MOVS     R0,#+126
   \   0000005C   0x4669             MOV      R1,SP
   \   0000005E   0x5548             STRB     R0,[R1, R5]
   2090          
   2091          	/* Append the number */
   2092          	for (j = 0; j < i && dst[j] != ' '; j++) {
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE000             B        ??gen_numname_4
   2093          		if (IsDBCS1(dst[j])) {
   \                     ??gen_numname_5: (+1)
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \                     ??gen_numname_4: (+1)
   \   00000066   0x42A8             CMP      R0,R5
   \   00000068   0xD202             BCS      ??gen_numname_6
   \   0000006A   0x5C31             LDRB     R1,[R6, R0]
   \   0000006C   0x2920             CMP      R1,#+32
   \   0000006E   0xD1F9             BNE      ??gen_numname_5
   2094          			if (j == i - 1) break;
   2095          			j++;
   2096          		}
   2097          	}
   2098          	do {
   2099          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   \                     ??gen_numname_6: (+1)
   \   00000070   0x0001             MOVS     R1,R0
   \   00000072   0x0008             MOVS     R0,R1
   \   00000074   0x1C40             ADDS     R0,R0,#+1
   \   00000076   0x2D08             CMP      R5,#+8
   \   00000078   0xD203             BCS      ??gen_numname_7
   \   0000007A   0x466A             MOV      R2,SP
   \   0000007C   0x5D52             LDRB     R2,[R2, R5]
   \   0000007E   0x1C6D             ADDS     R5,R5,#+1
   \   00000080   0xE000             B        ??gen_numname_8
   \                     ??gen_numname_7: (+1)
   \   00000082   0x2220             MOVS     R2,#+32
   \                     ??gen_numname_8: (+1)
   \   00000084   0x5472             STRB     R2,[R6, R1]
   2100          	} while (j < 8);
   \   00000086   0x2808             CMP      R0,#+8
   \   00000088   0xD3F2             BCC      ??gen_numname_6
   2101          }
   \   0000008A   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   2102          #endif
   2103          
   2104          /*FUNCTION*-------------------------------------------------------------------
   2105          *
   2106          * Function Name    : sum_sfn
   2107          * Returned Value   : Check sum value of short file name
   2108          * Comments         : Calculate sum of an SFN
   2109          *   
   2110          *END*----------------------------------------------------------------------*/
   2111          #if _USE_LFN

   \                                 In section .text, align 2, keep-with-next
   2112          static uint8_t sum_sfn 
   2113            (
   2114            	/* [IN] Ptr to directory entry */
   2115          	  const uint8_t *dir
   2116            )
   2117          {
   \                     sum_sfn: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
   2118          	uint8_t sum = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   2119          	uint32_t n = 11;
   \   00000006   0x220B             MOVS     R2,#+11
   2120          
   2121          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   \                     ??sum_sfn_0: (+1)
   \   00000008   0x0003             MOVS     R3,R0
   \   0000000A   0xB2DB             UXTB     R3,R3
   \   0000000C   0x085B             LSRS     R3,R3,#+1
   \   0000000E   0x01C0             LSLS     R0,R0,#+7
   \   00000010   0x1818             ADDS     R0,R3,R0
   \   00000012   0x780B             LDRB     R3,[R1, #+0]
   \   00000014   0x18C0             ADDS     R0,R0,R3
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x1E52             SUBS     R2,R2,#+1
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD1F4             BNE      ??sum_sfn_0
   2122          	return sum;
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0xBD00             POP      {PC}             ;; return
   2123          }
   2124          #endif
   2125          
   2126          
   2127          /*FUNCTION*-------------------------------------------------------------------
   2128          *
   2129          * Function Name    : dir_find
   2130          * Returned Value   : FR_OK: successful
   2131          *                    FR_INT_ERR: Internal error (invalid index range)
   2132          *                    FR_DISK_ERR: Disk error
   2133          *                    FR_NO_FILE: End of table
   2134          *                    FR_DENIED: No free cluster
   2135          * Comments         : Directory handling - Find an object in the directory  
   2136          *   
   2137          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   2138          static FRESULT dir_find 
   2139            (
   2140              /* [IN] Pointer to the directory object linked to the file name */
   2141          	  DIR *dj			
   2142            )
   2143          {
   \                     dir_find: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0007             MOVS     R7,R0
   2144          	FRESULT res;
   2145          	uint8_t c = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   2146            uint8_t	*dir;
   2147                  uint8_t a;
   2148          #if _USE_LFN
   2149          	uint8_t ord, sum;
   2150          #endif
   2151          
   2152          	res = dir_sdi(dj, 0);			/* Rewind directory object */
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x0038             MOVS     R0,R7
   \   0000000C   0x.... 0x....      BL       dir_sdi
   \   00000010   0x0006             MOVS     R6,R0
   2153          	if (res != FR_OK) return res;
   \   00000012   0xB2F6             UXTB     R6,R6
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD002             BEQ      ??dir_find_0
   \   00000018   0x0030             MOVS     R0,R6
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0xE051             B        ??dir_find_1
   2154          
   2155          #if _USE_LFN
   2156          	ord = sum = 0xFF;
   \                     ??dir_find_0: (+1)
   \   0000001E   0x20FF             MOVS     R0,#+255
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x7108             STRB     R0,[R1, #+4]
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x7904             LDRB     R4,[R0, #+4]
   2157          #endif
   2158          	do {
   2159          		res = move_window(dj->fs, dj->sect);
   \                     ??dir_find_2: (+1)
   \   00000028   0x6939             LDR      R1,[R7, #+16]
   \   0000002A   0x6838             LDR      R0,[R7, #+0]
   \   0000002C   0x.... 0x....      BL       move_window
   \   00000030   0x0006             MOVS     R6,R0
   2160          		if (res != FR_OK) break;
   \   00000032   0xB2F6             UXTB     R6,R6
   \   00000034   0x2E00             CMP      R6,#+0
   \   00000036   0xD131             BNE      ??dir_find_3
   2161          		dir = convert_ptr(dj->fs, dj->dir);					/* Ptr to the directory entry of current index */
   \                     ??dir_find_4: (+1)
   \   00000038   0x6979             LDR      R1,[R7, #+20]
   \   0000003A   0x6838             LDR      R0,[R7, #+0]
   \   0000003C   0x.... 0x....      BL       convert_ptr
   \   00000040   0x9000             STR      R0,[SP, #+0]
   2162                          c = dir[DIR_Name];
   \   00000042   0x9800             LDR      R0,[SP, #+0]
   \   00000044   0x7805             LDRB     R5,[R0, #+0]
   2163          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   2164                          if(entry_start_clust != dj->sclust && (c == DDE || c == 0))
   \   00000046   0x....             LDR      R0,??DataTable8
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x68B9             LDR      R1,[R7, #+8]
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xD00B             BEQ      ??dir_find_5
   \   00000050   0xB2ED             UXTB     R5,R5
   \   00000052   0x2DE5             CMP      R5,#+229
   \   00000054   0xD002             BEQ      ??dir_find_6
   \   00000056   0xB2ED             UXTB     R5,R5
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD105             BNE      ??dir_find_5
   2165                          {
   2166                              entry_start_clust = dj->sclust;
   \                     ??dir_find_6: (+1)
   \   0000005C   0x68B8             LDR      R0,[R7, #+8]
   \   0000005E   0x....             LDR      R1,??DataTable8
   \   00000060   0x6008             STR      R0,[R1, #+0]
   2167                              entry_start_free_index = dj->index;
   \   00000062   0x88F8             LDRH     R0,[R7, #+6]
   \   00000064   0x....             LDR      R1,??DataTable8_1
   \   00000066   0x8008             STRH     R0,[R1, #+0]
   2168                          }
   2169          #endif
   2170          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \                     ??dir_find_5: (+1)
   \   00000068   0xB2ED             UXTB     R5,R5
   \   0000006A   0x2D00             CMP      R5,#+0
   \   0000006C   0xD101             BNE      ??dir_find_7
   \   0000006E   0x2604             MOVS     R6,#+4
   \   00000070   0xE014             B        ??dir_find_3
   2171                          a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_find_7: (+1)
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000076   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   00000078   0x0E80             LSRS     R0,R0,#+26
   2172          #if _USE_LFN	/* LFN configuration */
   2173          		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   \   0000007A   0xB2ED             UXTB     R5,R5
   \   0000007C   0x2DE5             CMP      R5,#+229
   \   0000007E   0xD004             BEQ      ??dir_find_8
   \   00000080   0x0701             LSLS     R1,R0,#+28
   \   00000082   0xD51F             BPL      ??dir_find_9
   \   00000084   0xB2C0             UXTB     R0,R0
   \   00000086   0x280F             CMP      R0,#+15
   \   00000088   0xD01C             BEQ      ??dir_find_9
   2174          			ord = 0xFF;
   \                     ??dir_find_8: (+1)
   \   0000008A   0x24FF             MOVS     R4,#+255
   2175          		} else {
   2176          			if (a == AM_LFN) {			/* An LFN entry is found */
   2177          				if (dj->lfn) {
   2178          					if (c & LLE) {		/* Is it start of LFN sequence? */
   2179          						sum = dir[LDIR_Chksum];
   2180          						c &= ~LLE; ord = c;	/* LFN start order */
   2181          						dj->lfn_idx = dj->index;
   2182          					}
   2183          					/* Check validity of the LFN entry and compare it with given name */
   2184          					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   2185          				}
   2186          			} else {					/* An SFN entry is found */
   2187          				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
   2188          				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
   2189          				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) 
   2190                                            break;	/* SFN matched? */
   2191          			}
   2192          		}
   2193          #else		/* Non LFN configuration */
   2194          		if (!(dir[DIR_Attr] & AM_VOL) && a != AM_LFN && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
   2195          			break;
   2196          #endif
   2197          		res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_find_10: (+1)
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x0038             MOVS     R0,R7
   \   00000090   0x.... 0x....      BL       dir_next
   \   00000094   0x0006             MOVS     R6,R0
   2198          	} while (res == FR_OK);
   \   00000096   0xB2F6             UXTB     R6,R6
   \   00000098   0x2E00             CMP      R6,#+0
   \   0000009A   0xD0C5             BEQ      ??dir_find_2
   2199                  
   2200          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION//may reach to FR_NO_FILE
   2201                  if(entry_start_clust != dj->sclust && (c == DDE || c == 0))
   \                     ??dir_find_3: (+1)
   \   0000009C   0x....             LDR      R0,??DataTable8
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x68B9             LDR      R1,[R7, #+8]
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD00B             BEQ      ??dir_find_11
   \   000000A6   0xB2ED             UXTB     R5,R5
   \   000000A8   0x2DE5             CMP      R5,#+229
   \   000000AA   0xD002             BEQ      ??dir_find_12
   \   000000AC   0xB2ED             UXTB     R5,R5
   \   000000AE   0x2D00             CMP      R5,#+0
   \   000000B0   0xD105             BNE      ??dir_find_11
   2202                  {
   2203                      entry_start_clust = dj->sclust;
   \                     ??dir_find_12: (+1)
   \   000000B2   0x68B8             LDR      R0,[R7, #+8]
   \   000000B4   0x....             LDR      R1,??DataTable8
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   2204                      entry_start_free_index = dj->index;
   \   000000B8   0x88F8             LDRH     R0,[R7, #+6]
   \   000000BA   0x....             LDR      R1,??DataTable8_1
   \   000000BC   0x8008             STRH     R0,[R1, #+0]
   2205                  }
   2206          #endif
   2207          
   2208          	return res;
   \                     ??dir_find_11: (+1)
   \   000000BE   0x0030             MOVS     R0,R6
   \   000000C0   0xB2C0             UXTB     R0,R0
   \                     ??dir_find_1: (+1)
   \   000000C2   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??dir_find_9: (+1)
   \   000000C4   0xB2C0             UXTB     R0,R0
   \   000000C6   0x280F             CMP      R0,#+15
   \   000000C8   0xD122             BNE      ??dir_find_13
   \   000000CA   0x69F8             LDR      R0,[R7, #+28]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD0DD             BEQ      ??dir_find_10
   \   000000D0   0x0668             LSLS     R0,R5,#+25
   \   000000D2   0xD509             BPL      ??dir_find_14
   \   000000D4   0x4668             MOV      R0,SP
   \   000000D6   0x9900             LDR      R1,[SP, #+0]
   \   000000D8   0x7B49             LDRB     R1,[R1, #+13]
   \   000000DA   0x7101             STRB     R1,[R0, #+4]
   \   000000DC   0x0028             MOVS     R0,R5
   \   000000DE   0x25BF             MOVS     R5,#+191
   \   000000E0   0x4005             ANDS     R5,R5,R0
   \   000000E2   0x002C             MOVS     R4,R5
   \   000000E4   0x88F8             LDRH     R0,[R7, #+6]
   \   000000E6   0x8438             STRH     R0,[R7, #+32]
   \                     ??dir_find_14: (+1)
   \   000000E8   0xB2ED             UXTB     R5,R5
   \   000000EA   0xB2E4             UXTB     R4,R4
   \   000000EC   0x42A5             CMP      R5,R4
   \   000000EE   0xD10D             BNE      ??dir_find_15
   \   000000F0   0x4668             MOV      R0,SP
   \   000000F2   0x7900             LDRB     R0,[R0, #+4]
   \   000000F4   0x9900             LDR      R1,[SP, #+0]
   \   000000F6   0x7B49             LDRB     R1,[R1, #+13]
   \   000000F8   0x4288             CMP      R0,R1
   \   000000FA   0xD107             BNE      ??dir_find_15
   \   000000FC   0x9900             LDR      R1,[SP, #+0]
   \   000000FE   0x69F8             LDR      R0,[R7, #+28]
   \   00000100   0x.... 0x....      BL       cmp_lfn
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD001             BEQ      ??dir_find_15
   \   00000108   0x1E64             SUBS     R4,R4,#+1
   \   0000010A   0xE7BF             B        ??dir_find_10
   \                     ??dir_find_15: (+1)
   \   0000010C   0x24FF             MOVS     R4,#+255
   \   0000010E   0xE7BD             B        ??dir_find_10
   \                     ??dir_find_13: (+1)
   \   00000110   0xB2E4             UXTB     R4,R4
   \   00000112   0x2C00             CMP      R4,#+0
   \   00000114   0xD106             BNE      ??dir_find_16
   \   00000116   0x4668             MOV      R0,SP
   \   00000118   0x7904             LDRB     R4,[R0, #+4]
   \   0000011A   0x9800             LDR      R0,[SP, #+0]
   \   0000011C   0x.... 0x....      BL       sum_sfn
   \   00000120   0x4284             CMP      R4,R0
   \   00000122   0xD0BB             BEQ      ??dir_find_3
   \                     ??dir_find_16: (+1)
   \   00000124   0x24FF             MOVS     R4,#+255
   \   00000126   0x....             LDR      R0,??DataTable9  ;; 0xffff
   \   00000128   0x8438             STRH     R0,[R7, #+32]
   \   0000012A   0x69B8             LDR      R0,[R7, #+24]
   \   0000012C   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000012E   0x07C0             LSLS     R0,R0,#+31
   \   00000130   0xD4AC             BMI      ??dir_find_10
   \   00000132   0x220B             MOVS     R2,#+11
   \   00000134   0x69B9             LDR      R1,[R7, #+24]
   \   00000136   0x9800             LDR      R0,[SP, #+0]
   \   00000138   0x.... 0x....      BL       mem_cmp
   \   0000013C   0x2800             CMP      R0,#+0
   \   0000013E   0xD1A5             BNE      ??dir_find_10
   \   00000140   0xE7AC             B        ??dir_find_3
   2209          }
   2210          
   2211          
   2212          
   2213          
   2214          /*FUNCTION*-------------------------------------------------------------------
   2215          *
   2216          * Function Name    : dir_read
   2217          * Returned Value   : FR_OK: successful
   2218          *                    FR_INT_ERR: Internal error (invalid index range)
   2219          *                    FR_DISK_ERR: Disk error
   2220          *                    FR_NO_FILE: End of table
   2221          *                    FR_DENIED: No free cluster
   2222          * Comments         : Directory handling - Read an object from the directory  
   2223          *   
   2224          *END*----------------------------------------------------------------------*/
   2225          #if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
   2226          

   \                                 In section .text, align 2, keep-with-next
   2227          static FRESULT dir_read
   2228          (
   2229              /* [IN] Pointer to the directory object that pointing the entry to be read */
   2230          	DIR *dj,
   2231          	/* [IN] Filtered by 0:file/dir or 1:volume label */
   2232          	int vol
   2233          )
   2234          {
   \                     dir_read: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
   2235          	FRESULT res;
   2236          	uint8_t a, c, *dir;
   2237          #if _USE_LFN
   2238          	uint8_t ord = 0xFF, sum = 0xFF;
   \   00000006   0x24FF             MOVS     R4,#+255
   \   00000008   0x20FF             MOVS     R0,#+255
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   2239          #endif
   2240          
   2241          	res = FR_NO_FILE;
   \   0000000E   0x2504             MOVS     R5,#+4
   2242          	while (dj->sect) {
   \                     ??dir_read_0: (+1)
   \   00000010   0x6930             LDR      R0,[R6, #+16]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD02A             BEQ      ??dir_read_1
   2243          		res = move_window(dj->fs, dj->sect);
   \   00000016   0x6931             LDR      R1,[R6, #+16]
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       move_window
   \   0000001E   0x0005             MOVS     R5,R0
   2244          		if (res != FR_OK) break;
   \   00000020   0xB2ED             UXTB     R5,R5
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD122             BNE      ??dir_read_1
   2245          		dir = convert_ptr(dj->fs, dj->dir);					/* Ptr to the directory entry of current index */
   \                     ??dir_read_2: (+1)
   \   00000026   0x6971             LDR      R1,[R6, #+20]
   \   00000028   0x6830             LDR      R0,[R6, #+0]
   \   0000002A   0x.... 0x....      BL       convert_ptr
   2246          		c = dir[DIR_Name];
   \   0000002E   0x7801             LDRB     R1,[R0, #+0]
   2247          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   \   00000030   0xB2C9             UXTB     R1,R1
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD101             BNE      ??dir_read_3
   \   00000036   0x2504             MOVS     R5,#+4
   \   00000038   0xE018             B        ??dir_read_1
   2248          		a = dir[DIR_Attr] & AM_MASK;
   \                     ??dir_read_3: (+1)
   \   0000003A   0x7AC2             LDRB     R2,[R0, #+11]
   \   0000003C   0x0692             LSLS     R2,R2,#+26       ;; ZeroExtS R2,R2,#+26,#+26
   \   0000003E   0x0E92             LSRS     R2,R2,#+26
   2249          #if _USE_LFN	/* LFN configuration */
   2250          		if (c == DDE || (!_FS_RPATH && c == '.') || (a == AM_VOL) != vol) {	/* An entry without valid data */
   \   00000040   0xB2C9             UXTB     R1,R1
   \   00000042   0x29E5             CMP      R1,#+229
   \   00000044   0xD009             BEQ      ??dir_read_4
   \   00000046   0xB2D2             UXTB     R2,R2
   \   00000048   0x2A08             CMP      R2,#+8
   \   0000004A   0xD101             BNE      ??dir_read_5
   \   0000004C   0x2301             MOVS     R3,#+1
   \   0000004E   0xE000             B        ??dir_read_6
   \                     ??dir_read_5: (+1)
   \   00000050   0x2300             MOVS     R3,#+0
   \                     ??dir_read_6: (+1)
   \   00000052   0xB2DB             UXTB     R3,R3
   \   00000054   0x9F02             LDR      R7,[SP, #+8]
   \   00000056   0x42BB             CMP      R3,R7
   \   00000058   0xD010             BEQ      ??dir_read_7
   2251          			ord = 0xFF;
   \                     ??dir_read_4: (+1)
   \   0000005A   0x24FF             MOVS     R4,#+255
   2252          		} else {
   2253          			if (a == AM_LFN) {			/* An LFN entry is found */
   2254          				if (c & LLE) {			/* Is it start of LFN sequence? */
   2255          					sum = dir[LDIR_Chksum];
   2256          					c &= ~LLE; ord = c;
   2257          					dj->lfn_idx = dj->index;
   2258          				}
   2259          				/* Check LFN validity and capture it */
   2260          				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
   2261          			} else {					/* An SFN entry is found */
   2262          				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
   2263          					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
   2264          				break;
   2265          			}
   2266          		}
   2267          #else		/* Non LFN configuration */
   2268          		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (a == AM_VOL) == vol)	/* Is it a valid entry? */
   2269          			break;
   2270          #endif
   2271          		res = dir_next(dj, 0);				/* Next entry */
   \                     ??dir_read_8: (+1)
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x0030             MOVS     R0,R6
   \   00000060   0x.... 0x....      BL       dir_next
   \   00000064   0x0005             MOVS     R5,R0
   2272          		if (res != FR_OK) break;
   \   00000066   0xB2ED             UXTB     R5,R5
   \   00000068   0x2D00             CMP      R5,#+0
   \   0000006A   0xD0D1             BEQ      ??dir_read_0
   2273          	}
   2274          
   2275          	if (res != FR_OK) dj->sect = 0;
   \                     ??dir_read_1: (+1)
   \   0000006C   0xB2ED             UXTB     R5,R5
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD001             BEQ      ??dir_read_9
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6130             STR      R0,[R6, #+16]
   2276          
   2277          	return res;
   \                     ??dir_read_9: (+1)
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0xBDFE             POP      {R1-R7,PC}       ;; return
   \                     ??dir_read_7: (+1)
   \   0000007C   0xB2D2             UXTB     R2,R2
   \   0000007E   0x2A0F             CMP      R2,#+15
   \   00000080   0xD11D             BNE      ??dir_read_10
   \   00000082   0x064A             LSLS     R2,R1,#+25
   \   00000084   0xD508             BPL      ??dir_read_11
   \   00000086   0x466A             MOV      R2,SP
   \   00000088   0x7B43             LDRB     R3,[R0, #+13]
   \   0000008A   0x7013             STRB     R3,[R2, #+0]
   \   0000008C   0x000A             MOVS     R2,R1
   \   0000008E   0x21BF             MOVS     R1,#+191
   \   00000090   0x4011             ANDS     R1,R1,R2
   \   00000092   0x000C             MOVS     R4,R1
   \   00000094   0x88F2             LDRH     R2,[R6, #+6]
   \   00000096   0x8432             STRH     R2,[R6, #+32]
   \                     ??dir_read_11: (+1)
   \   00000098   0xB2C9             UXTB     R1,R1
   \   0000009A   0xB2E4             UXTB     R4,R4
   \   0000009C   0x42A1             CMP      R1,R4
   \   0000009E   0xD10C             BNE      ??dir_read_12
   \   000000A0   0x4669             MOV      R1,SP
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0x7B42             LDRB     R2,[R0, #+13]
   \   000000A6   0x4291             CMP      R1,R2
   \   000000A8   0xD107             BNE      ??dir_read_12
   \   000000AA   0x0001             MOVS     R1,R0
   \   000000AC   0x69F0             LDR      R0,[R6, #+28]
   \   000000AE   0x.... 0x....      BL       pick_lfn
   \   000000B2   0x2800             CMP      R0,#+0
   \   000000B4   0xD001             BEQ      ??dir_read_12
   \   000000B6   0x1E64             SUBS     R4,R4,#+1
   \   000000B8   0xE7D0             B        ??dir_read_8
   \                     ??dir_read_12: (+1)
   \   000000BA   0x24FF             MOVS     R4,#+255
   \   000000BC   0xE7CE             B        ??dir_read_8
   \                     ??dir_read_10: (+1)
   \   000000BE   0xB2E4             UXTB     R4,R4
   \   000000C0   0x2C00             CMP      R4,#+0
   \   000000C2   0xD105             BNE      ??dir_read_13
   \   000000C4   0x4669             MOV      R1,SP
   \   000000C6   0x780C             LDRB     R4,[R1, #+0]
   \   000000C8   0x.... 0x....      BL       sum_sfn
   \   000000CC   0x4284             CMP      R4,R0
   \   000000CE   0xD001             BEQ      ??dir_read_14
   \                     ??dir_read_13: (+1)
   \   000000D0   0x....             LDR      R0,??DataTable9  ;; 0xffff
   \   000000D2   0x8430             STRH     R0,[R6, #+32]
   \                     ??dir_read_14: (+1)
   \   000000D4   0xE7CA             B        ??dir_read_1
   2278          }
   2279          #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
   2280          
   2281          /*FUNCTION*-------------------------------------------------------------------
   2282          *
   2283          * Function Name    : dir_register
   2284          * Returned Value   : FR_OK: successful
   2285          *                    FR_INVALID_NAME: Cannot create dot entry
   2286          *                    FR_DENIED: No free entry or too many SFN collision
   2287          * Comments         : Directory handling - Register an object to the directory  
   2288          *   
   2289          *END*----------------------------------------------------------------------*/
   2290          #if !_FS_READONLY

   \                                 In section .text, align 2, keep-with-next
   2291          static FRESULT dir_register 
   2292            (
   2293              /* [IN] Target directory with object name to be created */
   2294            	DIR *dj				
   2295            )
   2296          {
   \                     dir_register: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0006             MOVS     R6,R0
   2297          	FRESULT res;
   2298          #if _USE_LFN	/* LFN configuration */
   2299          	uint16_t n, ne;
   2300          	uint8_t sn[12], *fn, sum;
   2301          	uint16_t *lfn;
   2302          
   2303          
   2304          	fn = dj->fn; lfn = dj->lfn;
   \   00000006   0x69B7             LDR      R7,[R6, #+24]
   \   00000008   0x69F0             LDR      R0,[R6, #+28]
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   2305          	mem_cpy(sn, fn, 12);
   \   0000000C   0x220C             MOVS     R2,#+12
   \   0000000E   0x0039             MOVS     R1,R7
   \   00000010   0xA801             ADD      R0,SP,#+4
   \   00000012   0x.... 0x....      BL       mem_cpy
   2306          
   2307          	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
   \   00000016   0xA801             ADD      R0,SP,#+4
   \   00000018   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000001A   0x0680             LSLS     R0,R0,#+26
   \   0000001C   0xD501             BPL      ??dir_register_0
   2308          		return FR_INVALID_NAME;
   \   0000001E   0x2006             MOVS     R0,#+6
   \   00000020   0xE0A9             B        ??dir_register_1
   2309          
   2310          	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   \                     ??dir_register_0: (+1)
   \   00000022   0xA801             ADD      R0,SP,#+4
   \   00000024   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000026   0x07C0             LSLS     R0,R0,#+31
   \   00000028   0xD527             BPL      ??dir_register_2
   2311          		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x72F8             STRB     R0,[R7, #+11]
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x61F0             STR      R0,[R6, #+28]
   2312          		for (n = 1; n < 100; n++) {
   \   00000032   0x2501             MOVS     R5,#+1
   \   00000034   0xE000             B        ??dir_register_3
   \                     ??dir_register_4: (+1)
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dir_register_3: (+1)
   \   00000038   0xB2AD             UXTH     R5,R5
   \   0000003A   0x2D64             CMP      R5,#+100
   \   0000003C   0xDA0D             BGE      ??dir_register_5
   2313          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   \   0000003E   0x002B             MOVS     R3,R5
   \   00000040   0xB29B             UXTH     R3,R3
   \   00000042   0x9A00             LDR      R2,[SP, #+0]
   \   00000044   0xA901             ADD      R1,SP,#+4
   \   00000046   0x0038             MOVS     R0,R7
   \   00000048   0x.... 0x....      BL       gen_numname
   2314          			res = dir_find(dj);				/* Check if the name collides with existing SFN */
   \   0000004C   0x0030             MOVS     R0,R6
   \   0000004E   0x.... 0x....      BL       dir_find
   \   00000052   0x0004             MOVS     R4,R0
   2315          			if (res != FR_OK) break;
   \   00000054   0xB2E4             UXTB     R4,R4
   \   00000056   0x2C00             CMP      R4,#+0
   \   00000058   0xD0ED             BEQ      ??dir_register_4
   2316          		}
   2317          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   \                     ??dir_register_5: (+1)
   \   0000005A   0xB2AD             UXTH     R5,R5
   \   0000005C   0x2D64             CMP      R5,#+100
   \   0000005E   0xD101             BNE      ??dir_register_6
   \   00000060   0x2007             MOVS     R0,#+7
   \   00000062   0xE088             B        ??dir_register_1
   2318          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   \                     ??dir_register_6: (+1)
   \   00000064   0xB2E4             UXTB     R4,R4
   \   00000066   0x2C04             CMP      R4,#+4
   \   00000068   0xD002             BEQ      ??dir_register_7
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0xE082             B        ??dir_register_1
   2319          		fn[NS] = sn[NS]; dj->lfn = lfn;
   \                     ??dir_register_7: (+1)
   \   00000070   0xA801             ADD      R0,SP,#+4
   \   00000072   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000074   0x72F8             STRB     R0,[R7, #+11]
   \   00000076   0x9800             LDR      R0,[SP, #+0]
   \   00000078   0x61F0             STR      R0,[R6, #+28]
   2320          	}
   2321          
   2322          	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
   \                     ??dir_register_2: (+1)
   \   0000007A   0xA801             ADD      R0,SP,#+4
   \   0000007C   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000007E   0x0780             LSLS     R0,R0,#+30
   \   00000080   0xD511             BPL      ??dir_register_8
   2323          		for (n = 0; lfn[n]; n++) ;
   \   00000082   0x2500             MOVS     R5,#+0
   \   00000084   0xE000             B        ??dir_register_9
   \                     ??dir_register_10: (+1)
   \   00000086   0x1C6D             ADDS     R5,R5,#+1
   \                     ??dir_register_9: (+1)
   \   00000088   0x9800             LDR      R0,[SP, #+0]
   \   0000008A   0xB2AD             UXTH     R5,R5
   \   0000008C   0x2102             MOVS     R1,#+2
   \   0000008E   0x4369             MULS     R1,R5,R1
   \   00000090   0x5A40             LDRH     R0,[R0, R1]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD1F7             BNE      ??dir_register_10
   2324          		ne = (n + 25) / 13;
   \   00000096   0xB2AD             UXTH     R5,R5
   \   00000098   0x3519             ADDS     R5,R5,#+25
   \   0000009A   0x0028             MOVS     R0,R5
   \   0000009C   0x210D             MOVS     R1,#+13
   \   0000009E   0x.... 0x....      BL       __aeabi_idiv
   \   000000A2   0x0005             MOVS     R5,R0
   \   000000A4   0xE000             B        ??dir_register_11
   2325          	} else {						/* Otherwise allocate an entry for an SFN  */
   2326          		ne = 1;
   \                     ??dir_register_8: (+1)
   \   000000A6   0x2501             MOVS     R5,#+1
   2327          	}
   2328          	res = dir_alloc(dj, ne);		/* Allocate entries */
   \                     ??dir_register_11: (+1)
   \   000000A8   0xB2AD             UXTH     R5,R5
   \   000000AA   0x0029             MOVS     R1,R5
   \   000000AC   0x0030             MOVS     R0,R6
   \   000000AE   0x.... 0x....      BL       dir_alloc
   \   000000B2   0x0004             MOVS     R4,R0
   2329          
   2330          	if (res == FR_OK && --ne) {		/* Set LFN entry if needed */
   \   000000B4   0xB2E4             UXTB     R4,R4
   \   000000B6   0x2C00             CMP      R4,#+0
   \   000000B8   0xD134             BNE      ??dir_register_12
   \   000000BA   0x1E6D             SUBS     R5,R5,#+1
   \   000000BC   0xB2AD             UXTH     R5,R5
   \   000000BE   0x2D00             CMP      R5,#+0
   \   000000C0   0xD030             BEQ      ??dir_register_12
   2331          		res = dir_sdi(dj, (uint16_t)(dj->index - ne));
   \   000000C2   0x88F0             LDRH     R0,[R6, #+6]
   \   000000C4   0x1B41             SUBS     R1,R0,R5
   \   000000C6   0xB289             UXTH     R1,R1
   \   000000C8   0x0030             MOVS     R0,R6
   \   000000CA   0x.... 0x....      BL       dir_sdi
   \   000000CE   0x0004             MOVS     R4,R0
   2332          		if (res == FR_OK) {
   \   000000D0   0xB2E4             UXTB     R4,R4
   \   000000D2   0x2C00             CMP      R4,#+0
   \   000000D4   0xD126             BNE      ??dir_register_12
   2333          			sum = sum_sfn(dj->fn);	/* Sum value of the SFN tied to the LFN */
   \   000000D6   0x69B0             LDR      R0,[R6, #+24]
   \   000000D8   0x.... 0x....      BL       sum_sfn
   \   000000DC   0x0007             MOVS     R7,R0
   2334          			do {					/* Store LFN entries in bottom first */
   2335          				res = move_window(dj->fs, dj->sect);
   \                     ??dir_register_13: (+1)
   \   000000DE   0x6931             LDR      R1,[R6, #+16]
   \   000000E0   0x6830             LDR      R0,[R6, #+0]
   \   000000E2   0x.... 0x....      BL       move_window
   \   000000E6   0x0004             MOVS     R4,R0
   2336          				if (res != FR_OK) break;
   \   000000E8   0xB2E4             UXTB     R4,R4
   \   000000EA   0x2C00             CMP      R4,#+0
   \   000000EC   0xD11A             BNE      ??dir_register_12
   2337          				fit_lfn(dj->lfn, convert_ptr(dj->fs, dj->dir), (uint8_t)ne, sum);
   \                     ??dir_register_14: (+1)
   \   000000EE   0x6971             LDR      R1,[R6, #+20]
   \   000000F0   0x6830             LDR      R0,[R6, #+0]
   \   000000F2   0x.... 0x....      BL       convert_ptr
   \   000000F6   0x003B             MOVS     R3,R7
   \   000000F8   0xB2DB             UXTB     R3,R3
   \   000000FA   0x002A             MOVS     R2,R5
   \   000000FC   0xB2D2             UXTB     R2,R2
   \   000000FE   0x0001             MOVS     R1,R0
   \   00000100   0x69F0             LDR      R0,[R6, #+28]
   \   00000102   0x.... 0x....      BL       fit_lfn
   2338                                          set_dirty(dj->fs);
   \   00000106   0x6830             LDR      R0,[R6, #+0]
   \   00000108   0x.... 0x....      BL       set_dirty
   2339          				res = dir_next(dj, 0);	/* Next entry */
   \   0000010C   0x2100             MOVS     R1,#+0
   \   0000010E   0x0030             MOVS     R0,R6
   \   00000110   0x.... 0x....      BL       dir_next
   \   00000114   0x0004             MOVS     R4,R0
   2340          			} while (res == FR_OK && --ne);
   \   00000116   0xB2E4             UXTB     R4,R4
   \   00000118   0x2C00             CMP      R4,#+0
   \   0000011A   0xD103             BNE      ??dir_register_12
   \   0000011C   0x1E6D             SUBS     R5,R5,#+1
   \   0000011E   0xB2AD             UXTH     R5,R5
   \   00000120   0x2D00             CMP      R5,#+0
   \   00000122   0xD1DC             BNE      ??dir_register_13
   2341          		}
   2342          	}
   2343          #else	/* Non LFN configuration */
   2344          	res = dir_alloc(dj, 1);		/* Allocate an entry for SFN */
   2345          #endif
   2346          
   2347          	if (res == FR_OK) {				/* Set SFN entry */
   \                     ??dir_register_12: (+1)
   \   00000124   0xB2E4             UXTB     R4,R4
   \   00000126   0x2C00             CMP      R4,#+0
   \   00000128   0xD123             BNE      ??dir_register_15
   2348          		res = move_window(dj->fs, dj->sect);
   \   0000012A   0x6931             LDR      R1,[R6, #+16]
   \   0000012C   0x6830             LDR      R0,[R6, #+0]
   \   0000012E   0x.... 0x....      BL       move_window
   \   00000132   0x0004             MOVS     R4,R0
   2349          		if (res == FR_OK) {
   \   00000134   0xB2E4             UXTB     R4,R4
   \   00000136   0x2C00             CMP      R4,#+0
   \   00000138   0xD11B             BNE      ??dir_register_15
   2350          			mem_set(convert_ptr(dj->fs, dj->dir), 0, SZ_DIR);	/* Clean the entry */
   \   0000013A   0x6971             LDR      R1,[R6, #+20]
   \   0000013C   0x6830             LDR      R0,[R6, #+0]
   \   0000013E   0x.... 0x....      BL       convert_ptr
   \   00000142   0x2220             MOVS     R2,#+32
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x.... 0x....      BL       mem_set
   2351          			mem_cpy(convert_ptr(dj->fs, dj->dir), dj->fn, 11);	/* Put SFN */
   \   0000014A   0x6971             LDR      R1,[R6, #+20]
   \   0000014C   0x6830             LDR      R0,[R6, #+0]
   \   0000014E   0x.... 0x....      BL       convert_ptr
   \   00000152   0x220B             MOVS     R2,#+11
   \   00000154   0x69B1             LDR      R1,[R6, #+24]
   \   00000156   0x.... 0x....      BL       mem_cpy
   2352          #if _USE_LFN
   2353          			convert_ptr(dj->fs, dj->dir)[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
   \   0000015A   0x6971             LDR      R1,[R6, #+20]
   \   0000015C   0x6830             LDR      R0,[R6, #+0]
   \   0000015E   0x.... 0x....      BL       convert_ptr
   \   00000162   0x69B1             LDR      R1,[R6, #+24]
   \   00000164   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000166   0x2218             MOVS     R2,#+24
   \   00000168   0x400A             ANDS     R2,R2,R1
   \   0000016A   0x7302             STRB     R2,[R0, #+12]
   2354          #endif
   2355                                  set_dirty(dj->fs);
   \   0000016C   0x6830             LDR      R0,[R6, #+0]
   \   0000016E   0x.... 0x....      BL       set_dirty
   2356          		}
   2357          	}
   2358          
   2359          	return res;
   \                     ??dir_register_15: (+1)
   \   00000172   0x0020             MOVS     R0,R4
   \   00000174   0xB2C0             UXTB     R0,R0
   \                     ??dir_register_1: (+1)
   \   00000176   0xB005             ADD      SP,SP,#+20
   \   00000178   0xBDF0             POP      {R4-R7,PC}       ;; return
   2360          }
   2361          #endif /* !_FS_READONLY */
   2362          
   2363          
   2364          /*FUNCTION*-------------------------------------------------------------------
   2365          *
   2366          * Function Name    : dir_remove
   2367          * Returned Value   : FR_OK: successful
   2368          *                    FR_DISK_ERR: Disk error
   2369          * Comments         : Directory handling - Remove an object from the directory  
   2370          *   
   2371          *END*----------------------------------------------------------------------*/
   2372          
   2373          #if !_FS_READONLY && !_FS_MINIMIZE

   \                                 In section .text, align 2, keep-with-next
   2374          static FRESULT dir_remove 
   2375            (
   2376              /* [IN] Directory object pointing the entry to be removed */
   2377            	DIR *dj				
   2378            )
   2379          {
   \                     dir_remove: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2380          	FRESULT res;
   2381          #if _USE_LFN	/* LFN configuration */
   2382          	uint16_t i;
   2383          
   2384          	i = dj->index;	/* SFN index */
   \   00000004   0x88E6             LDRH     R6,[R4, #+6]
   2385          	res = dir_sdi(dj, (uint16_t)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
   \   00000006   0x8C20             LDRH     R0,[R4, #+32]
   \   00000008   0x....             LDR      R1,??DataTable9  ;; 0xffff
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD101             BNE      ??dir_remove_0
   \   0000000E   0x0031             MOVS     R1,R6
   \   00000010   0xE000             B        ??dir_remove_1
   \                     ??dir_remove_0: (+1)
   \   00000012   0x8C21             LDRH     R1,[R4, #+32]
   \                     ??dir_remove_1: (+1)
   \   00000014   0xB289             UXTH     R1,R1
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       dir_sdi
   \   0000001C   0x0005             MOVS     R5,R0
   2386          	if (res == FR_OK) {
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD120             BNE      ??dir_remove_2
   2387          		do {
   2388          			res = move_window(dj->fs, dj->sect);
   \                     ??dir_remove_3: (+1)
   \   00000024   0x6921             LDR      R1,[R4, #+16]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       move_window
   \   0000002C   0x0005             MOVS     R5,R0
   2389          			if (res != FR_OK) break;
   \   0000002E   0xB2ED             UXTB     R5,R5
   \   00000030   0x2D00             CMP      R5,#+0
   \   00000032   0xD114             BNE      ??dir_remove_4
   2390          			*convert_ptr(dj->fs, dj->dir) = DDE;			/* Mark the entry "deleted" */
   \                     ??dir_remove_5: (+1)
   \   00000034   0x6961             LDR      R1,[R4, #+20]
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x.... 0x....      BL       convert_ptr
   \   0000003C   0x21E5             MOVS     R1,#+229
   \   0000003E   0x7001             STRB     R1,[R0, #+0]
   2391          			set_dirty(dj->fs);
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x.... 0x....      BL       set_dirty
   2392          			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
   \   00000046   0x88E0             LDRH     R0,[R4, #+6]
   \   00000048   0xB2B6             UXTH     R6,R6
   \   0000004A   0x42B0             CMP      R0,R6
   \   0000004C   0xD207             BCS      ??dir_remove_4
   2393          			res = dir_next(dj, 0);		/* Next entry */
   \                     ??dir_remove_6: (+1)
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       dir_next
   \   00000056   0x0005             MOVS     R5,R0
   2394          		} while (res == FR_OK);
   \   00000058   0xB2ED             UXTB     R5,R5
   \   0000005A   0x2D00             CMP      R5,#+0
   \   0000005C   0xD0E2             BEQ      ??dir_remove_3
   2395          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   \                     ??dir_remove_4: (+1)
   \   0000005E   0xB2ED             UXTB     R5,R5
   \   00000060   0x2D04             CMP      R5,#+4
   \   00000062   0xD100             BNE      ??dir_remove_2
   \   00000064   0x2502             MOVS     R5,#+2
   2396          	}
   2397          
   2398          #else			/* Non LFN configuration */
   2399          	res = dir_sdi(dj, dj->index);
   2400          	if (res == FR_OK) {
   2401          		res = move_window(dj->fs, dj->sect);
   2402          		if (res == FR_OK) {
   2403          			*convert_ptr(dj->fs, dj->dir) = DDE;			/* Mark the entry "deleted" */
   2404          			set_dirty(dj->fs);
   2405          		}
   2406          	}
   2407          #endif
   2408          
   2409          	return res;
   \                     ??dir_remove_2: (+1)
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0xB2C0             UXTB     R0,R0
   \   0000006A   0xBD70             POP      {R4-R6,PC}       ;; return
   2410          }
   2411          #endif /* !_FS_READONLY */
   2412          
   2413          
   2414          /*FUNCTION*-------------------------------------------------------------------
   2415          *
   2416          * Function Name    : create_name
   2417          * Returned Value   : FR_OK: successful
   2418          *                    FR_INVALID_NAME: invalid file name
   2419          * Comments         : Pick a segment and create the object name in directory form   
   2420          *   
   2421          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   2422          static FRESULT create_name 
   2423            (
   2424              /* [IN] Pointer to the directory object */
   2425            	DIR *dj,
   2426            	/* [IN] Pointer to pointer to the segment in the path string */			
   2427            	const TCHAR **path	
   2428            )
   2429          {
   \                     create_name: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2430          #if _USE_LFN	/* LFN configuration */
   2431          	uint8_t b, cf;
   2432          	uint16_t w, *lfn;
   2433          	uint32_t i, ni, si, di;
   2434          	const TCHAR *p;
   2435          
   2436          	/* Create LFN in Unicode */
   2437          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   \   00000004   0x9804             LDR      R0,[SP, #+16]
   \   00000006   0x6807             LDR      R7,[R0, #+0]
   \   00000008   0xE000             B        ??create_name_0
   \                     ??create_name_1: (+1)
   \   0000000A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??create_name_0: (+1)
   \   0000000C   0x7838             LDRB     R0,[R7, #+0]
   \   0000000E   0x282F             CMP      R0,#+47
   \   00000010   0xD0FB             BEQ      ??create_name_1
   \   00000012   0x7838             LDRB     R0,[R7, #+0]
   \   00000014   0x285C             CMP      R0,#+92
   \   00000016   0xD0F8             BEQ      ??create_name_1
   2438          	lfn = dj->lfn;
   \   00000018   0x9803             LDR      R0,[SP, #+12]
   \   0000001A   0x69C0             LDR      R0,[R0, #+28]
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   2439          	si = di = 0;
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0x0035             MOVS     R5,R6
   \   00000022   0xE004             B        ??create_name_2
   2440          	for (;;) {
   2441          		w = p[si++];					/* Get a character */
   2442          		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
   2443          		if (di >= _MAX_LFN)				/* Reject too long name */
   2444          			return FR_INVALID_NAME;
   2445          #if !_LFN_UNICODE//unicode
   2446          		w &= 0xFF;
   2447          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   2448          			b = (uint8_t)p[si++];			/* Get 2nd byte */
   2449          			if (!IsDBCS2(b))
   2450          				return FR_INVALID_NAME;	/* Reject invalid sequence */
   2451          			w = (w << 8) + b;			/* Create a DBC */
   2452          		}
   2453          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   2454          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   2455          #endif
   2456          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
   2457          			return FR_INVALID_NAME;
   2458          		lfn[di++] = w;					/* Store the Unicode char */
   \                     ??create_name_3: (+1)
   \   00000024   0x9801             LDR      R0,[SP, #+4]
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0x4371             MULS     R1,R6,R1
   \   0000002A   0x5244             STRH     R4,[R0, R1]
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \                     ??create_name_2: (+1)
   \   0000002E   0x5D7C             LDRB     R4,[R7, R5]
   \   00000030   0x1C6D             ADDS     R5,R5,#+1
   \   00000032   0xB2A4             UXTH     R4,R4
   \   00000034   0x2C20             CMP      R4,#+32
   \   00000036   0xDB05             BLT      ??create_name_4
   \   00000038   0xB2A4             UXTH     R4,R4
   \   0000003A   0x2C2F             CMP      R4,#+47
   \   0000003C   0xD002             BEQ      ??create_name_4
   \   0000003E   0xB2A4             UXTH     R4,R4
   \   00000040   0x2C5C             CMP      R4,#+92
   \   00000042   0xD109             BNE      ??create_name_5
   2459          	}
   2460          	*path = &p[si];						/* Return pointer to the next segment */
   \                     ??create_name_4: (+1)
   \   00000044   0x1978             ADDS     R0,R7,R5
   \   00000046   0x9904             LDR      R1,[SP, #+16]
   \   00000048   0x6008             STR      R0,[R1, #+0]
   2461          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   \   0000004A   0xB2A4             UXTH     R4,R4
   \   0000004C   0x2C20             CMP      R4,#+32
   \   0000004E   0xDA1F             BGE      ??create_name_6
   \   00000050   0x2004             MOVS     R0,#+4
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x7008             STRB     R0,[R1, #+0]
   \   00000056   0xE01E             B        ??create_name_7
   \                     ??create_name_5: (+1)
   \   00000058   0x2EFF             CMP      R6,#+255
   \   0000005A   0xD301             BCC      ??create_name_8
   \   0000005C   0x2006             MOVS     R0,#+6
   \   0000005E   0xE0EC             B        ??create_name_9
   \                     ??create_name_8: (+1)
   \   00000060   0xB2E4             UXTB     R4,R4
   \   00000062   0x2101             MOVS     R1,#+1
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0xB280             UXTH     R0,R0
   \   00000068   0x.... 0x....      BL       ff_convert
   \   0000006C   0x0004             MOVS     R4,R0
   \   0000006E   0xB2A4             UXTH     R4,R4
   \   00000070   0x2C00             CMP      R4,#+0
   \   00000072   0xD101             BNE      ??create_name_10
   \   00000074   0x2006             MOVS     R0,#+6
   \   00000076   0xE0E0             B        ??create_name_9
   \                     ??create_name_10: (+1)
   \   00000078   0xB2A4             UXTH     R4,R4
   \   0000007A   0x2C80             CMP      R4,#+128
   \   0000007C   0xDAD2             BGE      ??create_name_3
   \   0000007E   0xB2A4             UXTH     R4,R4
   \   00000080   0x0021             MOVS     R1,R4
   \   00000082   0x....             LDR      R0,??DataTable10
   \   00000084   0x.... 0x....      BL       chk_chr
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD0CB             BEQ      ??create_name_3
   \   0000008C   0x2006             MOVS     R0,#+6
   \   0000008E   0xE0D4             B        ??create_name_9
   \                     ??create_name_6: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x4669             MOV      R1,SP
   \   00000094   0x7008             STRB     R0,[R1, #+0]
   2462          #if _FS_RPATH
   2463          	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
   2464          		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
   \                     ??create_name_7: (+1)
   \   00000096   0x2E01             CMP      R6,#+1
   \   00000098   0xD107             BNE      ??create_name_11
   \   0000009A   0x9801             LDR      R0,[SP, #+4]
   \   0000009C   0x2102             MOVS     R1,#+2
   \   0000009E   0x4371             MULS     R1,R6,R1
   \   000000A0   0x1840             ADDS     R0,R0,R1
   \   000000A2   0x1E80             SUBS     R0,R0,#+2
   \   000000A4   0x8800             LDRH     R0,[R0, #+0]
   \   000000A6   0x282E             CMP      R0,#+46
   \   000000A8   0xD011             BEQ      ??create_name_12
   \                     ??create_name_11: (+1)
   \   000000AA   0x2E02             CMP      R6,#+2
   \   000000AC   0xD12B             BNE      ??create_name_13
   \   000000AE   0x9801             LDR      R0,[SP, #+4]
   \   000000B0   0x2102             MOVS     R1,#+2
   \   000000B2   0x4371             MULS     R1,R6,R1
   \   000000B4   0x1840             ADDS     R0,R0,R1
   \   000000B6   0x1E80             SUBS     R0,R0,#+2
   \   000000B8   0x8800             LDRH     R0,[R0, #+0]
   \   000000BA   0x282E             CMP      R0,#+46
   \   000000BC   0xD123             BNE      ??create_name_13
   \   000000BE   0x9801             LDR      R0,[SP, #+4]
   \   000000C0   0x2102             MOVS     R1,#+2
   \   000000C2   0x4371             MULS     R1,R6,R1
   \   000000C4   0x1840             ADDS     R0,R0,R1
   \   000000C6   0x1F00             SUBS     R0,R0,#+4
   \   000000C8   0x8800             LDRH     R0,[R0, #+0]
   \   000000CA   0x282E             CMP      R0,#+46
   \   000000CC   0xD11B             BNE      ??create_name_13
   2465          		lfn[di] = 0;
   \                     ??create_name_12: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x9901             LDR      R1,[SP, #+4]
   \   000000D2   0x2202             MOVS     R2,#+2
   \   000000D4   0x4372             MULS     R2,R6,R2
   \   000000D6   0x5288             STRH     R0,[R1, R2]
   2466          		for (i = 0; i < 11; i++)
   \   000000D8   0x2700             MOVS     R7,#+0
   \   000000DA   0xE004             B        ??create_name_14
   2467          			dj->fn[i] = (i < di) ? '.' : ' ';
   \                     ??create_name_15: (+1)
   \   000000DC   0x2020             MOVS     R0,#+32
   \                     ??create_name_16: (+1)
   \   000000DE   0x9903             LDR      R1,[SP, #+12]
   \   000000E0   0x6989             LDR      R1,[R1, #+24]
   \   000000E2   0x55C8             STRB     R0,[R1, R7]
   \   000000E4   0x1C7F             ADDS     R7,R7,#+1
   \                     ??create_name_14: (+1)
   \   000000E6   0x2F0B             CMP      R7,#+11
   \   000000E8   0xD203             BCS      ??create_name_17
   \   000000EA   0x42B7             CMP      R7,R6
   \   000000EC   0xD2F6             BCS      ??create_name_15
   \   000000EE   0x202E             MOVS     R0,#+46
   \   000000F0   0xE7F5             B        ??create_name_16
   2468          		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   \                     ??create_name_17: (+1)
   \   000000F2   0x4668             MOV      R0,SP
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x2120             MOVS     R1,#+32
   \   000000F8   0x4301             ORRS     R1,R1,R0
   \   000000FA   0x9803             LDR      R0,[SP, #+12]
   \   000000FC   0x6980             LDR      R0,[R0, #+24]
   \   000000FE   0x55C1             STRB     R1,[R0, R7]
   2469          		return FR_OK;//...
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0xE09A             B        ??create_name_9
   2470          	}
   2471          #endif
   2472          	while (di) {						/* Strip trailing spaces and dots */
   2473          		w = lfn[di-1];
   2474          		if (w != ' ' && w != '.') break;
   2475          		di--;
   \                     ??create_name_18: (+1)
   \   00000104   0x1E76             SUBS     R6,R6,#+1
   \                     ??create_name_13: (+1)
   \   00000106   0x2E00             CMP      R6,#+0
   \   00000108   0xD00B             BEQ      ??create_name_19
   \   0000010A   0x9801             LDR      R0,[SP, #+4]
   \   0000010C   0x2102             MOVS     R1,#+2
   \   0000010E   0x4371             MULS     R1,R6,R1
   \   00000110   0x1840             ADDS     R0,R0,R1
   \   00000112   0x1E80             SUBS     R0,R0,#+2
   \   00000114   0x8804             LDRH     R4,[R0, #+0]
   \   00000116   0xB2A4             UXTH     R4,R4
   \   00000118   0x2C20             CMP      R4,#+32
   \   0000011A   0xD0F3             BEQ      ??create_name_18
   \   0000011C   0xB2A4             UXTH     R4,R4
   \   0000011E   0x2C2E             CMP      R4,#+46
   \   00000120   0xD0F0             BEQ      ??create_name_18
   2476          	}
   2477          	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
   \                     ??create_name_19: (+1)
   \   00000122   0x2E00             CMP      R6,#+0
   \   00000124   0xD101             BNE      ??create_name_20
   \   00000126   0x2006             MOVS     R0,#+6
   \   00000128   0xE087             B        ??create_name_9
   2478          
   2479          	lfn[di] = 0;//LFN		/* LFN is created */
   \                     ??create_name_20: (+1)
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x9901             LDR      R1,[SP, #+4]
   \   0000012E   0x2202             MOVS     R2,#+2
   \   00000130   0x4372             MULS     R2,R6,R2
   \   00000132   0x5288             STRH     R0,[R1, R2]
   2480          
   2481          	/* Create SFN in directory form */
   2482          	mem_set(dj->fn, ' ', 11);
   \   00000134   0x220B             MOVS     R2,#+11
   \   00000136   0x2120             MOVS     R1,#+32
   \   00000138   0x9803             LDR      R0,[SP, #+12]
   \   0000013A   0x6980             LDR      R0,[R0, #+24]
   \   0000013C   0x.... 0x....      BL       mem_set
   2483          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots *///' ''.'ANSIUNICODE
   \   00000140   0x2500             MOVS     R5,#+0
   \   00000142   0xE000             B        ??create_name_21
   \                     ??create_name_22: (+1)
   \   00000144   0x1C6D             ADDS     R5,R5,#+1
   \                     ??create_name_21: (+1)
   \   00000146   0x9801             LDR      R0,[SP, #+4]
   \   00000148   0x2102             MOVS     R1,#+2
   \   0000014A   0x4369             MULS     R1,R5,R1
   \   0000014C   0x5A40             LDRH     R0,[R0, R1]
   \   0000014E   0x2820             CMP      R0,#+32
   \   00000150   0xD0F8             BEQ      ??create_name_22
   \   00000152   0x9801             LDR      R0,[SP, #+4]
   \   00000154   0x2102             MOVS     R1,#+2
   \   00000156   0x4369             MULS     R1,R5,R1
   \   00000158   0x5A40             LDRH     R0,[R0, R1]
   \   0000015A   0x282E             CMP      R0,#+46
   \   0000015C   0xD0F2             BEQ      ??create_name_22
   2484          	if (si) cf |= NS_LOSS | NS_LFN;
   \   0000015E   0x2D00             CMP      R5,#+0
   \   00000160   0xD007             BEQ      ??create_name_23
   \   00000162   0x4668             MOV      R0,SP
   \   00000164   0x4669             MOV      R1,SP
   \   00000166   0x7809             LDRB     R1,[R1, #+0]
   \   00000168   0x2203             MOVS     R2,#+3
   \   0000016A   0x430A             ORRS     R2,R2,R1
   \   0000016C   0x7002             STRB     R2,[R0, #+0]
   \   0000016E   0xE000             B        ??create_name_23
   2485          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   \                     ??create_name_24: (+1)
   \   00000170   0x1E76             SUBS     R6,R6,#+1
   \                     ??create_name_23: (+1)
   \   00000172   0x2E00             CMP      R6,#+0
   \   00000174   0xD007             BEQ      ??create_name_25
   \   00000176   0x9801             LDR      R0,[SP, #+4]
   \   00000178   0x2102             MOVS     R1,#+2
   \   0000017A   0x4371             MULS     R1,R6,R1
   \   0000017C   0x1840             ADDS     R0,R0,R1
   \   0000017E   0x1E80             SUBS     R0,R0,#+2
   \   00000180   0x8800             LDRH     R0,[R0, #+0]
   \   00000182   0x282E             CMP      R0,#+46
   \   00000184   0xD1F4             BNE      ??create_name_24
   2486          
   2487          	b = i = 0; ni = 8;
   \                     ??create_name_25: (+1)
   \   00000186   0x2700             MOVS     R7,#+0
   \   00000188   0x0038             MOVS     R0,R7
   \   0000018A   0x4669             MOV      R1,SP
   \   0000018C   0x7048             STRB     R0,[R1, #+1]
   \   0000018E   0x2008             MOVS     R0,#+8
   \   00000190   0x9002             STR      R0,[SP, #+8]
   \   00000192   0xE005             B        ??create_name_26
   2488          	for (;;) {
   2489          		w = lfn[si++];					/* Get an LFN char */
   2490          		if (!w) break;					/* Break on end of the LFN */
   2491          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   2492          			cf |= NS_LOSS | NS_LFN; continue;
   \                     ??create_name_27: (+1)
   \   00000194   0x4668             MOV      R0,SP
   \   00000196   0x4669             MOV      R1,SP
   \   00000198   0x7809             LDRB     R1,[R1, #+0]
   \   0000019A   0x2203             MOVS     R2,#+3
   \   0000019C   0x430A             ORRS     R2,R2,R1
   \   0000019E   0x7002             STRB     R2,[R0, #+0]
   2493          		}
   \                     ??create_name_26: (+1)
   \   000001A0   0x9801             LDR      R0,[SP, #+4]
   \   000001A2   0x2102             MOVS     R1,#+2
   \   000001A4   0x4369             MULS     R1,R5,R1
   \   000001A6   0x5A44             LDRH     R4,[R0, R1]
   \   000001A8   0x1C6D             ADDS     R5,R5,#+1
   \   000001AA   0xB2A4             UXTH     R4,R4
   \   000001AC   0x2C00             CMP      R4,#+0
   \   000001AE   0xD146             BNE      ??create_name_28
   2494          
   2495          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   2496          			if (ni == 11) {				/* Long extension */
   2497          				cf |= NS_LOSS | NS_LFN; break;
   2498          			}
   2499          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   2500          			if (si > di) break;			/* No extension */
   2501          			si = di; i = 8; ni = 11;	/* Enter extension section */
   2502          			b <<= 2; continue;
   2503          		}
   2504          
   2505          		if (w >= 0x80) {        		/* Non ASCII char or exended char*/
   2506          #ifdef _EXCVT                                           //sigle byte extended code (OEM)
   2507          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   2508          			if (w) w = ExCvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
   2509          #else                                                   //gb2312 etc
   2510          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   2511          #endif
   2512          			cf |= NS_LFN;				/* Force create LFN entry */
   2513          		}
   2514                          //OEM code
   2515          		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
   2516          			if (i >= ni - 1) {
   2517          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   2518          			}
   2519          			dj->fn[i++] = (uint8_t)(w >> 8);//
   2520          		} else {						/* Single byte char */
   2521          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
   2522          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   2523          			} else {
   2524          				if (IsUpper(w)) {		/* ASCII large capital */
   2525          					b |= 2;
   2526          				} else {
   2527          					if (IsLower(w)) {	/* ASCII small capital */
   2528          						b |= 1; w -= 0x20;
   2529          					}
   2530          				}
   2531          			}
   2532          		}
   2533          		dj->fn[i++] = (uint8_t)w;//
   2534          	}
   2535          
   2536          	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
   \                     ??create_name_29: (+1)
   \   000001B0   0x9803             LDR      R0,[SP, #+12]
   \   000001B2   0x6980             LDR      R0,[R0, #+24]
   \   000001B4   0x7800             LDRB     R0,[R0, #+0]
   \   000001B6   0x28E5             CMP      R0,#+229
   \   000001B8   0xD103             BNE      ??create_name_30
   \   000001BA   0x2005             MOVS     R0,#+5
   \   000001BC   0x9903             LDR      R1,[SP, #+12]
   \   000001BE   0x6989             LDR      R1,[R1, #+24]
   \   000001C0   0x7008             STRB     R0,[R1, #+0]
   2537          
   2538          	if (ni == 8) b <<= 2;
   \                     ??create_name_30: (+1)
   \   000001C2   0x9802             LDR      R0,[SP, #+8]
   \   000001C4   0x2808             CMP      R0,#+8
   \   000001C6   0xD104             BNE      ??create_name_31
   \   000001C8   0x4668             MOV      R0,SP
   \   000001CA   0x4669             MOV      R1,SP
   \   000001CC   0x7849             LDRB     R1,[R1, #+1]
   \   000001CE   0x0089             LSLS     R1,R1,#+2
   \   000001D0   0x7041             STRB     R1,[R0, #+1]
   2539          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
   \                     ??create_name_31: (+1)
   \   000001D2   0x4668             MOV      R0,SP
   \   000001D4   0x7840             LDRB     R0,[R0, #+1]
   \   000001D6   0x210C             MOVS     R1,#+12
   \   000001D8   0x4001             ANDS     R1,R1,R0
   \   000001DA   0x290C             CMP      R1,#+12
   \   000001DC   0xD005             BEQ      ??create_name_32
   \   000001DE   0x4668             MOV      R0,SP
   \   000001E0   0x7840             LDRB     R0,[R0, #+1]
   \   000001E2   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000001E4   0x0F80             LSRS     R0,R0,#+30
   \   000001E6   0x2803             CMP      R0,#+3
   \   000001E8   0xD105             BNE      ??create_name_33
   2540          		cf |= NS_LFN;
   \                     ??create_name_32: (+1)
   \   000001EA   0x4668             MOV      R0,SP
   \   000001EC   0x4669             MOV      R1,SP
   \   000001EE   0x7809             LDRB     R1,[R1, #+0]
   \   000001F0   0x2202             MOVS     R2,#+2
   \   000001F2   0x430A             ORRS     R2,R2,R1
   \   000001F4   0x7002             STRB     R2,[R0, #+0]
   2541          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
   \                     ??create_name_33: (+1)
   \   000001F6   0x4668             MOV      R0,SP
   \   000001F8   0x7800             LDRB     R0,[R0, #+0]
   \   000001FA   0x0780             LSLS     R0,R0,#+30
   \   000001FC   0xD417             BMI      ??create_name_34
   2542          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   \   000001FE   0x4668             MOV      R0,SP
   \   00000200   0x7840             LDRB     R0,[R0, #+1]
   \   00000202   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000204   0x0F80             LSRS     R0,R0,#+30
   \   00000206   0x2801             CMP      R0,#+1
   \   00000208   0xD105             BNE      ??create_name_35
   \   0000020A   0x4668             MOV      R0,SP
   \   0000020C   0x4669             MOV      R1,SP
   \   0000020E   0x7809             LDRB     R1,[R1, #+0]
   \   00000210   0x2210             MOVS     R2,#+16
   \   00000212   0x430A             ORRS     R2,R2,R1
   \   00000214   0x7002             STRB     R2,[R0, #+0]
   2543          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   \                     ??create_name_35: (+1)
   \   00000216   0x4668             MOV      R0,SP
   \   00000218   0x7840             LDRB     R0,[R0, #+1]
   \   0000021A   0x210C             MOVS     R1,#+12
   \   0000021C   0x4001             ANDS     R1,R1,R0
   \   0000021E   0x2904             CMP      R1,#+4
   \   00000220   0xD105             BNE      ??create_name_34
   \   00000222   0x4668             MOV      R0,SP
   \   00000224   0x4669             MOV      R1,SP
   \   00000226   0x7809             LDRB     R1,[R1, #+0]
   \   00000228   0x2208             MOVS     R2,#+8
   \   0000022A   0x430A             ORRS     R2,R2,R1
   \   0000022C   0x7002             STRB     R2,[R0, #+0]
   2544          	}
   2545          
   2546          	dj->fn[NS] = cf;	/* SFN is created */
   \                     ??create_name_34: (+1)
   \   0000022E   0x4668             MOV      R0,SP
   \   00000230   0x7800             LDRB     R0,[R0, #+0]
   \   00000232   0x9903             LDR      R1,[SP, #+12]
   \   00000234   0x6989             LDR      R1,[R1, #+24]
   \   00000236   0x72C8             STRB     R0,[R1, #+11]
   2547          
   2548          	return FR_OK;
   \   00000238   0x2000             MOVS     R0,#+0
   \                     ??create_name_9: (+1)
   \   0000023A   0xB005             ADD      SP,SP,#+20
   \   0000023C   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??create_name_28: (+1)
   \   0000023E   0xB2A4             UXTH     R4,R4
   \   00000240   0x2C20             CMP      R4,#+32
   \   00000242   0xD0A7             BEQ      ??create_name_27
   \   00000244   0xB2A4             UXTH     R4,R4
   \   00000246   0x2C2E             CMP      R4,#+46
   \   00000248   0xD101             BNE      ??create_name_36
   \   0000024A   0x42B5             CMP      R5,R6
   \   0000024C   0xD1A2             BNE      ??create_name_27
   \                     ??create_name_36: (+1)
   \   0000024E   0x9802             LDR      R0,[SP, #+8]
   \   00000250   0x4287             CMP      R7,R0
   \   00000252   0xD201             BCS      ??create_name_37
   \   00000254   0x42B5             CMP      R5,R6
   \   00000256   0xD11D             BNE      ??create_name_38
   \                     ??create_name_37: (+1)
   \   00000258   0x9802             LDR      R0,[SP, #+8]
   \   0000025A   0x280B             CMP      R0,#+11
   \   0000025C   0xD106             BNE      ??create_name_39
   \   0000025E   0x4668             MOV      R0,SP
   \   00000260   0x4669             MOV      R1,SP
   \   00000262   0x7809             LDRB     R1,[R1, #+0]
   \   00000264   0x2203             MOVS     R2,#+3
   \   00000266   0x430A             ORRS     R2,R2,R1
   \   00000268   0x7002             STRB     R2,[R0, #+0]
   \   0000026A   0xE7A1             B        ??create_name_29
   \                     ??create_name_39: (+1)
   \   0000026C   0x42B5             CMP      R5,R6
   \   0000026E   0xD005             BEQ      ??create_name_40
   \   00000270   0x4668             MOV      R0,SP
   \   00000272   0x4669             MOV      R1,SP
   \   00000274   0x7809             LDRB     R1,[R1, #+0]
   \   00000276   0x2203             MOVS     R2,#+3
   \   00000278   0x430A             ORRS     R2,R2,R1
   \   0000027A   0x7002             STRB     R2,[R0, #+0]
   \                     ??create_name_40: (+1)
   \   0000027C   0x42AE             CMP      R6,R5
   \   0000027E   0xD397             BCC      ??create_name_29
   \                     ??create_name_41: (+1)
   \   00000280   0x0035             MOVS     R5,R6
   \   00000282   0x2708             MOVS     R7,#+8
   \   00000284   0x200B             MOVS     R0,#+11
   \   00000286   0x9002             STR      R0,[SP, #+8]
   \   00000288   0x4668             MOV      R0,SP
   \   0000028A   0x4669             MOV      R1,SP
   \   0000028C   0x7849             LDRB     R1,[R1, #+1]
   \   0000028E   0x0089             LSLS     R1,R1,#+2
   \   00000290   0x7041             STRB     R1,[R0, #+1]
   \   00000292   0xE785             B        ??create_name_26
   \                     ??create_name_38: (+1)
   \   00000294   0xB2A4             UXTH     R4,R4
   \   00000296   0x2C80             CMP      R4,#+128
   \   00000298   0xDB13             BLT      ??create_name_42
   \   0000029A   0x2100             MOVS     R1,#+0
   \   0000029C   0x0020             MOVS     R0,R4
   \   0000029E   0xB280             UXTH     R0,R0
   \   000002A0   0x.... 0x....      BL       ff_convert
   \   000002A4   0x0004             MOVS     R4,R0
   \   000002A6   0xB2A4             UXTH     R4,R4
   \   000002A8   0x2C00             CMP      R4,#+0
   \   000002AA   0xD004             BEQ      ??create_name_43
   \   000002AC   0x....             LDR      R0,??DataTable12
   \   000002AE   0xB2A4             UXTH     R4,R4
   \   000002B0   0x1900             ADDS     R0,R0,R4
   \   000002B2   0x3880             SUBS     R0,R0,#+128
   \   000002B4   0x7804             LDRB     R4,[R0, #+0]
   \                     ??create_name_43: (+1)
   \   000002B6   0x4668             MOV      R0,SP
   \   000002B8   0x4669             MOV      R1,SP
   \   000002BA   0x7809             LDRB     R1,[R1, #+0]
   \   000002BC   0x2202             MOVS     R2,#+2
   \   000002BE   0x430A             ORRS     R2,R2,R1
   \   000002C0   0x7002             STRB     R2,[R0, #+0]
   \                     ??create_name_42: (+1)
   \   000002C2   0xB2A4             UXTH     R4,R4
   \   000002C4   0x2C00             CMP      R4,#+0
   \   000002C6   0xD006             BEQ      ??create_name_44
   \   000002C8   0xB2A4             UXTH     R4,R4
   \   000002CA   0x0021             MOVS     R1,R4
   \   000002CC   0x....             LDR      R0,??DataTable12_1
   \   000002CE   0x.... 0x....      BL       chk_chr
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD007             BEQ      ??create_name_45
   \                     ??create_name_44: (+1)
   \   000002D6   0x245F             MOVS     R4,#+95
   \   000002D8   0x4668             MOV      R0,SP
   \   000002DA   0x4669             MOV      R1,SP
   \   000002DC   0x7809             LDRB     R1,[R1, #+0]
   \   000002DE   0x2203             MOVS     R2,#+3
   \   000002E0   0x430A             ORRS     R2,R2,R1
   \   000002E2   0x7002             STRB     R2,[R0, #+0]
   \   000002E4   0xE017             B        ??create_name_46
   \                     ??create_name_45: (+1)
   \   000002E6   0xB2A4             UXTH     R4,R4
   \   000002E8   0x0020             MOVS     R0,R4
   \   000002EA   0x3841             SUBS     R0,R0,#+65
   \   000002EC   0x281A             CMP      R0,#+26
   \   000002EE   0xD206             BCS      ??create_name_47
   \   000002F0   0x4668             MOV      R0,SP
   \   000002F2   0x4669             MOV      R1,SP
   \   000002F4   0x7849             LDRB     R1,[R1, #+1]
   \   000002F6   0x2202             MOVS     R2,#+2
   \   000002F8   0x430A             ORRS     R2,R2,R1
   \   000002FA   0x7042             STRB     R2,[R0, #+1]
   \   000002FC   0xE00B             B        ??create_name_46
   \                     ??create_name_47: (+1)
   \   000002FE   0xB2A4             UXTH     R4,R4
   \   00000300   0x0020             MOVS     R0,R4
   \   00000302   0x3861             SUBS     R0,R0,#+97
   \   00000304   0x281A             CMP      R0,#+26
   \   00000306   0xD206             BCS      ??create_name_46
   \   00000308   0x4668             MOV      R0,SP
   \   0000030A   0x4669             MOV      R1,SP
   \   0000030C   0x7849             LDRB     R1,[R1, #+1]
   \   0000030E   0x2201             MOVS     R2,#+1
   \   00000310   0x430A             ORRS     R2,R2,R1
   \   00000312   0x7042             STRB     R2,[R0, #+1]
   \   00000314   0x3C20             SUBS     R4,R4,#+32
   \                     ??create_name_46: (+1)
   \   00000316   0x9803             LDR      R0,[SP, #+12]
   \   00000318   0x6980             LDR      R0,[R0, #+24]
   \   0000031A   0x55C4             STRB     R4,[R0, R7]
   \   0000031C   0x1C7F             ADDS     R7,R7,#+1
   \   0000031E   0xE73F             B        ??create_name_26
   2549          
   2550          
   2551          #else	/* Non-LFN configuration */
   2552          	uint8_t b, c, d, *sfn;
   2553          	uint32_t ni, si, i;
   2554          	const char *p;
   2555          
   2556          	/* Create file name in directory form */
   2557          	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
   2558          	sfn = dj->fn;
   2559          	mem_set(sfn, ' ', 11);
   2560          	si = i = b = 0; ni = 8;
   2561          #if _FS_RPATH
   2562          	if (p[si] == '.') { /* Is this a dot entry? */
   2563          		for (;;) {
   2564          			c = (uint8_t)p[si++];
   2565          			if (c != '.' || si >= 3) break;
   2566          			sfn[i++] = c;
   2567          		}
   2568          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   2569          		*path = &p[si];									/* Return pointer to the next segment */
   2570          		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   2571          		return FR_OK;
   2572          	}
   2573          #endif
   2574          	for (;;) {
   2575          		c = (uint8_t)p[si++];
   2576          		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
   2577          		if (c == '.' || i >= ni) {
   2578          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   2579          			i = 8; ni = 11;
   2580          			b <<= 2; continue;
   2581          		}
   2582          		if (c >= 0x80) {				/* Extended char? */
   2583          			b |= 3;						/* Eliminate NT flag */
   2584          #ifdef _EXCVT
   2585          			c = ExCvt[c - 0x80];		/* To upper extended chars (SBCS cfg) */
   2586          #else                                                   //when _EXCVT is not defined
   2587          #if !_DF1S                                              //single byte code
   2588          			return FR_INVALID_NAME;		/* Reject extended chars (ASCII cfg) */
   2589          #endif
   2590          #endif
   2591          		}
   2592          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   2593          			d = (uint8_t)p[si++];			/* Get 2nd byte */
   2594          			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
   2595          				return FR_INVALID_NAME;
   2596          			sfn[i++] = c;
   2597          			sfn[i++] = d;
   2598          		} else {						/* Single byte code */
   2599          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
   2600          				return FR_INVALID_NAME;
   2601          			if (IsUpper(c)) {			/* ASCII large capital? */
   2602          				b |= 2;
   2603          			} else {
   2604          				if (IsLower(c)) {		/* ASCII small capital? */
   2605          					b |= 1; c -= 0x20;
   2606          				}
   2607          			}
   2608          			sfn[i++] = c;
   2609          		}
   2610          	}
   2611          	*path = &p[si];						/* Return pointer to the next segment */
   2612          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2613          
   2614          	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
   2615          	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
   2616          
   2617          	if (ni == 8) b <<= 2;
   2618          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   2619          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   2620          
   2621          	sfn[NS] = c;		/* Store NT flag, File name is created */
   2622          
   2623          	return FR_OK;
   2624          #endif
   2625          }
   2626          
   2627          
   2628          
   2629          
   2630          /*FUNCTION*-------------------------------------------------------------------
   2631          *
   2632          * Function Name    : get_fileinfo
   2633          * Returned Value   : None
   2634          * Comments         : Get file information from directory entry   
   2635          *   
   2636          *END*----------------------------------------------------------------------*/
   2637          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   2638          static void get_fileinfo
   2639          (
   2640              /* [IN] Pointer to the directory object */
   2641            	DIR *dj,			
   2642            	/* [OUT] Pointer to the file information to be filled */
   2643            	FILINFO *fno	 	
   2644          )
   2645          {
   \                     get_fileinfo: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
   2646          	uint32_t i;
   2647          	uint8_t nt, *dir;
   2648          	TCHAR *p, c;
   2649          
   2650          
   2651          	p = fno->fname;
   \   00000006   0x003C             MOVS     R4,R7
   \   00000008   0x3409             ADDS     R4,R4,#+9
   2652          	if (dj->sect) {
   \   0000000A   0x6930             LDR      R0,[R6, #+16]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD04B             BEQ      ??get_fileinfo_0
   2653          		dir = convert_ptr(dj->fs, dj->dir);
   \   00000010   0x6971             LDR      R1,[R6, #+20]
   \   00000012   0x6830             LDR      R0,[R6, #+0]
   \   00000014   0x.... 0x....      BL       convert_ptr
   2654          		nt = dir[DIR_NTres];		/* NT flag */
   \   00000018   0x7B01             LDRB     R1,[R0, #+12]
   2655          		for (i = 0; i < 8; i++) {	/* Copy name body */
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xE00E             B        ??get_fileinfo_1
   2656          			c = dir[i];
   2657          			if (c == ' ') break;
   2658          			if (c == NDDE) c = (TCHAR)DDE;
   \                     ??get_fileinfo_2: (+1)
   \   0000001E   0xB2D2             UXTB     R2,R2
   \   00000020   0x2A05             CMP      R2,#+5
   \   00000022   0xD100             BNE      ??get_fileinfo_3
   \   00000024   0x22E5             MOVS     R2,#+229
   2659          			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;//
   \                     ??get_fileinfo_3: (+1)
   \   00000026   0x070B             LSLS     R3,R1,#+28
   \   00000028   0xD505             BPL      ??get_fileinfo_4
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x0013             MOVS     R3,R2
   \   0000002E   0x3B41             SUBS     R3,R3,#+65
   \   00000030   0x2B1A             CMP      R3,#+26
   \   00000032   0xD200             BCS      ??get_fileinfo_4
   \   00000034   0x3220             ADDS     R2,R2,#+32
   2660          #if _LFN_UNICODE//IDEUNICODESFNUNICODE
   2661          			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
   2662          				c = (c << 8) | dir[++i];
   2663          			c = ff_convert(c, 1);
   2664          			if (!c) c = '?';
   2665          #endif
   2666          			*p++ = c;
   \                     ??get_fileinfo_4: (+1)
   \   00000036   0x7022             STRB     R2,[R4, #+0]
   \   00000038   0x1C64             ADDS     R4,R4,#+1
   \   0000003A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_1: (+1)
   \   0000003C   0x2D08             CMP      R5,#+8
   \   0000003E   0xD203             BCS      ??get_fileinfo_5
   \   00000040   0x5D42             LDRB     R2,[R0, R5]
   \   00000042   0xB2D2             UXTB     R2,R2
   \   00000044   0x2A20             CMP      R2,#+32
   \   00000046   0xD1EA             BNE      ??get_fileinfo_2
   2667          		}
   2668          		if (dir[8] != ' ') {		/* Copy name extension */
   \                     ??get_fileinfo_5: (+1)
   \   00000048   0x7A02             LDRB     R2,[R0, #+8]
   \   0000004A   0x2A20             CMP      R2,#+32
   \   0000004C   0xD015             BEQ      ??get_fileinfo_6
   2669          			*p++ = '.';
   \   0000004E   0x222E             MOVS     R2,#+46
   \   00000050   0x7022             STRB     R2,[R4, #+0]
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   2670          			for (i = 8; i < 11; i++) {
   \   00000054   0x2508             MOVS     R5,#+8
   \   00000056   0xE00A             B        ??get_fileinfo_7
   2671          				c = dir[i];
   2672          				if (c == ' ') break;
   2673          				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
   \                     ??get_fileinfo_8: (+1)
   \   00000058   0x06CB             LSLS     R3,R1,#+27
   \   0000005A   0xD505             BPL      ??get_fileinfo_9
   \   0000005C   0xB2D2             UXTB     R2,R2
   \   0000005E   0x0013             MOVS     R3,R2
   \   00000060   0x3B41             SUBS     R3,R3,#+65
   \   00000062   0x2B1A             CMP      R3,#+26
   \   00000064   0xD200             BCS      ??get_fileinfo_9
   \   00000066   0x3220             ADDS     R2,R2,#+32
   2674          #if _LFN_UNICODE
   2675          				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
   2676          					c = (c << 8) | dir[++i];
   2677          				c = ff_convert(c, 1);
   2678          				if (!c) c = '?';
   2679          #endif
   2680          				*p++ = c;
   \                     ??get_fileinfo_9: (+1)
   \   00000068   0x7022             STRB     R2,[R4, #+0]
   \   0000006A   0x1C64             ADDS     R4,R4,#+1
   \   0000006C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_7: (+1)
   \   0000006E   0x2D0B             CMP      R5,#+11
   \   00000070   0xD203             BCS      ??get_fileinfo_6
   \   00000072   0x5D42             LDRB     R2,[R0, R5]
   \   00000074   0xB2D2             UXTB     R2,R2
   \   00000076   0x2A20             CMP      R2,#+32
   \   00000078   0xD1EE             BNE      ??get_fileinfo_8
   2681          			}
   2682          		}
   2683          		fno->fattrib = dir[DIR_Attr];				/* Attribute */
   \                     ??get_fileinfo_6: (+1)
   \   0000007A   0x7AC1             LDRB     R1,[R0, #+11]
   \   0000007C   0x7239             STRB     R1,[R7, #+8]
   2684          		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
   \   0000007E   0x7FC1             LDRB     R1,[R0, #+31]
   \   00000080   0x0609             LSLS     R1,R1,#+24
   \   00000082   0x7F82             LDRB     R2,[R0, #+30]
   \   00000084   0x0412             LSLS     R2,R2,#+16
   \   00000086   0x430A             ORRS     R2,R2,R1
   \   00000088   0x7F41             LDRB     R1,[R0, #+29]
   \   0000008A   0x0209             LSLS     R1,R1,#+8
   \   0000008C   0x4311             ORRS     R1,R1,R2
   \   0000008E   0x7F02             LDRB     R2,[R0, #+28]
   \   00000090   0x430A             ORRS     R2,R2,R1
   \   00000092   0x603A             STR      R2,[R7, #+0]
   2685          		fno->fdate.Word = LD_WORD(dir+DIR_WrtDate);		/* Date */
   \   00000094   0x7E41             LDRB     R1,[R0, #+25]
   \   00000096   0x0209             LSLS     R1,R1,#+8
   \   00000098   0x7E02             LDRB     R2,[R0, #+24]
   \   0000009A   0x4311             ORRS     R1,R1,R2
   \   0000009C   0x80B9             STRH     R1,[R7, #+4]
   2686          		fno->ftime.Word = LD_WORD(dir+DIR_WrtTime);		/* Time */
   \   0000009E   0x7DC1             LDRB     R1,[R0, #+23]
   \   000000A0   0x0209             LSLS     R1,R1,#+8
   \   000000A2   0x7D80             LDRB     R0,[R0, #+22]
   \   000000A4   0x4301             ORRS     R1,R1,R0
   \   000000A6   0x80F9             STRH     R1,[R7, #+6]
   2687          	}
   2688          	*p = 0;		/* Terminate SFN str by a \0 */
   \                     ??get_fileinfo_0: (+1)
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x7020             STRB     R0,[R4, #+0]
   2689          
   2690          #if _USE_LFN
   2691          	if (fno->lfname && fno->lfsize) {
   \   000000AC   0x69B8             LDR      R0,[R7, #+24]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD028             BEQ      ??get_fileinfo_10
   \   000000B2   0x69F8             LDR      R0,[R7, #+28]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD025             BEQ      ??get_fileinfo_10
   2692          		TCHAR *tp = fno->lfname;
   \   000000B8   0x69B8             LDR      R0,[R7, #+24]
   \   000000BA   0x9000             STR      R0,[SP, #+0]
   2693          		uint16_t w, *lfn;
   2694          
   2695          		i = 0;
   \   000000BC   0x2500             MOVS     R5,#+0
   2696          		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
   \   000000BE   0x6930             LDR      R0,[R6, #+16]
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD01C             BEQ      ??get_fileinfo_11
   \   000000C4   0x8C30             LDRH     R0,[R6, #+32]
   \   000000C6   0x....             LDR      R1,??DataTable12_2  ;; 0xffff
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xD018             BEQ      ??get_fileinfo_11
   2697          			lfn = dj->lfn;
   \   000000CC   0x69F4             LDR      R4,[R6, #+28]
   \   000000CE   0xE002             B        ??get_fileinfo_12
   2698          			while ((w = *lfn++) != 0) {			/* Get an LFN char */
   2699          #if !_LFN_UNICODE//LFNUNICODEIDEANSI
   2700          				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
   2701          				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
   2702          				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
   2703          					tp[i++] = (TCHAR)(w >> 8);
   2704          #endif
   2705          				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
   2706          				tp[i++] = (TCHAR)w;
   \                     ??get_fileinfo_13: (+1)
   \   000000D0   0x9900             LDR      R1,[SP, #+0]
   \   000000D2   0x5548             STRB     R0,[R1, R5]
   \   000000D4   0x1C6D             ADDS     R5,R5,#+1
   \                     ??get_fileinfo_12: (+1)
   \   000000D6   0x8820             LDRH     R0,[R4, #+0]
   \   000000D8   0x1CA4             ADDS     R4,R4,#+2
   \   000000DA   0x0001             MOVS     R1,R0
   \   000000DC   0xB289             UXTH     R1,R1
   \   000000DE   0x2900             CMP      R1,#+0
   \   000000E0   0xD00D             BEQ      ??get_fileinfo_11
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0xB280             UXTH     R0,R0
   \   000000E6   0x.... 0x....      BL       ff_convert
   \   000000EA   0xB280             UXTH     R0,R0
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD101             BNE      ??get_fileinfo_14
   \   000000F0   0x2500             MOVS     R5,#+0
   \   000000F2   0xE004             B        ??get_fileinfo_11
   \                     ??get_fileinfo_14: (+1)
   \   000000F4   0x69F9             LDR      R1,[R7, #+28]
   \   000000F6   0x1E49             SUBS     R1,R1,#+1
   \   000000F8   0x428D             CMP      R5,R1
   \   000000FA   0xD3E9             BCC      ??get_fileinfo_13
   \   000000FC   0x2500             MOVS     R5,#+0
   2707          			}
   2708          		}
   2709          		tp[i] = 0;	/* Terminate the LFN str by a \0 */
   \                     ??get_fileinfo_11: (+1)
   \   000000FE   0x2000             MOVS     R0,#+0
   \   00000100   0x9900             LDR      R1,[SP, #+0]
   \   00000102   0x5548             STRB     R0,[R1, R5]
   2710          	}
   2711          #endif
   2712          }
   \                     ??get_fileinfo_10: (+1)
   \   00000104   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2713          #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
   2714          
   2715          
   2716          
   2717          /*FUNCTION*-------------------------------------------------------------------
   2718          *
   2719          * Function Name    : follow_path
   2720          * Returned Value   : FR_OK(0): successful
   2721          *                    !=0: error
   2722          * Comments         : Follow a file path   
   2723          *   
   2724          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   2725          static FRESULT follow_path 
   2726            (
   2727              /* [OUT] Directory object to return last directory and found object */
   2728            	DIR *dj,
   2729              /* [IN] Full-path string to find a file or directory */				
   2730            	const TCHAR *path	
   2731            )
   2732          {
   \                     follow_path: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2733          	FRESULT res;
   2734          	uint8_t *dir, ns;
   2735          
   2736          
   2737          #if _FS_RPATH
   2738          	if (*path == '/' || *path == '\\') { /* There is a heading separator */
   \   00000004   0x9801             LDR      R0,[SP, #+4]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x282F             CMP      R0,#+47
   \   0000000A   0xD003             BEQ      ??follow_path_0
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x285C             CMP      R0,#+92
   \   00000012   0xD105             BNE      ??follow_path_1
   2739          		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
   \                     ??follow_path_0: (+1)
   \   00000014   0x9801             LDR      R0,[SP, #+4]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x9001             STR      R0,[SP, #+4]
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x60A0             STR      R0,[R4, #+8]
   \   0000001E   0xE002             B        ??follow_path_2
   2740          	} else {							/* No heading separator */
   2741          		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
   \                     ??follow_path_1: (+1)
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x60A0             STR      R0,[R4, #+8]
   2742          	}
   2743          #else
   2744          	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
   2745          		path++;
   2746          	dj->sclust = 0;						/* Start from the root dir */
   2747          #endif
   2748          
   2749          	if ((uint32_t)*path < ' ') {			/* Nul path means the start directory itself */
   \                     ??follow_path_2: (+1)
   \   00000026   0x9801             LDR      R0,[SP, #+4]
   \   00000028   0x7800             LDRB     R0,[R0, #+0]
   \   0000002A   0x2820             CMP      R0,#+32
   \   0000002C   0xD20E             BCS      ??follow_path_3
   2750          		res = dir_sdi(dj, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       dir_sdi
   2751          		dj->dir = 0;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6161             STR      R1,[R4, #+20]
   2752          	} else {							/* Follow path */
   2753          		for (;;) {
   2754          			res = create_name(dj, &path);	/* Get a segment */
   2755          			if (res != FR_OK) break;
   2756          			res = dir_find(dj);				/* Find it */
   2757          			ns = *(dj->fn+NS);
   2758          			if (res != FR_OK) {				/* Failed to find the object */
   2759          				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
   2760          				/* Object not found */
   2761          				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
   2762          					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
   2763          					res = FR_OK;
   2764          					if (!(ns & NS_LAST)) continue;
   2765          				} else {							/* Could not find the object */
   2766          					if (!(ns & NS_LAST)) res = FR_NO_PATH;
   2767          				}
   2768          				break;
   2769          			}
   2770          			if (ns & NS_LAST) break;//			/* Last segment match. Function completed. */
   2771          			dir = convert_ptr(dj->fs, dj->dir);						/* There is next segment. Follow the sub directory */
   2772          			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
   2773          				res = FR_NO_PATH; break;
   2774          			}
   2775          			dj->sclust = ld_clust(dj->fs, dir);//
   2776          		}
   2777          	}
   2778          
   2779          	return res;
   \                     ??follow_path_4: (+1)
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   \                     ??follow_path_5: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x60A0             STR      R0,[R4, #+8]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6160             STR      R0,[R4, #+20]
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x0749             LSLS     R1,R1,#+29
   \   0000004A   0xD416             BMI      ??follow_path_6
   \                     ??follow_path_3: (+1)
   \   0000004C   0xA901             ADD      R1,SP,#+4
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       create_name
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD1EF             BNE      ??follow_path_4
   \                     ??follow_path_7: (+1)
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       dir_find
   \   00000060   0x69A1             LDR      R1,[R4, #+24]
   \   00000062   0x7AC9             LDRB     R1,[R1, #+11]
   \   00000064   0xB2C0             UXTB     R0,R0
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD008             BEQ      ??follow_path_8
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xD1E4             BNE      ??follow_path_4
   \                     ??follow_path_9: (+1)
   \   00000070   0x068A             LSLS     R2,R1,#+26
   \   00000072   0xD4E4             BMI      ??follow_path_5
   \   00000074   0x0749             LSLS     R1,R1,#+29
   \   00000076   0xD400             BMI      ??follow_path_6
   \   00000078   0x2005             MOVS     R0,#+5
   \                     ??follow_path_6: (+1)
   \   0000007A   0xE7DE             B        ??follow_path_4
   \                     ??follow_path_8: (+1)
   \   0000007C   0x0749             LSLS     R1,R1,#+29
   \   0000007E   0xD4DC             BMI      ??follow_path_4
   \                     ??follow_path_10: (+1)
   \   00000080   0x6961             LDR      R1,[R4, #+20]
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x.... 0x....      BL       convert_ptr
   \   00000088   0x7AC1             LDRB     R1,[R0, #+11]
   \   0000008A   0x06C9             LSLS     R1,R1,#+27
   \   0000008C   0xD401             BMI      ??follow_path_11
   \   0000008E   0x2005             MOVS     R0,#+5
   \   00000090   0xE7D3             B        ??follow_path_4
   \                     ??follow_path_11: (+1)
   \   00000092   0x0001             MOVS     R1,R0
   \   00000094   0x6820             LDR      R0,[R4, #+0]
   \   00000096   0x.... 0x....      BL       ld_clust
   \   0000009A   0x60A0             STR      R0,[R4, #+8]
   \   0000009C   0xE7D6             B        ??follow_path_3
   2780          }
   2781          
   2782          /*FUNCTION*-------------------------------------------------------------------
   2783          *
   2784          * Function Name    : check_fs
   2785          * Returned Value   : 0:The FAT 
   2786          *                    1:Valid BR but not an FAT
   2787          *                    2:Not a BR 
   2788          *                    3:Disk error
   2789          * Comments         : Load boot record and check if it is an FAT boot record
   2790          *   
   2791          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   2792          static uint8_t check_fs 
   2793            (
   2794              /* [IN] File system object */
   2795            	FATFS *fs,
   2796            	/* [IN] Sector# (lba) to check if it is an FAT boot record or not */
   2797            	uint32_t sect	
   2798            )
   2799          {
   \                     check_fs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2800          	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0x6C61             LDR      R1,[R4, #+68]
   \   0000000A   0x7860             LDRB     R0,[R4, #+1]
   \   0000000C   0x.... 0x....      BL       disk_read
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ      ??check_fs_0
   2801          		return 3;
   \   00000014   0x2003             MOVS     R0,#+3
   \   00000016   0xE033             B        ??check_fs_1
   2802          	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
   \                     ??check_fs_0: (+1)
   \   00000018   0x6C60             LDR      R0,[R4, #+68]
   \   0000001A   0x....             LDR      R1,??DataTable12_3  ;; 0x1ff
   \   0000001C   0x5C40             LDRB     R0,[R0, R1]
   \   0000001E   0x0200             LSLS     R0,R0,#+8
   \   00000020   0x6C61             LDR      R1,[R4, #+68]
   \   00000022   0x22FF             MOVS     R2,#+255
   \   00000024   0x0052             LSLS     R2,R2,#+1        ;; #+510
   \   00000026   0x5C89             LDRB     R1,[R1, R2]
   \   00000028   0x4308             ORRS     R0,R0,R1
   \   0000002A   0xB280             UXTH     R0,R0
   \   0000002C   0x....             LDR      R1,??DataTable12_4  ;; 0xaa55
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD001             BEQ      ??check_fs_2
   2803          		return 2;
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE024             B        ??check_fs_1
   2804          
   2805          	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
   \                     ??check_fs_2: (+1)
   \   00000036   0x6C60             LDR      R0,[R4, #+68]
   \   00000038   0x3038             ADDS     R0,R0,#+56
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x0400             LSLS     R0,R0,#+16
   \   0000003E   0x6C61             LDR      R1,[R4, #+68]
   \   00000040   0x3137             ADDS     R1,R1,#+55
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x0209             LSLS     R1,R1,#+8
   \   00000046   0x4301             ORRS     R1,R1,R0
   \   00000048   0x6C60             LDR      R0,[R4, #+68]
   \   0000004A   0x3036             ADDS     R0,R0,#+54
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x4308             ORRS     R0,R0,R1
   \   00000050   0x....             LDR      R1,??DataTable12_5  ;; 0x544146
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD101             BNE      ??check_fs_3
   2806          		return 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE012             B        ??check_fs_1
   2807          	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
   \                     ??check_fs_3: (+1)
   \   0000005A   0x6C60             LDR      R0,[R4, #+68]
   \   0000005C   0x3054             ADDS     R0,R0,#+84
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x0400             LSLS     R0,R0,#+16
   \   00000062   0x6C61             LDR      R1,[R4, #+68]
   \   00000064   0x3153             ADDS     R1,R1,#+83
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x0209             LSLS     R1,R1,#+8
   \   0000006A   0x4301             ORRS     R1,R1,R0
   \   0000006C   0x6C60             LDR      R0,[R4, #+68]
   \   0000006E   0x3052             ADDS     R0,R0,#+82
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x4308             ORRS     R0,R0,R1
   \   00000074   0x....             LDR      R1,??DataTable12_5  ;; 0x544146
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD101             BNE      ??check_fs_4
   2808          		return 0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE000             B        ??check_fs_1
   2809          
   2810          	return 1;
   \                     ??check_fs_4: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \                     ??check_fs_1: (+1)
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
   2811          }
   2812          
   2813          
   2814          
   2815          
   2816          /*FUNCTION*-------------------------------------------------------------------
   2817          *
   2818          * Function Name    : chk_mounted
   2819          * Returned Value   : FR_OK(0): successful
   2820          *                    !=0: any error occurred
   2821          * Comments         : Check if the file system object is valid or not
   2822          *   
   2823          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 4, keep-with-next
   2824          static FRESULT chk_mounted
   2825          (
   2826            /* [IN] Pointer to pointer to the path name (drive number) */
   2827          	const TCHAR **path,
   2828          	/* [OUT] Pointer to pointer to the found file system object */	
   2829          	FATFS **rfs,		
   2830          	/* [IN] !=0: Check write protection for write access */
   2831          	uint8_t wmode
   2832          )
   2833          {
   \                     chk_mounted: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0015             MOVS     R5,R2
   2834          	uint8_t fmt, b, pi, *tbl;
   2835          	uint32_t vol;
   2836          	DSTATUS stat;
   2837          	uint32_t bsect, fasize, tsect, sysect, nclst, szbfat;
   2838          	uint16_t nrsv;
   2839          	const TCHAR *p = *path;
   \   00000006   0x6802             LDR      R2,[R0, #+0]
   2840          	FATFS *fs;
   2841          
   2842          
   2843          	/* Get logical drive number from the path name */
   2844          	vol = p[0] - '0';					/* Is there a drive number? */
   \   00000008   0x7816             LDRB     R6,[R2, #+0]
   \   0000000A   0x3E30             SUBS     R6,R6,#+48
   2845          	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
   \   0000000C   0x2E0A             CMP      R6,#+10
   \   0000000E   0xD205             BCS      ??chk_mounted_0
   \   00000010   0x7853             LDRB     R3,[R2, #+1]
   \   00000012   0x2B3A             CMP      R3,#+58
   \   00000014   0xD102             BNE      ??chk_mounted_0
   2846          		p += 2; *path = p;				/* Return pointer to the path name */
   \   00000016   0x1C92             ADDS     R2,R2,#+2
   \   00000018   0x6002             STR      R2,[R0, #+0]
   \   0000001A   0xE001             B        ??chk_mounted_1
   2847          	} else {							/* No drive number, use default drive */
   2848          #if _FS_RPATH
   2849          		vol = CurrVol;					/* Use current drive */
   \                     ??chk_mounted_0: (+1)
   \   0000001C   0x48A2             LDR      R0,??chk_mounted_2
   \   0000001E   0x7806             LDRB     R6,[R0, #+0]
   2850          #else
   2851          		vol = 0;						/* Use drive 0 */
   2852          #endif
   2853          	}
   2854          
   2855          	/* Check if the file system object is valid or not */
   2856          	*rfs = 0;
   \                     ??chk_mounted_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6008             STR      R0,[R1, #+0]
   2857          	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
   \   00000024   0x2E02             CMP      R6,#+2
   \   00000026   0xD301             BCC      ??chk_mounted_3
   2858          		return FR_INVALID_DRIVE;
   \   00000028   0x200B             MOVS     R0,#+11
   \   0000002A   0xE1D6             B        ??chk_mounted_4
   2859          	fs = FatFs[vol];					/* Get corresponding file system object */
   \                     ??chk_mounted_3: (+1)
   \   0000002C   0x489F             LDR      R0,??chk_mounted_2+0x4
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0x4372             MULS     R2,R6,R2
   \   00000032   0x5884             LDR      R4,[R0, R2]
   2860          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD101             BNE      ??chk_mounted_5
   \   00000038   0x200C             MOVS     R0,#+12
   \   0000003A   0xE1CE             B        ??chk_mounted_4
   2861          
   2862          	ENTER_FF(fs);						/* Lock volume */
   2863          
   2864          	*rfs = fs;							/* Return pointer to the corresponding file system object */
   \                     ??chk_mounted_5: (+1)
   \   0000003C   0x600C             STR      R4,[R1, #+0]
   2865          	if (fs->fs_type) {					/* If the volume has been mounted */
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00D             BEQ      ??chk_mounted_6
   2866          		stat = disk_status(fs->drv);
   \   00000044   0x7860             LDRB     R0,[R4, #+1]
   \   00000046   0x.... 0x....      BL       disk_status
   2867          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
   \   0000004A   0x07C1             LSLS     R1,R0,#+31
   \   0000004C   0xD408             BMI      ??chk_mounted_6
   2868          			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
   \   0000004E   0xB2ED             UXTB     R5,R5
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD003             BEQ      ??chk_mounted_7
   \   00000054   0x0740             LSLS     R0,R0,#+29
   \   00000056   0xD501             BPL      ??chk_mounted_7
   2869          				return FR_WRITE_PROTECTED;
   \   00000058   0x200A             MOVS     R0,#+10
   \   0000005A   0xE1BE             B        ??chk_mounted_4
   2870          			return FR_OK;				/* The file system object is valid */
   \                     ??chk_mounted_7: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE1BC             B        ??chk_mounted_4
   2871          		}
   2872          	}
   2873          
   2874          	/* The file system object is not valid. */
   2875          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2876          
   2877          	fs->fs_type = 0;					/* Clear the file system object */
   \                     ??chk_mounted_6: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x7020             STRB     R0,[R4, #+0]
   2878          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   \   00000064   0x7066             STRB     R6,[R4, #+1]
   2879          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   \   00000066   0x7860             LDRB     R0,[R4, #+1]
   \   00000068   0x.... 0x....      BL       disk_initialize
   2880          	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
   \   0000006C   0x07C1             LSLS     R1,R0,#+31
   \   0000006E   0xD501             BPL      ??chk_mounted_8
   2881          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   \   00000070   0x2003             MOVS     R0,#+3
   \   00000072   0xE1B2             B        ??chk_mounted_4
   2882          	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
   \                     ??chk_mounted_8: (+1)
   \   00000074   0xB2ED             UXTB     R5,R5
   \   00000076   0x2D00             CMP      R5,#+0
   \   00000078   0xD003             BEQ      ??chk_mounted_9
   \   0000007A   0x0740             LSLS     R0,R0,#+29
   \   0000007C   0xD501             BPL      ??chk_mounted_9
   2883          		return FR_WRITE_PROTECTED;
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0xE1AB             B        ??chk_mounted_4
   2884          #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
   2885          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
   2886          		return FR_DISK_ERR;
   2887          #endif
   2888          	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
   2889          	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
   \                     ??chk_mounted_9: (+1)
   \   00000082   0x2600             MOVS     R6,#+0
   \   00000084   0x0031             MOVS     R1,R6
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       check_fs
   \   0000008C   0x0005             MOVS     R5,R0
   2890          	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
   2891          	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
   \   0000008E   0xB2ED             UXTB     R5,R5
   \   00000090   0x2D01             CMP      R5,#+1
   \   00000092   0xD11E             BNE      ??chk_mounted_10
   2892          		/* Check the partition listed in the partition table */
   2893          		pi = LD2PT(vol);
   \   00000094   0x2000             MOVS     R0,#+0
   2894          		if (pi) pi--;
   \   00000096   0xB2C0             UXTB     R0,R0
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD000             BEQ      ??chk_mounted_11
   \   0000009C   0x1E40             SUBS     R0,R0,#+1
   2895          		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
   \                     ??chk_mounted_11: (+1)
   \   0000009E   0x6C61             LDR      R1,[R4, #+68]
   \   000000A0   0xB2C0             UXTB     R0,R0
   \   000000A2   0x2210             MOVS     R2,#+16
   \   000000A4   0x4350             MULS     R0,R2,R0
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x21DF             MOVS     R1,#+223
   \   000000AA   0x0049             LSLS     R1,R1,#+1        ;; #+446
   \   000000AC   0x1840             ADDS     R0,R0,R1
   2896          		if (tbl[4]) {						/* Is the partition existing? */
   \   000000AE   0x7901             LDRB     R1,[R0, #+4]
   \   000000B0   0x2900             CMP      R1,#+0
   \   000000B2   0xD00E             BEQ      ??chk_mounted_10
   2897          			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
   \   000000B4   0x7AC1             LDRB     R1,[R0, #+11]
   \   000000B6   0x0609             LSLS     R1,R1,#+24
   \   000000B8   0x7A82             LDRB     R2,[R0, #+10]
   \   000000BA   0x0412             LSLS     R2,R2,#+16
   \   000000BC   0x430A             ORRS     R2,R2,R1
   \   000000BE   0x7A41             LDRB     R1,[R0, #+9]
   \   000000C0   0x0209             LSLS     R1,R1,#+8
   \   000000C2   0x4311             ORRS     R1,R1,R2
   \   000000C4   0x7A06             LDRB     R6,[R0, #+8]
   \   000000C6   0x430E             ORRS     R6,R6,R1
   2898          			fmt = check_fs(fs, bsect);		/* Check the partition */
   \   000000C8   0x0031             MOVS     R1,R6
   \   000000CA   0x0020             MOVS     R0,R4
   \   000000CC   0x.... 0x....      BL       check_fs
   \   000000D0   0x0005             MOVS     R5,R0
   2899          		}
   2900          	}
   2901          	if (fmt == 3) return FR_DISK_ERR;
   \                     ??chk_mounted_10: (+1)
   \   000000D2   0xB2ED             UXTB     R5,R5
   \   000000D4   0x2D03             CMP      R5,#+3
   \   000000D6   0xD101             BNE      ??chk_mounted_12
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xE17E             B        ??chk_mounted_4
   2902          	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
   \                     ??chk_mounted_12: (+1)
   \   000000DC   0xB2ED             UXTB     R5,R5
   \   000000DE   0x2D00             CMP      R5,#+0
   \   000000E0   0xD001             BEQ      ??chk_mounted_13
   \   000000E2   0x200D             MOVS     R0,#+13
   \   000000E4   0xE179             B        ??chk_mounted_4
   2903          
   2904          	/* An FAT volume is found. Following code initializes the file system object */
   2905          
   2906          	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
   \                     ??chk_mounted_13: (+1)
   \   000000E6   0x6C60             LDR      R0,[R4, #+68]
   \   000000E8   0x7B00             LDRB     R0,[R0, #+12]
   \   000000EA   0x0200             LSLS     R0,R0,#+8
   \   000000EC   0x6C61             LDR      R1,[R4, #+68]
   \   000000EE   0x7AC9             LDRB     R1,[R1, #+11]
   \   000000F0   0x4308             ORRS     R0,R0,R1
   \   000000F2   0xB280             UXTH     R0,R0
   \   000000F4   0x2180             MOVS     R1,#+128
   \   000000F6   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000F8   0x4288             CMP      R0,R1
   \   000000FA   0xD001             BEQ      ??chk_mounted_14
   2907          		return FR_NO_FILESYSTEM;
   \   000000FC   0x200D             MOVS     R0,#+13
   \   000000FE   0xE16C             B        ??chk_mounted_4
   2908          
   2909          	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
   \                     ??chk_mounted_14: (+1)
   \   00000100   0x6C60             LDR      R0,[R4, #+68]
   \   00000102   0x7DC0             LDRB     R0,[R0, #+23]
   \   00000104   0x0207             LSLS     R7,R0,#+8
   \   00000106   0x6C60             LDR      R0,[R4, #+68]
   \   00000108   0x7D80             LDRB     R0,[R0, #+22]
   \   0000010A   0x4307             ORRS     R7,R7,R0
   \   0000010C   0xB2BF             UXTH     R7,R7
   2910          	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
   \   0000010E   0x2F00             CMP      R7,#+0
   \   00000110   0xD111             BNE      ??chk_mounted_15
   \   00000112   0x6C60             LDR      R0,[R4, #+68]
   \   00000114   0x3027             ADDS     R0,R0,#+39
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0x0600             LSLS     R0,R0,#+24
   \   0000011A   0x6C61             LDR      R1,[R4, #+68]
   \   0000011C   0x3126             ADDS     R1,R1,#+38
   \   0000011E   0x7809             LDRB     R1,[R1, #+0]
   \   00000120   0x0409             LSLS     R1,R1,#+16
   \   00000122   0x4301             ORRS     R1,R1,R0
   \   00000124   0x6C60             LDR      R0,[R4, #+68]
   \   00000126   0x3025             ADDS     R0,R0,#+37
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0x0200             LSLS     R0,R0,#+8
   \   0000012C   0x4308             ORRS     R0,R0,R1
   \   0000012E   0x6C61             LDR      R1,[R4, #+68]
   \   00000130   0x3124             ADDS     R1,R1,#+36
   \   00000132   0x780F             LDRB     R7,[R1, #+0]
   \   00000134   0x4307             ORRS     R7,R7,R0
   2911          	fs->fsize = fasize;
   \                     ??chk_mounted_15: (+1)
   \   00000136   0x6227             STR      R7,[R4, #+32]
   2912          
   2913          	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
   \   00000138   0x6C60             LDR      R0,[R4, #+68]
   \   0000013A   0x7C00             LDRB     R0,[R0, #+16]
   \   0000013C   0x70E0             STRB     R0,[R4, #+3]
   2914          	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
   \   0000013E   0xB2C0             UXTB     R0,R0
   \   00000140   0x2801             CMP      R0,#+1
   \   00000142   0xD004             BEQ      ??chk_mounted_16
   \   00000144   0xB2C0             UXTB     R0,R0
   \   00000146   0x2802             CMP      R0,#+2
   \   00000148   0xD001             BEQ      ??chk_mounted_16
   \   0000014A   0x200D             MOVS     R0,#+13
   \   0000014C   0xE145             B        ??chk_mounted_4
   2915          	fasize *= b;										/* Number of sectors for FAT area */
   \                     ??chk_mounted_16: (+1)
   \   0000014E   0xB2C0             UXTB     R0,R0
   \   00000150   0x4347             MULS     R7,R0,R7
   2916          
   2917          	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
   \   00000152   0x6C60             LDR      R0,[R4, #+68]
   \   00000154   0x7B40             LDRB     R0,[R0, #+13]
   \   00000156   0x70A0             STRB     R0,[R4, #+2]
   2918          	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   \   00000158   0xB2C0             UXTB     R0,R0
   \   0000015A   0x2800             CMP      R0,#+0
   \   0000015C   0xD003             BEQ      ??chk_mounted_17
   \   0000015E   0x1E41             SUBS     R1,R0,#+1
   \   00000160   0xB2C0             UXTB     R0,R0
   \   00000162   0x4208             TST      R0,R1
   \   00000164   0xD001             BEQ      ??chk_mounted_18
   \                     ??chk_mounted_17: (+1)
   \   00000166   0x200D             MOVS     R0,#+13
   \   00000168   0xE137             B        ??chk_mounted_4
   2919          
   2920          	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
   \                     ??chk_mounted_18: (+1)
   \   0000016A   0x6C60             LDR      R0,[R4, #+68]
   \   0000016C   0x7C80             LDRB     R0,[R0, #+18]
   \   0000016E   0x0200             LSLS     R0,R0,#+8
   \   00000170   0x6C61             LDR      R1,[R4, #+68]
   \   00000172   0x7C49             LDRB     R1,[R1, #+17]
   \   00000174   0x4308             ORRS     R0,R0,R1
   \   00000176   0x8120             STRH     R0,[R4, #+8]
   2921          	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
   \   00000178   0x8920             LDRH     R0,[R4, #+8]
   \   0000017A   0x2110             MOVS     R1,#+16
   \   0000017C   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000180   0x2900             CMP      R1,#+0
   \   00000182   0xD001             BEQ      ??chk_mounted_19
   \   00000184   0x200D             MOVS     R0,#+13
   \   00000186   0xE128             B        ??chk_mounted_4
   2922          
   2923          	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
   \                     ??chk_mounted_19: (+1)
   \   00000188   0x6C60             LDR      R0,[R4, #+68]
   \   0000018A   0x7D00             LDRB     R0,[R0, #+20]
   \   0000018C   0x0200             LSLS     R0,R0,#+8
   \   0000018E   0x6C61             LDR      R1,[R4, #+68]
   \   00000190   0x7CC9             LDRB     R1,[R1, #+19]
   \   00000192   0x4308             ORRS     R0,R0,R1
   \   00000194   0xB280             UXTH     R0,R0
   2924          	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
   \   00000196   0x2800             CMP      R0,#+0
   \   00000198   0xD111             BNE      ??chk_mounted_20
   \   0000019A   0x6C60             LDR      R0,[R4, #+68]
   \   0000019C   0x3023             ADDS     R0,R0,#+35
   \   0000019E   0x7800             LDRB     R0,[R0, #+0]
   \   000001A0   0x0600             LSLS     R0,R0,#+24
   \   000001A2   0x6C61             LDR      R1,[R4, #+68]
   \   000001A4   0x3122             ADDS     R1,R1,#+34
   \   000001A6   0x7809             LDRB     R1,[R1, #+0]
   \   000001A8   0x0409             LSLS     R1,R1,#+16
   \   000001AA   0x4301             ORRS     R1,R1,R0
   \   000001AC   0x6C60             LDR      R0,[R4, #+68]
   \   000001AE   0x3021             ADDS     R0,R0,#+33
   \   000001B0   0x7800             LDRB     R0,[R0, #+0]
   \   000001B2   0x0202             LSLS     R2,R0,#+8
   \   000001B4   0x430A             ORRS     R2,R2,R1
   \   000001B6   0x6C60             LDR      R0,[R4, #+68]
   \   000001B8   0x3020             ADDS     R0,R0,#+32
   \   000001BA   0x7800             LDRB     R0,[R0, #+0]
   \   000001BC   0x4310             ORRS     R0,R0,R2
   2925          
   2926          	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
   \                     ??chk_mounted_20: (+1)
   \   000001BE   0x6C61             LDR      R1,[R4, #+68]
   \   000001C0   0x7BC9             LDRB     R1,[R1, #+15]
   \   000001C2   0x0209             LSLS     R1,R1,#+8
   \   000001C4   0x6C62             LDR      R2,[R4, #+68]
   \   000001C6   0x7B92             LDRB     R2,[R2, #+14]
   \   000001C8   0x4311             ORRS     R1,R1,R2
   \   000001CA   0x466A             MOV      R2,SP
   \   000001CC   0x8011             STRH     R1,[R2, #+0]
   2927          	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
   \   000001CE   0x4669             MOV      R1,SP
   \   000001D0   0x8809             LDRH     R1,[R1, #+0]
   \   000001D2   0x2900             CMP      R1,#+0
   \   000001D4   0xD101             BNE      ??chk_mounted_21
   \   000001D6   0x200D             MOVS     R0,#+13
   \   000001D8   0xE0FF             B        ??chk_mounted_4
   2928          
   2929          	/* Determine the FAT sub type */
   2930          	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
   \                     ??chk_mounted_21: (+1)
   \   000001DA   0x4669             MOV      R1,SP
   \   000001DC   0x8809             LDRH     R1,[R1, #+0]
   \   000001DE   0x19C9             ADDS     R1,R1,R7
   \   000001E0   0x8922             LDRH     R2,[R4, #+8]
   \   000001E2   0x0912             LSRS     R2,R2,#+4
   \   000001E4   0x1889             ADDS     R1,R1,R2
   \   000001E6   0x9101             STR      R1,[SP, #+4]
   2931          	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   \   000001E8   0x9901             LDR      R1,[SP, #+4]
   \   000001EA   0x4288             CMP      R0,R1
   \   000001EC   0xD201             BCS      ??chk_mounted_22
   \   000001EE   0x200D             MOVS     R0,#+13
   \   000001F0   0xE0F3             B        ??chk_mounted_4
   2932          	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   \                     ??chk_mounted_22: (+1)
   \   000001F2   0x9901             LDR      R1,[SP, #+4]
   \   000001F4   0x1A40             SUBS     R0,R0,R1
   \   000001F6   0x78A1             LDRB     R1,[R4, #+2]
   \   000001F8   0x.... 0x....      BL       __aeabi_uidiv
   2933          	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD101             BNE      ??chk_mounted_23
   \   00000200   0x200D             MOVS     R0,#+13
   \   00000202   0xE0EA             B        ??chk_mounted_4
   2934          	fmt = FS_FAT12;
   \                     ??chk_mounted_23: (+1)
   \   00000204   0x2501             MOVS     R5,#+1
   2935          	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   \   00000206   0x....             LDR      R1,??DataTable14  ;; 0xff6
   \   00000208   0x4288             CMP      R0,R1
   \   0000020A   0xD300             BCC      ??chk_mounted_24
   \   0000020C   0x2502             MOVS     R5,#+2
   2936          	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   \                     ??chk_mounted_24: (+1)
   \   0000020E   0x....             LDR      R1,??DataTable14_1  ;; 0xfff6
   \   00000210   0x4288             CMP      R0,R1
   \   00000212   0xD300             BCC      ??chk_mounted_25
   \   00000214   0x2503             MOVS     R5,#+3
   2937          
   2938          	/* Boundaries and Limits */
   2939          	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   \                     ??chk_mounted_25: (+1)
   \   00000216   0x1C80             ADDS     R0,R0,#+2
   \   00000218   0x61E0             STR      R0,[R4, #+28]
   2940          	fs->volbase = bsect;								/* Volume start sector */
   \   0000021A   0x6266             STR      R6,[R4, #+36]
   2941          	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   \   0000021C   0x4668             MOV      R0,SP
   \   0000021E   0x8800             LDRH     R0,[R0, #+0]
   \   00000220   0x1830             ADDS     R0,R6,R0
   \   00000222   0x62A0             STR      R0,[R4, #+40]
   2942          	fs->database = bsect + sysect;						/* Data start sector */
   \   00000224   0x9801             LDR      R0,[SP, #+4]
   \   00000226   0x1830             ADDS     R0,R6,R0
   \   00000228   0x6320             STR      R0,[R4, #+48]
   2943          	if (fmt == FS_FAT32) {
   \   0000022A   0xB2ED             UXTB     R5,R5
   \   0000022C   0x2D03             CMP      R5,#+3
   \   0000022E   0xD11B             BNE      ??chk_mounted_26
   2944          		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   \   00000230   0x8920             LDRH     R0,[R4, #+8]
   \   00000232   0x2800             CMP      R0,#+0
   \   00000234   0xD001             BEQ      ??chk_mounted_27
   \   00000236   0x200D             MOVS     R0,#+13
   \   00000238   0xE0CF             B        ??chk_mounted_4
   2945          		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
   \                     ??chk_mounted_27: (+1)
   \   0000023A   0x6C60             LDR      R0,[R4, #+68]
   \   0000023C   0x302F             ADDS     R0,R0,#+47
   \   0000023E   0x7800             LDRB     R0,[R0, #+0]
   \   00000240   0x0600             LSLS     R0,R0,#+24
   \   00000242   0x6C61             LDR      R1,[R4, #+68]
   \   00000244   0x312E             ADDS     R1,R1,#+46
   \   00000246   0x7809             LDRB     R1,[R1, #+0]
   \   00000248   0x0409             LSLS     R1,R1,#+16
   \   0000024A   0x4301             ORRS     R1,R1,R0
   \   0000024C   0x6C60             LDR      R0,[R4, #+68]
   \   0000024E   0x302D             ADDS     R0,R0,#+45
   \   00000250   0x7800             LDRB     R0,[R0, #+0]
   \   00000252   0x0200             LSLS     R0,R0,#+8
   \   00000254   0x4308             ORRS     R0,R0,R1
   \   00000256   0x6C61             LDR      R1,[R4, #+68]
   \   00000258   0x312C             ADDS     R1,R1,#+44
   \   0000025A   0x7809             LDRB     R1,[R1, #+0]
   \   0000025C   0x4301             ORRS     R1,R1,R0
   \   0000025E   0x62E1             STR      R1,[R4, #+44]
   2946          		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
   \   00000260   0x69E0             LDR      R0,[R4, #+28]
   \   00000262   0x2104             MOVS     R1,#+4
   \   00000264   0x4348             MULS     R0,R1,R0
   \   00000266   0xE017             B        ??chk_mounted_28
   2947          	} else {
   2948          		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
   \                     ??chk_mounted_26: (+1)
   \   00000268   0x8920             LDRH     R0,[R4, #+8]
   \   0000026A   0x2800             CMP      R0,#+0
   \   0000026C   0xD101             BNE      ??chk_mounted_29
   \   0000026E   0x200D             MOVS     R0,#+13
   \   00000270   0xE0B3             B        ??chk_mounted_4
   2949          		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   \                     ??chk_mounted_29: (+1)
   \   00000272   0x6AA0             LDR      R0,[R4, #+40]
   \   00000274   0x19C0             ADDS     R0,R0,R7
   \   00000276   0x62E0             STR      R0,[R4, #+44]
   2950          		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
   2951          			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   \   00000278   0xB2ED             UXTB     R5,R5
   \   0000027A   0x2D02             CMP      R5,#+2
   \   0000027C   0xD103             BNE      ??chk_mounted_30
   \   0000027E   0x69E0             LDR      R0,[R4, #+28]
   \   00000280   0x2102             MOVS     R1,#+2
   \   00000282   0x4348             MULS     R0,R1,R0
   \   00000284   0xE008             B        ??chk_mounted_28
   \                     ??chk_mounted_30: (+1)
   \   00000286   0x69E0             LDR      R0,[R4, #+28]
   \   00000288   0x2103             MOVS     R1,#+3
   \   0000028A   0x4348             MULS     R0,R1,R0
   \   0000028C   0x0840             LSRS     R0,R0,#+1
   \   0000028E   0x7F21             LDRB     R1,[R4, #+28]
   \   00000290   0x000A             MOVS     R2,R1
   \   00000292   0x07D2             LSLS     R2,R2,#+31       ;; ZeroExtS R2,R2,#+31,#+31
   \   00000294   0x0FD2             LSRS     R2,R2,#+31
   \   00000296   0x1880             ADDS     R0,R0,R2
   2952          	}
   2953          	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
   \                     ??chk_mounted_28: (+1)
   \   00000298   0x6A21             LDR      R1,[R4, #+32]
   \   0000029A   0x....             LDR      R2,??DataTable14_2  ;; 0x1ff
   \   0000029C   0x1880             ADDS     R0,R0,R2
   \   0000029E   0x0A40             LSRS     R0,R0,#+9
   \   000002A0   0x4281             CMP      R1,R0
   \   000002A2   0xD205             BCS      ??chk_mounted_31
   2954          		return FR_NO_FILESYSTEM;
   \   000002A4   0x200D             MOVS     R0,#+13
   \   000002A6   0xE098             B        ??chk_mounted_4
   \                     ??chk_mounted_2:
   \   000002A8   0x........         DC32     CurrVol
   \   000002AC   0x........         DC32     FatFs
   2955          
   2956          #if !_FS_READONLY
   2957          	/* Initialize cluster allocation information */
   2958          	fs->free_clust = 0xFFFFFFFF;
   \                     ??chk_mounted_31: (+1)
   \   000002B0   0x2000             MOVS     R0,#+0
   \   000002B2   0x43C0             MVNS     R0,R0            ;; #-1
   \   000002B4   0x6120             STR      R0,[R4, #+16]
   2959          	fs->last_clust = 0;
   \   000002B6   0x2000             MOVS     R0,#+0
   \   000002B8   0x60E0             STR      R0,[R4, #+12]
   2960          
   2961          	/* Get fsinfo if available */
   2962          	if (fmt == FS_FAT32) {
   \   000002BA   0xB2ED             UXTB     R5,R5
   \   000002BC   0x2D03             CMP      R5,#+3
   \   000002BE   0xD179             BNE      ??chk_mounted_32
   2963          	 	fs->fsi_flag = 0;
   \   000002C0   0x2000             MOVS     R0,#+0
   \   000002C2   0x7160             STRB     R0,[R4, #+5]
   2964          		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
   \   000002C4   0x6C60             LDR      R0,[R4, #+68]
   \   000002C6   0x3031             ADDS     R0,R0,#+49
   \   000002C8   0x7800             LDRB     R0,[R0, #+0]
   \   000002CA   0x0200             LSLS     R0,R0,#+8
   \   000002CC   0x6C61             LDR      R1,[R4, #+68]
   \   000002CE   0x3130             ADDS     R1,R1,#+48
   \   000002D0   0x7809             LDRB     R1,[R1, #+0]
   \   000002D2   0x4308             ORRS     R0,R0,R1
   \   000002D4   0xB280             UXTH     R0,R0
   \   000002D6   0x1830             ADDS     R0,R6,R0
   \   000002D8   0x6160             STR      R0,[R4, #+20]
   2965          		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
   2966          			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
   2967          			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
   2968          			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
   \   000002DA   0x2301             MOVS     R3,#+1
   \   000002DC   0x6962             LDR      R2,[R4, #+20]
   \   000002DE   0x6C61             LDR      R1,[R4, #+68]
   \   000002E0   0x7860             LDRB     R0,[R4, #+1]
   \   000002E2   0x.... 0x....      BL       disk_read
   \   000002E6   0x2800             CMP      R0,#+0
   \   000002E8   0xD164             BNE      ??chk_mounted_32
   \   000002EA   0x6C60             LDR      R0,[R4, #+68]
   \   000002EC   0x....             LDR      R1,??DataTable14_2  ;; 0x1ff
   \   000002EE   0x5C40             LDRB     R0,[R0, R1]
   \   000002F0   0x0200             LSLS     R0,R0,#+8
   \   000002F2   0x6C61             LDR      R1,[R4, #+68]
   \   000002F4   0x22FF             MOVS     R2,#+255
   \   000002F6   0x0052             LSLS     R2,R2,#+1        ;; #+510
   \   000002F8   0x5C89             LDRB     R1,[R1, R2]
   \   000002FA   0x4308             ORRS     R0,R0,R1
   \   000002FC   0xB280             UXTH     R0,R0
   \   000002FE   0x....             LDR      R1,??DataTable14_3  ;; 0xaa55
   \   00000300   0x4288             CMP      R0,R1
   \   00000302   0xD157             BNE      ??chk_mounted_32
   \   00000304   0x6C60             LDR      R0,[R4, #+68]
   \   00000306   0x78C0             LDRB     R0,[R0, #+3]
   \   00000308   0x0600             LSLS     R0,R0,#+24
   \   0000030A   0x6C61             LDR      R1,[R4, #+68]
   \   0000030C   0x7889             LDRB     R1,[R1, #+2]
   \   0000030E   0x0409             LSLS     R1,R1,#+16
   \   00000310   0x4301             ORRS     R1,R1,R0
   \   00000312   0x6C60             LDR      R0,[R4, #+68]
   \   00000314   0x7840             LDRB     R0,[R0, #+1]
   \   00000316   0x0200             LSLS     R0,R0,#+8
   \   00000318   0x4308             ORRS     R0,R0,R1
   \   0000031A   0x6C61             LDR      R1,[R4, #+68]
   \   0000031C   0x7809             LDRB     R1,[R1, #+0]
   \   0000031E   0x4301             ORRS     R1,R1,R0
   \   00000320   0x....             LDR      R0,??DataTable15  ;; 0x41615252
   \   00000322   0x4281             CMP      R1,R0
   \   00000324   0xD146             BNE      ??chk_mounted_32
   \   00000326   0x6C60             LDR      R0,[R4, #+68]
   \   00000328   0x21FF             MOVS     R1,#+255
   \   0000032A   0x31E8             ADDS     R1,R1,#+232      ;; #+487
   \   0000032C   0x5C40             LDRB     R0,[R0, R1]
   \   0000032E   0x0600             LSLS     R0,R0,#+24
   \   00000330   0x6C61             LDR      R1,[R4, #+68]
   \   00000332   0x22F3             MOVS     R2,#+243
   \   00000334   0x0052             LSLS     R2,R2,#+1        ;; #+486
   \   00000336   0x5C89             LDRB     R1,[R1, R2]
   \   00000338   0x0409             LSLS     R1,R1,#+16
   \   0000033A   0x4301             ORRS     R1,R1,R0
   \   0000033C   0x6C60             LDR      R0,[R4, #+68]
   \   0000033E   0x22FF             MOVS     R2,#+255
   \   00000340   0x32E6             ADDS     R2,R2,#+230      ;; #+485
   \   00000342   0x5C80             LDRB     R0,[R0, R2]
   \   00000344   0x0200             LSLS     R0,R0,#+8
   \   00000346   0x4308             ORRS     R0,R0,R1
   \   00000348   0x6C61             LDR      R1,[R4, #+68]
   \   0000034A   0x22F2             MOVS     R2,#+242
   \   0000034C   0x0052             LSLS     R2,R2,#+1        ;; #+484
   \   0000034E   0x5C89             LDRB     R1,[R1, R2]
   \   00000350   0x4301             ORRS     R1,R1,R0
   \   00000352   0x....             LDR      R0,??DataTable15_1  ;; 0x61417272
   \   00000354   0x4281             CMP      R1,R0
   \   00000356   0xD12D             BNE      ??chk_mounted_32
   2969          				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   \   00000358   0x6C60             LDR      R0,[R4, #+68]
   \   0000035A   0x21FF             MOVS     R1,#+255
   \   0000035C   0x31F0             ADDS     R1,R1,#+240      ;; #+495
   \   0000035E   0x5C40             LDRB     R0,[R0, R1]
   \   00000360   0x0600             LSLS     R0,R0,#+24
   \   00000362   0x6C61             LDR      R1,[R4, #+68]
   \   00000364   0x22F7             MOVS     R2,#+247
   \   00000366   0x0052             LSLS     R2,R2,#+1        ;; #+494
   \   00000368   0x5C89             LDRB     R1,[R1, R2]
   \   0000036A   0x0409             LSLS     R1,R1,#+16
   \   0000036C   0x4301             ORRS     R1,R1,R0
   \   0000036E   0x6C60             LDR      R0,[R4, #+68]
   \   00000370   0x22FF             MOVS     R2,#+255
   \   00000372   0x32EE             ADDS     R2,R2,#+238      ;; #+493
   \   00000374   0x5C80             LDRB     R0,[R0, R2]
   \   00000376   0x0200             LSLS     R0,R0,#+8
   \   00000378   0x4308             ORRS     R0,R0,R1
   \   0000037A   0x6C61             LDR      R1,[R4, #+68]
   \   0000037C   0x22F6             MOVS     R2,#+246
   \   0000037E   0x0052             LSLS     R2,R2,#+1        ;; #+492
   \   00000380   0x5C89             LDRB     R1,[R1, R2]
   \   00000382   0x4301             ORRS     R1,R1,R0
   \   00000384   0x60E1             STR      R1,[R4, #+12]
   2970          				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   \   00000386   0x6C60             LDR      R0,[R4, #+68]
   \   00000388   0x21FF             MOVS     R1,#+255
   \   0000038A   0x31EC             ADDS     R1,R1,#+236      ;; #+491
   \   0000038C   0x5C40             LDRB     R0,[R0, R1]
   \   0000038E   0x0600             LSLS     R0,R0,#+24
   \   00000390   0x6C61             LDR      R1,[R4, #+68]
   \   00000392   0x22F5             MOVS     R2,#+245
   \   00000394   0x0052             LSLS     R2,R2,#+1        ;; #+490
   \   00000396   0x5C89             LDRB     R1,[R1, R2]
   \   00000398   0x0409             LSLS     R1,R1,#+16
   \   0000039A   0x4301             ORRS     R1,R1,R0
   \   0000039C   0x6C60             LDR      R0,[R4, #+68]
   \   0000039E   0x22FF             MOVS     R2,#+255
   \   000003A0   0x32EA             ADDS     R2,R2,#+234      ;; #+489
   \   000003A2   0x5C80             LDRB     R0,[R0, R2]
   \   000003A4   0x0200             LSLS     R0,R0,#+8
   \   000003A6   0x4308             ORRS     R0,R0,R1
   \   000003A8   0x6C61             LDR      R1,[R4, #+68]
   \   000003AA   0x22F4             MOVS     R2,#+244
   \   000003AC   0x0052             LSLS     R2,R2,#+1        ;; #+488
   \   000003AE   0x5C89             LDRB     R1,[R1, R2]
   \   000003B0   0x4301             ORRS     R1,R1,R0
   \   000003B2   0x6121             STR      R1,[R4, #+16]
   2971          		}
   2972          	}
   2973          #endif
   2974          	fs->fs_type = fmt;		/* FAT sub-type */
   \                     ??chk_mounted_32: (+1)
   \   000003B4   0x7025             STRB     R5,[R4, #+0]
   2975          	fs->id = ++Fsid;		/* File system mount ID */
   \   000003B6   0x....             LDR      R0,??DataTable15_2
   \   000003B8   0x8800             LDRH     R0,[R0, #+0]
   \   000003BA   0x1C40             ADDS     R0,R0,#+1
   \   000003BC   0x....             LDR      R1,??DataTable15_2
   \   000003BE   0x8008             STRH     R0,[R1, #+0]
   \   000003C0   0x....             LDR      R0,??DataTable15_2
   \   000003C2   0x8800             LDRH     R0,[R0, #+0]
   \   000003C4   0x80E0             STRH     R0,[R4, #+6]
   2976          	fs->winsect = 0;		/* Invalidate sector cache */
   \   000003C6   0x2000             MOVS     R0,#+0
   \   000003C8   0x6360             STR      R0,[R4, #+52]
   2977          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   2978                  clear_buff(fs);
   \   000003CA   0x0020             MOVS     R0,R4
   \   000003CC   0x.... 0x....      BL       clear_buff
   2979          #endif
   2980          	clear_alldirty(fs);
   \   000003D0   0x2000             MOVS     R0,#+0
   \   000003D2   0x7120             STRB     R0,[R4, #+4]
   2981          #if _FS_RPATH
   2982          	fs->cdir = 0;			/* Current directory (root dir) */
   \   000003D4   0x2000             MOVS     R0,#+0
   \   000003D6   0x61A0             STR      R0,[R4, #+24]
   2983          #endif
   2984          #if _FS_LOCK				/* Clear file lock semaphores */
   2985          	clear_lock(fs);
   2986          #endif
   2987          
   2988          	return FR_OK;
   \   000003D8   0x2000             MOVS     R0,#+0
   \                     ??chk_mounted_4: (+1)
   \   000003DA   0xBDFE             POP      {R1-R7,PC}       ;; return
   2989          }
   2990          
   2991          
   2992          
   2993          
   2994          /*FUNCTION*-------------------------------------------------------------------
   2995          *
   2996          * Function Name    : validate
   2997          * Returned Value   : FR_OK(0): The object is valid
   2998          *                    !=0: Invalid
   2999          * Comments         : Check if the file/dir object is valid or not 
   3000          *   
   3001          *END*----------------------------------------------------------------------*/
   3002          //_FS_REENTRANTENTER_FFlock

   \                                 In section .text, align 2, keep-with-next
   3003          static FRESULT validate
   3004          (
   3005              /* [IN] Pointer to the object FIL/DIR to check validity */
   3006          	void* obj
   3007          )
   3008          {
   \                     validate: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3009          	FIL *fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
   3010          
   3011          
   3012          	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00B             BEQ      ??validate_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD008             BEQ      ??validate_0
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD004             BEQ      ??validate_0
   \   00000014   0x6801             LDR      R1,[R0, #+0]
   \   00000016   0x88C9             LDRH     R1,[R1, #+6]
   \   00000018   0x8882             LDRH     R2,[R0, #+4]
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xD001             BEQ      ??validate_1
   3013          		return FR_INVALID_OBJECT;
   \                     ??validate_0: (+1)
   \   0000001E   0x2009             MOVS     R0,#+9
   \   00000020   0xE008             B        ??validate_2
   3014          
   3015          	ENTER_FF(fil->fs);		/* Lock file system */
   3016          
   3017          	if (disk_status(fil->fs->drv) & STA_NOINIT)
   \                     ??validate_1: (+1)
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x7840             LDRB     R0,[R0, #+1]
   \   00000026   0x.... 0x....      BL       disk_status
   \   0000002A   0x07C0             LSLS     R0,R0,#+31
   \   0000002C   0xD501             BPL      ??validate_3
   3018          		return FR_NOT_READY;
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0xE000             B        ??validate_2
   3019          
   3020          	return FR_OK;
   \                     ??validate_3: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??validate_2: (+1)
   \   00000034   0xBD02             POP      {R1,PC}          ;; return
   3021          }
   3022          
   3023          
   3024          
   3025          
   3026          /*--------------------------------------------------------------------------
   3027          
   3028             Public Functions
   3029          
   3030          --------------------------------------------------------------------------*/
   3031          
   3032          
   3033          
   3034          /*FUNCTION*-------------------------------------------------------------------
   3035          *
   3036          * Function Name    : f_mount
   3037          * Returned Value   : FR_OK (0): successful
   3038          *                    FR_INVALID_DRIVE: The drive number is invalid.
   3039          * Comments         : The f_mount function registers/unregisters a work area to the FatFs module.
   3040          *                    The work area must be given to the each volume with this function prior to 
   3041          *                    use any other file function. To unregister a work area, specify a NULL to 
   3042          *                    the FileSystemObject, and then the work area can be discarded.
   3043          *
   3044          *                    This function always succeeds regardless of the drive status. No media 
   3045          *                    access is occured in this function and it only initializes the given 
   3046          *                    work area and registers its address to the internal table. 
   3047          *                    The volume mount process is performed on first file access after 
   3048          *                    f_mount function or media change
   3049          *   
   3050          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3051          FRESULT f_mount 
   3052            (
   3053              /* [IN] Logical drive number to be mounted/unmounted */
   3054            	uint8_t vol,	
   3055            	/* [IN] Pointer to new file system object (NULL for unmount)*/	
   3056            	FATFS *fs		
   3057            )
   3058          {
   \                     f_mount: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   3059          	FATFS *rfs;
   3060          
   3061          
   3062          	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
   \   00000006   0xB2ED             UXTB     R5,R5
   \   00000008   0x2D02             CMP      R5,#+2
   \   0000000A   0xDB01             BLT      ??f_mount_0
   3063          		return FR_INVALID_DRIVE;
   \   0000000C   0x200B             MOVS     R0,#+11
   \   0000000E   0xE015             B        ??f_mount_1
   3064          	rfs = FatFs[vol];			/* Get current fs object */
   \                     ??f_mount_0: (+1)
   \   00000010   0x....             LDR      R0,??DataTable15_3
   \   00000012   0xB2ED             UXTB     R5,R5
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x4369             MULS     R1,R5,R1
   \   00000018   0x5840             LDR      R0,[R0, R1]
   3065          
   3066          	if (rfs) {
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ      ??f_mount_2
   3067          #if _FS_LOCK
   3068          		clear_lock(rfs);
   3069          #endif
   3070          #if _FS_REENTRANT				/* Discard sync object of the current volume */
   3071          		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
   3072          #endif
   3073          		rfs->fs_type = 0;		/* Clear old fs object */
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   3074          	}
   3075          
   3076          	if (fs) {
   \                     ??f_mount_2: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD004             BEQ      ??f_mount_3
   3077          		fs->fs_type = 0;		/* Clear new fs object */
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   3078          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3079                      clear_buff(fs);
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       clear_buff
   3080          #endif
   3081          #if _FS_REENTRANT				/* Create sync object for the new volume */
   3082          		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
   3083          #endif
   3084          	}
   3085          	FatFs[vol] = fs;			/* Register new fs object */
   \                     ??f_mount_3: (+1)
   \   00000030   0x....             LDR      R0,??DataTable15_3
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2104             MOVS     R1,#+4
   \   00000036   0x434D             MULS     R5,R1,R5
   \   00000038   0x5144             STR      R4,[R0, R5]
   3086          
   3087          	return FR_OK;
   \   0000003A   0x2000             MOVS     R0,#+0
   \                     ??f_mount_1: (+1)
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3088          }
   3089          
   3090          /*FUNCTION*-------------------------------------------------------------------
   3091          *
   3092          * Function Name    : f_open
   3093          * Returned Value   : FR_OK (0): The function succeeded and the file object is valid.
   3094          *                    FR_NO_FILE: Could not find the file.
   3095          *                    FR_NO_PATH: Could not find the path.
   3096          *                    FR_INVALID_NAME: The file name is invalid.
   3097          *                    FR_INVALID_DRIVE: The drive number is invalid.
   3098          *                    FR_EXIST: The file is already existing.
   3099          *                    FR_DENIED :The required access was denied due to one of the following reasons:
   3100          *                               Write mode open against a read-only file.
   3101          *                               File cannot be created due to a directory or read-only file is existing.
   3102          *                               File cannot be created due to the directory table is full.
   3103          *                    FR_NOT_READY: The disk drive cannot work due to no medium in the drive or any other reason.
   3104          *                    FR_WRITE_PROTECTED: Write mode open or creation under the medium is write protected.
   3105          *                    FR_DISK_ERR: The function failed due to an error in the disk function.
   3106          *                    FR_INT_ERR: The function failed due to a wrong FAT structure or an internal error.
   3107          *                    FR_NOT_ENABLED: The logical drive has no work area.
   3108          *                    FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   3109          *                    FR_LOCKED: The function was rejected due to file shareing policy (_FS_SHARE). 
   3110          *                    
   3111          * Comments         : A file object is created when the function succeeded. 
   3112          *                    The file object is used for subsequent read/write functions
   3113          *                    to refer to the file. When close an open file object, use 
   3114          *                    f_close function. If the modified file is not closed, 
   3115          *                    the file data can be collapsed
   3116          *   
   3117          *END*----------------------------------------------------------------------*/
   3118          

   \                                 In section .text, align 2, keep-with-next
   3119          FRESULT f_open 
   3120          (
   3121            /* [OUT] Pointer to the blank file object */
   3122          	FIL *fp,			
   3123          	/* [IN] Pointer to the file name */
   3124          	const TCHAR *path,
   3125          	/* [IN] Access mode and file open mode flags */	
   3126          	uint8_t mode			
   3127          )
   3128          {
   \                     f_open: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB08F             SUB      SP,SP,#+60
   \   00000004   0x0016             MOVS     R6,R2
   3129          	FRESULT res;
   3130          	DIR dj;
   3131          	uint8_t *dir;
   3132          	DEF_NAMEBUF;
   3133          
   3134          
   3135          	if (!fp) return FR_INVALID_OBJECT;
   \   00000006   0x980F             LDR      R0,[SP, #+60]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE      ??f_open_0
   \   0000000C   0x2009             MOVS     R0,#+9
   \   0000000E   0xE0DA             B        ??f_open_1
   3136          	fp->fs = 0;			/* Clear file object */
   \                     ??f_open_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x990F             LDR      R1,[SP, #+60]
   \   00000014   0x6008             STR      R0,[R1, #+0]
   3137          
   3138          #if !_FS_READONLY
   3139          	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   \   00000016   0x06F6             LSLS     R6,R6,#+27       ;; ZeroExtS R6,R6,#+27,#+27
   \   00000018   0x0EF6             LSRS     R6,R6,#+27
   3140          	res = chk_mounted(&path, &dj.fs, (uint8_t)(mode & ~FA_READ));
   \   0000001A   0x22FE             MOVS     R2,#+254
   \   0000001C   0x4032             ANDS     R2,R2,R6
   \   0000001E   0xA902             ADD      R1,SP,#+8
   \   00000020   0xA810             ADD      R0,SP,#+64
   \   00000022   0x.... 0x....      BL       chk_mounted
   \   00000026   0x0004             MOVS     R4,R0
   3141          #else
   3142          	mode &= FA_READ;
   3143          	res = chk_mounted(&path, &dj.fs, 0);
   3144          #endif
   3145          	if (res == FR_OK) {
   \   00000028   0xB2E4             UXTB     R4,R4
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD000             BEQ      .+4
   \   0000002E   0xE0C8             B        ??f_open_2
   3146          		INIT_BUF(dj);
   \   00000030   0x2080             MOVS     R0,#+128
   \   00000032   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000034   0x.... 0x....      BL       ff_memalloc
   \   00000038   0x9001             STR      R0,[SP, #+4]
   \   0000003A   0x9801             LDR      R0,[SP, #+4]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD101             BNE      ??f_open_3
   \   00000040   0x2011             MOVS     R0,#+17
   \   00000042   0xE0C0             B        ??f_open_1
   \                     ??f_open_3: (+1)
   \   00000044   0x9801             LDR      R0,[SP, #+4]
   \   00000046   0x9009             STR      R0,[SP, #+36]
   \   00000048   0xA80B             ADD      R0,SP,#+44
   \   0000004A   0x9008             STR      R0,[SP, #+32]
   3147          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3148                          /* need to create directory entry, do not let invalid free entry affect alloc entry */
   3149                          if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW))
   \   0000004C   0x201C             MOVS     R0,#+28
   \   0000004E   0x4206             TST      R6,R0
   \   00000050   0xD005             BEQ      ??f_open_4
   3150                          {
   3151                              entry_start_clust = 0;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x....             LDR      R1,??DataTable15_4
   \   00000056   0x6008             STR      R0,[R1, #+0]
   3152                              entry_start_free_index = 0;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x....             LDR      R1,??DataTable15_5
   \   0000005C   0x8008             STRH     R0,[R1, #+0]
   3153                          }
   3154          #endif
   3155          		res = follow_path(&dj, path);	/* Follow the file path */
   \                     ??f_open_4: (+1)
   \   0000005E   0x9910             LDR      R1,[SP, #+64]
   \   00000060   0xA802             ADD      R0,SP,#+8
   \   00000062   0x.... 0x....      BL       follow_path
   \   00000066   0x0004             MOVS     R4,R0
   3156          		dir = convert_ptr(dj.fs, dj.dir);
   \   00000068   0x9907             LDR      R1,[SP, #+28]
   \   0000006A   0x9802             LDR      R0,[SP, #+8]
   \   0000006C   0x.... 0x....      BL       convert_ptr
   \   00000070   0x0005             MOVS     R5,R0
   3157          #if !_FS_READONLY	/* R/W configuration */
   3158          		if (res == FR_OK) {
   \   00000072   0xB2E4             UXTB     R4,R4
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD102             BNE      ??f_open_5
   3159          			if (!dir)	/* Current dir itself */
   \   00000078   0x2D00             CMP      R5,#+0
   \   0000007A   0xD100             BNE      ??f_open_5
   3160          				res = FR_INVALID_NAME;
   \   0000007C   0x2406             MOVS     R4,#+6
   3161          #if _FS_LOCK
   3162          			else
   3163          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   3164          #endif
   3165          		}
   3166          		/* Create or Open a file */
   3167          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   \                     ??f_open_5: (+1)
   \   0000007E   0x201C             MOVS     R0,#+28
   \   00000080   0x4206             TST      R6,R0
   \   00000082   0xD05B             BEQ      ??f_open_6
   3168          			uint32_t dw, cl;
   3169          
   3170          			if (res != FR_OK) {					/* No file, create new */
   \   00000084   0xB2E4             UXTB     R4,R4
   \   00000086   0x2C00             CMP      R4,#+0
   \   00000088   0xD00F             BEQ      ??f_open_7
   3171          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   \   0000008A   0xB2E4             UXTB     R4,R4
   \   0000008C   0x2C04             CMP      R4,#+4
   \   0000008E   0xD103             BNE      ??f_open_8
   3172          #if _FS_LOCK
   3173          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   3174          #else
   3175          					res = dir_register(&dj);
   \   00000090   0xA802             ADD      R0,SP,#+8
   \   00000092   0x.... 0x....      BL       dir_register
   \   00000096   0x0004             MOVS     R4,R0
   3176          #endif
   3177          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   \                     ??f_open_8: (+1)
   \   00000098   0x0030             MOVS     R0,R6
   \   0000009A   0x2608             MOVS     R6,#+8
   \   0000009C   0x4306             ORRS     R6,R6,R0
   3178          				dir = convert_ptr(dj.fs, dj.dir);					/* New entry */
   \   0000009E   0x9907             LDR      R1,[SP, #+28]
   \   000000A0   0x9802             LDR      R0,[SP, #+8]
   \   000000A2   0x.... 0x....      BL       convert_ptr
   \   000000A6   0x0005             MOVS     R5,R0
   \   000000A8   0xE008             B        ??f_open_9
   3179          			}
   3180          			else {								/* Any object is already existing */
   3181          				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   \                     ??f_open_7: (+1)
   \   000000AA   0x7AE8             LDRB     R0,[R5, #+11]
   \   000000AC   0x2111             MOVS     R1,#+17
   \   000000AE   0x4208             TST      R0,R1
   \   000000B0   0xD001             BEQ      ??f_open_10
   3182          					res = FR_DENIED;
   \   000000B2   0x2407             MOVS     R4,#+7
   \   000000B4   0xE002             B        ??f_open_9
   3183          				} else {
   3184          					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
   \                     ??f_open_10: (+1)
   \   000000B6   0x0770             LSLS     R0,R6,#+29
   \   000000B8   0xD500             BPL      ??f_open_9
   3185          						res = FR_EXIST;
   \   000000BA   0x2408             MOVS     R4,#+8
   3186          				}
   3187          			}
   3188          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   \                     ??f_open_9: (+1)
   \   000000BC   0xB2E4             UXTB     R4,R4
   \   000000BE   0x2C00             CMP      R4,#+0
   \   000000C0   0xD14A             BNE      ??f_open_11
   \   000000C2   0x0730             LSLS     R0,R6,#+28
   \   000000C4   0xD548             BPL      ??f_open_11
   3189          				dw = get_fattime();					/* Created time */
   \   000000C6   0x.... 0x....      BL       get_fattime
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   3190          				ST_DWORD(dir+DIR_CrtTime, dw);
   \   000000CC   0x9800             LDR      R0,[SP, #+0]
   \   000000CE   0x73A8             STRB     R0,[R5, #+14]
   \   000000D0   0x9800             LDR      R0,[SP, #+0]
   \   000000D2   0xB280             UXTH     R0,R0
   \   000000D4   0x0A00             LSRS     R0,R0,#+8
   \   000000D6   0x73E8             STRB     R0,[R5, #+15]
   \   000000D8   0x9800             LDR      R0,[SP, #+0]
   \   000000DA   0x0C00             LSRS     R0,R0,#+16
   \   000000DC   0x7428             STRB     R0,[R5, #+16]
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   \   000000E0   0x0E00             LSRS     R0,R0,#+24
   \   000000E2   0x7468             STRB     R0,[R5, #+17]
   3191          				dir[DIR_Attr] = 0;					/* Reset attribute */
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x72E8             STRB     R0,[R5, #+11]
   3192          				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x7728             STRB     R0,[R5, #+28]
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x7768             STRB     R0,[R5, #+29]
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x77A8             STRB     R0,[R5, #+30]
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x77E8             STRB     R0,[R5, #+31]
   3193          				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
   \   000000F8   0x0029             MOVS     R1,R5
   \   000000FA   0x9802             LDR      R0,[SP, #+8]
   \   000000FC   0x.... 0x....      BL       ld_clust
   \   00000100   0x0007             MOVS     R7,R0
   3194          				st_clust(dir, 0);					/* cluster = 0 */
   \   00000102   0x2100             MOVS     R1,#+0
   \   00000104   0x0028             MOVS     R0,R5
   \   00000106   0x.... 0x....      BL       st_clust
   3195                                          set_dirty(dj.fs);
   \   0000010A   0x9802             LDR      R0,[SP, #+8]
   \   0000010C   0x.... 0x....      BL       set_dirty
   3196          				if (cl) {							/* Remove the cluster chain if exist */
   \   00000110   0x2F00             CMP      R7,#+0
   \   00000112   0xD021             BEQ      ??f_open_11
   3197          					dw = dj.fs->winsect;
   \   00000114   0x9802             LDR      R0,[SP, #+8]
   \   00000116   0x6B40             LDR      R0,[R0, #+52]
   \   00000118   0x9000             STR      R0,[SP, #+0]
   3198          					res = remove_chain(dj.fs, cl);
   \   0000011A   0x0039             MOVS     R1,R7
   \   0000011C   0x9802             LDR      R0,[SP, #+8]
   \   0000011E   0x.... 0x....      BL       remove_chain
   \   00000122   0x0004             MOVS     R4,R0
   3199          					if (res == FR_OK) {
   \   00000124   0xB2E4             UXTB     R4,R4
   \   00000126   0x2C00             CMP      R4,#+0
   \   00000128   0xD116             BNE      ??f_open_11
   3200          						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
   \   0000012A   0x1E7F             SUBS     R7,R7,#+1
   \   0000012C   0x9802             LDR      R0,[SP, #+8]
   \   0000012E   0x60C7             STR      R7,[R0, #+12]
   3201          						res = move_window(dj.fs, dw);
   \   00000130   0x9900             LDR      R1,[SP, #+0]
   \   00000132   0x9802             LDR      R0,[SP, #+8]
   \   00000134   0x.... 0x....      BL       move_window
   \   00000138   0x0004             MOVS     R4,R0
   \   0000013A   0xE00D             B        ??f_open_11
   3202          					}
   3203          				}
   3204          			}
   3205          		}
   3206          		else {	/* Open an existing file */
   3207          			if (res == FR_OK) {						/* Follow succeeded */
   \                     ??f_open_6: (+1)
   \   0000013C   0xB2E4             UXTB     R4,R4
   \   0000013E   0x2C00             CMP      R4,#+0
   \   00000140   0xD10A             BNE      ??f_open_11
   3208          				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
   \   00000142   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000144   0x06C0             LSLS     R0,R0,#+27
   \   00000146   0xD501             BPL      ??f_open_12
   3209          					res = FR_NO_FILE;
   \   00000148   0x2404             MOVS     R4,#+4
   \   0000014A   0xE005             B        ??f_open_11
   3210          				} else {
   3211          					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
   \                     ??f_open_12: (+1)
   \   0000014C   0x07B0             LSLS     R0,R6,#+30
   \   0000014E   0xD503             BPL      ??f_open_11
   \   00000150   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000152   0x07C0             LSLS     R0,R0,#+31
   \   00000154   0xD500             BPL      ??f_open_11
   3212          						res = FR_DENIED;
   \   00000156   0x2407             MOVS     R4,#+7
   3213          				}
   3214          			}
   3215          		}
   3216          		if (res == FR_OK) {
   \                     ??f_open_11: (+1)
   \   00000158   0xB2E4             UXTB     R4,R4
   \   0000015A   0x2C00             CMP      R4,#+0
   \   0000015C   0xD10A             BNE      ??f_open_13
   3217          			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
   \   0000015E   0x0730             LSLS     R0,R6,#+28
   \   00000160   0xD502             BPL      ??f_open_14
   3218          				mode |= FA__WRITTEN;
   \   00000162   0x0030             MOVS     R0,R6
   \   00000164   0x2620             MOVS     R6,#+32
   \   00000166   0x4306             ORRS     R6,R6,R0
   3219          			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
   \                     ??f_open_14: (+1)
   \   00000168   0x9802             LDR      R0,[SP, #+8]
   \   0000016A   0x6B40             LDR      R0,[R0, #+52]
   \   0000016C   0x990F             LDR      R1,[SP, #+60]
   \   0000016E   0x61C8             STR      R0,[R1, #+28]
   3220          			fp->dir_ptr = dir;
   \   00000170   0x980F             LDR      R0,[SP, #+60]
   \   00000172   0x6205             STR      R5,[R0, #+32]
   3221          #if _FS_LOCK
   3222          			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   3223          			if (!fp->lockid) res = FR_INT_ERR;
   3224          #endif
   3225          		}
   3226          
   3227          #else				/* R/O configuration */
   3228          		if (res == FR_OK) {					/* Follow succeeded */
   3229          			dir = convert_ptr(dj.fs, dj.dir);
   3230          			if (!dir) {						/* Current dir itself */
   3231          				res = FR_INVALID_NAME;
   3232          			} else {
   3233          				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
   3234          					res = FR_NO_FILE;
   3235          			}
   3236          		}
   3237          #endif
   3238          		FREE_BUF();
   \                     ??f_open_13: (+1)
   \   00000174   0x9801             LDR      R0,[SP, #+4]
   \   00000176   0x.... 0x....      BL       ff_memfree
   3239          
   3240          		if (res == FR_OK) {
   \   0000017A   0xB2E4             UXTB     R4,R4
   \   0000017C   0x2C00             CMP      R4,#+0
   \   0000017E   0xD120             BNE      ??f_open_2
   3241          			fp->flag = mode;					/* File access mode */
   \   00000180   0x980F             LDR      R0,[SP, #+60]
   \   00000182   0x7186             STRB     R6,[R0, #+6]
   3242          			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
   \   00000184   0x0029             MOVS     R1,R5
   \   00000186   0x9802             LDR      R0,[SP, #+8]
   \   00000188   0x.... 0x....      BL       ld_clust
   \   0000018C   0x990F             LDR      R1,[SP, #+60]
   \   0000018E   0x6108             STR      R0,[R1, #+16]
   3243          			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
   \   00000190   0x7FE8             LDRB     R0,[R5, #+31]
   \   00000192   0x0600             LSLS     R0,R0,#+24
   \   00000194   0x7FA9             LDRB     R1,[R5, #+30]
   \   00000196   0x0409             LSLS     R1,R1,#+16
   \   00000198   0x4301             ORRS     R1,R1,R0
   \   0000019A   0x7F68             LDRB     R0,[R5, #+29]
   \   0000019C   0x0200             LSLS     R0,R0,#+8
   \   0000019E   0x4308             ORRS     R0,R0,R1
   \   000001A0   0x7F29             LDRB     R1,[R5, #+28]
   \   000001A2   0x4301             ORRS     R1,R1,R0
   \   000001A4   0x980F             LDR      R0,[SP, #+60]
   \   000001A6   0x60C1             STR      R1,[R0, #+12]
   3244          			fp->fptr = 0;						/* File pointer */
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0x990F             LDR      R1,[SP, #+60]
   \   000001AC   0x6088             STR      R0,[R1, #+8]
   3245          			fp->dsect = 0;
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x990F             LDR      R1,[SP, #+60]
   \   000001B2   0x6188             STR      R0,[R1, #+24]
   3246          #if _USE_FASTSEEK
   3247          			fp->cltbl = 0;						/* Normal seek mode */
   3248          #endif
   3249          			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
   \   000001B4   0x9802             LDR      R0,[SP, #+8]
   \   000001B6   0x990F             LDR      R1,[SP, #+60]
   \   000001B8   0x6008             STR      R0,[R1, #+0]
   \   000001BA   0x9802             LDR      R0,[SP, #+8]
   \   000001BC   0x88C0             LDRH     R0,[R0, #+6]
   \   000001BE   0x990F             LDR      R1,[SP, #+60]
   \   000001C0   0x8088             STRH     R0,[R1, #+4]
   3250          		}
   3251          	}
   3252          
   3253          	LEAVE_FF(dj.fs, res);
   \                     ??f_open_2: (+1)
   \   000001C2   0x0020             MOVS     R0,R4
   \   000001C4   0xB2C0             UXTB     R0,R0
   \                     ??f_open_1: (+1)
   \   000001C6   0xB011             ADD      SP,SP,#+68
   \   000001C8   0xBDF0             POP      {R4-R7,PC}       ;; return
   3254          }
   3255          
   3256          
   3257          /*FUNCTION*-------------------------------------------------------------------
   3258          *
   3259          * Function Name    : f_read
   3260          * Returned Value   : FR_OK : 		The file object has been closed successfully.
   3261          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   3262          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   3263          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   3264          *                    FR_INVALID_OBJECT:The file object is invalid.
   3265          *
   3266          *                    
   3267          * Comments         : The f_close() function closes an open file object. If any data has been written to the file,
   3268          *                    the cached information of the file is written back to the disk. After the function succeeded,
   3269          *                    the file object is no longer valid and it can be discarded
   3270          *   
   3271          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3272          FRESULT f_read 
   3273            (
   3274              /* [IN] Pointer to the file object */
   3275            	FIL *fp, 		
   3276            	/* [OUT] Pointer to data buffer */
   3277            	void *buff,	
   3278            	/* [IN] Number of bytes to read */	
   3279            	uint32_t btr,		
   3280            	/* [OUT] Pointer to number of bytes read */
   3281            	uint32_t *br		
   3282            )
   3283          {
   \                     f_read: (+1)
   \   00000000   0xB5FC             PUSH     {R2-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   3284          	FRESULT res;
   3285          	uint32_t clst, sect, remain;
   3286          	uint32_t rcnt, cc;
   3287          	uint8_t csect, *rbuff = (uint8_t*)buff;
   \   00000006   0x9101             STR      R1,[SP, #+4]
   3288          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3289                  uint32_t desired_num = 0;
   \   00000008   0x2500             MOVS     R5,#+0
   3290                  uint32_t get_num = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   3291                  uint32_t prev_clst = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
   3292                  uint32_t i = 0, tmp = 0;
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0x2000             MOVS     R0,#+0
   3293          #endif
   3294          
   3295          
   3296          	*br = 0;	/* Clear read byte counter */
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x9904             LDR      R1,[SP, #+16]
   \   00000016   0x6008             STR      R0,[R1, #+0]
   3297          
   3298          	res = validate(fp);//_FS_REENTRANT,		/* Check validity */
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       validate
   3299          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD001             BEQ      ??f_read_0
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0xE139             B        ??f_read_1
   3300          	if (fp->flag & FA__ERROR)					/* Aborted file? */
   \                     ??f_read_0: (+1)
   \   00000028   0x79A0             LDRB     R0,[R4, #+6]
   \   0000002A   0x0600             LSLS     R0,R0,#+24
   \   0000002C   0xD501             BPL      ??f_read_2
   3301          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE134             B        ??f_read_1
   3302          	if (!(fp->flag & FA_READ)) 					/* Check access mode */
   \                     ??f_read_2: (+1)
   \   00000032   0x79A0             LDRB     R0,[R4, #+6]
   \   00000034   0x07C0             LSLS     R0,R0,#+31
   \   00000036   0xD401             BMI      ??f_read_3
   3303          		LEAVE_FF(fp->fs, FR_DENIED);
   \   00000038   0x2007             MOVS     R0,#+7
   \   0000003A   0xE12F             B        ??f_read_1
   3304          	remain = fp->fsize - fp->fptr;
   \                     ??f_read_3: (+1)
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0x68A1             LDR      R1,[R4, #+8]
   \   00000040   0x1A40             SUBS     R0,R0,R1
   3305          	if (btr > remain) btr = (uint32_t)remain;		/* Truncate btr by remaining bytes */
   \   00000042   0x9903             LDR      R1,[SP, #+12]
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD21D             BCS      ??f_read_4
   \   00000048   0x9003             STR      R0,[SP, #+12]
   \   0000004A   0xE01B             B        ??f_read_4
   3306          
   3307          	for ( ;  btr;								/* Repeat until all data read */
   3308          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   3309          		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
   3310          			csect = (uint8_t)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3311          			if (!csect) {						/* On the cluster boundary? */
   3312          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3313                                          desired_num = (btr + (SS(fp->fs) - 1)) / SS(fp->fs);
   3314                                          desired_num = desired_num / (fp->fs->csize) + ((desired_num & (fp->fs->csize - 1)) ? 1 : 0);
   3315                                          if(desired_num > MAX_WRITE_CLUSTERS)
   3316                                            desired_num = MAX_WRITE_CLUSTERS;
   3317          #endif
   3318          				if (fp->fptr == 0) {			/* On the top of the file? */
   3319          					clst = fp->sclust;			/* Follow from the origin */
   3320          				} else {						/* Middle or end of the file */
   3321          #if _USE_FASTSEEK
   3322          					if (fp->cltbl)
   3323          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   3324          					else
   3325          #endif
   3326          						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
   3327          				}
   3328          				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
   3329          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3330          				fp->clust = clst;				/* Update current cluster */
   3331          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3332                                          //desired_num
   3333                                          get_num = 1;
   3334                                          if(desired_num > 1)
   3335                                          {
   3336                                              prev_clst = clst;
   3337                                              do
   3338                                              {
   3339          #if _USE_FASTSEEK
   3340                                                  if(fp->cltbl)
   3341                                                    clst = clmt_clust(fp, fp->fptr);
   3342                                                  else
   3343          #endif
   3344                                                    clst = get_fat(fp->fs, prev_clst);
   3345                                                  if(clst < 2) ABORT(fp->fs, FR_INT_ERR);
   3346                                                  if(clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3347                                                  if(clst == 0x0FFFFFFF)//last one
   3348                                                    break;
   3349                                                  if(clst == prev_clst + 1)
   3350                                                    ++get_num;
   3351                                                  else
   3352                                                    break;
   3353                                              }while(get_num < desired_num);
   3354                                          }
   3355                                          clst = fp->clust;//start cluster.
   3356          #endif
   3357          			}
   3358          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   3359          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3360                                  if(get_num > 1)
   3361                                    fp->clust += (get_num - 1);
   3362          #endif
   3363          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3364          			sect += csect;
   3365          			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
   3366          			if (cc) {							/* Read maximum contiguous sectors directly */
   3367          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3368                                          if(csect == 0 && get_num > 1)
   3369                                          {
   3370                                              if(cc > fp->fs->csize * get_num)
   3371                                                  cc = fp->fs->csize * get_num;
   3372                                          }
   3373                                          else if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   3374          #else
   3375          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   3376          #endif
   3377          					cc = fp->fs->csize - csect;
   3378          				if (disk_read(fp->fs->drv, rbuff, sect, (uint8_t)cc) != RES_OK)
   3379          					ABORT(fp->fs, FR_DISK_ERR);
   3380          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   3381          #if _FS_TINY
   3382          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3383                                          if(judge_alldirty(fp->fs))
   3384                                          {
   3385                                              for (i = 0; i < WIN_SECTOR_NUM; ++i)
   3386                                              {
   3387                                                  tmp = get_sectorprev(fp->fs, i);
   3388                                                  if(tmp >= sect && tmp < sect + cc)
   3389                                                      mem_cpy(rbuff + (tmp - sect) * SS(fp->fs), fp->fs->winprev + SS(fp->fs) * i, SS(fp->fs));
   3390                                              }
   3391                                          }
   3392          #else                                
   3393          				if (judge_alldirty(fp->fs) && fp->fs->winsect - sect < cc)
   3394          					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
   3395          #endif                                
   3396          #else
   3397          				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
   3398          					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   3399          #endif
   3400          #endif
   3401          				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
   3402          				continue;
   3403          			}
   3404          #if !_FS_TINY
   3405          			if (fp->dsect != sect) {			/* Load data sector if not in cache */
   3406          #if !_FS_READONLY
   3407          				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   3408          					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3409          						ABORT(fp->fs, FR_DISK_ERR);
   3410          					fp->flag &= ~FA__DIRTY;
   3411          				}
   3412          #endif
   3413          				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
   3414          					ABORT(fp->fs, FR_DISK_ERR);
   3415          			}
   3416          #endif
   3417          			fp->dsect = sect;
   3418          		}
   3419          		rcnt = SS(fp->fs) - ((uint32_t)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
   3420          		if (rcnt > btr) rcnt = btr;
   3421          #if _FS_TINY
   3422          		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
   3423          			ABORT(fp->fs, FR_DISK_ERR);
   3424          		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   \                     ??f_read_5: (+1)
   \   0000004C   0x002A             MOVS     R2,R5
   \   0000004E   0x0015             MOVS     R5,R2
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x6C46             LDR      R6,[R0, #+68]
   \   00000054   0x68A0             LDR      R0,[R4, #+8]
   \   00000056   0x2180             MOVS     R1,#+128
   \   00000058   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000005A   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000005E   0x1871             ADDS     R1,R6,R1
   \   00000060   0x002A             MOVS     R2,R5
   \   00000062   0x9801             LDR      R0,[SP, #+4]
   \   00000064   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_6: (+1)
   \   00000068   0x9801             LDR      R0,[SP, #+4]
   \   0000006A   0x1940             ADDS     R0,R0,R5
   \   0000006C   0x9001             STR      R0,[SP, #+4]
   \   0000006E   0x68A0             LDR      R0,[R4, #+8]
   \   00000070   0x1940             ADDS     R0,R0,R5
   \   00000072   0x60A0             STR      R0,[R4, #+8]
   \   00000074   0x9804             LDR      R0,[SP, #+16]
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x1940             ADDS     R0,R0,R5
   \   0000007A   0x9904             LDR      R1,[SP, #+16]
   \   0000007C   0x6008             STR      R0,[R1, #+0]
   \   0000007E   0x9803             LDR      R0,[SP, #+12]
   \   00000080   0x1B40             SUBS     R0,R0,R5
   \   00000082   0x9003             STR      R0,[SP, #+12]
   \                     ??f_read_4: (+1)
   \   00000084   0x9803             LDR      R0,[SP, #+12]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD100             BNE      .+4
   \   0000008A   0xE106             B        ??f_read_7
   \   0000008C   0x68A0             LDR      R0,[R4, #+8]
   \   0000008E   0x2180             MOVS     R1,#+128
   \   00000090   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000092   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD000             BEQ      .+4
   \   0000009A   0xE0E5             B        ??f_read_8
   \   0000009C   0x68A0             LDR      R0,[R4, #+8]
   \   0000009E   0x0A40             LSRS     R0,R0,#+9
   \   000000A0   0x6821             LDR      R1,[R4, #+0]
   \   000000A2   0x7889             LDRB     R1,[R1, #+2]
   \   000000A4   0x1E49             SUBS     R1,R1,#+1
   \   000000A6   0x4001             ANDS     R1,R1,R0
   \   000000A8   0x4668             MOV      R0,SP
   \   000000AA   0x7201             STRB     R1,[R0, #+8]
   \   000000AC   0x4668             MOV      R0,SP
   \   000000AE   0x7A00             LDRB     R0,[R0, #+8]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD162             BNE      ??f_read_9
   \   000000B4   0x9803             LDR      R0,[SP, #+12]
   \   000000B6   0x....             LDR      R1,??DataTable16  ;; 0x1ff
   \   000000B8   0x1840             ADDS     R0,R0,R1
   \   000000BA   0x0005             MOVS     R5,R0
   \   000000BC   0x0A6D             LSRS     R5,R5,#+9
   \   000000BE   0x6820             LDR      R0,[R4, #+0]
   \   000000C0   0x7880             LDRB     R0,[R0, #+2]
   \   000000C2   0x1E40             SUBS     R0,R0,#+1
   \   000000C4   0x4028             ANDS     R0,R0,R5
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD001             BEQ      ??f_read_10
   \   000000CA   0x2601             MOVS     R6,#+1
   \   000000CC   0xE000             B        ??f_read_11
   \                     ??f_read_10: (+1)
   \   000000CE   0x2600             MOVS     R6,#+0
   \                     ??f_read_11: (+1)
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0x6821             LDR      R1,[R4, #+0]
   \   000000D4   0x7889             LDRB     R1,[R1, #+2]
   \   000000D6   0x.... 0x....      BL       __aeabi_uidiv
   \   000000DA   0x1985             ADDS     R5,R0,R6
   \   000000DC   0x2080             MOVS     R0,#+128
   \   000000DE   0x6821             LDR      R1,[R4, #+0]
   \   000000E0   0x7889             LDRB     R1,[R1, #+2]
   \   000000E2   0x.... 0x....      BL       __aeabi_uidiv
   \   000000E6   0x42A8             CMP      R0,R5
   \   000000E8   0xD205             BCS      ??f_read_12
   \   000000EA   0x2080             MOVS     R0,#+128
   \   000000EC   0x6821             LDR      R1,[R4, #+0]
   \   000000EE   0x7889             LDRB     R1,[R1, #+2]
   \   000000F0   0x.... 0x....      BL       __aeabi_uidiv
   \   000000F4   0x0005             MOVS     R5,R0
   \                     ??f_read_12: (+1)
   \   000000F6   0x68A0             LDR      R0,[R4, #+8]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD101             BNE      ??f_read_13
   \   000000FC   0x6920             LDR      R0,[R4, #+16]
   \   000000FE   0xE003             B        ??f_read_14
   \                     ??f_read_13: (+1)
   \   00000100   0x6961             LDR      R1,[R4, #+20]
   \   00000102   0x6820             LDR      R0,[R4, #+0]
   \   00000104   0x.... 0x....      BL       get_fat
   \                     ??f_read_14: (+1)
   \   00000108   0x2802             CMP      R0,#+2
   \   0000010A   0xD205             BCS      ??f_read_15
   \   0000010C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000010E   0x2180             MOVS     R1,#+128
   \   00000110   0x4301             ORRS     R1,R1,R0
   \   00000112   0x71A1             STRB     R1,[R4, #+6]
   \   00000114   0x2002             MOVS     R0,#+2
   \   00000116   0xE0C1             B        ??f_read_1
   \                     ??f_read_15: (+1)
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD105             BNE      ??f_read_16
   \   00000120   0x79A0             LDRB     R0,[R4, #+6]
   \   00000122   0x2180             MOVS     R1,#+128
   \   00000124   0x4301             ORRS     R1,R1,R0
   \   00000126   0x71A1             STRB     R1,[R4, #+6]
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0xE0B7             B        ??f_read_1
   \                     ??f_read_16: (+1)
   \   0000012C   0x6160             STR      R0,[R4, #+20]
   \   0000012E   0x2701             MOVS     R7,#+1
   \   00000130   0x2D02             CMP      R5,#+2
   \   00000132   0xD321             BCC      ??f_read_17
   \   00000134   0x0006             MOVS     R6,R0
   \                     ??f_read_18: (+1)
   \   00000136   0x0031             MOVS     R1,R6
   \   00000138   0x6820             LDR      R0,[R4, #+0]
   \   0000013A   0x.... 0x....      BL       get_fat
   \   0000013E   0x2802             CMP      R0,#+2
   \   00000140   0xD205             BCS      ??f_read_19
   \   00000142   0x79A0             LDRB     R0,[R4, #+6]
   \   00000144   0x2180             MOVS     R1,#+128
   \   00000146   0x4301             ORRS     R1,R1,R0
   \   00000148   0x71A1             STRB     R1,[R4, #+6]
   \   0000014A   0x2002             MOVS     R0,#+2
   \   0000014C   0xE0A6             B        ??f_read_1
   \                     ??f_read_19: (+1)
   \   0000014E   0x2100             MOVS     R1,#+0
   \   00000150   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000152   0x4288             CMP      R0,R1
   \   00000154   0xD105             BNE      ??f_read_20
   \   00000156   0x79A0             LDRB     R0,[R4, #+6]
   \   00000158   0x2180             MOVS     R1,#+128
   \   0000015A   0x4301             ORRS     R1,R1,R0
   \   0000015C   0x71A1             STRB     R1,[R4, #+6]
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0xE09C             B        ??f_read_1
   \                     ??f_read_20: (+1)
   \   00000162   0x....             LDR      R1,??DataTable16_1  ;; 0xfffffff
   \   00000164   0x4288             CMP      R0,R1
   \   00000166   0xD007             BEQ      ??f_read_17
   \                     ??f_read_21: (+1)
   \   00000168   0x0031             MOVS     R1,R6
   \   0000016A   0x1C49             ADDS     R1,R1,#+1
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xD103             BNE      ??f_read_22
   \   00000170   0x1C7F             ADDS     R7,R7,#+1
   \   00000172   0x42AF             CMP      R7,R5
   \   00000174   0xD3DF             BCC      ??f_read_18
   \   00000176   0xE7FF             B        ??f_read_17
   \                     ??f_read_22: (+1)
   \                     ??f_read_17: (+1)
   \   00000178   0x6960             LDR      R0,[R4, #+20]
   \                     ??f_read_9: (+1)
   \   0000017A   0x6961             LDR      R1,[R4, #+20]
   \   0000017C   0x6820             LDR      R0,[R4, #+0]
   \   0000017E   0x.... 0x....      BL       clust2sect
   \   00000182   0x0006             MOVS     R6,R0
   \   00000184   0x2F02             CMP      R7,#+2
   \   00000186   0xD303             BCC      ??f_read_23
   \   00000188   0x6960             LDR      R0,[R4, #+20]
   \   0000018A   0x1E79             SUBS     R1,R7,#+1
   \   0000018C   0x1840             ADDS     R0,R0,R1
   \   0000018E   0x6160             STR      R0,[R4, #+20]
   \                     ??f_read_23: (+1)
   \   00000190   0x2E00             CMP      R6,#+0
   \   00000192   0xD105             BNE      ??f_read_24
   \   00000194   0x79A0             LDRB     R0,[R4, #+6]
   \   00000196   0x2180             MOVS     R1,#+128
   \   00000198   0x4301             ORRS     R1,R1,R0
   \   0000019A   0x71A1             STRB     R1,[R4, #+6]
   \   0000019C   0x2002             MOVS     R0,#+2
   \   0000019E   0xE07D             B        ??f_read_1
   \                     ??f_read_24: (+1)
   \   000001A0   0x4668             MOV      R0,SP
   \   000001A2   0x7A00             LDRB     R0,[R0, #+8]
   \   000001A4   0x1836             ADDS     R6,R6,R0
   \   000001A6   0x9803             LDR      R0,[SP, #+12]
   \   000001A8   0x0A40             LSRS     R0,R0,#+9
   \   000001AA   0x9000             STR      R0,[SP, #+0]
   \   000001AC   0x9800             LDR      R0,[SP, #+0]
   \   000001AE   0x2800             CMP      R0,#+0
   \   000001B0   0xD059             BEQ      ??f_read_25
   \   000001B2   0x4668             MOV      R0,SP
   \   000001B4   0x7A00             LDRB     R0,[R0, #+8]
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD10C             BNE      ??f_read_26
   \   000001BA   0x2F02             CMP      R7,#+2
   \   000001BC   0xD30A             BCC      ??f_read_26
   \   000001BE   0x6820             LDR      R0,[R4, #+0]
   \   000001C0   0x7880             LDRB     R0,[R0, #+2]
   \   000001C2   0x4378             MULS     R0,R7,R0
   \   000001C4   0x9900             LDR      R1,[SP, #+0]
   \   000001C6   0x4288             CMP      R0,R1
   \   000001C8   0xD212             BCS      ??f_read_27
   \   000001CA   0x6820             LDR      R0,[R4, #+0]
   \   000001CC   0x7880             LDRB     R0,[R0, #+2]
   \   000001CE   0x4378             MULS     R0,R7,R0
   \   000001D0   0x9000             STR      R0,[SP, #+0]
   \   000001D2   0xE00D             B        ??f_read_27
   \                     ??f_read_26: (+1)
   \   000001D4   0x6820             LDR      R0,[R4, #+0]
   \   000001D6   0x7880             LDRB     R0,[R0, #+2]
   \   000001D8   0x4669             MOV      R1,SP
   \   000001DA   0x7A09             LDRB     R1,[R1, #+8]
   \   000001DC   0x9A00             LDR      R2,[SP, #+0]
   \   000001DE   0x1889             ADDS     R1,R1,R2
   \   000001E0   0x4288             CMP      R0,R1
   \   000001E2   0xD205             BCS      ??f_read_27
   \   000001E4   0x6820             LDR      R0,[R4, #+0]
   \   000001E6   0x7880             LDRB     R0,[R0, #+2]
   \   000001E8   0x4669             MOV      R1,SP
   \   000001EA   0x7A09             LDRB     R1,[R1, #+8]
   \   000001EC   0x1A40             SUBS     R0,R0,R1
   \   000001EE   0x9000             STR      R0,[SP, #+0]
   \                     ??f_read_27: (+1)
   \   000001F0   0x9B00             LDR      R3,[SP, #+0]
   \   000001F2   0xB2DB             UXTB     R3,R3
   \   000001F4   0x0032             MOVS     R2,R6
   \   000001F6   0x9901             LDR      R1,[SP, #+4]
   \   000001F8   0x6820             LDR      R0,[R4, #+0]
   \   000001FA   0x7840             LDRB     R0,[R0, #+1]
   \   000001FC   0x.... 0x....      BL       disk_read
   \   00000200   0x2800             CMP      R0,#+0
   \   00000202   0xD005             BEQ      ??f_read_28
   \   00000204   0x79A0             LDRB     R0,[R4, #+6]
   \   00000206   0x2180             MOVS     R1,#+128
   \   00000208   0x4301             ORRS     R1,R1,R0
   \   0000020A   0x71A1             STRB     R1,[R4, #+6]
   \   0000020C   0x2001             MOVS     R0,#+1
   \   0000020E   0xE045             B        ??f_read_1
   \                     ??f_read_28: (+1)
   \   00000210   0x6820             LDR      R0,[R4, #+0]
   \   00000212   0x7900             LDRB     R0,[R0, #+4]
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD021             BEQ      ??f_read_29
   \   00000218   0x2500             MOVS     R5,#+0
   \   0000021A   0xE01D             B        ??f_read_30
   \                     ??f_read_31: (+1)
   \   0000021C   0x0029             MOVS     R1,R5
   \   0000021E   0xB2C9             UXTB     R1,R1
   \   00000220   0x6820             LDR      R0,[R4, #+0]
   \   00000222   0x.... 0x....      BL       get_sectorprev
   \   00000226   0x42B0             CMP      R0,R6
   \   00000228   0xD315             BCC      ??f_read_32
   \   0000022A   0x9900             LDR      R1,[SP, #+0]
   \   0000022C   0x1871             ADDS     R1,R6,R1
   \   0000022E   0x4288             CMP      R0,R1
   \   00000230   0xD211             BCS      ??f_read_32
   \   00000232   0x2280             MOVS     R2,#+128
   \   00000234   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   00000236   0x6821             LDR      R1,[R4, #+0]
   \   00000238   0x2380             MOVS     R3,#+128
   \   0000023A   0x009B             LSLS     R3,R3,#+2        ;; #+512
   \   0000023C   0x436B             MULS     R3,R5,R3
   \   0000023E   0x18C9             ADDS     R1,R1,R3
   \   00000240   0x3148             ADDS     R1,R1,#+72
   \   00000242   0x468C             MOV      R12,R1
   \   00000244   0x9901             LDR      R1,[SP, #+4]
   \   00000246   0x1B83             SUBS     R3,R0,R6
   \   00000248   0x2080             MOVS     R0,#+128
   \   0000024A   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   0000024C   0x4343             MULS     R3,R0,R3
   \   0000024E   0x18C8             ADDS     R0,R1,R3
   \   00000250   0x4661             MOV      R1,R12
   \   00000252   0x.... 0x....      BL       mem_cpy
   \                     ??f_read_32: (+1)
   \   00000256   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_read_30: (+1)
   \   00000258   0x2D02             CMP      R5,#+2
   \   0000025A   0xD3DF             BCC      ??f_read_31
   \                     ??f_read_29: (+1)
   \   0000025C   0x9D00             LDR      R5,[SP, #+0]
   \   0000025E   0x2080             MOVS     R0,#+128
   \   00000260   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000262   0x4345             MULS     R5,R0,R5
   \   00000264   0xE700             B        ??f_read_6
   \                     ??f_read_25: (+1)
   \   00000266   0x61A6             STR      R6,[R4, #+24]
   \                     ??f_read_8: (+1)
   \   00000268   0x2580             MOVS     R5,#+128
   \   0000026A   0x00AD             LSLS     R5,R5,#+2        ;; #+512
   \   0000026C   0x68A0             LDR      R0,[R4, #+8]
   \   0000026E   0x2180             MOVS     R1,#+128
   \   00000270   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000272   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000276   0x1A6D             SUBS     R5,R5,R1
   \   00000278   0x9803             LDR      R0,[SP, #+12]
   \   0000027A   0x42A8             CMP      R0,R5
   \   0000027C   0xD200             BCS      ??f_read_33
   \   0000027E   0x9D03             LDR      R5,[SP, #+12]
   \                     ??f_read_33: (+1)
   \   00000280   0x69A1             LDR      R1,[R4, #+24]
   \   00000282   0x6820             LDR      R0,[R4, #+0]
   \   00000284   0x.... 0x....      BL       move_window
   \   00000288   0x2800             CMP      R0,#+0
   \   0000028A   0xD100             BNE      .+4
   \   0000028C   0xE6DE             B        ??f_read_5
   \   0000028E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000290   0x2180             MOVS     R1,#+128
   \   00000292   0x4301             ORRS     R1,R1,R0
   \   00000294   0x71A1             STRB     R1,[R4, #+6]
   \   00000296   0x2001             MOVS     R0,#+1
   \   00000298   0xE000             B        ??f_read_1
   3425          #else
   3426          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
   3427          #endif
   3428          	}
   3429          
   3430          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_read_7: (+1)
   \   0000029A   0x2000             MOVS     R0,#+0
   \                     ??f_read_1: (+1)
   \   0000029C   0xB005             ADD      SP,SP,#+20
   \   0000029E   0xBDF0             POP      {R4-R7,PC}       ;; return
   3431          }
   3432          
   3433          
   3434          #if !_FS_READONLY
   3435          
   3436          /*FUNCTION*-------------------------------------------------------------------
   3437          *
   3438          * Function Name    : f_write
   3439          * Returned Value   : FR_OK : 		The function succeeded.
   3440          *                    FR_DENIED: 	The function denied due to the file has been opened in non-write mode.
   3441          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   3442          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   3443          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   3444          *                    FR_INVALID_OBJECT: The file object is invalid.                   
   3445          * Comments         : The read/write pointer in the file object is increased in number of bytes written.
   3446          *                    After the function succeeded, *ByteWritten should be checked to detect the disk full.
   3447          *                    In case of *ByteWritten < ByteToWrite, it means the volume got full during the write operation.
   3448          *                    The function can take a time when the volume is full or close to full
   3449          *   
   3450          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3451          FRESULT f_write 
   3452          (
   3453            /* [IN] Pointer to the file object */
   3454          	FIL *fp,		
   3455          	/* [IN] Pointer to the data to be written */
   3456          	void *buff,	
   3457          	/* [IN] Number of bytes to write */
   3458          	uint32_t btw,			
   3459          	/* [OUT] Pointer to number of bytes written */
   3460          	uint32_t *bw			
   3461          )
   3462          {
   \                     f_write: (+1)
   \   00000000   0xB5FC             PUSH     {R2-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   3463          	FRESULT res;
   3464          	uint32_t clst, sect;
   3465          	uint32_t wcnt, cc;
   3466          	uint8_t *wbuff = (uint8_t*)buff;
   \   00000006   0x9104             STR      R1,[SP, #+16]
   3467          	uint8_t csect;
   3468          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3469                  clst = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   3470                  uint32_t desired_num = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
   3471                  uint32_t get_num = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x9003             STR      R0,[SP, #+12]
   3472                  uint32_t i = 0, tmp = 0;
   \   00000012   0x2500             MOVS     R5,#+0
   \   00000014   0x2600             MOVS     R6,#+0
   3473          #endif
   3474          
   3475          
   3476          	*bw = 0;	/* Clear write byte counter */
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x9906             LDR      R1,[SP, #+24]
   \   0000001A   0x6008             STR      R0,[R1, #+0]
   3477          
   3478          	res = validate(fp);						/* Check validity */
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       validate
   3479          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ      ??f_write_0
   \   00000028   0xB2C0             UXTB     R0,R0
   \   0000002A   0xE090             B        ??f_write_1
   3480          	if (fp->flag & FA__ERROR)				/* Aborted file? */
   \                     ??f_write_0: (+1)
   \   0000002C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000002E   0x0600             LSLS     R0,R0,#+24
   \   00000030   0xD501             BPL      ??f_write_2
   3481          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0xE08B             B        ??f_write_1
   3482          	if (!(fp->flag & FA_WRITE))				/* Check access mode */
   \                     ??f_write_2: (+1)
   \   00000036   0x79A0             LDRB     R0,[R4, #+6]
   \   00000038   0x0780             LSLS     R0,R0,#+30
   \   0000003A   0xD401             BMI      ??f_write_3
   3483          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000003C   0x2007             MOVS     R0,#+7
   \   0000003E   0xE086             B        ??f_write_1
   3484          	if ((uint32_t)(fp->fsize + btw) < fp->fsize) btw = 0;//	/* File size cannot reach 4GB */
   \                     ??f_write_3: (+1)
   \   00000040   0x68E0             LDR      R0,[R4, #+12]
   \   00000042   0x9905             LDR      R1,[SP, #+20]
   \   00000044   0x1840             ADDS     R0,R0,R1
   \   00000046   0x68E1             LDR      R1,[R4, #+12]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD223             BCS      ??f_write_4
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9005             STR      R0,[SP, #+20]
   \   00000050   0xE020             B        ??f_write_4
   3485          
   3486          	for ( ;  btw;							/* Repeat until all data written */
   3487          		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
   3488          		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
   3489          			csect = (uint8_t)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   3490          			if (!csect) {					/* On the cluster boundary? */
   3491          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3492                                      desired_num = (btw + (SS(fp->fs) - 1)) / SS(fp->fs);
   3493                                      desired_num = desired_num / (fp->fs->csize) + ((desired_num & (fp->fs->csize - 1)) ? 1 : 0);
   3494                                      if(desired_num > MAX_WRITE_CLUSTERS)
   3495                                          desired_num = MAX_WRITE_CLUSTERS;
   3496          #endif
   3497          				if (fp->fptr == 0) {		/* On the top of the file? */
   3498          					clst = fp->sclust;		/* Follow from the origin */
   3499          					if (clst == 0)			/* When no cluster is allocated, */
   3500                                                  {
   3501          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION                                          
   3502                                                    clst = create_chain_for_clusts(fp->fs, 0, desired_num, &get_num);
   3503          #else
   3504          					  clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
   3505          #endif
   3506                                                  }
   3507          				} else {					/* Middle or end of the file */
   3508          #if _USE_FASTSEEK
   3509          					if (fp->cltbl)
   3510          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   3511          					else
   3512          #endif
   3513          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3514                                                          clst = create_chain_for_clusts(fp->fs, fp->clust, desired_num, &get_num);
   3515          #else
   3516                                                          clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   3517          #endif
   3518          				}
   3519          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   3520          				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   3521          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3522          				fp->clust = clst;			/* Update current cluster */
   3523                                          if(fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
   3524          			}
   3525          #if _FS_TINY
   3526          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3527                                  for (i = 0; i < WIN_SECTOR_NUM; ++i)
   3528                                  {
   3529                                      tmp = get_sectorprev(fp->fs, i);
   3530                                      if (tmp == fp->dsect)
   3531                                      {
   3532                                          break;
   3533                                      }
   3534                                  }
   3535                                  if (tmp == fp->dsect && sync_window(fp->fs, i))
   3536          #else
   3537          			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs, WIN_INDEX(fp->fs)))	/* Write-back sector cache */
   3538          #endif                          
   3539          				ABORT(fp->fs, FR_DISK_ERR);
   3540          #else
   3541          			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
   3542          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3543          					ABORT(fp->fs, FR_DISK_ERR);
   3544          				fp->flag &= ~FA__DIRTY;
   3545          			}
   3546          #endif
   3547          			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
   3548          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3549                                  if(get_num > 1)
   3550                                    fp->clust = clst + get_num - 1;
   3551          #endif
   3552          			if (!sect) ABORT(fp->fs, FR_INT_ERR);
   3553          			sect += csect;
   3554          			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
   3555          			if (cc) {						/* Write maximum contiguous sectors directly */
   3556          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3557                                          if (csect == 0 && get_num > 1)//csect==0cluster
   3558                                          {
   3559                                              if(cc > fp->fs->csize * get_num)
   3560                                                  cc = fp->fs->csize * get_num;
   3561                                          }
   3562                                          else if(csect + cc > fp->fs->csize)
   3563          #else
   3564          				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
   3565          #endif
   3566          					cc = fp->fs->csize - csect;
   3567          				if (disk_write(fp->fs->drv, wbuff, sect, (uint8_t)cc) != RES_OK)
   3568          					ABORT(fp->fs, FR_DISK_ERR);
   3569          #if _FS_TINY
   3570          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3571                                          for (i = 0; i < WIN_SECTOR_NUM; ++i)    /* Refill sector cache if it gets invalidated by the direct write */
   3572                                          {
   3573                                              tmp = get_sectorprev(fp->fs, i);
   3574                                              if(tmp >= sect && tmp < sect + cc)
   3575                                              {
   3576                                                  mem_cpy(fp->fs->winprev + i * SS(fp->fs), wbuff + (tmp - sect) * SS(fp->fs), SS(fp->fs));
   3577          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION == 1
   3578                                                  clear_dirty2(fp->fs, i);
   3579          #endif
   3580                                              }
   3581                                          }
   3582          #else
   3583          				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   3584                                              mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
   3585                                              fp->fs->wflag = 0;
   3586          				}
   3587          #endif
   3588          #else
   3589          				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   3590          					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   3591          					fp->flag &= ~FA__DIRTY;
   3592          				}
   3593          #endif
   3594          				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
   3595          				continue;
   3596          			}
   3597          #if _FS_TINY//here mean: sectorsectorwinsectsectsectorsector
   3598          			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
   3599          				if (sync_window(fp->fs, WIN_INDEX(fp->fs))) ABORT(fp->fs, FR_DISK_ERR);
   3600          				fp->fs->winsect = sect;
   3601          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   3602                                          set_sectorprev(fp->fs, sect);
   3603          #endif
   3604          			}
   3605          #else
   3606          			if (fp->dsect != sect) {		/* Fill sector cache with file data */
   3607          				if (fp->fptr < fp->fsize &&
   3608          					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
   3609          						ABORT(fp->fs, FR_DISK_ERR);
   3610          			}
   3611          #endif
   3612          			fp->dsect = sect;
   3613          		}
   3614          		wcnt = SS(fp->fs) - ((uint32_t)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
   3615          		if (wcnt > btw) wcnt = btw;
   3616          #if _FS_TINY
   3617          		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
   3618          			ABORT(fp->fs, FR_DISK_ERR);
   3619          		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   \                     ??f_write_5: (+1)
   \   00000052   0x002A             MOVS     R2,R5
   \   00000054   0x9904             LDR      R1,[SP, #+16]
   \   00000056   0x9100             STR      R1,[SP, #+0]
   \   00000058   0x0015             MOVS     R5,R2
   \   0000005A   0x6820             LDR      R0,[R4, #+0]
   \   0000005C   0x6C47             LDR      R7,[R0, #+68]
   \   0000005E   0x68A0             LDR      R0,[R4, #+8]
   \   00000060   0x2180             MOVS     R1,#+128
   \   00000062   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000064   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000068   0x1878             ADDS     R0,R7,R1
   \   0000006A   0x002A             MOVS     R2,R5
   \   0000006C   0x9900             LDR      R1,[SP, #+0]
   \   0000006E   0x.... 0x....      BL       mem_cpy
   3620          		set_dirty(fp->fs);
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0x.... 0x....      BL       set_dirty
   \                     ??f_write_6: (+1)
   \   00000078   0x9804             LDR      R0,[SP, #+16]
   \   0000007A   0x1940             ADDS     R0,R0,R5
   \   0000007C   0x9004             STR      R0,[SP, #+16]
   \   0000007E   0x68A0             LDR      R0,[R4, #+8]
   \   00000080   0x1940             ADDS     R0,R0,R5
   \   00000082   0x60A0             STR      R0,[R4, #+8]
   \   00000084   0x9806             LDR      R0,[SP, #+24]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x1940             ADDS     R0,R0,R5
   \   0000008A   0x9906             LDR      R1,[SP, #+24]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   \   0000008E   0x9805             LDR      R0,[SP, #+20]
   \   00000090   0x1B40             SUBS     R0,R0,R5
   \   00000092   0x9005             STR      R0,[SP, #+20]
   \                     ??f_write_4: (+1)
   \   00000094   0x9805             LDR      R0,[SP, #+20]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD04E             BEQ      ??f_write_7
   \   0000009A   0x68A0             LDR      R0,[R4, #+8]
   \   0000009C   0x2180             MOVS     R1,#+128
   \   0000009E   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000A0   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000A4   0x2900             CMP      R1,#+0
   \   000000A6   0xD000             BEQ      .+4
   \   000000A8   0xE126             B        ??f_write_8
   \   000000AA   0x68A0             LDR      R0,[R4, #+8]
   \   000000AC   0x0A40             LSRS     R0,R0,#+9
   \   000000AE   0x6821             LDR      R1,[R4, #+0]
   \   000000B0   0x7889             LDRB     R1,[R1, #+2]
   \   000000B2   0x1E49             SUBS     R1,R1,#+1
   \   000000B4   0x4001             ANDS     R1,R1,R0
   \   000000B6   0x4668             MOV      R0,SP
   \   000000B8   0x7001             STRB     R1,[R0, #+0]
   \   000000BA   0x4668             MOV      R0,SP
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD162             BNE      ??f_write_9
   \   000000C2   0x9805             LDR      R0,[SP, #+20]
   \   000000C4   0x....             LDR      R1,??DataTable18  ;; 0x1ff
   \   000000C6   0x1840             ADDS     R0,R0,R1
   \   000000C8   0x0005             MOVS     R5,R0
   \   000000CA   0x0A6D             LSRS     R5,R5,#+9
   \   000000CC   0x6820             LDR      R0,[R4, #+0]
   \   000000CE   0x7880             LDRB     R0,[R0, #+2]
   \   000000D0   0x1E40             SUBS     R0,R0,#+1
   \   000000D2   0x4028             ANDS     R0,R0,R5
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD001             BEQ      ??f_write_10
   \   000000D8   0x2701             MOVS     R7,#+1
   \   000000DA   0xE000             B        ??f_write_11
   \                     ??f_write_10: (+1)
   \   000000DC   0x2700             MOVS     R7,#+0
   \                     ??f_write_11: (+1)
   \   000000DE   0x0028             MOVS     R0,R5
   \   000000E0   0x6821             LDR      R1,[R4, #+0]
   \   000000E2   0x7889             LDRB     R1,[R1, #+2]
   \   000000E4   0x.... 0x....      BL       __aeabi_uidiv
   \   000000E8   0x19C5             ADDS     R5,R0,R7
   \   000000EA   0x2080             MOVS     R0,#+128
   \   000000EC   0x6821             LDR      R1,[R4, #+0]
   \   000000EE   0x7889             LDRB     R1,[R1, #+2]
   \   000000F0   0x.... 0x....      BL       __aeabi_uidiv
   \   000000F4   0x42A8             CMP      R0,R5
   \   000000F6   0xD205             BCS      ??f_write_12
   \   000000F8   0x2080             MOVS     R0,#+128
   \   000000FA   0x6821             LDR      R1,[R4, #+0]
   \   000000FC   0x7889             LDRB     R1,[R1, #+2]
   \   000000FE   0x.... 0x....      BL       __aeabi_uidiv
   \   00000102   0x0005             MOVS     R5,R0
   \                     ??f_write_12: (+1)
   \   00000104   0x68A0             LDR      R0,[R4, #+8]
   \   00000106   0x2800             CMP      R0,#+0
   \   00000108   0xD10C             BNE      ??f_write_13
   \   0000010A   0x6920             LDR      R0,[R4, #+16]
   \   0000010C   0x9001             STR      R0,[SP, #+4]
   \   0000010E   0x9801             LDR      R0,[SP, #+4]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD10E             BNE      ??f_write_14
   \   00000114   0xAB03             ADD      R3,SP,#+12
   \   00000116   0x002A             MOVS     R2,R5
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0x6820             LDR      R0,[R4, #+0]
   \   0000011C   0x.... 0x....      BL       create_chain_for_clusts
   \   00000120   0x9001             STR      R0,[SP, #+4]
   \   00000122   0xE006             B        ??f_write_14
   \                     ??f_write_13: (+1)
   \   00000124   0xAB03             ADD      R3,SP,#+12
   \   00000126   0x002A             MOVS     R2,R5
   \   00000128   0x6961             LDR      R1,[R4, #+20]
   \   0000012A   0x6820             LDR      R0,[R4, #+0]
   \   0000012C   0x.... 0x....      BL       create_chain_for_clusts
   \   00000130   0x9001             STR      R0,[SP, #+4]
   \                     ??f_write_14: (+1)
   \   00000132   0x9801             LDR      R0,[SP, #+4]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD10C             BNE      ??f_write_15
   3621          #else
   3622          		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
   3623          		fp->flag |= FA__DIRTY;
   3624          #endif
   3625          	}
   3626          
   3627          	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
   \                     ??f_write_7: (+1)
   \   00000138   0x68E0             LDR      R0,[R4, #+12]
   \   0000013A   0x68A1             LDR      R1,[R4, #+8]
   \   0000013C   0x4288             CMP      R0,R1
   \   0000013E   0xD201             BCS      ??f_write_16
   \   00000140   0x68A0             LDR      R0,[R4, #+8]
   \   00000142   0x60E0             STR      R0,[R4, #+12]
   3628          	fp->flag |= FA__WRITTEN;						/* Set file change flag */
   \                     ??f_write_16: (+1)
   \   00000144   0x79A0             LDRB     R0,[R4, #+6]
   \   00000146   0x2120             MOVS     R1,#+32
   \   00000148   0x4301             ORRS     R1,R1,R0
   \   0000014A   0x71A1             STRB     R1,[R4, #+6]
   3629          
   3630          	LEAVE_FF(fp->fs, FR_OK);
   \   0000014C   0x2000             MOVS     R0,#+0
   \                     ??f_write_1: (+1)
   \   0000014E   0xB007             ADD      SP,SP,#+28
   \   00000150   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??f_write_15: (+1)
   \   00000152   0x9801             LDR      R0,[SP, #+4]
   \   00000154   0x2801             CMP      R0,#+1
   \   00000156   0xD105             BNE      ??f_write_17
   \   00000158   0x79A0             LDRB     R0,[R4, #+6]
   \   0000015A   0x2180             MOVS     R1,#+128
   \   0000015C   0x4301             ORRS     R1,R1,R0
   \   0000015E   0x71A1             STRB     R1,[R4, #+6]
   \   00000160   0x2002             MOVS     R0,#+2
   \   00000162   0xE7F4             B        ??f_write_1
   \                     ??f_write_17: (+1)
   \   00000164   0x9801             LDR      R0,[SP, #+4]
   \   00000166   0x2100             MOVS     R1,#+0
   \   00000168   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000016A   0x4288             CMP      R0,R1
   \   0000016C   0xD105             BNE      ??f_write_18
   \   0000016E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000170   0x2180             MOVS     R1,#+128
   \   00000172   0x4301             ORRS     R1,R1,R0
   \   00000174   0x71A1             STRB     R1,[R4, #+6]
   \   00000176   0x2001             MOVS     R0,#+1
   \   00000178   0xE7E9             B        ??f_write_1
   \                     ??f_write_18: (+1)
   \   0000017A   0x9801             LDR      R0,[SP, #+4]
   \   0000017C   0x6160             STR      R0,[R4, #+20]
   \   0000017E   0x6920             LDR      R0,[R4, #+16]
   \   00000180   0x2800             CMP      R0,#+0
   \   00000182   0xD101             BNE      ??f_write_9
   \   00000184   0x9801             LDR      R0,[SP, #+4]
   \   00000186   0x6120             STR      R0,[R4, #+16]
   \                     ??f_write_9: (+1)
   \   00000188   0x2500             MOVS     R5,#+0
   \   0000018A   0xE000             B        ??f_write_19
   \                     ??f_write_20: (+1)
   \   0000018C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_write_19: (+1)
   \   0000018E   0x2D02             CMP      R5,#+2
   \   00000190   0xD208             BCS      ??f_write_21
   \   00000192   0x0029             MOVS     R1,R5
   \   00000194   0xB2C9             UXTB     R1,R1
   \   00000196   0x6820             LDR      R0,[R4, #+0]
   \   00000198   0x.... 0x....      BL       get_sectorprev
   \   0000019C   0x0006             MOVS     R6,R0
   \   0000019E   0x69A0             LDR      R0,[R4, #+24]
   \   000001A0   0x4286             CMP      R6,R0
   \   000001A2   0xD1F3             BNE      ??f_write_20
   \                     ??f_write_21: (+1)
   \   000001A4   0x69A0             LDR      R0,[R4, #+24]
   \   000001A6   0x4286             CMP      R6,R0
   \   000001A8   0xD10C             BNE      ??f_write_22
   \   000001AA   0x0029             MOVS     R1,R5
   \   000001AC   0xB2C9             UXTB     R1,R1
   \   000001AE   0x6820             LDR      R0,[R4, #+0]
   \   000001B0   0x.... 0x....      BL       sync_winindex
   \   000001B4   0x2800             CMP      R0,#+0
   \   000001B6   0xD005             BEQ      ??f_write_22
   \   000001B8   0x79A0             LDRB     R0,[R4, #+6]
   \   000001BA   0x2180             MOVS     R1,#+128
   \   000001BC   0x4301             ORRS     R1,R1,R0
   \   000001BE   0x71A1             STRB     R1,[R4, #+6]
   \   000001C0   0x2001             MOVS     R0,#+1
   \   000001C2   0xE7C4             B        ??f_write_1
   \                     ??f_write_22: (+1)
   \   000001C4   0x6961             LDR      R1,[R4, #+20]
   \   000001C6   0x6820             LDR      R0,[R4, #+0]
   \   000001C8   0x.... 0x....      BL       clust2sect
   \   000001CC   0x0007             MOVS     R7,R0
   \   000001CE   0x9803             LDR      R0,[SP, #+12]
   \   000001D0   0x2802             CMP      R0,#+2
   \   000001D2   0xD304             BCC      ??f_write_23
   \   000001D4   0x9801             LDR      R0,[SP, #+4]
   \   000001D6   0x9903             LDR      R1,[SP, #+12]
   \   000001D8   0x1840             ADDS     R0,R0,R1
   \   000001DA   0x1E40             SUBS     R0,R0,#+1
   \   000001DC   0x6160             STR      R0,[R4, #+20]
   \                     ??f_write_23: (+1)
   \   000001DE   0x2F00             CMP      R7,#+0
   \   000001E0   0xD105             BNE      ??f_write_24
   \   000001E2   0x79A0             LDRB     R0,[R4, #+6]
   \   000001E4   0x2180             MOVS     R1,#+128
   \   000001E6   0x4301             ORRS     R1,R1,R0
   \   000001E8   0x71A1             STRB     R1,[R4, #+6]
   \   000001EA   0x2002             MOVS     R0,#+2
   \   000001EC   0xE7AF             B        ??f_write_1
   \                     ??f_write_24: (+1)
   \   000001EE   0x4668             MOV      R0,SP
   \   000001F0   0x7800             LDRB     R0,[R0, #+0]
   \   000001F2   0x183F             ADDS     R7,R7,R0
   \   000001F4   0x9805             LDR      R0,[SP, #+20]
   \   000001F6   0x0A40             LSRS     R0,R0,#+9
   \   000001F8   0x9002             STR      R0,[SP, #+8]
   \   000001FA   0x9802             LDR      R0,[SP, #+8]
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD05B             BEQ      ??f_write_25
   \   00000200   0x4668             MOV      R0,SP
   \   00000202   0x7800             LDRB     R0,[R0, #+0]
   \   00000204   0x2800             CMP      R0,#+0
   \   00000206   0xD10F             BNE      ??f_write_26
   \   00000208   0x9803             LDR      R0,[SP, #+12]
   \   0000020A   0x2802             CMP      R0,#+2
   \   0000020C   0xD30C             BCC      ??f_write_26
   \   0000020E   0x6820             LDR      R0,[R4, #+0]
   \   00000210   0x7880             LDRB     R0,[R0, #+2]
   \   00000212   0x9903             LDR      R1,[SP, #+12]
   \   00000214   0x4348             MULS     R0,R1,R0
   \   00000216   0x9902             LDR      R1,[SP, #+8]
   \   00000218   0x4288             CMP      R0,R1
   \   0000021A   0xD213             BCS      ??f_write_27
   \   0000021C   0x6820             LDR      R0,[R4, #+0]
   \   0000021E   0x7880             LDRB     R0,[R0, #+2]
   \   00000220   0x9903             LDR      R1,[SP, #+12]
   \   00000222   0x4348             MULS     R0,R1,R0
   \   00000224   0x9002             STR      R0,[SP, #+8]
   \   00000226   0xE00D             B        ??f_write_27
   \                     ??f_write_26: (+1)
   \   00000228   0x6820             LDR      R0,[R4, #+0]
   \   0000022A   0x7880             LDRB     R0,[R0, #+2]
   \   0000022C   0x4669             MOV      R1,SP
   \   0000022E   0x7809             LDRB     R1,[R1, #+0]
   \   00000230   0x9A02             LDR      R2,[SP, #+8]
   \   00000232   0x1889             ADDS     R1,R1,R2
   \   00000234   0x4288             CMP      R0,R1
   \   00000236   0xD205             BCS      ??f_write_27
   \   00000238   0x6820             LDR      R0,[R4, #+0]
   \   0000023A   0x7880             LDRB     R0,[R0, #+2]
   \   0000023C   0x4669             MOV      R1,SP
   \   0000023E   0x7809             LDRB     R1,[R1, #+0]
   \   00000240   0x1A40             SUBS     R0,R0,R1
   \   00000242   0x9002             STR      R0,[SP, #+8]
   \                     ??f_write_27: (+1)
   \   00000244   0x9B02             LDR      R3,[SP, #+8]
   \   00000246   0xB2DB             UXTB     R3,R3
   \   00000248   0x003A             MOVS     R2,R7
   \   0000024A   0x9904             LDR      R1,[SP, #+16]
   \   0000024C   0x6820             LDR      R0,[R4, #+0]
   \   0000024E   0x7840             LDRB     R0,[R0, #+1]
   \   00000250   0x.... 0x....      BL       disk_write
   \   00000254   0x2800             CMP      R0,#+0
   \   00000256   0xD005             BEQ      ??f_write_28
   \   00000258   0x79A0             LDRB     R0,[R4, #+6]
   \   0000025A   0x2180             MOVS     R1,#+128
   \   0000025C   0x4301             ORRS     R1,R1,R0
   \   0000025E   0x71A1             STRB     R1,[R4, #+6]
   \   00000260   0x2001             MOVS     R0,#+1
   \   00000262   0xE774             B        ??f_write_1
   \                     ??f_write_28: (+1)
   \   00000264   0x2500             MOVS     R5,#+0
   \   00000266   0xE020             B        ??f_write_29
   \                     ??f_write_30: (+1)
   \   00000268   0x0029             MOVS     R1,R5
   \   0000026A   0xB2C9             UXTB     R1,R1
   \   0000026C   0x6820             LDR      R0,[R4, #+0]
   \   0000026E   0x.... 0x....      BL       get_sectorprev
   \   00000272   0x0006             MOVS     R6,R0
   \   00000274   0x42BE             CMP      R6,R7
   \   00000276   0xD317             BCC      ??f_write_31
   \   00000278   0x9802             LDR      R0,[SP, #+8]
   \   0000027A   0x1838             ADDS     R0,R7,R0
   \   0000027C   0x4286             CMP      R6,R0
   \   0000027E   0xD213             BCS      ??f_write_31
   \   00000280   0x2280             MOVS     R2,#+128
   \   00000282   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   00000284   0x9804             LDR      R0,[SP, #+16]
   \   00000286   0x1BF1             SUBS     R1,R6,R7
   \   00000288   0x2380             MOVS     R3,#+128
   \   0000028A   0x009B             LSLS     R3,R3,#+2        ;; #+512
   \   0000028C   0x4359             MULS     R1,R3,R1
   \   0000028E   0x1841             ADDS     R1,R0,R1
   \   00000290   0x6820             LDR      R0,[R4, #+0]
   \   00000292   0x2380             MOVS     R3,#+128
   \   00000294   0x009B             LSLS     R3,R3,#+2        ;; #+512
   \   00000296   0x436B             MULS     R3,R5,R3
   \   00000298   0x18C0             ADDS     R0,R0,R3
   \   0000029A   0x3048             ADDS     R0,R0,#+72
   \   0000029C   0x.... 0x....      BL       mem_cpy
   \   000002A0   0x0029             MOVS     R1,R5
   \   000002A2   0x6820             LDR      R0,[R4, #+0]
   \   000002A4   0x.... 0x....      BL       clear_dirty2
   \                     ??f_write_31: (+1)
   \   000002A8   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_write_29: (+1)
   \   000002AA   0x2D02             CMP      R5,#+2
   \   000002AC   0xD3DC             BCC      ??f_write_30
   \   000002AE   0x9D02             LDR      R5,[SP, #+8]
   \   000002B0   0x2080             MOVS     R0,#+128
   \   000002B2   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   000002B4   0x4345             MULS     R5,R0,R5
   \   000002B6   0xE6DF             B        ??f_write_6
   \                     ??f_write_25: (+1)
   \   000002B8   0x68A0             LDR      R0,[R4, #+8]
   \   000002BA   0x68E1             LDR      R1,[R4, #+12]
   \   000002BC   0x4288             CMP      R0,R1
   \   000002BE   0xD31A             BCC      ??f_write_32
   \   000002C0   0x6820             LDR      R0,[R4, #+0]
   \   000002C2   0x6C40             LDR      R0,[R0, #+68]
   \   000002C4   0x6821             LDR      R1,[R4, #+0]
   \   000002C6   0x3148             ADDS     R1,R1,#+72
   \   000002C8   0x4288             CMP      R0,R1
   \   000002CA   0xD101             BNE      ??f_write_33
   \   000002CC   0x2100             MOVS     R1,#+0
   \   000002CE   0xE000             B        ??f_write_34
   \                     ??f_write_33: (+1)
   \   000002D0   0x2101             MOVS     R1,#+1
   \                     ??f_write_34: (+1)
   \   000002D2   0xB2C9             UXTB     R1,R1
   \   000002D4   0x6820             LDR      R0,[R4, #+0]
   \   000002D6   0x.... 0x....      BL       sync_winindex
   \   000002DA   0x2800             CMP      R0,#+0
   \   000002DC   0xD005             BEQ      ??f_write_35
   \   000002DE   0x79A0             LDRB     R0,[R4, #+6]
   \   000002E0   0x2180             MOVS     R1,#+128
   \   000002E2   0x4301             ORRS     R1,R1,R0
   \   000002E4   0x71A1             STRB     R1,[R4, #+6]
   \   000002E6   0x2001             MOVS     R0,#+1
   \   000002E8   0xE731             B        ??f_write_1
   \                     ??f_write_35: (+1)
   \   000002EA   0x6820             LDR      R0,[R4, #+0]
   \   000002EC   0x6347             STR      R7,[R0, #+52]
   \   000002EE   0x0039             MOVS     R1,R7
   \   000002F0   0x6820             LDR      R0,[R4, #+0]
   \   000002F2   0x.... 0x....      BL       set_sectorprev
   \                     ??f_write_32: (+1)
   \   000002F6   0x61A7             STR      R7,[R4, #+24]
   \                     ??f_write_8: (+1)
   \   000002F8   0x2580             MOVS     R5,#+128
   \   000002FA   0x00AD             LSLS     R5,R5,#+2        ;; #+512
   \   000002FC   0x68A0             LDR      R0,[R4, #+8]
   \   000002FE   0x2180             MOVS     R1,#+128
   \   00000300   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000302   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000306   0x1A6D             SUBS     R5,R5,R1
   \   00000308   0x9805             LDR      R0,[SP, #+20]
   \   0000030A   0x42A8             CMP      R0,R5
   \   0000030C   0xD200             BCS      ??f_write_36
   \   0000030E   0x9D05             LDR      R5,[SP, #+20]
   \                     ??f_write_36: (+1)
   \   00000310   0x69A1             LDR      R1,[R4, #+24]
   \   00000312   0x6820             LDR      R0,[R4, #+0]
   \   00000314   0x.... 0x....      BL       move_window
   \   00000318   0x2800             CMP      R0,#+0
   \   0000031A   0xD100             BNE      .+4
   \   0000031C   0xE699             B        ??f_write_5
   \   0000031E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000320   0x2180             MOVS     R1,#+128
   \   00000322   0x4301             ORRS     R1,R1,R0
   \   00000324   0x71A1             STRB     R1,[R4, #+6]
   \   00000326   0x2001             MOVS     R0,#+1
   \   00000328   0xE711             B        ??f_write_1
   3631          }
   3632          
   3633          
   3634          /*FUNCTION*-------------------------------------------------------------------
   3635          *
   3636          * Function Name    :  f_sync
   3637          * Returned Value   : 
   3638          *                    
   3639          * Comments         :   Synchronize the File Object
   3640          *   
   3641          *END*----------------------------------------------------------------------*/
   3642          //
   3643          //!_FS_TINYfp->fs->win

   \                                 In section .text, align 2, keep-with-next
   3644          FRESULT f_sync 
   3645            (
   3646              /* [IN] Pointer to the file object */
   3647            	FIL *fp		
   3648            )
   3649          {
   \                     f_sync: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3650          	FRESULT res;
   3651          	uint32_t tm;
   3652          	uint8_t *dir;
   3653          
   3654          
   3655          	res = validate(fp);					/* Check validity of the object */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       validate
   3656          	if (res == FR_OK) {
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD13D             BNE      ??f_sync_0
   3657          		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
   \   00000010   0x79A1             LDRB     R1,[R4, #+6]
   \   00000012   0x0689             LSLS     R1,R1,#+26
   \   00000014   0xD53A             BPL      ??f_sync_0
   3658          #if !_FS_TINY	/* Write-back dirty buffer */
   3659          			if (fp->flag & FA__DIRTY) {
   3660          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3661          					LEAVE_FF(fp->fs, FR_DISK_ERR);
   3662          				fp->flag &= ~FA__DIRTY;
   3663          			}
   3664          #endif
   3665          			/* Update the directory entry */
   3666          			res = move_window(fp->fs, fp->dir_sect);
   \   00000016   0x69E1             LDR      R1,[R4, #+28]
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       move_window
   3667          			if (res == FR_OK) {
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD133             BNE      ??f_sync_0
   3668          				dir = convert_ptr(fp->fs, fp->dir_ptr);
   \   00000024   0x6A21             LDR      R1,[R4, #+32]
   \   00000026   0x6820             LDR      R0,[R4, #+0]
   \   00000028   0x.... 0x....      BL       convert_ptr
   \   0000002C   0x0005             MOVS     R5,R0
   3669          				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
   \   0000002E   0x7AE8             LDRB     R0,[R5, #+11]
   \   00000030   0x2120             MOVS     R1,#+32
   \   00000032   0x4301             ORRS     R1,R1,R0
   \   00000034   0x72E9             STRB     R1,[R5, #+11]
   3670          				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
   \   00000036   0x68E0             LDR      R0,[R4, #+12]
   \   00000038   0x7728             STRB     R0,[R5, #+28]
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0xB280             UXTH     R0,R0
   \   0000003E   0x0A00             LSRS     R0,R0,#+8
   \   00000040   0x7768             STRB     R0,[R5, #+29]
   \   00000042   0x68E0             LDR      R0,[R4, #+12]
   \   00000044   0x0C00             LSRS     R0,R0,#+16
   \   00000046   0x77A8             STRB     R0,[R5, #+30]
   \   00000048   0x68E0             LDR      R0,[R4, #+12]
   \   0000004A   0x0E00             LSRS     R0,R0,#+24
   \   0000004C   0x77E8             STRB     R0,[R5, #+31]
   3671          				st_clust(dir, fp->sclust);					/* Update start cluster */
   \   0000004E   0x6921             LDR      R1,[R4, #+16]
   \   00000050   0x0028             MOVS     R0,R5
   \   00000052   0x.... 0x....      BL       st_clust
   3672          				tm = get_fattime();							/* Update updated time */
   \   00000056   0x.... 0x....      BL       get_fattime
   3673          				ST_DWORD(dir+DIR_WrtTime, tm);
   \   0000005A   0x0001             MOVS     R1,R0
   \   0000005C   0x75A9             STRB     R1,[R5, #+22]
   \   0000005E   0x0001             MOVS     R1,R0
   \   00000060   0xB289             UXTH     R1,R1
   \   00000062   0x0A09             LSRS     R1,R1,#+8
   \   00000064   0x75E9             STRB     R1,[R5, #+23]
   \   00000066   0x0001             MOVS     R1,R0
   \   00000068   0x0C09             LSRS     R1,R1,#+16
   \   0000006A   0x7629             STRB     R1,[R5, #+24]
   \   0000006C   0x0E00             LSRS     R0,R0,#+24
   \   0000006E   0x7668             STRB     R0,[R5, #+25]
   3674          				ST_WORD(dir+DIR_LstAccDate, 0);
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x74A8             STRB     R0,[R5, #+18]
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x74E8             STRB     R0,[R5, #+19]
   3675          				fp->flag &= ~FA__WRITTEN;
   \   00000078   0x79A0             LDRB     R0,[R4, #+6]
   \   0000007A   0x21DF             MOVS     R1,#+223
   \   0000007C   0x4001             ANDS     R1,R1,R0
   \   0000007E   0x71A1             STRB     R1,[R4, #+6]
   3676                          set_dirty(fp->fs);
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x.... 0x....      BL       set_dirty
   3677          				res = sync_fs(fp->fs);
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       sync_fs
   3678          			}
   3679          		}
   3680          	}
   3681          
   3682          	LEAVE_FF(fp->fs, res);
   \                     ??f_sync_0: (+1)
   \   0000008C   0xB2C0             UXTB     R0,R0
   \   0000008E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3683          }
   3684          
   3685          #endif /* !_FS_READONLY */
   3686          
   3687          
   3688          
   3689          /*FUNCTION*-------------------------------------------------------------------
   3690          *
   3691          * Function Name    : f_close
   3692          * Returned Value   : FR_OK : 		The file object has been closed successfully.
   3693          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   3694          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   3695          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   3696          *                    FR_INVALID_OBJECT:The file object is invalid.
   3697          *
   3698          *                    
   3699          * Comments         :  The f_close function closes an open file object. If any data has been
   3700          *                     written to the file, the cached information of the file is written back
   3701          *                     to the disk. After the function succeeded, the file object is no longer
   3702          *                     valid and it can be discarded
   3703          *   
   3704          *END*----------------------------------------------------------------------*/
   3705          //fp->fs = 0; f_sync; _FS_LOCKdec_lock

   \                                 In section .text, align 2, keep-with-next
   3706          FRESULT f_close 
   3707            (
   3708              /* [IN] Pointer to the file object to be closed */
   3709            	FIL *fp		
   3710            )
   3711          {
   \                     f_close: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   3712          	FRESULT res;
   3713          
   3714          
   3715          #if _FS_READONLY
   3716          	res = validate(fp);
   3717          	{
   3718          #if _FS_REENTRANT
   3719          		FATFS *fs = fp->fs;
   3720          #endif
   3721          		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   3722          		LEAVE_FF(fs, res);
   3723          	}
   3724          #else
   3725          	res = f_sync(fp);		/* Flush cached data */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       f_sync
   3726          #if _FS_LOCK
   3727          	if (res == FR_OK) {		/* Decrement open counter */
   3728          #if _FS_REENTRANT
   3729          		FATFS *fs = fp->fs;;
   3730          		res = validate(fp);
   3731          		if (res == FR_OK) {
   3732          			res = dec_lock(fp->lockid);	
   3733          			unlock_fs(fs, FR_OK);
   3734          		}
   3735          #else
   3736          		res = dec_lock(fp->lockid);
   3737          #endif
   3738          	}
   3739          #endif
   3740          	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD101             BNE      ??f_close_0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6021             STR      R1,[R4, #+0]
   3741          	return res;
   \                     ??f_close_0: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   3742          #endif
   3743          }
   3744          
   3745          
   3746          /*FUNCTION*-------------------------------------------------------------------
   3747          *
   3748          * Function Name    : f_chdrive
   3749          * Returned Value   : FR_OK (0): The function succeeded.
   3750          *                    FR_INVALID_DRIVE: The drive number is invalid. 
   3751          *                    
   3752          * Comments         : The f_chdrive function changes the current drive. The initial value
   3753          *                    of the current drive number is 0. Note that the current drive is retained
   3754          *                    in a static variable so that it also affects other tasks that using the
   3755          *                    file functions. 
   3756          *   
   3757          *END*----------------------------------------------------------------------*/
   3758          
   3759          #if _FS_RPATH >= 1
   3760          

   \                                 In section .text, align 2, keep-with-next
   3761          FRESULT f_chdrive 
   3762            (
   3763              /* [IN] Drive number */
   3764            	uint8_t drv		
   3765            )
   3766          {
   \                     f_chdrive: (+1)
   \   00000000   0xB500             PUSH     {LR}
   3767          	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xDB01             BLT      ??f_chdrive_0
   \   00000008   0x200B             MOVS     R0,#+11
   \   0000000A   0xE002             B        ??f_chdrive_1
   3768          
   3769          	CurrVol = drv;
   \                     ??f_chdrive_0: (+1)
   \   0000000C   0x....             LDR      R1,??DataTable19
   \   0000000E   0x7008             STRB     R0,[R1, #+0]
   3770          
   3771          	return FR_OK;
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??f_chdrive_1: (+1)
   \   00000012   0xBD00             POP      {PC}             ;; return
   3772          }
   3773          
   3774          /*FUNCTION*-------------------------------------------------------------------
   3775          *
   3776          * Function Name    : f_chdir
   3777          * Returned Value   : FR_OK (0): The function succeeded.
   3778          *                    FR_NO_PATH: 	Could not find the path.
   3779          *                    FR_INVALID_NAME: 	The path name is invalid.
   3780          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   3781          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   3782          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   3783          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   3784          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   3785          *                    FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   3786          * 
   3787          *                    
   3788          * Comments         : The f_chdir function changes the current directory of the logical drive.
   3789          *                    The current directory of a drive is initialized to the root directory when
   3790          *                    the drive is auto-mounted. Note that the current directory is retained in
   3791          *                    the each file system object so that it also affects other tasks that using the drive. 
   3792          *   
   3793          *END*----------------------------------------------------------------------*/
   3794          

   \                                 In section .text, align 2, keep-with-next
   3795          FRESULT f_chdir 
   3796            (
   3797              /* [IN] Pointer to the directory path */
   3798            	const TCHAR *path	
   3799            )
   3800          {
   \                     f_chdir: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   3801          	FRESULT res;
   3802          	DIR dj;
   3803          	DEF_NAMEBUF;
   3804          
   3805          
   3806          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0xA80C             ADD      R0,SP,#+48
   \   0000000A   0x.... 0x....      BL       chk_mounted
   \   0000000E   0x0004             MOVS     R4,R0
   3807          	if (res == FR_OK) {
   \   00000010   0xB2E4             UXTB     R4,R4
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD134             BNE      ??f_chdir_0
   3808          		INIT_BUF(dj);
   \   00000016   0x2080             MOVS     R0,#+128
   \   00000018   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   0000001A   0x.... 0x....      BL       ff_memalloc
   \   0000001E   0x0005             MOVS     R5,R0
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD101             BNE      ??f_chdir_1
   \   00000024   0x2011             MOVS     R0,#+17
   \   00000026   0xE02D             B        ??f_chdir_2
   \                     ??f_chdir_1: (+1)
   \   00000028   0x9507             STR      R5,[SP, #+28]
   \   0000002A   0xA809             ADD      R0,SP,#+36
   \   0000002C   0x9006             STR      R0,[SP, #+24]
   3809          		res = follow_path(&dj, path);		/* Follow the path */
   \   0000002E   0x990C             LDR      R1,[SP, #+48]
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0004             MOVS     R4,R0
   3810          		FREE_BUF();
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       ff_memfree
   3811          		if (res == FR_OK) {					/* Follow completed */
   \   0000003E   0xB2E4             UXTB     R4,R4
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD119             BNE      ??f_chdir_3
   3812          			if (!dj.dir) {
   \   00000044   0x9805             LDR      R0,[SP, #+20]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD103             BNE      ??f_chdir_4
   3813          				dj.fs->cdir = dj.sclust;	/* Start directory itself */
   \   0000004A   0x9802             LDR      R0,[SP, #+8]
   \   0000004C   0x9900             LDR      R1,[SP, #+0]
   \   0000004E   0x6188             STR      R0,[R1, #+24]
   \   00000050   0xE012             B        ??f_chdir_3
   3814          			} else {
   3815          				if (convert_ptr(dj.fs, dj.dir)[DIR_Attr] & AM_DIR)	/* Reached to the directory */
   \                     ??f_chdir_4: (+1)
   \   00000052   0x9905             LDR      R1,[SP, #+20]
   \   00000054   0x9800             LDR      R0,[SP, #+0]
   \   00000056   0x.... 0x....      BL       convert_ptr
   \   0000005A   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000005C   0x06C0             LSLS     R0,R0,#+27
   \   0000005E   0xD50A             BPL      ??f_chdir_5
   3816          					dj.fs->cdir = ld_clust(dj.fs, convert_ptr(dj.fs, dj.dir));
   \   00000060   0x9905             LDR      R1,[SP, #+20]
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x.... 0x....      BL       convert_ptr
   \   00000068   0x0001             MOVS     R1,R0
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x.... 0x....      BL       ld_clust
   \   00000070   0x9900             LDR      R1,[SP, #+0]
   \   00000072   0x6188             STR      R0,[R1, #+24]
   \   00000074   0xE000             B        ??f_chdir_3
   3817          				else
   3818          					res = FR_NO_PATH;		/* Reached but a file */
   \                     ??f_chdir_5: (+1)
   \   00000076   0x2405             MOVS     R4,#+5
   3819          			}
   3820          		}
   3821          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_chdir_3: (+1)
   \   00000078   0xB2E4             UXTB     R4,R4
   \   0000007A   0x2C04             CMP      R4,#+4
   \   0000007C   0xD100             BNE      ??f_chdir_0
   \   0000007E   0x2405             MOVS     R4,#+5
   3822          	}
   3823          
   3824          	LEAVE_FF(dj.fs, res);
   \                     ??f_chdir_0: (+1)
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0xB2C0             UXTB     R0,R0
   \                     ??f_chdir_2: (+1)
   \   00000084   0xB00D             ADD      SP,SP,#+52
   \   00000086   0xBD30             POP      {R4,R5,PC}       ;; return
   3825          }
   3826          
   3827          /*FUNCTION*-------------------------------------------------------------------
   3828          *
   3829          * Function Name    : f_getcwd
   3830          * Returned Value   : FR_OK: 		The function succeeded.
   3831          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   3832          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   3833          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   3834          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   3835          *                    FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   3836          *                    FR_NOT_ENOUGH_CORE: Insufficient size of Buffer.
   3837          *
   3838          *                    
   3839          * Comments         : The f_getcwd function retrieves the current directory of the
   3840          *                    current drive in full path string including drive number
   3841          *   
   3842          *END*----------------------------------------------------------------------*/
   3843          #if _FS_RPATH >= 2

   \                                 In section .text, align 2, keep-with-next
   3844          FRESULT f_getcwd
   3845          (
   3846              /* [OUT] Pointer to the directory path */
   3847          	TCHAR *buff,
   3848          	/* [IN/OUT]Size of path */
   3849          	uint32_t len
   3850          )
   3851          {
   \                     f_getcwd: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB095             SUB      SP,SP,#+84
   3852          	FRESULT res;
   3853          	DIR dj;
   3854          	uint32_t i, n;
   3855          	uint32_t ccl;
   3856          	TCHAR *tp;
   3857          	FILINFO fno;
   3858          	DEF_NAMEBUF;
   3859          
   3860          
   3861          	*buff = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9915             LDR      R1,[SP, #+84]
   \   00000008   0x7008             STRB     R0,[R1, #+0]
   3862          	res = chk_mounted((const TCHAR**)&buff, &dj.fs, 0);	/* Get current volume */
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0xA815             ADD      R0,SP,#+84
   \   00000010   0x.... 0x....      BL       chk_mounted
   \   00000014   0x0004             MOVS     R4,R0
   3863          	if (res == FR_OK) {
   \   00000016   0xB2E4             UXTB     R4,R4
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD000             BEQ      .+4
   \   0000001C   0xE099             B        ??f_getcwd_0
   3864          		INIT_BUF(dj);
   \   0000001E   0x2080             MOVS     R0,#+128
   \   00000020   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000022   0x.... 0x....      BL       ff_memalloc
   \   00000026   0x0006             MOVS     R6,R0
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD101             BNE      ??f_getcwd_1
   \   0000002C   0x2011             MOVS     R0,#+17
   \   0000002E   0xE092             B        ??f_getcwd_2
   \                     ??f_getcwd_1: (+1)
   \   00000030   0x9607             STR      R6,[SP, #+28]
   \   00000032   0xA809             ADD      R0,SP,#+36
   \   00000034   0x9006             STR      R0,[SP, #+24]
   3865          		i = len;			/* Bottom of buffer (dir stack base) */
   \   00000036   0x9D16             LDR      R5,[SP, #+88]
   3866          		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
   \   00000038   0x9800             LDR      R0,[SP, #+0]
   \   0000003A   0x6980             LDR      R0,[R0, #+24]
   \   0000003C   0x9002             STR      R0,[SP, #+8]
   \   0000003E   0xE00A             B        ??f_getcwd_3
   3867          		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
   3868          			res = dir_sdi(&dj, 1);			/* Get parent dir */
   3869          			if (res != FR_OK) break;
   3870          			res = dir_read(&dj, 0);
   3871          			if (res != FR_OK) break;
   3872          			dj.sclust = ld_clust(dj.fs, convert_ptr(dj.fs, dj.dir));	/* Goto parent dir */
   3873          			res = dir_sdi(&dj, 0);
   3874          			if (res != FR_OK) break;
   3875          			do {							/* Find the entry links to the child dir */
   3876          				res = dir_read(&dj, 0);
   3877          				if (res != FR_OK) break;
   3878          				if (ccl == ld_clust(dj.fs, convert_ptr(dj.fs, dj.dir))) break;	/* Found the entry */
   3879          				res = dir_next(&dj, 0);	
   3880          			} while (res == FR_OK);
   3881          			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   3882          			if (res != FR_OK) break;
   3883          #if _USE_LFN
   3884          			fno.lfname = buff;
   3885          			fno.lfsize = i;
   3886          #endif
   3887          			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
   3888          			tp = fno.fname;
   3889          			if (_USE_LFN && *buff) tp = buff;
   3890          			for (n = 0; tp[n]; n++) ;
   3891          			if (i < n + 3) {
   3892          				res = FR_NOT_ENOUGH_CORE; break;
   3893          			}
   3894          			while (n) buff[--i] = tp[--n];
   \                     ??f_getcwd_4: (+1)
   \   00000040   0x1E6D             SUBS     R5,R5,#+1
   \   00000042   0x1E52             SUBS     R2,R2,#+1
   \   00000044   0x5C88             LDRB     R0,[R1, R2]
   \   00000046   0x9B15             LDR      R3,[SP, #+84]
   \   00000048   0x5558             STRB     R0,[R3, R5]
   \                     ??f_getcwd_5: (+1)
   \   0000004A   0x2A00             CMP      R2,#+0
   \   0000004C   0xD1F8             BNE      ??f_getcwd_4
   3895          			buff[--i] = '/';
   \   0000004E   0x1E6D             SUBS     R5,R5,#+1
   \   00000050   0x202F             MOVS     R0,#+47
   \   00000052   0x9915             LDR      R1,[SP, #+84]
   \   00000054   0x5548             STRB     R0,[R1, R5]
   \                     ??f_getcwd_3: (+1)
   \   00000056   0x9F02             LDR      R7,[SP, #+8]
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xD05A             BEQ      ??f_getcwd_6
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x4668             MOV      R0,SP
   \   00000060   0x.... 0x....      BL       dir_sdi
   \   00000064   0x0004             MOVS     R4,R0
   \   00000066   0xB2E4             UXTB     R4,R4
   \   00000068   0x2C00             CMP      R4,#+0
   \   0000006A   0xD152             BNE      ??f_getcwd_6
   \                     ??f_getcwd_7: (+1)
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x4668             MOV      R0,SP
   \   00000070   0x.... 0x....      BL       dir_read
   \   00000074   0x0004             MOVS     R4,R0
   \   00000076   0xB2E4             UXTB     R4,R4
   \   00000078   0x2C00             CMP      R4,#+0
   \   0000007A   0xD14A             BNE      ??f_getcwd_6
   \                     ??f_getcwd_8: (+1)
   \   0000007C   0x9905             LDR      R1,[SP, #+20]
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x.... 0x....      BL       convert_ptr
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x9800             LDR      R0,[SP, #+0]
   \   00000088   0x.... 0x....      BL       ld_clust
   \   0000008C   0x9002             STR      R0,[SP, #+8]
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x4668             MOV      R0,SP
   \   00000092   0x.... 0x....      BL       dir_sdi
   \   00000096   0x0004             MOVS     R4,R0
   \   00000098   0xB2E4             UXTB     R4,R4
   \   0000009A   0x2C00             CMP      R4,#+0
   \   0000009C   0xD139             BNE      ??f_getcwd_6
   \                     ??f_getcwd_9: (+1)
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x.... 0x....      BL       dir_read
   \   000000A6   0x0004             MOVS     R4,R0
   \   000000A8   0xB2E4             UXTB     R4,R4
   \   000000AA   0x2C00             CMP      R4,#+0
   \   000000AC   0xD111             BNE      ??f_getcwd_10
   \                     ??f_getcwd_11: (+1)
   \   000000AE   0x9905             LDR      R1,[SP, #+20]
   \   000000B0   0x9800             LDR      R0,[SP, #+0]
   \   000000B2   0x.... 0x....      BL       convert_ptr
   \   000000B6   0x0001             MOVS     R1,R0
   \   000000B8   0x9800             LDR      R0,[SP, #+0]
   \   000000BA   0x.... 0x....      BL       ld_clust
   \   000000BE   0x4287             CMP      R7,R0
   \   000000C0   0xD007             BEQ      ??f_getcwd_10
   \                     ??f_getcwd_12: (+1)
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x4668             MOV      R0,SP
   \   000000C6   0x.... 0x....      BL       dir_next
   \   000000CA   0x0004             MOVS     R4,R0
   \   000000CC   0xB2E4             UXTB     R4,R4
   \   000000CE   0x2C00             CMP      R4,#+0
   \   000000D0   0xD0E5             BEQ      ??f_getcwd_9
   \                     ??f_getcwd_10: (+1)
   \   000000D2   0xB2E4             UXTB     R4,R4
   \   000000D4   0x2C04             CMP      R4,#+4
   \   000000D6   0xD100             BNE      ??f_getcwd_13
   \   000000D8   0x2402             MOVS     R4,#+2
   \                     ??f_getcwd_13: (+1)
   \   000000DA   0xB2E4             UXTB     R4,R4
   \   000000DC   0x2C00             CMP      R4,#+0
   \   000000DE   0xD118             BNE      ??f_getcwd_6
   \                     ??f_getcwd_14: (+1)
   \   000000E0   0x9815             LDR      R0,[SP, #+84]
   \   000000E2   0x9012             STR      R0,[SP, #+72]
   \   000000E4   0x9513             STR      R5,[SP, #+76]
   \   000000E6   0xA90C             ADD      R1,SP,#+48
   \   000000E8   0x4668             MOV      R0,SP
   \   000000EA   0x.... 0x....      BL       get_fileinfo
   \   000000EE   0xA90C             ADD      R1,SP,#+48
   \   000000F0   0x3109             ADDS     R1,R1,#+9
   \   000000F2   0x9815             LDR      R0,[SP, #+84]
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD000             BEQ      ??f_getcwd_15
   \   000000FA   0x9915             LDR      R1,[SP, #+84]
   \                     ??f_getcwd_15: (+1)
   \   000000FC   0x2200             MOVS     R2,#+0
   \   000000FE   0xE000             B        ??f_getcwd_16
   \                     ??f_getcwd_17: (+1)
   \   00000100   0x1C52             ADDS     R2,R2,#+1
   \                     ??f_getcwd_16: (+1)
   \   00000102   0x5C88             LDRB     R0,[R1, R2]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD1FB             BNE      ??f_getcwd_17
   \   00000108   0x0010             MOVS     R0,R2
   \   0000010A   0x1CC0             ADDS     R0,R0,#+3
   \   0000010C   0x4285             CMP      R5,R0
   \   0000010E   0xD29C             BCS      ??f_getcwd_5
   \   00000110   0x2411             MOVS     R4,#+17
   3896          		}
   3897          		tp = buff;
   \                     ??f_getcwd_6: (+1)
   \   00000112   0x9915             LDR      R1,[SP, #+84]
   3898          		if (res == FR_OK) {
   \   00000114   0xB2E4             UXTB     R4,R4
   \   00000116   0x2C00             CMP      R4,#+0
   \   00000118   0xD116             BNE      ??f_getcwd_18
   3899          			*tp++ = '0' + CurrVol;			/* Put drive number */
   \   0000011A   0x....             LDR      R0,??DataTable19
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x3030             ADDS     R0,R0,#+48
   \   00000120   0x7008             STRB     R0,[R1, #+0]
   \   00000122   0x1C49             ADDS     R1,R1,#+1
   3900          			*tp++ = ':';
   \   00000124   0x203A             MOVS     R0,#+58
   \   00000126   0x7008             STRB     R0,[R1, #+0]
   \   00000128   0x1C49             ADDS     R1,R1,#+1
   3901          			if (i == len) {					/* Root-dir */
   \   0000012A   0x9816             LDR      R0,[SP, #+88]
   \   0000012C   0x4285             CMP      R5,R0
   \   0000012E   0xD103             BNE      ??f_getcwd_19
   3902          				*tp++ = '/';
   \   00000130   0x202F             MOVS     R0,#+47
   \   00000132   0x7008             STRB     R0,[R1, #+0]
   \   00000134   0x1C49             ADDS     R1,R1,#+1
   \   00000136   0xE007             B        ??f_getcwd_18
   3903          			} else {						/* Sub-dir */
   3904          				do		/* Add stacked path str */
   3905          					*tp++ = buff[i++];
   \                     ??f_getcwd_19: (+1)
   \   00000138   0x9815             LDR      R0,[SP, #+84]
   \   0000013A   0x5D40             LDRB     R0,[R0, R5]
   \   0000013C   0x7008             STRB     R0,[R1, #+0]
   \   0000013E   0x1C6D             ADDS     R5,R5,#+1
   \   00000140   0x1C49             ADDS     R1,R1,#+1
   3906          				while (i < len);
   \   00000142   0x9816             LDR      R0,[SP, #+88]
   \   00000144   0x4285             CMP      R5,R0
   \   00000146   0xD3F7             BCC      ??f_getcwd_19
   3907          			}
   3908          		}
   3909          		*tp = 0;
   \                     ??f_getcwd_18: (+1)
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0x7008             STRB     R0,[R1, #+0]
   3910          		FREE_BUF();
   \   0000014C   0x0030             MOVS     R0,R6
   \   0000014E   0x.... 0x....      BL       ff_memfree
   3911          	}
   3912          
   3913          	LEAVE_FF(dj.fs, res);
   \                     ??f_getcwd_0: (+1)
   \   00000152   0x0020             MOVS     R0,R4
   \   00000154   0xB2C0             UXTB     R0,R0
   \                     ??f_getcwd_2: (+1)
   \   00000156   0xB017             ADD      SP,SP,#+92
   \   00000158   0xBDF0             POP      {R4-R7,PC}       ;; return
   3914          }
   3915          #endif /* _FS_RPATH >= 2 */
   3916          #endif /* _FS_RPATH >= 1 */
   3917          
   3918          
   3919          
   3920          #if _FS_MINIMIZE <= 2
   3921          /*FUNCTION*-------------------------------------------------------------------
   3922          *
   3923          * Function Name    :  f_lseek
   3924          * Returned Value   :  FR_OK : 		The function succeeded.
   3925          *                     FR_DENIED: 	The function denied due to the file has been opened in non-write mode.
   3926          *                     FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   3927          *                     FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   3928          *                     FR_INVALID_OBJECT: The file object is invalid.
   3929          *                     FR_NOT_ENOUGH_CORE: Insufficient size of link map table for the file.
   3930          *
   3931          *                    
   3932          * Comments         : The f_lseek function moves the file read/write pointer of an open file.
   3933                               The offset can be specified in only origin from top of the file
   3934          *   
   3935          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   3936          FRESULT f_lseek 
   3937            (
   3938              /* [IN] Pointer to the file object */
   3939          	  FIL *fp,		
   3940          	  /* [IN] File pointer from top of file */
   3941          	  uint32_t ofs		
   3942            )
   3943          {
   \                     f_lseek: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   3944          	FRESULT res;
   3945          
   3946          
   3947          	res = validate(fp);					/* Check validity of the object */
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       validate
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7108             STRB     R0,[R1, #+4]
   3948          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x7900             LDRB     R0,[R0, #+4]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ      ??f_lseek_0
   \   00000018   0x4668             MOV      R0,SP
   \   0000001A   0x7900             LDRB     R0,[R0, #+4]
   \   0000001C   0xE0AF             B        ??f_lseek_1
   3949          	if (fp->flag & FA__ERROR)			/* Check abort flag */
   \                     ??f_lseek_0: (+1)
   \   0000001E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD501             BPL      ??f_lseek_2
   3950          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000024   0x2002             MOVS     R0,#+2
   \   00000026   0xE0AA             B        ??f_lseek_1
   3951          
   3952          #if _USE_FASTSEEK
   3953          	if (fp->cltbl) {	/* Fast seek */
   3954          		uint32_t cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   3955          
   3956          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   3957          			tbl = fp->cltbl;
   3958          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   3959          			cl = fp->sclust;			/* Top of the chain */
   3960          			if (cl) {
   3961          				do {
   3962          					/* Get a fragment */
   3963          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   3964          					do {
   3965          						pcl = cl; ncl++;
   3966          						cl = get_fat(fp->fs, cl);
   3967          						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
   3968          						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   3969          					} while (cl == pcl + 1);
   3970          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   3971          						*tbl++ = ncl; *tbl++ = tcl;
   3972          					}
   3973          				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
   3974          			}
   3975          			*fp->cltbl = ulen;	/* Number of items used */
   3976          			if (ulen <= tlen)
   3977          				*tbl = 0;		/* Terminate table */
   3978          			else
   3979          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   3980          
   3981          		} else {						/* Fast seek */
   3982          			if (ofs > fp->fsize)		/* Clip offset at the file size */
   3983          				ofs = fp->fsize;
   3984          			fp->fptr = ofs;				/* Set file pointer */
   3985          			if (ofs) {
   3986          				fp->clust = clmt_clust(fp, ofs - 1);
   3987          				dsc = clust2sect(fp->fs, fp->clust);
   3988          				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
   3989          				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
   3990          				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
   3991          #if !_FS_TINY
   3992          #if !_FS_READONLY
   3993          					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
   3994          						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   3995          							ABORT(fp->fs, FR_DISK_ERR);
   3996          						fp->flag &= ~FA__DIRTY;
   3997          					}
   3998          #endif
   3999          					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
   4000          						ABORT(fp->fs, FR_DISK_ERR);
   4001          #endif
   4002          					fp->dsect = dsc;
   4003          				}
   4004          			}
   4005          		}
   4006          	} else
   4007          #endif
   4008          
   4009          	/* Normal Seek */
   4010          	{
   4011          		uint32_t clst, bcs, nsect, ifptr;
   4012          
   4013          		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
   4014          #if !_FS_READONLY
   4015          			 && !(fp->flag & FA_WRITE)
   4016          #endif
   4017          			) ofs = fp->fsize;
   \                     ??f_lseek_2: (+1)
   \   00000028   0x68E0             LDR      R0,[R4, #+12]
   \   0000002A   0x42A8             CMP      R0,R5
   \   0000002C   0xD203             BCS      ??f_lseek_3
   \   0000002E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000030   0x0780             LSLS     R0,R0,#+30
   \   00000032   0xD400             BMI      ??f_lseek_3
   \   00000034   0x68E5             LDR      R5,[R4, #+12]
   4018          
   4019          		ifptr = fp->fptr;
   \                     ??f_lseek_3: (+1)
   \   00000036   0x68A7             LDR      R7,[R4, #+8]
   4020          		fp->fptr = nsect = 0;
   \   00000038   0x2600             MOVS     R6,#+0
   \   0000003A   0x60A6             STR      R6,[R4, #+8]
   4021          		if (ofs) {
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD100             BNE      .+4
   \   00000040   0xE086             B        ??f_lseek_4
   4022          			bcs = (uint32_t)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x7880             LDRB     R0,[R0, #+2]
   \   00000046   0x2180             MOVS     R1,#+128
   \   00000048   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000004A   0x4348             MULS     R0,R1,R0
   \   0000004C   0x9002             STR      R0,[SP, #+8]
   4023          			if (ifptr > 0 &&
   4024          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   \   0000004E   0x2F00             CMP      R7,#+0
   \   00000050   0xD015             BEQ      ??f_lseek_5
   \   00000052   0x1E78             SUBS     R0,R7,#+1
   \   00000054   0x9902             LDR      R1,[SP, #+8]
   \   00000056   0x.... 0x....      BL       __aeabi_uidiv
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x1E68             SUBS     R0,R5,#+1
   \   0000005E   0x9902             LDR      R1,[SP, #+8]
   \   00000060   0x.... 0x....      BL       __aeabi_uidiv
   \   00000064   0x0001             MOVS     R1,R0
   \   00000066   0x9800             LDR      R0,[SP, #+0]
   \   00000068   0x4281             CMP      R1,R0
   \   0000006A   0xD308             BCC      ??f_lseek_5
   4025          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   \   0000006C   0x1E7F             SUBS     R7,R7,#+1
   \   0000006E   0x9802             LDR      R0,[SP, #+8]
   \   00000070   0x1E40             SUBS     R0,R0,#+1
   \   00000072   0x4387             BICS     R7,R7,R0
   \   00000074   0x60A7             STR      R7,[R4, #+8]
   4026          				ofs -= fp->fptr;
   \   00000076   0x68A0             LDR      R0,[R4, #+8]
   \   00000078   0x1A2D             SUBS     R5,R5,R0
   4027          				clst = fp->clust;
   \   0000007A   0x6967             LDR      R7,[R4, #+20]
   \   0000007C   0xE01B             B        ??f_lseek_6
   4028          			} else {									/* When seek to back cluster, */
   4029          				clst = fp->sclust;						/* start from the first cluster */
   \                     ??f_lseek_5: (+1)
   \   0000007E   0x6927             LDR      R7,[R4, #+16]
   4030          #if !_FS_READONLY
   4031          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   \   00000080   0x2F00             CMP      R7,#+0
   \   00000082   0xD117             BNE      ??f_lseek_7
   4032          					clst = create_chain(fp->fs, 0);
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x6820             LDR      R0,[R4, #+0]
   \   00000088   0x.... 0x....      BL       create_chain
   \   0000008C   0x0007             MOVS     R7,R0
   4033          					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
   \   0000008E   0x2F01             CMP      R7,#+1
   \   00000090   0xD105             BNE      ??f_lseek_8
   \   00000092   0x79A0             LDRB     R0,[R4, #+6]
   \   00000094   0x2180             MOVS     R1,#+128
   \   00000096   0x4301             ORRS     R1,R1,R0
   \   00000098   0x71A1             STRB     R1,[R4, #+6]
   \   0000009A   0x2002             MOVS     R0,#+2
   \   0000009C   0xE06F             B        ??f_lseek_1
   4034          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_lseek_8: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000A2   0x4287             CMP      R7,R0
   \   000000A4   0xD105             BNE      ??f_lseek_9
   \   000000A6   0x79A0             LDRB     R0,[R4, #+6]
   \   000000A8   0x2180             MOVS     R1,#+128
   \   000000AA   0x4301             ORRS     R1,R1,R0
   \   000000AC   0x71A1             STRB     R1,[R4, #+6]
   \   000000AE   0x2001             MOVS     R0,#+1
   \   000000B0   0xE065             B        ??f_lseek_1
   4035          					fp->sclust = clst;
   \                     ??f_lseek_9: (+1)
   \   000000B2   0x6127             STR      R7,[R4, #+16]
   4036          				}
   4037          #endif
   4038          				fp->clust = clst;
   \                     ??f_lseek_7: (+1)
   \   000000B4   0x6167             STR      R7,[R4, #+20]
   4039          			}
   4040          			if (clst != 0) {
   \                     ??f_lseek_6: (+1)
   \   000000B6   0x2F00             CMP      R7,#+0
   \   000000B8   0xD107             BNE      ??f_lseek_10
   \   000000BA   0xE049             B        ??f_lseek_4
   4041          				while (ofs > bcs) {						/* Cluster following loop */
   4042          #if !_FS_READONLY
   4043          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   4044          						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
   4045          						if (clst == 0) {				/* When disk gets full, clip file size */
   4046          							ofs = bcs; break;
   4047          						}
   4048          					} else
   4049          #endif
   4050          						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
   4051          					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   4052          					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
   4053          					fp->clust = clst;
   \                     ??f_lseek_11: (+1)
   \   000000BC   0x6167             STR      R7,[R4, #+20]
   4054          					fp->fptr += bcs;
   \   000000BE   0x68A0             LDR      R0,[R4, #+8]
   \   000000C0   0x9902             LDR      R1,[SP, #+8]
   \   000000C2   0x1840             ADDS     R0,R0,R1
   \   000000C4   0x60A0             STR      R0,[R4, #+8]
   4055          					ofs -= bcs;
   \   000000C6   0x9802             LDR      R0,[SP, #+8]
   \   000000C8   0x1A2D             SUBS     R5,R5,R0
   \                     ??f_lseek_10: (+1)
   \   000000CA   0x9802             LDR      R0,[SP, #+8]
   \   000000CC   0x42A8             CMP      R0,R5
   \   000000CE   0xD20A             BCS      ??f_lseek_12
   \   000000D0   0x79A0             LDRB     R0,[R4, #+6]
   \   000000D2   0x0780             LSLS     R0,R0,#+30
   \   000000D4   0xD51E             BPL      ??f_lseek_13
   \   000000D6   0x0039             MOVS     R1,R7
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x.... 0x....      BL       create_chain
   \   000000DE   0x0007             MOVS     R7,R0
   \   000000E0   0x2F00             CMP      R7,#+0
   \   000000E2   0xD11C             BNE      ??f_lseek_14
   \   000000E4   0x9D02             LDR      R5,[SP, #+8]
   4056          				}
   4057          				fp->fptr += ofs;
   \                     ??f_lseek_12: (+1)
   \   000000E6   0x68A0             LDR      R0,[R4, #+8]
   \   000000E8   0x1940             ADDS     R0,R0,R5
   \   000000EA   0x60A0             STR      R0,[R4, #+8]
   4058          				if (ofs % SS(fp->fs)) {
   \   000000EC   0x0028             MOVS     R0,R5
   \   000000EE   0x2180             MOVS     R1,#+128
   \   000000F0   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000F2   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000F6   0x2900             CMP      R1,#+0
   \   000000F8   0xD02A             BEQ      ??f_lseek_4
   4059          					nsect = clust2sect(fp->fs, clst);	/* Current sector */
   \   000000FA   0x0039             MOVS     R1,R7
   \   000000FC   0x6820             LDR      R0,[R4, #+0]
   \   000000FE   0x.... 0x....      BL       clust2sect
   \   00000102   0x0006             MOVS     R6,R0
   4060          					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
   \   00000104   0x2E00             CMP      R6,#+0
   \   00000106   0xD120             BNE      ??f_lseek_15
   \   00000108   0x79A0             LDRB     R0,[R4, #+6]
   \   0000010A   0x2180             MOVS     R1,#+128
   \   0000010C   0x4301             ORRS     R1,R1,R0
   \   0000010E   0x71A1             STRB     R1,[R4, #+6]
   \   00000110   0x2002             MOVS     R0,#+2
   \   00000112   0xE034             B        ??f_lseek_1
   \                     ??f_lseek_13: (+1)
   \   00000114   0x0039             MOVS     R1,R7
   \   00000116   0x6820             LDR      R0,[R4, #+0]
   \   00000118   0x.... 0x....      BL       get_fat
   \   0000011C   0x0007             MOVS     R7,R0
   \                     ??f_lseek_14: (+1)
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000122   0x4287             CMP      R7,R0
   \   00000124   0xD105             BNE      ??f_lseek_16
   \   00000126   0x79A0             LDRB     R0,[R4, #+6]
   \   00000128   0x2180             MOVS     R1,#+128
   \   0000012A   0x4301             ORRS     R1,R1,R0
   \   0000012C   0x71A1             STRB     R1,[R4, #+6]
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0xE025             B        ??f_lseek_1
   \                     ??f_lseek_16: (+1)
   \   00000132   0x2F02             CMP      R7,#+2
   \   00000134   0xD303             BCC      ??f_lseek_17
   \   00000136   0x6820             LDR      R0,[R4, #+0]
   \   00000138   0x69C0             LDR      R0,[R0, #+28]
   \   0000013A   0x4287             CMP      R7,R0
   \   0000013C   0xD3BE             BCC      ??f_lseek_11
   \                     ??f_lseek_17: (+1)
   \   0000013E   0x79A0             LDRB     R0,[R4, #+6]
   \   00000140   0x2180             MOVS     R1,#+128
   \   00000142   0x4301             ORRS     R1,R1,R0
   \   00000144   0x71A1             STRB     R1,[R4, #+6]
   \   00000146   0x2002             MOVS     R0,#+2
   \   00000148   0xE019             B        ??f_lseek_1
   4061          					nsect += ofs / SS(fp->fs);
   \                     ??f_lseek_15: (+1)
   \   0000014A   0x0028             MOVS     R0,R5
   \   0000014C   0x0A40             LSRS     R0,R0,#+9
   \   0000014E   0x1836             ADDS     R6,R6,R0
   4062          				}
   4063          			}
   4064          		}
   4065          		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
   \                     ??f_lseek_4: (+1)
   \   00000150   0x68A0             LDR      R0,[R4, #+8]
   \   00000152   0x2180             MOVS     R1,#+128
   \   00000154   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000156   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000015A   0x2900             CMP      R1,#+0
   \   0000015C   0xD003             BEQ      ??f_lseek_18
   \   0000015E   0x69A0             LDR      R0,[R4, #+24]
   \   00000160   0x4286             CMP      R6,R0
   \   00000162   0xD000             BEQ      ??f_lseek_18
   4066          #if !_FS_TINY
   4067          #if !_FS_READONLY
   4068          			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
   4069          				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
   4070          					ABORT(fp->fs, FR_DISK_ERR);
   4071          				fp->flag &= ~FA__DIRTY;
   4072          			}
   4073          #endif
   4074          			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
   4075          				ABORT(fp->fs, FR_DISK_ERR);
   4076          #endif
   4077          			fp->dsect = nsect;
   \   00000164   0x61A6             STR      R6,[R4, #+24]
   4078          		}
   4079          #if !_FS_READONLY
   4080          		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
   \                     ??f_lseek_18: (+1)
   \   00000166   0x68E0             LDR      R0,[R4, #+12]
   \   00000168   0x68A1             LDR      R1,[R4, #+8]
   \   0000016A   0x4288             CMP      R0,R1
   \   0000016C   0xD205             BCS      ??f_lseek_19
   4081          			fp->fsize = fp->fptr;
   \   0000016E   0x68A0             LDR      R0,[R4, #+8]
   \   00000170   0x60E0             STR      R0,[R4, #+12]
   4082          			fp->flag |= FA__WRITTEN;
   \   00000172   0x79A0             LDRB     R0,[R4, #+6]
   \   00000174   0x2120             MOVS     R1,#+32
   \   00000176   0x4301             ORRS     R1,R1,R0
   \   00000178   0x71A1             STRB     R1,[R4, #+6]
   4083          		}
   4084          #endif
   4085          	}
   4086          
   4087          	LEAVE_FF(fp->fs, res);
   \                     ??f_lseek_19: (+1)
   \   0000017A   0x4668             MOV      R0,SP
   \   0000017C   0x7900             LDRB     R0,[R0, #+4]
   \                     ??f_lseek_1: (+1)
   \   0000017E   0xBDFE             POP      {R1-R7,PC}       ;; return
   4088          }
   4089          
   4090          
   4091          
   4092          #if _FS_MINIMIZE <= 1
   4093          /*FUNCTION*-------------------------------------------------------------------
   4094          *
   4095          * Function Name    : f_opendir
   4096          * Returned Value   :  FR_OK: 	The function succeeded and the directory object is created. It is used for subsequent calls to read the directory entries.
   4097          *                     FR_NO_PATH:		Could not find the path.
   4098          *                     FR_INVALID_NAME: 	The path name is invalid.
   4099          *                     FR_INVALID_DRIVE: 	The drive number is invalid.
   4100          *                     FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4101          *                     FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4102          *                     FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4103          *                     FR_NOT_ENABLED: 	The logical drive has no work area.
   4104          *                     FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   4105          *
   4106          * Comments         : The f_opendir function opens an exsisting directory and creates the directory object for subsequent calls
   4107          *   
   4108          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   4109          FRESULT f_opendir 
   4110            (
   4111              /* [OUT] Pointer to directory object to create */
   4112            	DIR *dj,			
   4113            	/* [IN] Pointer to the directory path */
   4114            	const TCHAR *path	
   4115            )
   4116          {
   \                     f_opendir: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   4117          	FRESULT res;
   4118          	FATFS *fs;
   4119          	DEF_NAMEBUF;
   4120          
   4121          
   4122          	if (!dj) return FR_INVALID_OBJECT;
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE      ??f_opendir_0
   \   0000000A   0x2009             MOVS     R0,#+9
   \   0000000C   0xE04D             B        ??f_opendir_1
   4123          
   4124          	res = chk_mounted(&path, &dj->fs, 0);
   \                     ??f_opendir_0: (+1)
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0xA804             ADD      R0,SP,#+16
   \   00000014   0x.... 0x....      BL       chk_mounted
   \   00000018   0x0005             MOVS     R5,R0
   4125          	fs = dj->fs;
   \   0000001A   0x6826             LDR      R6,[R4, #+0]
   4126          	if (res == FR_OK) {
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD13F             BNE      ??f_opendir_2
   4127          		INIT_BUF(*dj);
   \   00000022   0x2080             MOVS     R0,#+128
   \   00000024   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000026   0x.... 0x....      BL       ff_memalloc
   \   0000002A   0x0007             MOVS     R7,R0
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD101             BNE      ??f_opendir_3
   \   00000030   0x2011             MOVS     R0,#+17
   \   00000032   0xE03A             B        ??f_opendir_1
   \                     ??f_opendir_3: (+1)
   \   00000034   0x61E7             STR      R7,[R4, #+28]
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x61A0             STR      R0,[R4, #+24]
   4128          		res = follow_path(dj, path);			/* Follow the path to the directory */
   \   0000003A   0x9904             LDR      R1,[SP, #+16]
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       follow_path
   \   00000042   0x0005             MOVS     R5,R0
   4129          		FREE_BUF();
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0x.... 0x....      BL       ff_memfree
   4130          		if (res == FR_OK) {						/* Follow completed */
   \   0000004A   0xB2ED             UXTB     R5,R5
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD11E             BNE      ??f_opendir_4
   4131          			if (dj->dir) {						/* It is not the root dir */
   \   00000050   0x6960             LDR      R0,[R4, #+20]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD011             BEQ      ??f_opendir_5
   4132          				if (convert_ptr(dj->fs, dj->dir)[DIR_Attr] & AM_DIR) {	/* The object is a directory */
   \   00000056   0x6961             LDR      R1,[R4, #+20]
   \   00000058   0x6820             LDR      R0,[R4, #+0]
   \   0000005A   0x.... 0x....      BL       convert_ptr
   \   0000005E   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000060   0x06C0             LSLS     R0,R0,#+27
   \   00000062   0xD509             BPL      ??f_opendir_6
   4133          					dj->sclust = ld_clust(fs, convert_ptr(dj->fs, dj->dir));
   \   00000064   0x6961             LDR      R1,[R4, #+20]
   \   00000066   0x6820             LDR      R0,[R4, #+0]
   \   00000068   0x.... 0x....      BL       convert_ptr
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0x0030             MOVS     R0,R6
   \   00000070   0x.... 0x....      BL       ld_clust
   \   00000074   0x60A0             STR      R0,[R4, #+8]
   \   00000076   0xE000             B        ??f_opendir_5
   4134          				} else {						/* The object is not a directory */
   4135          					res = FR_NO_PATH;
   \                     ??f_opendir_6: (+1)
   \   00000078   0x2505             MOVS     R5,#+5
   4136          				}
   4137          			}
   4138          			if (res == FR_OK) {
   \                     ??f_opendir_5: (+1)
   \   0000007A   0xB2ED             UXTB     R5,R5
   \   0000007C   0x2D00             CMP      R5,#+0
   \   0000007E   0xD106             BNE      ??f_opendir_4
   4139          				dj->id = fs->id;
   \   00000080   0x88F0             LDRH     R0,[R6, #+6]
   \   00000082   0x80A0             STRH     R0,[R4, #+4]
   4140          				res = dir_sdi(dj, 0);			/* Rewind dir */
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0x.... 0x....      BL       dir_sdi
   \   0000008C   0x0005             MOVS     R5,R0
   4141          			}
   4142          		}
   4143          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   \                     ??f_opendir_4: (+1)
   \   0000008E   0xB2ED             UXTB     R5,R5
   \   00000090   0x2D04             CMP      R5,#+4
   \   00000092   0xD100             BNE      ??f_opendir_7
   \   00000094   0x2505             MOVS     R5,#+5
   4144          		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
   \                     ??f_opendir_7: (+1)
   \   00000096   0xB2ED             UXTB     R5,R5
   \   00000098   0x2D00             CMP      R5,#+0
   \   0000009A   0xD004             BEQ      ??f_opendir_8
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x6020             STR      R0,[R4, #+0]
   \   000000A0   0xE001             B        ??f_opendir_8
   4145          	} else {
   4146          		dj->fs = 0;
   \                     ??f_opendir_2: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x6020             STR      R0,[R4, #+0]
   4147          	}
   4148          
   4149          	LEAVE_FF(fs, res);
   \                     ??f_opendir_8: (+1)
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0xB2C0             UXTB     R0,R0
   \                     ??f_opendir_1: (+1)
   \   000000AA   0xB005             ADD      SP,SP,#+20
   \   000000AC   0xBDF0             POP      {R4-R7,PC}       ;; return
   4150          }
   4151          
   4152          
   4153          /*FUNCTION*-------------------------------------------------------------------
   4154          *
   4155          * Function Name    : f_readdir
   4156          * Returned Value   : FR_OK: 		The function succeeded.
   4157          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4158          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4159          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4160          *                    FR_INVALID_OBJECT: The directory object is invalid.
   4161          *
   4162          *                    
   4163          * Comments         : Read Directory Entry in Sequense
   4164          *   
   4165          *END*----------------------------------------------------------------------*/
   4166          

   \                                 In section .text, align 2, keep-with-next
   4167          FRESULT f_readdir 
   4168            (
   4169              /* [IN] Pointer to the open directory object */
   4170            	DIR *dj,			
   4171            	/* [OUT] Pointer to file information to return */
   4172            	FILINFO *fno		
   4173            )
   4174          {
   \                     f_readdir: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   4175          	FRESULT res;
   4176          	DEF_NAMEBUF;
   4177          
   4178          
   4179          	res = validate(dj);						/* Check validity of the object */
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       validate
   \   0000000C   0x0006             MOVS     R6,R0
   4180          	if (res == FR_OK) {
   \   0000000E   0xB2F6             UXTB     R6,R6
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD133             BNE      ??f_readdir_0
   4181          		if (!fno) {
   \   00000014   0x2F00             CMP      R7,#+0
   \   00000016   0xD105             BNE      ??f_readdir_1
   4182          			res = dir_sdi(dj, 0);			/* Rewind the directory object */
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       dir_sdi
   \   00000020   0x0006             MOVS     R6,R0
   \   00000022   0xE02B             B        ??f_readdir_0
   4183          		} else {
   4184          			INIT_BUF(*dj);
   \                     ??f_readdir_1: (+1)
   \   00000024   0x2080             MOVS     R0,#+128
   \   00000026   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000028   0x.... 0x....      BL       ff_memalloc
   \   0000002C   0x0005             MOVS     R5,R0
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD101             BNE      ??f_readdir_2
   \   00000032   0x2011             MOVS     R0,#+17
   \   00000034   0xE024             B        ??f_readdir_3
   \                     ??f_readdir_2: (+1)
   \   00000036   0x61E5             STR      R5,[R4, #+28]
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x61A0             STR      R0,[R4, #+24]
   4185          			res = dir_read(dj, 0);			/* Read an item */
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       dir_read
   \   00000044   0x0006             MOVS     R6,R0
   4186          			if (res == FR_NO_FILE) {		/* Reached end of dir */
   \   00000046   0xB2F6             UXTB     R6,R6
   \   00000048   0x2E04             CMP      R6,#+4
   \   0000004A   0xD102             BNE      ??f_readdir_4
   4187          				dj->sect = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6120             STR      R0,[R4, #+16]
   4188          				res = FR_OK;
   \   00000050   0x2600             MOVS     R6,#+0
   4189          			}
   4190          			if (res == FR_OK) {				/* A valid entry is found */
   \                     ??f_readdir_4: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD10E             BNE      ??f_readdir_5
   4191          				get_fileinfo(dj, fno);		/* Get the object information */
   \   00000058   0x0039             MOVS     R1,R7
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       get_fileinfo
   4192          				res = dir_next(dj, 0);		/* Increment index for next */
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       dir_next
   \   00000068   0x0006             MOVS     R6,R0
   4193          				if (res == FR_NO_FILE) {
   \   0000006A   0xB2F6             UXTB     R6,R6
   \   0000006C   0x2E04             CMP      R6,#+4
   \   0000006E   0xD102             BNE      ??f_readdir_5
   4194          					dj->sect = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x6120             STR      R0,[R4, #+16]
   4195          					res = FR_OK;
   \   00000074   0x2600             MOVS     R6,#+0
   4196          				}
   4197          			}
   4198          			FREE_BUF();
   \                     ??f_readdir_5: (+1)
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0x.... 0x....      BL       ff_memfree
   4199          		}
   4200          	}
   4201          
   4202          	LEAVE_FF(dj->fs, res);
   \                     ??f_readdir_0: (+1)
   \   0000007C   0x0030             MOVS     R0,R6
   \   0000007E   0xB2C0             UXTB     R0,R0
   \                     ??f_readdir_3: (+1)
   \   00000080   0xBDFE             POP      {R1-R7,PC}       ;; return
   4203          }
   4204          
   4205          
   4206          
   4207          #if _FS_MINIMIZE == 0
   4208          /*FUNCTION*-------------------------------------------------------------------
   4209          *
   4210          * Function Name    : f_stat
   4211          * Returned Value   : FR_OK: 		The function succeeded.
   4212          *                    FR_NO_FILE: 		Could not find the file or directory.
   4213          *                    FR_NO_PATH:		Could not find the path.
   4214          *                    FR_INVALID_NAME: 	The file name is invalid.
   4215          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   4216          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4217          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4218          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4219          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   4220          *                    FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   4221          *
   4222          *                    
   4223          * Comments         : The f_stat() gets the information of a file or directory
   4224          *   
   4225          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   4226          FRESULT f_stat 
   4227            (
   4228              /* [IN] Pointer to the file path */
   4229            	const TCHAR *path,
   4230            	/* [OUT] Pointer to file information to return */	
   4231            	FILINFO *fno		
   4232            )
   4233          {
   \                     f_stat: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000E             MOVS     R6,R1
   4234          	FRESULT res;
   4235          	DIR dj;
   4236          	DEF_NAMEBUF;
   4237          
   4238          
   4239          	res = chk_mounted(&path, &dj.fs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0xA903             ADD      R1,SP,#+12
   \   0000000A   0xA80D             ADD      R0,SP,#+52
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0004             MOVS     R4,R0
   4240          	if (res == FR_OK) {
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD11F             BNE      ??f_stat_0
   4241          		INIT_BUF(dj);
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   0000001C   0x.... 0x....      BL       ff_memalloc
   \   00000020   0x0005             MOVS     R5,R0
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD101             BNE      ??f_stat_1
   \   00000026   0x2011             MOVS     R0,#+17
   \   00000028   0xE018             B        ??f_stat_2
   \                     ??f_stat_1: (+1)
   \   0000002A   0x950A             STR      R5,[SP, #+40]
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0x9009             STR      R0,[SP, #+36]
   4242          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000030   0x990D             LDR      R1,[SP, #+52]
   \   00000032   0xA803             ADD      R0,SP,#+12
   \   00000034   0x.... 0x....      BL       follow_path
   \   00000038   0x0004             MOVS     R4,R0
   4243          		if (res == FR_OK) {				/* Follow completed */
   \   0000003A   0xB2E4             UXTB     R4,R4
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD108             BNE      ??f_stat_3
   4244          			if (dj.dir)		/* Found an object */
   \   00000040   0x9808             LDR      R0,[SP, #+32]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD004             BEQ      ??f_stat_4
   4245          				get_fileinfo(&dj, fno);
   \   00000046   0x0031             MOVS     R1,R6
   \   00000048   0xA803             ADD      R0,SP,#+12
   \   0000004A   0x.... 0x....      BL       get_fileinfo
   \   0000004E   0xE000             B        ??f_stat_3
   4246          			else			/* It is root dir */
   4247          				res = FR_INVALID_NAME;
   \                     ??f_stat_4: (+1)
   \   00000050   0x2406             MOVS     R4,#+6
   4248          		}
   4249          		FREE_BUF();
   \                     ??f_stat_3: (+1)
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x.... 0x....      BL       ff_memfree
   4250          	}
   4251          
   4252          	LEAVE_FF(dj.fs, res);
   \                     ??f_stat_0: (+1)
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0xB2C0             UXTB     R0,R0
   \                     ??f_stat_2: (+1)
   \   0000005C   0xB00E             ADD      SP,SP,#+56
   \   0000005E   0xBD70             POP      {R4-R6,PC}       ;; return
   4253          }
   4254          
   4255          
   4256          
   4257          #if !_FS_READONLY
   4258          /*FUNCTION*-------------------------------------------------------------------
   4259          *
   4260          * Function Name    : f_getfree
   4261          * Returned Value   : FR_OK: 	The function succeeded. The *Clusters has number of free clusters and *FileSystemObject points the file system object.
   4262          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   4263          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4264          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4265          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4266          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   4267          *                    FR_NO_FILESYSTEM: There is no valid FAT partition on the drive.
   4268          *                    
   4269          * Comments         : gets number of free clusters on the drive
   4270          *   
   4271          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   4272          FRESULT f_getfree 
   4273            (
   4274              /* [IN] Pointer to the logical drive number (root dir) */
   4275            	const TCHAR *path,
   4276            	/* [IN] Pointer to the variable to return number of free clusters */	
   4277            	uint32_t *nclst,	
   4278            	/* [OUT] Pointer to pointer to corresponding file system object to return */	
   4279            	FATFS **fatfs		
   4280            )
   4281          {
   \                     f_getfree: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0014             MOVS     R4,R2
   4282          	FRESULT res;
   4283          	FATFS *fs;
   4284          	uint32_t n, clst, sect, stat;
   4285          	uint32_t i;
   4286          	uint8_t fat, *p;
   4287          
   4288          
   4289          	/* Get drive number */
   4290          	res = chk_mounted(&path, fatfs, 0);
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0xA803             ADD      R0,SP,#+12
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0006             MOVS     R6,R0
   4291          	fs = *fatfs;
   \   00000012   0x6827             LDR      R7,[R4, #+0]
   4292          	if (res == FR_OK) {
   \   00000014   0xB2F6             UXTB     R6,R6
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD168             BNE      ??f_getfree_0
   4293          		/* If free_clust is valid, return it without full cluster scan */
   4294          		if (fs->free_clust <= fs->n_fatent - 2) {
   \   0000001A   0x69F8             LDR      R0,[R7, #+28]
   \   0000001C   0x1E80             SUBS     R0,R0,#+2
   \   0000001E   0x6939             LDR      R1,[R7, #+16]
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD303             BCC      ??f_getfree_1
   4295          			*nclst = fs->free_clust;
   \   00000024   0x6938             LDR      R0,[R7, #+16]
   \   00000026   0x9904             LDR      R1,[SP, #+16]
   \   00000028   0x6008             STR      R0,[R1, #+0]
   \   0000002A   0xE05F             B        ??f_getfree_0
   4296          		} else {
   4297          			/* Get number of free clusters */
   4298          			fat = fs->fs_type;
   \                     ??f_getfree_1: (+1)
   \   0000002C   0x7838             LDRB     R0,[R7, #+0]
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x7008             STRB     R0,[R1, #+0]
   4299          			n = 0;
   \   00000032   0x2400             MOVS     R4,#+0
   4300          			if (fat == FS_FAT12) {
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD116             BNE      ??f_getfree_2
   4301          				clst = 2;
   \   0000003C   0x2502             MOVS     R5,#+2
   4302          				do {
   4303          					stat = get_fat(fs, clst);
   \                     ??f_getfree_3: (+1)
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0038             MOVS     R0,R7
   \   00000042   0x.... 0x....      BL       get_fat
   4304          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD101             BNE      ??f_getfree_4
   \   0000004E   0x2601             MOVS     R6,#+1
   \   00000050   0xE043             B        ??f_getfree_5
   4305          					if (stat == 1) { res = FR_INT_ERR; break; }
   \                     ??f_getfree_4: (+1)
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD101             BNE      ??f_getfree_6
   \   00000056   0x2602             MOVS     R6,#+2
   \   00000058   0xE03F             B        ??f_getfree_5
   4306          					if (stat == 0) n++;
   \                     ??f_getfree_6: (+1)
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD100             BNE      ??f_getfree_7
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
   4307          				} while (++clst < fs->n_fatent);
   \                     ??f_getfree_7: (+1)
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   \   00000062   0x69F8             LDR      R0,[R7, #+28]
   \   00000064   0x4285             CMP      R5,R0
   \   00000066   0xD3EA             BCC      ??f_getfree_3
   \   00000068   0xE037             B        ??f_getfree_5
   4308          			} else {
   4309          				clst = fs->n_fatent;
   \                     ??f_getfree_2: (+1)
   \   0000006A   0x69FD             LDR      R5,[R7, #+28]
   4310          				sect = fs->fatbase;
   \   0000006C   0x6AB8             LDR      R0,[R7, #+40]
   \   0000006E   0x9001             STR      R0,[SP, #+4]
   4311          				i = 0; p = 0;
   \   00000070   0x2200             MOVS     R2,#+0
   \   00000072   0x2100             MOVS     R1,#+0
   4312          				do {
   4313          					if (!i) {
   \                     ??f_getfree_8: (+1)
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0xD10D             BNE      ??f_getfree_9
   4314          						res = move_window(fs, sect++);
   \   00000078   0x9901             LDR      R1,[SP, #+4]
   \   0000007A   0x0038             MOVS     R0,R7
   \   0000007C   0x.... 0x....      BL       move_window
   \   00000080   0x0006             MOVS     R6,R0
   \   00000082   0x9801             LDR      R0,[SP, #+4]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x9001             STR      R0,[SP, #+4]
   4315          						if (res != FR_OK) break;
   \   00000088   0xB2F6             UXTB     R6,R6
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD125             BNE      ??f_getfree_5
   4316          						p = fs->win;
   \                     ??f_getfree_10: (+1)
   \   0000008E   0x6C79             LDR      R1,[R7, #+68]
   4317          						i = SS(fs);
   \   00000090   0x2280             MOVS     R2,#+128
   \   00000092   0x0092             LSLS     R2,R2,#+2        ;; #+512
   4318          					}
   4319          					if (fat == FS_FAT16) {
   \                     ??f_getfree_9: (+1)
   \   00000094   0x4668             MOV      R0,SP
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x2802             CMP      R0,#+2
   \   0000009A   0xD10A             BNE      ??f_getfree_11
   4320          						if (LD_WORD(p) == 0) n++;
   \   0000009C   0x7848             LDRB     R0,[R1, #+1]
   \   0000009E   0x0200             LSLS     R0,R0,#+8
   \   000000A0   0x780B             LDRB     R3,[R1, #+0]
   \   000000A2   0x4318             ORRS     R0,R0,R3
   \   000000A4   0xB280             UXTH     R0,R0
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD100             BNE      ??f_getfree_12
   \   000000AA   0x1C64             ADDS     R4,R4,#+1
   4321          						p += 2; i -= 2;
   \                     ??f_getfree_12: (+1)
   \   000000AC   0x1C89             ADDS     R1,R1,#+2
   \   000000AE   0x1E92             SUBS     R2,R2,#+2
   \   000000B0   0xE010             B        ??f_getfree_13
   4322          					} else {
   4323          						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
   \                     ??f_getfree_11: (+1)
   \   000000B2   0x78C8             LDRB     R0,[R1, #+3]
   \   000000B4   0x0603             LSLS     R3,R0,#+24
   \   000000B6   0x7888             LDRB     R0,[R1, #+2]
   \   000000B8   0x0400             LSLS     R0,R0,#+16
   \   000000BA   0x4318             ORRS     R0,R0,R3
   \   000000BC   0x784B             LDRB     R3,[R1, #+1]
   \   000000BE   0x021B             LSLS     R3,R3,#+8
   \   000000C0   0x4303             ORRS     R3,R3,R0
   \   000000C2   0x7808             LDRB     R0,[R1, #+0]
   \   000000C4   0x4318             ORRS     R0,R0,R3
   \   000000C6   0x0100             LSLS     R0,R0,#+4        ;; ZeroExtS R0,R0,#+4,#+4
   \   000000C8   0x0900             LSRS     R0,R0,#+4
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD100             BNE      ??f_getfree_14
   \   000000CE   0x1C64             ADDS     R4,R4,#+1
   4324          						p += 4; i -= 4;
   \                     ??f_getfree_14: (+1)
   \   000000D0   0x1D09             ADDS     R1,R1,#+4
   \   000000D2   0x1F12             SUBS     R2,R2,#+4
   4325          					}
   4326          				} while (--clst);
   \                     ??f_getfree_13: (+1)
   \   000000D4   0x1E6D             SUBS     R5,R5,#+1
   \   000000D6   0x2D00             CMP      R5,#+0
   \   000000D8   0xD1CC             BNE      ??f_getfree_8
   4327          			}
   4328          			fs->free_clust = n;
   \                     ??f_getfree_5: (+1)
   \   000000DA   0x613C             STR      R4,[R7, #+16]
   4329          			if (fat == FS_FAT32) fs->fsi_flag = 1;
   \   000000DC   0x4668             MOV      R0,SP
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x2803             CMP      R0,#+3
   \   000000E2   0xD101             BNE      ??f_getfree_15
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x7178             STRB     R0,[R7, #+5]
   4330          			*nclst = n;
   \                     ??f_getfree_15: (+1)
   \   000000E8   0x9804             LDR      R0,[SP, #+16]
   \   000000EA   0x6004             STR      R4,[R0, #+0]
   4331          		}
   4332          	}
   4333          	LEAVE_FF(fs, res);
   \                     ??f_getfree_0: (+1)
   \   000000EC   0x0030             MOVS     R0,R6
   \   000000EE   0xB2C0             UXTB     R0,R0
   \   000000F0   0xB005             ADD      SP,SP,#+20
   \   000000F2   0xBDF0             POP      {R4-R7,PC}       ;; return
   4334          }
   4335          
   4336          
   4337          /*FUNCTION*-------------------------------------------------------------------
   4338          *
   4339          * Function Name    : f_truncate
   4340          * Returned Value   : FR_OK : 		The function succeeded.
   4341          *                    FR_DENIED: 	The function denied due to the file has been opened in non-write mode.
   4342          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4343          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4344          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any  other reason.
   4345          *                    FR_INVALID_OBJECT: The file object is invalid.
   4346          *
   4347          *                    
   4348          * Comments         : The f_truncate function truncates the file size to the current file read/write point
   4349          *   
   4350          *END*----------------------------------------------------------------------*/
   4351          

   \                                 In section .text, align 2, keep-with-next
   4352          FRESULT f_truncate 
   4353            (
   4354              /* [IN] Pointer to the file object */
   4355            	FIL *fp		
   4356            )
   4357          {
   \                     f_truncate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   4358          	FRESULT res;
   4359          	uint32_t ncl;
   4360          
   4361          
   4362          	res = validate(fp);						/* Check validity of the object */
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       validate
   4363          	if (res == FR_OK) {
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD108             BNE      ??f_truncate_0
   4364          		if (fp->flag & FA__ERROR) {			/* Check abort flag */
   \   00000010   0x79A1             LDRB     R1,[R4, #+6]
   \   00000012   0x0609             LSLS     R1,R1,#+24
   \   00000014   0xD501             BPL      ??f_truncate_1
   4365          			res = FR_INT_ERR;
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0xE003             B        ??f_truncate_0
   4366          		} else {
   4367          			if (!(fp->flag & FA_WRITE))		/* Check access mode */
   \                     ??f_truncate_1: (+1)
   \   0000001A   0x79A1             LDRB     R1,[R4, #+6]
   \   0000001C   0x0789             LSLS     R1,R1,#+30
   \   0000001E   0xD400             BMI      ??f_truncate_0
   4368          				res = FR_DENIED;
   \   00000020   0x2007             MOVS     R0,#+7
   4369          		}
   4370          	}
   4371          	if (res == FR_OK) {
   \                     ??f_truncate_0: (+1)
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD13B             BNE      ??f_truncate_2
   4372          		if (fp->fsize > fp->fptr) {
   \   00000028   0x68A1             LDR      R1,[R4, #+8]
   \   0000002A   0x68E2             LDR      R2,[R4, #+12]
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD230             BCS      ??f_truncate_3
   4373          			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x60E0             STR      R0,[R4, #+12]
   4374          			fp->flag |= FA__WRITTEN;
   \   00000034   0x79A0             LDRB     R0,[R4, #+6]
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0x4301             ORRS     R1,R1,R0
   \   0000003A   0x71A1             STRB     R1,[R4, #+6]
   4375          			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   \   0000003C   0x68A0             LDR      R0,[R4, #+8]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD106             BNE      ??f_truncate_4
   4376          				res = remove_chain(fp->fs, fp->sclust);
   \   00000042   0x6921             LDR      R1,[R4, #+16]
   \   00000044   0x6820             LDR      R0,[R4, #+0]
   \   00000046   0x.... 0x....      BL       remove_chain
   4377          				fp->sclust = 0;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x6121             STR      R1,[R4, #+16]
   \   0000004E   0xE020             B        ??f_truncate_3
   4378          			} else {				/* When truncate a part of the file, remove remaining clusters */
   4379          				ncl = get_fat(fp->fs, fp->clust);
   \                     ??f_truncate_4: (+1)
   \   00000050   0x6961             LDR      R1,[R4, #+20]
   \   00000052   0x6820             LDR      R0,[R4, #+0]
   \   00000054   0x.... 0x....      BL       get_fat
   \   00000058   0x0005             MOVS     R5,R0
   4380          				res = FR_OK;
   \   0000005A   0x2000             MOVS     R0,#+0
   4381          				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000060   0x428D             CMP      R5,R1
   \   00000062   0xD100             BNE      ??f_truncate_5
   \   00000064   0x2001             MOVS     R0,#+1
   4382          				if (ncl == 1) res = FR_INT_ERR;
   \                     ??f_truncate_5: (+1)
   \   00000066   0x2D01             CMP      R5,#+1
   \   00000068   0xD100             BNE      ??f_truncate_6
   \   0000006A   0x2002             MOVS     R0,#+2
   4383          				if (res == FR_OK && ncl < fp->fs->n_fatent) {
   \                     ??f_truncate_6: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD10F             BNE      ??f_truncate_3
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x69C9             LDR      R1,[R1, #+28]
   \   00000076   0x428D             CMP      R5,R1
   \   00000078   0xD20B             BCS      ??f_truncate_3
   4384          					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
   \   0000007A   0x....             LDR      R2,??DataTable20  ;; 0xfffffff
   \   0000007C   0x6961             LDR      R1,[R4, #+20]
   \   0000007E   0x6820             LDR      R0,[R4, #+0]
   \   00000080   0x.... 0x....      BL       put_fat
   4385          					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
   \   00000084   0xB2C0             UXTB     R0,R0
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD103             BNE      ??f_truncate_3
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x.... 0x....      BL       remove_chain
   4386          				}
   4387          			}
   4388          		}
   4389          		if (res != FR_OK) fp->flag |= FA__ERROR;
   \                     ??f_truncate_3: (+1)
   \   00000092   0xB2C0             UXTB     R0,R0
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD003             BEQ      ??f_truncate_2
   \   00000098   0x79A1             LDRB     R1,[R4, #+6]
   \   0000009A   0x2280             MOVS     R2,#+128
   \   0000009C   0x430A             ORRS     R2,R2,R1
   \   0000009E   0x71A2             STRB     R2,[R4, #+6]
   4390          	}
   4391          
   4392          	LEAVE_FF(fp->fs, res);
   \                     ??f_truncate_2: (+1)
   \   000000A0   0xB2C0             UXTB     R0,R0
   \   000000A2   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   4393          }
   4394          
   4395          
   4396          /*FUNCTION*-------------------------------------------------------------------
   4397          *
   4398          * Function Name    : f_unlink
   4399          * Returned Value   : FR_OK: 		The function succeeded.
   4400          *                    FR_NO_FILE: 		Could not find the file or directory.
   4401          *                    FR_NO_PATH: 		Could not find the path.
   4402          *                    FR_INVALID_NAME: 	The path name is invalid.
   4403          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   4404          *                    FR_DENIED: 		The function was denied.
   4405          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4406          *                    FR_WRITE_PROTECTED: The medium is write protected.
   4407          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4408          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4409          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   4410          *                    FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   4411          *                    FR_LOCKED: 		The function was rejected due to file sharing policy 
   4412          *                    
   4413          * Comments         :  Delete a File or Directory  
   4414          *   
   4415          *END*----------------------------------------------------------------------*/
   4416          

   \                                 In section .text, align 2, keep-with-next
   4417          FRESULT f_unlink 
   4418            (
   4419            	/* [IN] Pointer to the file or directory path */
   4420            	const TCHAR *path	
   4421            )
   4422          {
   \                     f_unlink: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB096             SUB      SP,SP,#+88
   4423          	FRESULT res;
   4424          	DIR dj, sdj;
   4425          	uint8_t *dir;
   4426          	uint32_t dclst;
   4427          	DEF_NAMEBUF;
   4428          
   4429          
   4430          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0xA816             ADD      R0,SP,#+88
   \   0000000A   0x.... 0x....      BL       chk_mounted
   \   0000000E   0x0005             MOVS     R5,R0
   4431          	if (res == FR_OK) {
   \   00000010   0xB2ED             UXTB     R5,R5
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD177             BNE      ??f_unlink_0
   4432          		INIT_BUF(dj);
   \   00000016   0x2080             MOVS     R0,#+128
   \   00000018   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   0000001A   0x.... 0x....      BL       ff_memalloc
   \   0000001E   0x0007             MOVS     R7,R0
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD101             BNE      ??f_unlink_1
   \   00000024   0x2011             MOVS     R0,#+17
   \   00000026   0xE070             B        ??f_unlink_2
   \                     ??f_unlink_1: (+1)
   \   00000028   0x9707             STR      R7,[SP, #+28]
   \   0000002A   0xA809             ADD      R0,SP,#+36
   \   0000002C   0x9006             STR      R0,[SP, #+24]
   4433          		res = follow_path(&dj, path);		/* Follow the file path */
   \   0000002E   0x9916             LDR      R1,[SP, #+88]
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x.... 0x....      BL       follow_path
   \   00000036   0x0005             MOVS     R5,R0
   4434          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000038   0xB2ED             UXTB     R5,R5
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0xD104             BNE      ??f_unlink_3
   \   0000003E   0x9806             LDR      R0,[SP, #+24]
   \   00000040   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000042   0x0680             LSLS     R0,R0,#+26
   \   00000044   0xD500             BPL      ??f_unlink_3
   4435          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   \   00000046   0x2506             MOVS     R5,#+6
   4436          #if _FS_LOCK
   4437          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
   4438          #endif
   4439          		if (res == FR_OK) {					/* The object is accessible */
   \                     ??f_unlink_3: (+1)
   \   00000048   0xB2ED             UXTB     R5,R5
   \   0000004A   0x2D00             CMP      R5,#+0
   \   0000004C   0xD158             BNE      ??f_unlink_4
   4440          			dir = convert_ptr(dj.fs, dj.dir);
   \   0000004E   0x9905             LDR      R1,[SP, #+20]
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x.... 0x....      BL       convert_ptr
   \   00000056   0x0006             MOVS     R6,R0
   4441          			if (!dir) {
   \   00000058   0x2E00             CMP      R6,#+0
   \   0000005A   0xD101             BNE      ??f_unlink_5
   4442          				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
   \   0000005C   0x2506             MOVS     R5,#+6
   \   0000005E   0xE003             B        ??f_unlink_6
   4443          			} else {
   4444          				if (dir[DIR_Attr] & AM_RDO)
   \                     ??f_unlink_5: (+1)
   \   00000060   0x7AF0             LDRB     R0,[R6, #+11]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD500             BPL      ??f_unlink_6
   4445          					res = FR_DENIED;		/* Cannot remove R/O object */
   \   00000066   0x2507             MOVS     R5,#+7
   4446          			}
   4447          			dclst = ld_clust(dj.fs, dir);
   \                     ??f_unlink_6: (+1)
   \   00000068   0x0031             MOVS     R1,R6
   \   0000006A   0x9800             LDR      R0,[SP, #+0]
   \   0000006C   0x.... 0x....      BL       ld_clust
   \   00000070   0x0004             MOVS     R4,R0
   4448          			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
   \   00000072   0xB2ED             UXTB     R5,R5
   \   00000074   0x2D00             CMP      R5,#+0
   \   00000076   0xD125             BNE      ??f_unlink_7
   \   00000078   0x7AF0             LDRB     R0,[R6, #+11]
   \   0000007A   0x06C0             LSLS     R0,R0,#+27
   \   0000007C   0xD522             BPL      ??f_unlink_7
   4449          				if (dclst < 2) {
   \   0000007E   0x2C02             CMP      R4,#+2
   \   00000080   0xD201             BCS      ??f_unlink_8
   4450          					res = FR_INT_ERR;
   \   00000082   0x2502             MOVS     R5,#+2
   \   00000084   0xE01E             B        ??f_unlink_7
   4451          				} else {
   4452          					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
   \                     ??f_unlink_8: (+1)
   \   00000086   0x2224             MOVS     R2,#+36
   \   00000088   0x4669             MOV      R1,SP
   \   0000008A   0xA80C             ADD      R0,SP,#+48
   \   0000008C   0x.... 0x....      BL       mem_cpy
   4453          					sdj.sclust = dclst;
   \   00000090   0x940E             STR      R4,[SP, #+56]
   4454          					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
   \   00000092   0x2102             MOVS     R1,#+2
   \   00000094   0xA80C             ADD      R0,SP,#+48
   \   00000096   0x.... 0x....      BL       dir_sdi
   \   0000009A   0x0005             MOVS     R5,R0
   4455          					if (res == FR_OK) {
   \   0000009C   0xB2ED             UXTB     R5,R5
   \   0000009E   0x2D00             CMP      R5,#+0
   \   000000A0   0xD110             BNE      ??f_unlink_7
   4456          						res = dir_read(&sdj, 0);	/* Read an item */
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0xA80C             ADD      R0,SP,#+48
   \   000000A6   0x.... 0x....      BL       dir_read
   \   000000AA   0x0005             MOVS     R5,R0
   4457          						if (res == FR_OK		/* Not empty dir */
   4458          #if _FS_RPATH
   4459          						|| dclst == dj.fs->cdir	/* Current dir */
   4460          #endif
   4461          						) res = FR_DENIED;
   \   000000AC   0xB2ED             UXTB     R5,R5
   \   000000AE   0x2D00             CMP      R5,#+0
   \   000000B0   0xD003             BEQ      ??f_unlink_9
   \   000000B2   0x9800             LDR      R0,[SP, #+0]
   \   000000B4   0x6980             LDR      R0,[R0, #+24]
   \   000000B6   0x4284             CMP      R4,R0
   \   000000B8   0xD100             BNE      ??f_unlink_10
   \                     ??f_unlink_9: (+1)
   \   000000BA   0x2507             MOVS     R5,#+7
   4462          						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
   \                     ??f_unlink_10: (+1)
   \   000000BC   0xB2ED             UXTB     R5,R5
   \   000000BE   0x2D04             CMP      R5,#+4
   \   000000C0   0xD100             BNE      ??f_unlink_7
   \   000000C2   0x2500             MOVS     R5,#+0
   4463          					}
   4464          				}
   4465          			}
   4466          			if (res == FR_OK) {
   \                     ??f_unlink_7: (+1)
   \   000000C4   0xB2ED             UXTB     R5,R5
   \   000000C6   0x2D00             CMP      R5,#+0
   \   000000C8   0xD11A             BNE      ??f_unlink_4
   4467          				res = dir_remove(&dj);		/* Remove the directory entry */
   \   000000CA   0x4668             MOV      R0,SP
   \   000000CC   0x.... 0x....      BL       dir_remove
   \   000000D0   0x0005             MOVS     R5,R0
   4468          				if (res == FR_OK) {
   \   000000D2   0xB2ED             UXTB     R5,R5
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD113             BNE      ??f_unlink_4
   4469          					if (dclst)				/* Remove the cluster chain if exist */
   \   000000D8   0x2C00             CMP      R4,#+0
   \   000000DA   0xD004             BEQ      ??f_unlink_11
   4470          						res = remove_chain(dj.fs, dclst);
   \   000000DC   0x0021             MOVS     R1,R4
   \   000000DE   0x9800             LDR      R0,[SP, #+0]
   \   000000E0   0x.... 0x....      BL       remove_chain
   \   000000E4   0x0005             MOVS     R5,R0
   4471          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   4472                                                  if (res == FR_OK) {
   \                     ??f_unlink_11: (+1)
   \   000000E6   0xB2ED             UXTB     R5,R5
   \   000000E8   0x2D00             CMP      R5,#+0
   \   000000EA   0xD102             BNE      ??f_unlink_12
   4473          						dj.fs->last_clust = dclst - 1;	/* Reuse the cluster hole */
   \   000000EC   0x1E64             SUBS     R4,R4,#+1
   \   000000EE   0x9800             LDR      R0,[SP, #+0]
   \   000000F0   0x60C4             STR      R4,[R0, #+12]
   4474          					}
   4475          #endif
   4476          					if (res == FR_OK) res = sync_fs(dj.fs);
   \                     ??f_unlink_12: (+1)
   \   000000F2   0xB2ED             UXTB     R5,R5
   \   000000F4   0x2D00             CMP      R5,#+0
   \   000000F6   0xD103             BNE      ??f_unlink_4
   \   000000F8   0x9800             LDR      R0,[SP, #+0]
   \   000000FA   0x.... 0x....      BL       sync_fs
   \   000000FE   0x0005             MOVS     R5,R0
   4477          				}
   4478          			}
   4479          		}
   4480          		FREE_BUF();
   \                     ??f_unlink_4: (+1)
   \   00000100   0x0038             MOVS     R0,R7
   \   00000102   0x.... 0x....      BL       ff_memfree
   4481          	}
   4482          
   4483          	LEAVE_FF(dj.fs, res);
   \                     ??f_unlink_0: (+1)
   \   00000106   0x0028             MOVS     R0,R5
   \   00000108   0xB2C0             UXTB     R0,R0
   \                     ??f_unlink_2: (+1)
   \   0000010A   0xB017             ADD      SP,SP,#+92
   \   0000010C   0xBDF0             POP      {R4-R7,PC}       ;; return
   4484          }
   4485          
   4486          
   4487          /*FUNCTION*-------------------------------------------------------------------
   4488          *
   4489          * Function Name    : f_mkdir
   4490          * Returned Value   : FR_OK: 		The function succeeded.
   4491          *                    FR_NO_PATH: 	Could not find the path.
   4492          *                    FR_INVALID_NAME: 	The path name is invalid.
   4493          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   4494          *                    FR_DENIED: 	The directory cannot be created due to directory table or disk is full.
   4495          *                    FR_EXIST: 		A file or directory that has same name is already existing.
   4496          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4497          *                    FR_WRITE_PROTECTED: The medium is writing protected.
   4498          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4499          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4500          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   4501          *                    FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   4502          *                    
   4503          * Comments         : Create a Directory 
   4504          *   
   4505          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   4506          FRESULT f_mkdir 
   4507            ( /* [IN] Pointer to the directory path */
   4508            	const TCHAR *path		
   4509            )
   4510          {
   \                     f_mkdir: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB090             SUB      SP,SP,#+64
   4511          	FRESULT res;
   4512          	DIR dj;
   4513          	uint8_t *dir, n;
   4514          	uint32_t dsc, dcl, pcl, tm = get_fattime();
   \   00000004   0x.... 0x....      BL       get_fattime
   \   00000008   0x9000             STR      R0,[SP, #+0]
   4515          	DEF_NAMEBUF;
   4516          
   4517          
   4518          	res = chk_mounted(&path, &dj.fs, 1);
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xA903             ADD      R1,SP,#+12
   \   0000000E   0xA810             ADD      R0,SP,#+64
   \   00000010   0x.... 0x....      BL       chk_mounted
   \   00000014   0x0004             MOVS     R4,R0
   4519          	if (res == FR_OK) {
   \   00000016   0xB2E4             UXTB     R4,R4
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD000             BEQ      .+4
   \   0000001C   0xE0E0             B        ??f_mkdir_0
   4520          		INIT_BUF(dj);
   \   0000001E   0x2080             MOVS     R0,#+128
   \   00000020   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000022   0x.... 0x....      BL       ff_memalloc
   \   00000026   0x9002             STR      R0,[SP, #+8]
   \   00000028   0x9802             LDR      R0,[SP, #+8]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD101             BNE      ??f_mkdir_1
   \   0000002E   0x2011             MOVS     R0,#+17
   \   00000030   0xE0D8             B        ??f_mkdir_2
   \                     ??f_mkdir_1: (+1)
   \   00000032   0x9802             LDR      R0,[SP, #+8]
   \   00000034   0x900A             STR      R0,[SP, #+40]
   \   00000036   0xA80C             ADD      R0,SP,#+48
   \   00000038   0x9009             STR      R0,[SP, #+36]
   4521          		res = follow_path(&dj, path);			/* Follow the file path */
   \   0000003A   0x9910             LDR      R1,[SP, #+64]
   \   0000003C   0xA803             ADD      R0,SP,#+12
   \   0000003E   0x.... 0x....      BL       follow_path
   \   00000042   0x0004             MOVS     R4,R0
   4522          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   \   00000044   0xB2E4             UXTB     R4,R4
   \   00000046   0x2C00             CMP      R4,#+0
   \   00000048   0xD100             BNE      ??f_mkdir_3
   \   0000004A   0x2408             MOVS     R4,#+8
   4523          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
   \                     ??f_mkdir_3: (+1)
   \   0000004C   0xB2E4             UXTB     R4,R4
   \   0000004E   0x2C04             CMP      R4,#+4
   \   00000050   0xD104             BNE      ??f_mkdir_4
   \   00000052   0x9809             LDR      R0,[SP, #+36]
   \   00000054   0x7AC0             LDRB     R0,[R0, #+11]
   \   00000056   0x0680             LSLS     R0,R0,#+26
   \   00000058   0xD500             BPL      ??f_mkdir_4
   4524          			res = FR_INVALID_NAME;
   \   0000005A   0x2406             MOVS     R4,#+6
   4525          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   \                     ??f_mkdir_4: (+1)
   \   0000005C   0xB2E4             UXTB     R4,R4
   \   0000005E   0x2C04             CMP      R4,#+4
   \   00000060   0xD000             BEQ      .+4
   \   00000062   0xE0BA             B        ??f_mkdir_5
   4526          			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x9803             LDR      R0,[SP, #+12]
   \   00000068   0x.... 0x....      BL       create_chain
   \   0000006C   0x9001             STR      R0,[SP, #+4]
   4527          			res = FR_OK;
   \   0000006E   0x2400             MOVS     R4,#+0
   4528          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   \   00000070   0x9801             LDR      R0,[SP, #+4]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD100             BNE      ??f_mkdir_6
   \   00000076   0x2407             MOVS     R4,#+7
   4529          			if (dcl == 1) res = FR_INT_ERR;
   \                     ??f_mkdir_6: (+1)
   \   00000078   0x9801             LDR      R0,[SP, #+4]
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD100             BNE      ??f_mkdir_7
   \   0000007E   0x2402             MOVS     R4,#+2
   4530          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   \                     ??f_mkdir_7: (+1)
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xD100             BNE      ??f_mkdir_8
   \   0000008A   0x2401             MOVS     R4,#+1
   4531          			if (res == FR_OK)					/* Flush FAT */
   \                     ??f_mkdir_8: (+1)
   \   0000008C   0xB2E4             UXTB     R4,R4
   \   0000008E   0x2C00             CMP      R4,#+0
   \   00000090   0xD10D             BNE      ??f_mkdir_9
   4532          				res = sync_window(dj.fs, WIN_INDEX(dj.fs));
   \   00000092   0x9803             LDR      R0,[SP, #+12]
   \   00000094   0x6C40             LDR      R0,[R0, #+68]
   \   00000096   0x9903             LDR      R1,[SP, #+12]
   \   00000098   0x3148             ADDS     R1,R1,#+72
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD101             BNE      ??f_mkdir_10
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0xE000             B        ??f_mkdir_11
   \                     ??f_mkdir_10: (+1)
   \   000000A2   0x2101             MOVS     R1,#+1
   \                     ??f_mkdir_11: (+1)
   \   000000A4   0xB2C9             UXTB     R1,R1
   \   000000A6   0x9803             LDR      R0,[SP, #+12]
   \   000000A8   0x.... 0x....      BL       sync_winindex
   \   000000AC   0x0004             MOVS     R4,R0
   4533          			if (res == FR_OK) {					/* Initialize the new directory table */
   \                     ??f_mkdir_9: (+1)
   \   000000AE   0xB2E4             UXTB     R4,R4
   \   000000B0   0x2C00             CMP      R4,#+0
   \   000000B2   0xD165             BNE      ??f_mkdir_12
   4534          				dsc = clust2sect(dj.fs, dcl);
   \   000000B4   0x9901             LDR      R1,[SP, #+4]
   \   000000B6   0x9803             LDR      R0,[SP, #+12]
   \   000000B8   0x.... 0x....      BL       clust2sect
   \   000000BC   0x0006             MOVS     R6,R0
   4535          				dir = dj.fs->win;
   \   000000BE   0x9803             LDR      R0,[SP, #+12]
   \   000000C0   0x6C45             LDR      R5,[R0, #+68]
   4536          				mem_set(dir, 0, SS(dj.fs));
   \   000000C2   0x2280             MOVS     R2,#+128
   \   000000C4   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0x0028             MOVS     R0,R5
   \   000000CA   0x.... 0x....      BL       mem_set
   4537          				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
   \   000000CE   0x220B             MOVS     R2,#+11
   \   000000D0   0x2120             MOVS     R1,#+32
   \   000000D2   0x0028             MOVS     R0,R5
   \   000000D4   0x.... 0x....      BL       mem_set
   4538          				dir[DIR_Name] = '.';
   \   000000D8   0x202E             MOVS     R0,#+46
   \   000000DA   0x7028             STRB     R0,[R5, #+0]
   4539          				dir[DIR_Attr] = AM_DIR;
   \   000000DC   0x2010             MOVS     R0,#+16
   \   000000DE   0x72E8             STRB     R0,[R5, #+11]
   4540          				ST_DWORD(dir+DIR_WrtTime, tm);
   \   000000E0   0x9800             LDR      R0,[SP, #+0]
   \   000000E2   0x75A8             STRB     R0,[R5, #+22]
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0xB280             UXTH     R0,R0
   \   000000E8   0x0A00             LSRS     R0,R0,#+8
   \   000000EA   0x75E8             STRB     R0,[R5, #+23]
   \   000000EC   0x9800             LDR      R0,[SP, #+0]
   \   000000EE   0x0C00             LSRS     R0,R0,#+16
   \   000000F0   0x7628             STRB     R0,[R5, #+24]
   \   000000F2   0x9800             LDR      R0,[SP, #+0]
   \   000000F4   0x0E00             LSRS     R0,R0,#+24
   \   000000F6   0x7668             STRB     R0,[R5, #+25]
   4541          				st_clust(dir, dcl);
   \   000000F8   0x9901             LDR      R1,[SP, #+4]
   \   000000FA   0x0028             MOVS     R0,R5
   \   000000FC   0x.... 0x....      BL       st_clust
   4542          				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
   \   00000100   0x2220             MOVS     R2,#+32
   \   00000102   0x0029             MOVS     R1,R5
   \   00000104   0x0028             MOVS     R0,R5
   \   00000106   0x3020             ADDS     R0,R0,#+32
   \   00000108   0x.... 0x....      BL       mem_cpy
   4543          				dir[33] = '.'; pcl = dj.sclust;
   \   0000010C   0x202E             MOVS     R0,#+46
   \   0000010E   0x2121             MOVS     R1,#+33
   \   00000110   0x5468             STRB     R0,[R5, R1]
   \   00000112   0x9905             LDR      R1,[SP, #+20]
   4544          				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
   \   00000114   0x9803             LDR      R0,[SP, #+12]
   \   00000116   0x7800             LDRB     R0,[R0, #+0]
   \   00000118   0x2803             CMP      R0,#+3
   \   0000011A   0xD104             BNE      ??f_mkdir_13
   \   0000011C   0x9803             LDR      R0,[SP, #+12]
   \   0000011E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000120   0x4281             CMP      R1,R0
   \   00000122   0xD100             BNE      ??f_mkdir_13
   4545          					pcl = 0;
   \   00000124   0x2100             MOVS     R1,#+0
   4546          				st_clust(dir+SZ_DIR, pcl);
   \                     ??f_mkdir_13: (+1)
   \   00000126   0x0028             MOVS     R0,R5
   \   00000128   0x3020             ADDS     R0,R0,#+32
   \   0000012A   0x.... 0x....      BL       st_clust
   4547          				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   \   0000012E   0x9803             LDR      R0,[SP, #+12]
   \   00000130   0x7887             LDRB     R7,[R0, #+2]
   \   00000132   0xE006             B        ??f_mkdir_14
   4548          					dj.fs->winsect = dsc++;
   4549          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   4550                                                  set_sectorprev(dj.fs, dj.fs->winsect);
   4551          #endif
   4552                                                  set_dirty(dj.fs);
   4553          					res = sync_window(dj.fs, WIN_INDEX(dj.fs));
   4554          					if (res != FR_OK) break;
   4555          					mem_set(dir, 0, SS(dj.fs));
   \                     ??f_mkdir_15: (+1)
   \   00000134   0x2280             MOVS     R2,#+128
   \   00000136   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \   00000138   0x2100             MOVS     R1,#+0
   \   0000013A   0x0028             MOVS     R0,R5
   \   0000013C   0x.... 0x....      BL       mem_set
   \   00000140   0x1E7F             SUBS     R7,R7,#+1
   \                     ??f_mkdir_14: (+1)
   \   00000142   0xB2FF             UXTB     R7,R7
   \   00000144   0x2F00             CMP      R7,#+0
   \   00000146   0xD01B             BEQ      ??f_mkdir_12
   \   00000148   0x9803             LDR      R0,[SP, #+12]
   \   0000014A   0x6346             STR      R6,[R0, #+52]
   \   0000014C   0x1C76             ADDS     R6,R6,#+1
   \   0000014E   0x9803             LDR      R0,[SP, #+12]
   \   00000150   0x6B41             LDR      R1,[R0, #+52]
   \   00000152   0x9803             LDR      R0,[SP, #+12]
   \   00000154   0x.... 0x....      BL       set_sectorprev
   \   00000158   0x9803             LDR      R0,[SP, #+12]
   \   0000015A   0x.... 0x....      BL       set_dirty
   \   0000015E   0x9803             LDR      R0,[SP, #+12]
   \   00000160   0x6C40             LDR      R0,[R0, #+68]
   \   00000162   0x9903             LDR      R1,[SP, #+12]
   \   00000164   0x3148             ADDS     R1,R1,#+72
   \   00000166   0x4288             CMP      R0,R1
   \   00000168   0xD101             BNE      ??f_mkdir_16
   \   0000016A   0x2100             MOVS     R1,#+0
   \   0000016C   0xE000             B        ??f_mkdir_17
   \                     ??f_mkdir_16: (+1)
   \   0000016E   0x2101             MOVS     R1,#+1
   \                     ??f_mkdir_17: (+1)
   \   00000170   0xB2C9             UXTB     R1,R1
   \   00000172   0x9803             LDR      R0,[SP, #+12]
   \   00000174   0x.... 0x....      BL       sync_winindex
   \   00000178   0x0004             MOVS     R4,R0
   \   0000017A   0xB2E4             UXTB     R4,R4
   \   0000017C   0x2C00             CMP      R4,#+0
   \   0000017E   0xD0D9             BEQ      ??f_mkdir_15
   4556          				}
   4557          			}
   4558          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   \                     ??f_mkdir_12: (+1)
   \   00000180   0xB2E4             UXTB     R4,R4
   \   00000182   0x2C00             CMP      R4,#+0
   \   00000184   0xD103             BNE      ??f_mkdir_18
   \   00000186   0xA803             ADD      R0,SP,#+12
   \   00000188   0x.... 0x....      BL       dir_register
   \   0000018C   0x0004             MOVS     R4,R0
   4559          			if (res != FR_OK) {
   \                     ??f_mkdir_18: (+1)
   \   0000018E   0xB2E4             UXTB     R4,R4
   \   00000190   0x2C00             CMP      R4,#+0
   \   00000192   0xD004             BEQ      ??f_mkdir_19
   4560          				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
   \   00000194   0x9901             LDR      R1,[SP, #+4]
   \   00000196   0x9803             LDR      R0,[SP, #+12]
   \   00000198   0x.... 0x....      BL       remove_chain
   \   0000019C   0xE01D             B        ??f_mkdir_5
   4561          			} else {
   4562          				dir = convert_ptr(dj.fs, dj.dir);
   \                     ??f_mkdir_19: (+1)
   \   0000019E   0x9908             LDR      R1,[SP, #+32]
   \   000001A0   0x9803             LDR      R0,[SP, #+12]
   \   000001A2   0x.... 0x....      BL       convert_ptr
   \   000001A6   0x0005             MOVS     R5,R0
   4563          				dir[DIR_Attr] = AM_DIR;				/* Attribute */
   \   000001A8   0x2010             MOVS     R0,#+16
   \   000001AA   0x72E8             STRB     R0,[R5, #+11]
   4564          				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
   \   000001AC   0x9800             LDR      R0,[SP, #+0]
   \   000001AE   0x75A8             STRB     R0,[R5, #+22]
   \   000001B0   0x9800             LDR      R0,[SP, #+0]
   \   000001B2   0xB280             UXTH     R0,R0
   \   000001B4   0x0A00             LSRS     R0,R0,#+8
   \   000001B6   0x75E8             STRB     R0,[R5, #+23]
   \   000001B8   0x9800             LDR      R0,[SP, #+0]
   \   000001BA   0x0C00             LSRS     R0,R0,#+16
   \   000001BC   0x7628             STRB     R0,[R5, #+24]
   \   000001BE   0x9800             LDR      R0,[SP, #+0]
   \   000001C0   0x0E00             LSRS     R0,R0,#+24
   \   000001C2   0x7668             STRB     R0,[R5, #+25]
   4565          				st_clust(dir, dcl);					/* Table start cluster */
   \   000001C4   0x9901             LDR      R1,[SP, #+4]
   \   000001C6   0x0028             MOVS     R0,R5
   \   000001C8   0x.... 0x....      BL       st_clust
   4566                                          set_dirty(dj.fs);
   \   000001CC   0x9803             LDR      R0,[SP, #+12]
   \   000001CE   0x.... 0x....      BL       set_dirty
   4567          				res = sync_fs(dj.fs);
   \   000001D2   0x9803             LDR      R0,[SP, #+12]
   \   000001D4   0x.... 0x....      BL       sync_fs
   \   000001D8   0x0004             MOVS     R4,R0
   4568          			}
   4569          		}
   4570          		FREE_BUF();
   \                     ??f_mkdir_5: (+1)
   \   000001DA   0x9802             LDR      R0,[SP, #+8]
   \   000001DC   0x.... 0x....      BL       ff_memfree
   4571          	}
   4572          
   4573          	LEAVE_FF(dj.fs, res);
   \                     ??f_mkdir_0: (+1)
   \   000001E0   0x0020             MOVS     R0,R4
   \   000001E2   0xB2C0             UXTB     R0,R0
   \                     ??f_mkdir_2: (+1)
   \   000001E4   0xB011             ADD      SP,SP,#+68
   \   000001E6   0xBDF0             POP      {R4-R7,PC}       ;; return
   4574          }
   4575          
   4576          
   4577          
   4578          /*FUNCTION*-------------------------------------------------------------------
   4579          *
   4580          * Function Name    : f_chmod 
   4581          * Returned Value   : FR_OK: 		The function succeeded.
   4582          *                    FR_NO_FILE: 		Could not find the file.
   4583          *                    FR_NO_PATH:		Could not find the path.
   4584          *                    FR_INVALID_NAME: 	The file name is invalid.
   4585          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   4586          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4587          *                    FR_WRITE_PROTECTED: The medium is writing protected.
   4588          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4589          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4590          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   4591          *                    FR_NO_FILESYSTEM: 	There is no valid FAT volume on the drive.
   4592          *                    
   4593          * Comments         : Change Attribute of file or directory
   4594          *   
   4595          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   4596          FRESULT f_chmod 
   4597            (
   4598              /* [IN] Pointer to the file path */
   4599            	const TCHAR *path,
   4600            	/* [IN] Attribute bits */	
   4601            	uint8_t value,		
   4602            	/* [IN] Attribute mask to change */	
   4603            	uint8_t mask			
   4604            )
   4605          {
   \                     f_chmod: (+1)
   \   00000000   0xB5F1             PUSH     {R0,R4-R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
   4606          	FRESULT res;
   4607          	DIR dj;
   4608          	uint8_t *dir;
   4609          	DEF_NAMEBUF;
   4610          
   4611          
   4612          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0xA80C             ADD      R0,SP,#+48
   \   0000000E   0x.... 0x....      BL       chk_mounted
   \   00000012   0x0006             MOVS     R6,R0
   4613          	if (res == FR_OK) {
   \   00000014   0xB2F6             UXTB     R6,R6
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD135             BNE      ??f_chmod_0
   4614          		INIT_BUF(dj);
   \   0000001A   0x2080             MOVS     R0,#+128
   \   0000001C   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   0000001E   0x.... 0x....      BL       ff_memalloc
   \   00000022   0x0007             MOVS     R7,R0
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD101             BNE      ??f_chmod_1
   \   00000028   0x2011             MOVS     R0,#+17
   \   0000002A   0xE02E             B        ??f_chmod_2
   \                     ??f_chmod_1: (+1)
   \   0000002C   0x9707             STR      R7,[SP, #+28]
   \   0000002E   0xA809             ADD      R0,SP,#+36
   \   00000030   0x9006             STR      R0,[SP, #+24]
   4615          		res = follow_path(&dj, path);		/* Follow the file path */
   \   00000032   0x990C             LDR      R1,[SP, #+48]
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x.... 0x....      BL       follow_path
   \   0000003A   0x0006             MOVS     R6,R0
   4616          		FREE_BUF();
   \   0000003C   0x0038             MOVS     R0,R7
   \   0000003E   0x.... 0x....      BL       ff_memfree
   4617          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000042   0xB2F6             UXTB     R6,R6
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD104             BNE      ??f_chmod_3
   \   00000048   0x9806             LDR      R0,[SP, #+24]
   \   0000004A   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000004C   0x0680             LSLS     R0,R0,#+26
   \   0000004E   0xD500             BPL      ??f_chmod_3
   4618          			res = FR_INVALID_NAME;
   \   00000050   0x2606             MOVS     R6,#+6
   4619          		if (res == FR_OK) {
   \                     ??f_chmod_3: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6
   \   00000054   0x2E00             CMP      R6,#+0
   \   00000056   0xD116             BNE      ??f_chmod_0
   4620          			dir = convert_ptr(dj.fs, dj.dir);
   \   00000058   0x9905             LDR      R1,[SP, #+20]
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x.... 0x....      BL       convert_ptr
   4621          			if (!dir) {						/* Is it a root directory? */
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD101             BNE      ??f_chmod_4
   4622          				res = FR_INVALID_NAME;
   \   00000064   0x2606             MOVS     R6,#+6
   \   00000066   0xE00E             B        ??f_chmod_0
   4623          			} else {						/* File or sub directory */
   4624          				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   \                     ??f_chmod_4: (+1)
   \   00000068   0x0029             MOVS     R1,R5
   \   0000006A   0x2527             MOVS     R5,#+39
   \   0000006C   0x400D             ANDS     R5,R5,R1
   4625          				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (uint8_t)~mask);	/* Apply attribute change */
   \   0000006E   0x402C             ANDS     R4,R4,R5
   \   00000070   0x7AC1             LDRB     R1,[R0, #+11]
   \   00000072   0x43A9             BICS     R1,R1,R5
   \   00000074   0x4321             ORRS     R1,R1,R4
   \   00000076   0x72C1             STRB     R1,[R0, #+11]
   4626          				set_dirty(dj.fs);
   \   00000078   0x9800             LDR      R0,[SP, #+0]
   \   0000007A   0x.... 0x....      BL       set_dirty
   4627          				res = sync_fs(dj.fs);
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x.... 0x....      BL       sync_fs
   \   00000084   0x0006             MOVS     R6,R0
   4628          			}
   4629          		}
   4630          	}
   4631          
   4632          	LEAVE_FF(dj.fs, res);
   \                     ??f_chmod_0: (+1)
   \   00000086   0x0030             MOVS     R0,R6
   \   00000088   0xB2C0             UXTB     R0,R0
   \                     ??f_chmod_2: (+1)
   \   0000008A   0xB00D             ADD      SP,SP,#+52
   \   0000008C   0xBDF0             POP      {R4-R7,PC}       ;; return
   4633          }
   4634          
   4635          
   4636          
   4637          /*FUNCTION*-------------------------------------------------------------------
   4638          *
   4639          * Function Name    : f_utime
   4640          * Returned Value   : FR_OK: 		The function succeeded.
   4641          *                    FR_NO_FILE: 		Could not find the file.
   4642          *                    FR_NO_PATH: 		Could not find the path.
   4643          *                    FR_INVALID_NAME: 	The file name is invalid.
   4644          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   4645          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4646          *                    FR_WRITE_PROTECTED: The medium is write protected.
   4647          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4648          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4649          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   4650          *                    FR_NO_FILESYSTEM: 	There is no valid FAT volume on the drive.
   4651          *
   4652          *                    
   4653          * Comments         : Change Timestamp of file or directory
   4654          *   
   4655          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   4656          FRESULT f_utime 
   4657            (
   4658              /* [IN] Pointer to the file/directory name */
   4659            	const TCHAR *path,	
   4660            	/* [IN] Pointer to the time stamp to be set */
   4661            	const FILINFO *fno	
   4662            )
   4663          {
   \                     f_utime: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x000C             MOVS     R4,R1
   4664          	FRESULT res;
   4665          	DIR dj;
   4666          	uint8_t *dir;
   4667          	DEF_NAMEBUF;
   4668          
   4669          
   4670          	res = chk_mounted(&path, &dj.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0xA80D             ADD      R0,SP,#+52
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0006             MOVS     R6,R0
   4671          	if (res == FR_OK) {
   \   00000012   0xB2F6             UXTB     R6,R6
   \   00000014   0x2E00             CMP      R6,#+0
   \   00000016   0xD139             BNE      ??f_utime_0
   4672          		INIT_BUF(dj);
   \   00000018   0x2080             MOVS     R0,#+128
   \   0000001A   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   0000001C   0x.... 0x....      BL       ff_memalloc
   \   00000020   0x0005             MOVS     R5,R0
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD101             BNE      ??f_utime_1
   \   00000026   0x2011             MOVS     R0,#+17
   \   00000028   0xE032             B        ??f_utime_2
   \                     ??f_utime_1: (+1)
   \   0000002A   0x9507             STR      R5,[SP, #+28]
   \   0000002C   0xA809             ADD      R0,SP,#+36
   \   0000002E   0x9006             STR      R0,[SP, #+24]
   4673          		res = follow_path(&dj, path);	/* Follow the file path */
   \   00000030   0x990D             LDR      R1,[SP, #+52]
   \   00000032   0x4668             MOV      R0,SP
   \   00000034   0x.... 0x....      BL       follow_path
   \   00000038   0x0006             MOVS     R6,R0
   4674          		FREE_BUF();
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x.... 0x....      BL       ff_memfree
   4675          		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
   \   00000040   0xB2F6             UXTB     R6,R6
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD104             BNE      ??f_utime_3
   \   00000046   0x9806             LDR      R0,[SP, #+24]
   \   00000048   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000004A   0x0680             LSLS     R0,R0,#+26
   \   0000004C   0xD500             BPL      ??f_utime_3
   4676          			res = FR_INVALID_NAME;
   \   0000004E   0x2606             MOVS     R6,#+6
   4677          		if (res == FR_OK) {
   \                     ??f_utime_3: (+1)
   \   00000050   0xB2F6             UXTB     R6,R6
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD11A             BNE      ??f_utime_0
   4678          			dir = convert_ptr(dj.fs, dj.dir);
   \   00000056   0x9905             LDR      R1,[SP, #+20]
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x.... 0x....      BL       convert_ptr
   4679          			if (!dir) {					/* Root directory */
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD101             BNE      ??f_utime_4
   4680          				res = FR_INVALID_NAME;
   \   00000062   0x2606             MOVS     R6,#+6
   \   00000064   0xE012             B        ??f_utime_0
   4681          			} else {					/* File or sub-directory */
   4682          				ST_WORD(dir+DIR_WrtTime, fno->ftime.Word);
   \                     ??f_utime_4: (+1)
   \   00000066   0x88E1             LDRH     R1,[R4, #+6]
   \   00000068   0x7581             STRB     R1,[R0, #+22]
   \   0000006A   0x88E1             LDRH     R1,[R4, #+6]
   \   0000006C   0xB289             UXTH     R1,R1
   \   0000006E   0x0A09             LSRS     R1,R1,#+8
   \   00000070   0x75C1             STRB     R1,[R0, #+23]
   4683          				ST_WORD(dir+DIR_WrtDate, fno->fdate.Word);
   \   00000072   0x88A1             LDRH     R1,[R4, #+4]
   \   00000074   0x7601             STRB     R1,[R0, #+24]
   \   00000076   0x88A1             LDRH     R1,[R4, #+4]
   \   00000078   0xB289             UXTH     R1,R1
   \   0000007A   0x0A09             LSRS     R1,R1,#+8
   \   0000007C   0x7641             STRB     R1,[R0, #+25]
   4684          				set_dirty(dj.fs);
   \   0000007E   0x9800             LDR      R0,[SP, #+0]
   \   00000080   0x.... 0x....      BL       set_dirty
   4685          				res = sync_fs(dj.fs);
   \   00000084   0x9800             LDR      R0,[SP, #+0]
   \   00000086   0x.... 0x....      BL       sync_fs
   \   0000008A   0x0006             MOVS     R6,R0
   4686          			}
   4687          		}
   4688          	}
   4689          
   4690          	LEAVE_FF(dj.fs, res);
   \                     ??f_utime_0: (+1)
   \   0000008C   0x0030             MOVS     R0,R6
   \   0000008E   0xB2C0             UXTB     R0,R0
   \                     ??f_utime_2: (+1)
   \   00000090   0xB00E             ADD      SP,SP,#+56
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return
   4691          }
   4692          /*FUNCTION*-------------------------------------------------------------------
   4693          *
   4694          * Function Name    : f_rename
   4695          * Returned Value   : FR_OK: 		The function succeeded.
   4696          *                    FR_NO_FILE: 		Could not find the old name.
   4697          *                    FR_NO_PATH:		Could not find the path.
   4698          *                    FR_INVALID_NAME: 	The file name is invalid.
   4699          *                    FR_INVALID_DRIVE: 	The drive number is invalid.
   4700          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4701          *                    FR_EXIST: 		The new name is colliding with an existing name.
   4702          *                    FR_DENIED: 		The new name could not be created due to any reason.
   4703          *                    FR_WRITE_PROTECTED: The medium is write protected.
   4704          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4705          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4706          *                    FR_NOT_ENABLED: 	The logical drive has no work area.
   4707          *                    FR_NO_FILESYSTEM: There is no valid FAT volume on the drive.
   4708          *                    FR_LOCKED: 		The function was rejected due to file sharing policy  
   4709          *                    
   4710          * Comments         : Rename File/Directory 
   4711          *   
   4712          *END*----------------------------------------------------------------------*/
   4713          

   \                                 In section .text, align 2, keep-with-next
   4714          FRESULT f_rename 
   4715            (
   4716              /* [IN] Pointer to the old name */
   4717            	const TCHAR *path_old,
   4718            	/* [IN] Pointer to the new name */	
   4719            	const TCHAR *path_new	
   4720            )
   4721          {
   \                     f_rename: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB09B             SUB      SP,SP,#+108
   \   00000004   0x000D             MOVS     R5,R1
   4722          	FRESULT res;
   4723          	DIR djo, djn;
   4724          	uint8_t buf[21], *dir;
   4725          	uint32_t dw;
   4726          	DEF_NAMEBUF;
   4727          
   4728          
   4729          	res = chk_mounted(&path_old, &djo.fs, 1);
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0xA81B             ADD      R0,SP,#+108
   \   0000000C   0x.... 0x....      BL       chk_mounted
   \   00000010   0x0004             MOVS     R4,R0
   4730          	if (res == FR_OK) {
   \   00000012   0xB2E4             UXTB     R4,R4
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD000             BEQ      .+4
   \   00000018   0xE09C             B        ??f_rename_0
   4731          		djn.fs = djo.fs;
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x9009             STR      R0,[SP, #+36]
   4732          		INIT_BUF(djo);
   \   0000001E   0x2080             MOVS     R0,#+128
   \   00000020   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000022   0x.... 0x....      BL       ff_memalloc
   \   00000026   0x0006             MOVS     R6,R0
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD101             BNE      ??f_rename_1
   \   0000002C   0x2011             MOVS     R0,#+17
   \   0000002E   0xE093             B        ??f_rename_2
   \                     ??f_rename_1: (+1)
   \   00000030   0x9607             STR      R6,[SP, #+28]
   \   00000032   0xA812             ADD      R0,SP,#+72
   \   00000034   0x9006             STR      R0,[SP, #+24]
   4733          		res = follow_path(&djo, path_old);		/* Check old object */
   \   00000036   0x991B             LDR      R1,[SP, #+108]
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x.... 0x....      BL       follow_path
   \   0000003E   0x0004             MOVS     R4,R0
   4734          		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
   \   00000040   0xB2E4             UXTB     R4,R4
   \   00000042   0x2C00             CMP      R4,#+0
   \   00000044   0xD104             BNE      ??f_rename_3
   \   00000046   0x9806             LDR      R0,[SP, #+24]
   \   00000048   0x7AC0             LDRB     R0,[R0, #+11]
   \   0000004A   0x0680             LSLS     R0,R0,#+26
   \   0000004C   0xD500             BPL      ??f_rename_3
   4735          			res = FR_INVALID_NAME;
   \   0000004E   0x2406             MOVS     R4,#+6
   4736          #if _FS_LOCK
   4737          		if (res == FR_OK) res = chk_lock(&djo, 2);
   4738          #endif
   4739          		if (res == FR_OK) {						/* Old object is found */
   \                     ??f_rename_3: (+1)
   \   00000050   0xB2E4             UXTB     R4,R4
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD17B             BNE      ??f_rename_4
   4740          			if (!djo.dir) {						/* Is root dir? */
   \   00000056   0x9805             LDR      R0,[SP, #+20]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD101             BNE      ??f_rename_5
   4741          				res = FR_NO_FILE;
   \   0000005C   0x2404             MOVS     R4,#+4
   \   0000005E   0xE076             B        ??f_rename_4
   4742          			} else {
   4743          				mem_cpy(buf, convert_ptr(djo.fs, djo.dir)+DIR_Attr, 21);		/* Save the object information except for name */
   \                     ??f_rename_5: (+1)
   \   00000060   0x9905             LDR      R1,[SP, #+20]
   \   00000062   0x9800             LDR      R0,[SP, #+0]
   \   00000064   0x.... 0x....      BL       convert_ptr
   \   00000068   0x2215             MOVS     R2,#+21
   \   0000006A   0x300B             ADDS     R0,R0,#+11
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0xA815             ADD      R0,SP,#+84
   \   00000070   0x.... 0x....      BL       mem_cpy
   4744          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
   \   00000074   0x2224             MOVS     R2,#+36
   \   00000076   0x4669             MOV      R1,SP
   \   00000078   0xA809             ADD      R0,SP,#+36
   \   0000007A   0x.... 0x....      BL       mem_cpy
   4745          				res = follow_path(&djn, path_new);
   \   0000007E   0x0029             MOVS     R1,R5
   \   00000080   0xA809             ADD      R0,SP,#+36
   \   00000082   0x.... 0x....      BL       follow_path
   \   00000086   0x0004             MOVS     R4,R0
   4746          				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
   \   00000088   0xB2E4             UXTB     R4,R4
   \   0000008A   0x2C00             CMP      R4,#+0
   \   0000008C   0xD100             BNE      ??f_rename_6
   \   0000008E   0x2408             MOVS     R4,#+8
   4747          				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
   \                     ??f_rename_6: (+1)
   \   00000090   0xB2E4             UXTB     R4,R4
   \   00000092   0x2C04             CMP      R4,#+4
   \   00000094   0xD15B             BNE      ??f_rename_4
   4748          /* Start critical section that any interruption can cause a cross-link */
   4749          					res = dir_register(&djn);			/* Register the new entry */
   \   00000096   0xA809             ADD      R0,SP,#+36
   \   00000098   0x.... 0x....      BL       dir_register
   \   0000009C   0x0004             MOVS     R4,R0
   4750          					if (res == FR_OK) {
   \   0000009E   0xB2E4             UXTB     R4,R4
   \   000000A0   0x2C00             CMP      R4,#+0
   \   000000A2   0xD154             BNE      ??f_rename_4
   4751          						dir = convert_ptr(djn.fs, djn.dir);					/* Copy object information except for name */
   \   000000A4   0x990E             LDR      R1,[SP, #+56]
   \   000000A6   0x9809             LDR      R0,[SP, #+36]
   \   000000A8   0x.... 0x....      BL       convert_ptr
   \   000000AC   0x0005             MOVS     R5,R0
   4752          						mem_cpy(dir+13, buf+2, 19);
   \   000000AE   0x2213             MOVS     R2,#+19
   \   000000B0   0xA915             ADD      R1,SP,#+84
   \   000000B2   0x1C89             ADDS     R1,R1,#+2
   \   000000B4   0x0028             MOVS     R0,R5
   \   000000B6   0x300D             ADDS     R0,R0,#+13
   \   000000B8   0x.... 0x....      BL       mem_cpy
   4753          						dir[DIR_Attr] = buf[0] | AM_ARC;
   \   000000BC   0xA815             ADD      R0,SP,#+84
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x2120             MOVS     R1,#+32
   \   000000C2   0x4301             ORRS     R1,R1,R0
   \   000000C4   0x72E9             STRB     R1,[R5, #+11]
   4754          						set_dirty(djo.fs);
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0x.... 0x....      BL       set_dirty
   4755          						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
   \   000000CC   0x9802             LDR      R0,[SP, #+8]
   \   000000CE   0x990B             LDR      R1,[SP, #+44]
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD02E             BEQ      ??f_rename_7
   \   000000D4   0x7AE8             LDRB     R0,[R5, #+11]
   \   000000D6   0x06C0             LSLS     R0,R0,#+27
   \   000000D8   0xD52B             BPL      ??f_rename_7
   4756          							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
   \   000000DA   0x0029             MOVS     R1,R5
   \   000000DC   0x9800             LDR      R0,[SP, #+0]
   \   000000DE   0x.... 0x....      BL       ld_clust
   \   000000E2   0x0001             MOVS     R1,R0
   \   000000E4   0x9800             LDR      R0,[SP, #+0]
   \   000000E6   0x.... 0x....      BL       clust2sect
   \   000000EA   0x0001             MOVS     R1,R0
   4757          							if (!dw) {
   \   000000EC   0x2900             CMP      R1,#+0
   \   000000EE   0xD101             BNE      ??f_rename_8
   4758          								res = FR_INT_ERR;
   \   000000F0   0x2402             MOVS     R4,#+2
   \   000000F2   0xE01E             B        ??f_rename_7
   4759          							} else {
   4760          								res = move_window(djo.fs, dw);
   \                     ??f_rename_8: (+1)
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       move_window
   \   000000FA   0x0004             MOVS     R4,R0
   4761          								dir = djo.fs->win+SZ_DIR;	/* .. entry */
   \   000000FC   0x9800             LDR      R0,[SP, #+0]
   \   000000FE   0x6C45             LDR      R5,[R0, #+68]
   \   00000100   0x3520             ADDS     R5,R5,#+32
   4762          								if (res == FR_OK && dir[1] == '.') {
   \   00000102   0xB2E4             UXTB     R4,R4
   \   00000104   0x2C00             CMP      R4,#+0
   \   00000106   0xD114             BNE      ??f_rename_7
   \   00000108   0x7868             LDRB     R0,[R5, #+1]
   \   0000010A   0x282E             CMP      R0,#+46
   \   0000010C   0xD111             BNE      ??f_rename_7
   4763          									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
   \   0000010E   0x9800             LDR      R0,[SP, #+0]
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x2803             CMP      R0,#+3
   \   00000114   0xD106             BNE      ??f_rename_9
   \   00000116   0x980B             LDR      R0,[SP, #+44]
   \   00000118   0x9900             LDR      R1,[SP, #+0]
   \   0000011A   0x6AC9             LDR      R1,[R1, #+44]
   \   0000011C   0x4288             CMP      R0,R1
   \   0000011E   0xD101             BNE      ??f_rename_9
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0xE000             B        ??f_rename_10
   \                     ??f_rename_9: (+1)
   \   00000124   0x990B             LDR      R1,[SP, #+44]
   4764          									st_clust(dir, dw);
   \                     ??f_rename_10: (+1)
   \   00000126   0x0028             MOVS     R0,R5
   \   00000128   0x.... 0x....      BL       st_clust
   4765          									set_dirty(djo.fs);
   \   0000012C   0x9800             LDR      R0,[SP, #+0]
   \   0000012E   0x.... 0x....      BL       set_dirty
   4766          								}
   4767          							}
   4768          						}
   4769          						if (res == FR_OK) {
   \                     ??f_rename_7: (+1)
   \   00000132   0xB2E4             UXTB     R4,R4
   \   00000134   0x2C00             CMP      R4,#+0
   \   00000136   0xD10A             BNE      ??f_rename_4
   4770          							res = dir_remove(&djo);		/* Remove old entry */
   \   00000138   0x4668             MOV      R0,SP
   \   0000013A   0x.... 0x....      BL       dir_remove
   \   0000013E   0x0004             MOVS     R4,R0
   4771          							if (res == FR_OK)
   \   00000140   0xB2E4             UXTB     R4,R4
   \   00000142   0x2C00             CMP      R4,#+0
   \   00000144   0xD103             BNE      ??f_rename_4
   4772          								res = sync_fs(djo.fs);
   \   00000146   0x9800             LDR      R0,[SP, #+0]
   \   00000148   0x.... 0x....      BL       sync_fs
   \   0000014C   0x0004             MOVS     R4,R0
   4773          						}
   4774          					}
   4775          /* End critical section */
   4776          				}
   4777          			}
   4778          		}
   4779          		FREE_BUF();
   \                     ??f_rename_4: (+1)
   \   0000014E   0x0030             MOVS     R0,R6
   \   00000150   0x.... 0x....      BL       ff_memfree
   4780          	}
   4781          
   4782          	LEAVE_FF(djo.fs, res);
   \                     ??f_rename_0: (+1)
   \   00000154   0x0020             MOVS     R0,R4
   \   00000156   0xB2C0             UXTB     R0,R0
   \                     ??f_rename_2: (+1)
   \   00000158   0xB01C             ADD      SP,SP,#+112
   \   0000015A   0xBD70             POP      {R4-R6,PC}       ;; return
   4783          }
   4784          
   4785          #endif /* !_FS_READONLY */
   4786          #endif /* _FS_MINIMIZE == 0 */
   4787          #endif /* _FS_MINIMIZE <= 1 */
   4788          #endif /* _FS_MINIMIZE <= 2 */
   4789          
   4790          
   4791          
   4792          #if _USE_LABEL
   4793          /*-----------------------------------------------------------------------*/
   4794          /* Get volume label                                                      */
   4795          /*-----------------------------------------------------------------------*/
   4796          
   4797          FRESULT f_getlabel (
   4798          	const TCHAR* path,	/* Path name of the logical drive number */
   4799          	TCHAR* label,		/* Pointer to a buffer to return the volume label */
   4800          	uint32_t* sn			/* Pointer to a variable to return the volume serial number */
   4801          )
   4802          {
   4803          	FRESULT res;
   4804          	DIR dj;
   4805          	uint32_t i, j;
   4806          
   4807          
   4808          	/* Get logical drive */
   4809          	res = chk_mounted(&path, &dj.fs, 0);
   4810          
   4811          	/* Get volume label */
   4812          	if (res == FR_OK && label) {
   4813          		dj.sclust = 0;					/* Open root dir */
   4814          		res = dir_sdi(&dj, 0);
   4815          		if (res == FR_OK) {
   4816          			res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   4817          			if (res == FR_OK) {			/* A volume label is exist */
   4818          #if _LFN_UNICODE
   4819          				uint16_t w;
   4820          				i = j = 0;
   4821          				do {
   4822          					w = (i < 11) ? convert_ptr(dj.fs, dj.dir)[i++] : ' ';
   4823          					if (IsDBCS1(w) && i < 11 && IsDBCS2(convert_ptr(dj.fs, dj.dir)[i]))
   4824          						w = (w << 8) | convert_ptr(dj.fs, dj.dir)[i++];
   4825          					label[j++] = ff_convert(w, 1);
   4826          				} while (j < 11);
   4827          #else
   4828          				mem_cpy(label, convert_ptr(dj.fs, dj.dir), 11);
   4829          #endif
   4830          				j = 11;
   4831          				do {
   4832          					label[j] = 0;
   4833          					if (!j) break;
   4834          				} while (label[--j] == ' ');
   4835          			}
   4836          			if (res == FR_NO_FILE) {	/* No label, return nul string */
   4837          				label[0] = 0;
   4838          				res = FR_OK;
   4839          			}
   4840          		}
   4841          	}
   4842          
   4843          	/* Get volume serial number */
   4844          	if (res == FR_OK && sn) {
   4845          		res = move_window(dj.fs, dj.fs->volbase);
   4846          		if (res == FR_OK) {
   4847          			i = dj.fs->fs_type == FS_FAT32 ? BS_VolID32 : BS_VolID;
   4848          			*sn = LD_DWORD(&dj.fs->win[i]);
   4849          		}
   4850          	}
   4851          
   4852          	LEAVE_FF(dj.fs, res);
   4853          }
   4854          
   4855          
   4856          
   4857          #if !_FS_READONLY
   4858          /*-----------------------------------------------------------------------*/
   4859          /* Set volume label                                                      */
   4860          /*-----------------------------------------------------------------------*/
   4861          
   4862          FRESULT f_setlabel (
   4863          	const TCHAR* label	/* Pointer to the volume label to set */
   4864          )
   4865          {
   4866          	FRESULT res;
   4867          	DIR dj;
   4868          	uint8_t vn[11];
   4869          	uint32_t i, j, sl;
   4870          	uint16_t w;
   4871          	uint32_t tm;
   4872          
   4873          
   4874          	/* Get logical drive */
   4875          	res = chk_mounted(&label, &dj.fs, 1);
   4876          	if (res) LEAVE_FF(dj.fs, res);
   4877          
   4878          	/* Create a volume label in directory form */
   4879          	vn[0] = 0;
   4880          	for (sl = 0; label[sl]; sl++) ;				/* Get name length */
   4881          	for ( ; sl && label[sl-1] == ' '; sl--) ;	/* Remove trailing spaces */
   4882          	if (sl) {	/* Create volume label in directory form */
   4883          		i = j = 0;
   4884          		do {
   4885          #if _LFN_UNICODE
   4886          			w = ff_convert(ff_wtoupper(label[i++]), 0);
   4887          #else
   4888          			w = (uint8_t)label[i++];
   4889          			if (IsDBCS1(w))
   4890          				w = (j < 10 && i < sl && IsDBCS2(label[i])) ? (w << 8) | (uint8_t)label[i++] : 0;
   4891          #if _USE_LFN
   4892          			w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
   4893          #else
   4894          			if (IsLower(w)) w -= 0x20;			/* To upper ASCII chars */
   4895          #ifdef _EXCVT
   4896          			if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended chars (SBCS cfg) */
   4897          #else
   4898          			if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended chars (ASCII cfg) */
   4899          #endif
   4900          #endif
   4901          #endif
   4902          			if (!w || chk_chr("\"*+,.:;<=>\?[]|\x7F", w) || j >= (uint32_t)((w >= 0x100) ? 10 : 11)) /* Reject invalid chars for volume label */
   4903          				LEAVE_FF(dj.fs, FR_INVALID_NAME);
   4904          			if (w >= 0x100) vn[j++] = (uint8_t)(w >> 8);
   4905          			vn[j++] = (uint8_t)w;
   4906          		} while (i < sl);
   4907          		while (j < 11) vn[j++] = ' ';
   4908          	}
   4909          
   4910          	/* Set volume label */
   4911          	dj.sclust = 0;					/* Open root dir */
   4912          	res = dir_sdi(&dj, 0);
   4913          	if (res == FR_OK) {
   4914          		res = dir_read(&dj, 1);		/* Get an entry with AM_VOL */
   4915          		if (res == FR_OK) {			/* A volume label is found */
   4916          			if (vn[0]) {
   4917          				mem_cpy(convert_ptr(dj.fs, dj.dir), vn, 11);	/* Change the volume label name */
   4918          				tm = get_fattime();
   4919          				ST_DWORD(convert_ptr(dj.fs, dj.dir)+DIR_WrtTime, tm);
   4920          			} else {
   4921          				convert_ptr(dj.fs, dj.dir)[0] = DDE;			/* Remove the volume label */
   4922          			}
   4923          			set_dirty(dj.fs);
   4924          			res = sync_fs(dj.fs);
   4925          		} else {					/* No volume label is found or error */
   4926          			if (res == FR_NO_FILE) {
   4927          				res = FR_OK;
   4928          				if (vn[0]) {				/* Create volume label as new */
   4929          					res = dir_alloc(&dj, 1);	/* Allocate an entry for volume label */
   4930          					if (res == FR_OK) {
   4931          						mem_set(convert_ptr(dj.fs, dj.dir), 0, SZ_DIR);	/* Set volume label */
   4932          						mem_cpy(convert_ptr(dj.fs, dj.dir), vn, 11);
   4933          						convert_ptr(dj.fs, dj.dir)[DIR_Attr] = AM_VOL;
   4934          						tm = get_fattime();
   4935          						ST_DWORD(convert_ptr(dj.fs, dj.dir)+DIR_WrtTime, tm);
   4936          						set_dirty(dj.fs);
   4937          						res = sync_fs(dj.fs);
   4938          					}
   4939          				}
   4940          			}
   4941          		}
   4942          	}
   4943          
   4944          	LEAVE_FF(dj.fs, res);
   4945          }
   4946          
   4947          #endif /* !_FS_READONLY */
   4948          #endif /* _USE_LABEL */
   4949          
   4950          
   4951          
   4952          /*FUNCTION*-------------------------------------------------------------------
   4953          *
   4954          * Function Name    : f_forward
   4955          * Returned Value   : FR_OK: 		The function succeeded.
   4956          *                    FR_DENIED: 	The function denied due to the file has been opened in non-read mode.
   4957          *                    FR_DISK_ERR: 	The function failed due to an error in the disk function.
   4958          *                    FR_INT_ERR: 	The function failed due to a wrong FAT structure or an internal error.
   4959          *                    FR_NOT_READY: 	The disk drive cannot work due to no medium in the drive or any other reason.
   4960          *                    FR_INVALID_OBJECT: The file object is invalid.
   4961          *
   4962          *                    
   4963          * Comments         : Forward data to the stream directly (available on only tiny cfg) 
   4964          *   
   4965          *END*----------------------------------------------------------------------*/
   4966          
   4967          #if _USE_FORWARD && _FS_TINY
   4968          

   \                                 In section .text, align 2, keep-with-next
   4969          FRESULT f_forward 
   4970            (
   4971              /* [IN] Pointer to the file object */
   4972            	FIL *fp, 						
   4973            	/* [IN] Pointer to the streaming function */
   4974            	uint32_t (*func)(const uint8_t*,uint32_t),	
   4975            	/* [IN] Number of bytes to forward */
   4976            	uint32_t btf,						
   4977            	/* [OUT] Pointer to number of bytes forwarded */
   4978            	uint32_t *bf						
   4979            )
   4980          {
   \                     f_forward: (+1)
   \   00000000   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   4981          	FRESULT res;
   4982          	uint32_t remain, clst, sect;
   4983          	uint32_t rcnt;
   4984          	uint8_t csect;
   4985          
   4986          
   4987          	*bf = 0;	/* Clear transfer byte counter */
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x9902             LDR      R1,[SP, #+8]
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   4988          
   4989          	res = validate(fp);								/* Check validity of the object */
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       validate
   4990          	if (res != FR_OK) LEAVE_FF(fp->fs, res);
   \   00000012   0xB2C0             UXTB     R0,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ      ??f_forward_0
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0xE08C             B        ??f_forward_1
   4991          	if (fp->flag & FA__ERROR)						/* Check error flag */
   \                     ??f_forward_0: (+1)
   \   0000001C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000001E   0x0600             LSLS     R0,R0,#+24
   \   00000020   0xD501             BPL      ??f_forward_2
   4992          		LEAVE_FF(fp->fs, FR_INT_ERR);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE087             B        ??f_forward_1
   4993          	if (!(fp->flag & FA_READ))						/* Check access mode */
   \                     ??f_forward_2: (+1)
   \   00000026   0x79A0             LDRB     R0,[R4, #+6]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD401             BMI      ??f_forward_3
   4994          		LEAVE_FF(fp->fs, FR_DENIED);
   \   0000002C   0x2007             MOVS     R0,#+7
   \   0000002E   0xE082             B        ??f_forward_1
   4995          
   4996          	remain = fp->fsize - fp->fptr;
   \                     ??f_forward_3: (+1)
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x68A1             LDR      R1,[R4, #+8]
   \   00000034   0x1A40             SUBS     R0,R0,R1
   4997          	if (btf > remain) btf = (uint32_t)remain;			/* Truncate btf by remaining bytes */
   \   00000036   0x42A8             CMP      R0,R5
   \   00000038   0xD20A             BCS      ??f_forward_4
   \   0000003A   0x0005             MOVS     R5,R0
   \   0000003C   0xE008             B        ??f_forward_4
   4998          
   4999          	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   5000          		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
   \                     ??f_forward_5: (+1)
   \   0000003E   0x68A1             LDR      R1,[R4, #+8]
   \   00000040   0x1809             ADDS     R1,R1,R0
   \   00000042   0x60A1             STR      R1,[R4, #+8]
   \   00000044   0x9902             LDR      R1,[SP, #+8]
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x1809             ADDS     R1,R1,R0
   \   0000004A   0x9A02             LDR      R2,[SP, #+8]
   \   0000004C   0x6011             STR      R1,[R2, #+0]
   \   0000004E   0x1A2D             SUBS     R5,R5,R0
   \                     ??f_forward_4: (+1)
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD06F             BEQ      ??f_forward_6
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x9A01             LDR      R2,[SP, #+4]
   \   0000005A   0x4790             BLX      R2
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD069             BEQ      ??f_forward_6
   5001          		csect = (uint8_t)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
   \   00000060   0x68A0             LDR      R0,[R4, #+8]
   \   00000062   0x0A40             LSRS     R0,R0,#+9
   \   00000064   0x6821             LDR      R1,[R4, #+0]
   \   00000066   0x788F             LDRB     R7,[R1, #+2]
   \   00000068   0x1E7F             SUBS     R7,R7,#+1
   \   0000006A   0x4007             ANDS     R7,R7,R0
   5002          		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
   \   0000006C   0x68A0             LDR      R0,[R4, #+8]
   \   0000006E   0x2180             MOVS     R1,#+128
   \   00000070   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000072   0x.... 0x....      BL       __aeabi_uidivmod
   \   00000076   0x2900             CMP      R1,#+0
   \   00000078   0xD11E             BNE      ??f_forward_7
   5003          			if (!csect) {							/* On the cluster boundary? */
   \   0000007A   0xB2FF             UXTB     R7,R7
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD11B             BNE      ??f_forward_7
   5004          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   5005          					fp->sclust : get_fat(fp->fs, fp->clust);
   \   00000080   0x68A0             LDR      R0,[R4, #+8]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD101             BNE      ??f_forward_8
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0xE003             B        ??f_forward_9
   \                     ??f_forward_8: (+1)
   \   0000008A   0x6961             LDR      R1,[R4, #+20]
   \   0000008C   0x6820             LDR      R0,[R4, #+0]
   \   0000008E   0x.... 0x....      BL       get_fat
   5006          				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
   \                     ??f_forward_9: (+1)
   \   00000092   0x2802             CMP      R0,#+2
   \   00000094   0xD205             BCS      ??f_forward_10
   \   00000096   0x79A0             LDRB     R0,[R4, #+6]
   \   00000098   0x2180             MOVS     R1,#+128
   \   0000009A   0x4301             ORRS     R1,R1,R0
   \   0000009C   0x71A1             STRB     R1,[R4, #+6]
   \   0000009E   0x2002             MOVS     R0,#+2
   \   000000A0   0xE049             B        ??f_forward_1
   5007          				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
   \                     ??f_forward_10: (+1)
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x43C9             MVNS     R1,R1            ;; #-1
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xD105             BNE      ??f_forward_11
   \   000000AA   0x79A0             LDRB     R0,[R4, #+6]
   \   000000AC   0x2180             MOVS     R1,#+128
   \   000000AE   0x4301             ORRS     R1,R1,R0
   \   000000B0   0x71A1             STRB     R1,[R4, #+6]
   \   000000B2   0x2001             MOVS     R0,#+1
   \   000000B4   0xE03F             B        ??f_forward_1
   5008          				fp->clust = clst;					/* Update current cluster */
   \                     ??f_forward_11: (+1)
   \   000000B6   0x6160             STR      R0,[R4, #+20]
   5009          			}
   5010          		}
   5011          		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
   \                     ??f_forward_7: (+1)
   \   000000B8   0x6961             LDR      R1,[R4, #+20]
   \   000000BA   0x6820             LDR      R0,[R4, #+0]
   \   000000BC   0x.... 0x....      BL       clust2sect
   \   000000C0   0x0006             MOVS     R6,R0
   5012          		if (!sect) ABORT(fp->fs, FR_INT_ERR);
   \   000000C2   0x2E00             CMP      R6,#+0
   \   000000C4   0xD105             BNE      ??f_forward_12
   \   000000C6   0x79A0             LDRB     R0,[R4, #+6]
   \   000000C8   0x2180             MOVS     R1,#+128
   \   000000CA   0x4301             ORRS     R1,R1,R0
   \   000000CC   0x71A1             STRB     R1,[R4, #+6]
   \   000000CE   0x2002             MOVS     R0,#+2
   \   000000D0   0xE031             B        ??f_forward_1
   5013          		sect += csect;
   \                     ??f_forward_12: (+1)
   \   000000D2   0xB2FF             UXTB     R7,R7
   \   000000D4   0x19F6             ADDS     R6,R6,R7
   5014          		if (move_window(fp->fs, sect))				/* Move sector window */
   \   000000D6   0x0031             MOVS     R1,R6
   \   000000D8   0x6820             LDR      R0,[R4, #+0]
   \   000000DA   0x.... 0x....      BL       move_window
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD005             BEQ      ??f_forward_13
   5015          			ABORT(fp->fs, FR_DISK_ERR);
   \   000000E2   0x79A0             LDRB     R0,[R4, #+6]
   \   000000E4   0x2180             MOVS     R1,#+128
   \   000000E6   0x4301             ORRS     R1,R1,R0
   \   000000E8   0x71A1             STRB     R1,[R4, #+6]
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE023             B        ??f_forward_1
   5016          		fp->dsect = sect;
   \                     ??f_forward_13: (+1)
   \   000000EE   0x61A6             STR      R6,[R4, #+24]
   5017          		rcnt = SS(fp->fs) - (uint16_t)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
   \   000000F0   0x2680             MOVS     R6,#+128
   \   000000F2   0x00B6             LSLS     R6,R6,#+2        ;; #+512
   \   000000F4   0x68A0             LDR      R0,[R4, #+8]
   \   000000F6   0x2180             MOVS     R1,#+128
   \   000000F8   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   000000FA   0x.... 0x....      BL       __aeabi_uidivmod
   \   000000FE   0xB289             UXTH     R1,R1
   \   00000100   0x1A70             SUBS     R0,R6,R1
   5018          		if (rcnt > btf) rcnt = btf;
   \   00000102   0x4285             CMP      R5,R0
   \   00000104   0xD200             BCS      ??f_forward_14
   \   00000106   0x0028             MOVS     R0,R5
   5019          		rcnt = (*func)(&fp->fs->win[(uint16_t)fp->fptr % SS(fp->fs)], rcnt);
   \                     ??f_forward_14: (+1)
   \   00000108   0x0001             MOVS     R1,R0
   \   0000010A   0x000E             MOVS     R6,R1
   \   0000010C   0x6820             LDR      R0,[R4, #+0]
   \   0000010E   0x6C47             LDR      R7,[R0, #+68]
   \   00000110   0x68A0             LDR      R0,[R4, #+8]
   \   00000112   0xB280             UXTH     R0,R0
   \   00000114   0x2180             MOVS     R1,#+128
   \   00000116   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000118   0x.... 0x....      BL       __aeabi_uidivmod
   \   0000011C   0x1878             ADDS     R0,R7,R1
   \   0000011E   0x0031             MOVS     R1,R6
   \   00000120   0x9A01             LDR      R2,[SP, #+4]
   \   00000122   0x4790             BLX      R2
   5020          		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
   \   00000124   0x2800             CMP      R0,#+0
   \   00000126   0xD18A             BNE      ??f_forward_5
   \   00000128   0x79A0             LDRB     R0,[R4, #+6]
   \   0000012A   0x2180             MOVS     R1,#+128
   \   0000012C   0x4301             ORRS     R1,R1,R0
   \   0000012E   0x71A1             STRB     R1,[R4, #+6]
   \   00000130   0x2002             MOVS     R0,#+2
   \   00000132   0xE000             B        ??f_forward_1
   5021          	}
   5022          
   5023          	LEAVE_FF(fp->fs, FR_OK);
   \                     ??f_forward_6: (+1)
   \   00000134   0x2000             MOVS     R0,#+0
   \                     ??f_forward_1: (+1)
   \   00000136   0xBDFE             POP      {R1-R7,PC}       ;; return
   5024          }
   5025          #endif /* _USE_FORWARD */
   5026          
   5027          
   5028          
   5029          #if _USE_MKFS && !_FS_READONLY
   5030            /*FUNCTION*-------------------------------------------------------------------
   5031          *
   5032          * Function Name    : f_mkfs
   5033          * Returned Value   : FR_OK : 			The function succeeded.
   5034          *                    FR_INVALID_DRIVE: 		The drive number is invalid.
   5035          *                    FR_NOT_READY: 		The drive cannot work due to any reason.
   5036          *                    FR_WRITE_PROTECTED: 	The drive is write protected.
   5037          *                    FR_NOT_ENABLED: 		The logical drive has no work area.
   5038          *                    FR_DISK_ERR: 		The function failed due to an error in the disk function.
   5039          *                    FR_MKFS_ABORTED: 	The function aborted before start 
   5040          *                    
   5041          * Comments         : Create File System on the Drive 
   5042          *   
   5043          *END*----------------------------------------------------------------------*/
   5044          #define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
   5045          #define N_FATS		1		/* Number of FAT copies (1 or 2) */
   5046          
   5047          
   5048          FRESULT f_mkfs 
   5049            (
   5050              /* [IN] Logical drive number */
   5051            	uint8_t vol,		
   5052            	/* [IN] Partitioning rule 0:FDISK, 1:SFD */
   5053            	uint8_t sfd,	
   5054            	/* [IN] Allocation unit size [bytes] */	
   5055            	uint32_t au			
   5056            )
   5057          {
   5058          	static const uint16_t vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   5059          	static const uint16_t cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   5060          	uint8_t fmt, md, sys, *tbl, pdrv, part;
   5061          	uint32_t n_clst, vs, n, wsect;
   5062          	uint32_t i;
   5063          	uint32_t b_vol, b_fat, b_dir, b_data;	/* LBA */
   5064          	uint32_t n_vol, n_rsv, n_fat, n_dir;	/* Size */
   5065          	FATFS *fs;
   5066          	DSTATUS stat;
   5067          
   5068          
   5069          	/* Check mounted drive and clear work area */
   5070          	if (vol >= _VOLUMES) return FR_INVALID_DRIVE;
   5071          	if (sfd > 1) return FR_INVALID_PARAMETER;
   5072          	if (au & (au - 1)) return FR_INVALID_PARAMETER;
   5073          	fs = FatFs[vol];
   5074          	if (!fs) return FR_NOT_ENABLED;
   5075          	fs->fs_type = 0;
   5076          	pdrv = LD2PD(vol);	/* Physical drive */
   5077          	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   5078          
   5079          	/* Get disk statics */
   5080          	stat = disk_initialize(pdrv);
   5081          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   5082                  disk_read(pdrv, fs->win, 0, 1);
   5083          #endif
   5084          	if (stat & STA_NOINIT) return FR_NOT_READY;
   5085          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   5086          #if _MAX_SS != 512					/* Get disk sector size */
   5087          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
   5088          		return FR_DISK_ERR;
   5089          #endif
   5090          	if (_MULTI_PARTITION && part) {
   5091          		/* Get partition information from partition table in the MBR */
   5092          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   5093          		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   5094          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   5095          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   5096          		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
   5097          		n_vol = LD_DWORD(tbl+12);	/* Volume size */
   5098          	} else {
   5099          		/* Create a partition in this function */
   5100          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
   5101          			return FR_DISK_ERR;
   5102          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   5103          		n_vol -= b_vol;				/* Volume size */
   5104          	}
   5105          
   5106          	if (!au) {				/* AU auto selection */
   5107          		vs = n_vol / (2000 / (SS(fs) / 512));
   5108          		for (i = 0; vs < vst[i]; i++) ;
   5109          		au = cst[i];
   5110          	}
   5111          	au /= SS(fs);		/* Number of sectors per cluster */
   5112          	if (au == 0) au = 1;
   5113          	if (au > 128) au = 128;
   5114          
   5115          	/* Pre-compute number of clusters and FAT sub-type */
   5116          	n_clst = n_vol / au;
   5117          	fmt = FS_FAT12;
   5118          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   5119          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   5120          
   5121          	/* Determine offset and size of FAT structure */
   5122          	if (fmt == FS_FAT32) {
   5123          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   5124          		n_rsv = 32;
   5125          		n_dir = 0;
   5126          	} else {
   5127          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   5128          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   5129          		n_rsv = 1;
   5130          		n_dir = (uint32_t)N_ROOTDIR * SZ_DIR / SS(fs);
   5131          	}
   5132          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   5133          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   5134          	b_data = b_dir + n_dir;				/* Data area start sector */
   5135          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   5136          
   5137          	/* Align data start sector to erase block boundary (for flash memory media) */
   5138          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   5139          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   5140          	n = (n - b_data) / N_FATS;
   5141          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   5142          		n_rsv += n;
   5143          		b_fat += n;
   5144          	} else {					/* FAT12/16: Expand FAT size */
   5145          		n_fat += n;
   5146          	}
   5147          
   5148          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   5149          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   5150          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   5151          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
   5152          		return FR_MKFS_ABORTED;
   5153          
   5154          	switch (fmt) {	/* Determine system ID for partition table */
   5155          	case FS_FAT12:	sys = 0x01; break;
   5156          	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
   5157          	default: 		sys = 0x0C;
   5158          	}
   5159          
   5160          	if (_MULTI_PARTITION && part) {
   5161          		/* Update system ID in the partition table */
   5162          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   5163          		tbl[4] = sys;
   5164          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   5165          		md = 0xF8;
   5166          	} else {
   5167          		if (sfd) {	/* No partition table (SFD) */
   5168          			md = 0xF0;
   5169          		} else {	/* Create partition table (FDISK) */
   5170          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   5171                            clear_buff(fs);
   5172          #endif
   5173          			mem_set(fs->win, 0, SS(fs));
   5174          			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
   5175          			tbl[1] = 1;						/* Partition start head */
   5176          			tbl[2] = 1;						/* Partition start sector */
   5177          			tbl[3] = 0;						/* Partition start cylinder */
   5178          			tbl[4] = sys;					/* System type */
   5179          			tbl[5] = 254;					/* Partition end head */
   5180          			n = (b_vol + n_vol) / 63 / 255;
   5181          			tbl[6] = (uint8_t)((n >> 2) | 63);	/* Partition end sector */
   5182          			tbl[7] = (uint8_t)n;				/* End cylinder */
   5183          			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
   5184          			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
   5185          			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
   5186          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
   5187          				return FR_DISK_ERR;
   5188          			md = 0xF8;
   5189          		}
   5190          	}
   5191          
   5192          	/* Create BPB in the VBR */
   5193          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   5194                            clear_buff(fs);
   5195          #endif
   5196          	tbl = fs->win;							/* Clear sector */
   5197          	mem_set(tbl, 0, SS(fs));
   5198          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   5199          	i = SS(fs);								/* Sector size */
   5200          	ST_WORD(tbl+BPB_BytsPerSec, i);
   5201          	tbl[BPB_SecPerClus] = (uint8_t)au;			/* Sectors per cluster */
   5202          	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
   5203          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   5204          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
   5205          	ST_WORD(tbl+BPB_RootEntCnt, i);
   5206          	if (n_vol < 0x10000) {					/* Number of total sectors */
   5207          		ST_WORD(tbl+BPB_TotSec16, n_vol);
   5208          	} else {
   5209          		ST_DWORD(tbl+BPB_TotSec32, n_vol);
   5210          	}
   5211          	tbl[BPB_Media] = md;					/* Media descriptor */
   5212          	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
   5213          	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
   5214          	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
   5215          	n = get_fattime();						/* Use current time as VSN */
   5216          	if (fmt == FS_FAT32) {
   5217          		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
   5218          		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   5219          		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
   5220          		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
   5221          		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
   5222          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   5223          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   5224          		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   5225          	} else {
   5226          		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
   5227          		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
   5228          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   5229          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   5230          		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   5231          	}
   5232          	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   5233          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
   5234          		return FR_DISK_ERR;
   5235          	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
   5236          		disk_write(pdrv, tbl, b_vol + 6, 1);
   5237          
   5238          	/* Initialize FAT area */
   5239          	wsect = b_fat;
   5240          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   5241          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   5242                            clear_buff(fs);
   5243          #endif          
   5244          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   5245          		n = md;								/* Media descriptor byte */
   5246          		if (fmt != FS_FAT32) {
   5247          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   5248          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
   5249          		} else {
   5250          			n |= 0xFFFFFF00;
   5251          			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
   5252          			ST_DWORD(tbl+4, 0xFFFFFFFF);
   5253          			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
   5254          		}
   5255          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   5256          			return FR_DISK_ERR;
   5257          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   5258                            clear_buff(fs);
   5259          #endif                
   5260          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   5261                          //uint32_t u_fatSecN = (n_fat * 4 + SS(fs) - 1) / SS(fs);
   5262          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   5263          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   5264          				return FR_DISK_ERR;
   5265          		}
   5266          	}
   5267          
   5268          	/* Initialize root directory */
   5269          	i = (fmt == FS_FAT32) ? au : n_dir;
   5270          	do {
   5271          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
   5272          			return FR_DISK_ERR;
   5273          	} while (--i);
   5274          
   5275          #if _USE_ERASE	/* Erase data area if needed */
   5276          	{
   5277          		uint32_t eb[2];
   5278          
   5279          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   5280          		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
   5281          	}
   5282          #endif
   5283          
   5284          	/* Create FSInfo if needed */
   5285          	if (fmt == FS_FAT32) {
   5286          		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
   5287          		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
   5288          		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   5289          		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
   5290          		ST_WORD(tbl+BS_55AA, 0xAA55);
   5291          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
   5292          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
   5293          	}
   5294          
   5295          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   5296          }
   5297          
   5298          
   5299          #if _MULTI_PARTITION
   5300          /*-----------------------------------------------------------------------*/
   5301          /* Divide Physical Drive                                                 */
   5302          /*-----------------------------------------------------------------------*/
   5303          FRESULT f_fdisk (
   5304          	uint8_t pdrv,			/* Physical drive number */
   5305          	const uint32_t szt[],	/* Pointer to the size table for each partitions */
   5306          	void* work			/* Pointer to the working buffer */
   5307          )
   5308          {
   5309          	uint32_t i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   5310          	uint8_t s_hd, e_hd, *p, *buf = (uint8_t*)work;
   5311          	DSTATUS stat;
   5312          	uint32_t sz_disk, sz_part, s_part;
   5313          
   5314          
   5315          	stat = disk_initialize(pdrv);
   5316          #if _FS_ENABLE_THROUGHPUT_OPTIMIZATION
   5317                  disk_read(pdrv, work, 0, 1);
   5318          #endif
   5319          	if (stat & STA_NOINIT) return FR_NOT_READY;
   5320          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   5321          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   5322          
   5323          	/* Determine CHS in the table regardless of the drive geometry */
   5324          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;//102463n2551024
   5325          	if (n == 256) n--;
   5326          	e_hd = n - 1;//0
   5327          	sz_cyl = 63 * n;//  63*1024 63102463*
   5328          	tot_cyl = sz_disk / sz_cyl;//
   5329          
   5330          	/* Create partition table */
   5331          	mem_set(buf, 0, _MAX_SS);
   5332          	p = buf + MBR_Table; b_cyl = 0;//
   5333          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   5334          		p_cyl = (szt[i] <= 100) ? (uint32_t)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;//
   5335          		if (!p_cyl) continue;
   5336          		s_part = (uint32_t)sz_cyl * b_cyl;//
   5337          		sz_part = (uint32_t)sz_cyl * p_cyl;//
   5338          		if (i == 0) {	/* Exclude first track of cylinder 0 *///0
   5339          			s_hd = 1;//
   5340          			s_part += 63; sz_part -= 63;//
   5341          		} else {//00.
   5342          			s_hd = 0;
   5343          		}
   5344          		e_cyl = b_cyl + p_cyl - 1;//
   5345          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   5346          
   5347          		/* Set partition table */
   5348          		p[1] = s_hd;						/* Start head *///
   5349          		p[2] = (uint8_t)((b_cyl >> 2) + 1);	/* Start sector *///
   5350          		p[3] = (uint8_t)b_cyl;					/* Start cylinder *///
   5351          		p[4] = 0x06;						/* System type (temporary setting) */
   5352          		p[5] = e_hd;						/* End head *///
   5353          		p[6] = (uint8_t)((e_cyl >> 2) + 63);	/* End sector *///
   5354          		p[7] = (uint8_t)e_cyl;					/* End cylinder *///
   5355          		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
   5356          		ST_DWORD(p + 12, sz_part);			/* Partition size */
   5357          
   5358          		/* Next partition */
   5359          		b_cyl += p_cyl;
   5360          	}
   5361          	ST_WORD(p, 0xAA55);
   5362          
   5363          	/* Write it to the MBR */
   5364          	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
   5365          }
   5366          
   5367          
   5368          #endif /* _MULTI_PARTITION */
   5369          #endif /* _USE_MKFS && !_FS_READONLY */
   5370          
   5371          
   5372          
   5373          
   5374          #if _USE_STRFUNC
   5375          /*FUNCTION*-------------------------------------------------------------------
   5376          *
   5377          * Function Name    : f_gets 
   5378          * Returned Value   : When the function succeeded, Str will be returned
   5379          *                    
   5380          * Comments         : Get a string from the file  
   5381          *   
   5382          *END*----------------------------------------------------------------------*/
   5383          

   \                                 In section .text, align 2, keep-with-next
   5384          TCHAR* f_gets 
   5385            (
   5386              /* Pointer to the string buffer to read */
   5387            	TCHAR* buff,
   5388            	/* Size of string buffer (characters) */	
   5389            	int len,		
   5390            	/* Pointer to the file object */
   5391            	FIL* fp		
   5392            )
   5393          {
   \                     f_gets: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x0017             MOVS     R7,R2
   5394          	int n = 0;
   \   00000008   0x2400             MOVS     R4,#+0
   5395          	TCHAR c, *p = buff;
   \   0000000A   0x0035             MOVS     R5,R6
   5396          	uint8_t s[2];
   5397          	uint32_t rc;
   5398          
   5399          
   5400          	while (n < len - 1) {			/* Read bytes until buffer gets filled */
   \                     ??f_gets_0: (+1)
   \   0000000C   0x9802             LDR      R0,[SP, #+8]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xDA10             BGE      ??f_gets_1
   5401          		f_read(fp, s, 1, &rc);
   \   00000014   0x466B             MOV      R3,SP
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0xA901             ADD      R1,SP,#+4
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0x.... 0x....      BL       f_read
   5402          		if (rc != 1) break;			/* Break on EOF or error */
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD107             BNE      ??f_gets_1
   5403          		c = s[0];
   \                     ??f_gets_2: (+1)
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x7900             LDRB     R0,[R0, #+4]
   5404          #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
   5405          		if (c >= 0x80) {
   5406          			if (c < 0xC0) continue;	/* Skip stray trailer */
   5407          			if (c < 0xE0) {			/* Two-byte sequence */
   5408          				f_read(fp, s, 1, &rc);
   5409          				if (rc != 1) break;
   5410          				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
   5411          				if (c < 0x80) c = '?';
   5412          			} else {
   5413          				if (c < 0xF0) {		/* Three-byte sequence */
   5414          					f_read(fp, s, 2, &rc);
   5415          					if (rc != 2) break;
   5416          					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
   5417          					if (c < 0x800) c = '?';
   5418          				} else {			/* Reject four-byte sequence */
   5419          					c = '?';
   5420          				}
   5421          			}
   5422          		}
   5423          #endif
   5424          #if _USE_STRFUNC >= 2
   5425          		if (c == '\r') continue;	/* Strip '\r' */
   5426          #endif
   5427          		*p++ = c;
   \   0000002A   0x7028             STRB     R0,[R5, #+0]
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   5428          		n++;
   \   0000002E   0x1C64             ADDS     R4,R4,#+1
   5429          		if (c == '\n') break;		/* Break on EOL */
   \   00000030   0xB2C0             UXTB     R0,R0
   \   00000032   0x280A             CMP      R0,#+10
   \   00000034   0xD1EA             BNE      ??f_gets_0
   5430          	}
   5431          	*p = 0;
   \                     ??f_gets_1: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7028             STRB     R0,[R5, #+0]
   5432          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD001             BEQ      ??f_gets_3
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0xE000             B        ??f_gets_4
   \                     ??f_gets_3: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??f_gets_4: (+1)
   \   00000044   0xBDFE             POP      {R1-R7,PC}       ;; return
   5433          }
   5434          
   5435          
   5436          
   5437          #if !_FS_READONLY
   5438          #include <stdarg.h>
   5439          /*FUNCTION*-------------------------------------------------------------------
   5440          *
   5441          * Function Name    :f_putc 
   5442          * Returned Value   :When the character was written successfully, the function returns the character 
   5443          *                    
   5444          * Comments         :Put a character to the file  
   5445          *   
   5446          *END*----------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   5447          int f_putc 
   5448            (
   5449              /* [IN] A character to be output */
   5450            	TCHAR c,	
   5451            	/* [IN] Pointer to the file object */
   5452            	FIL* fp	
   5453            )
   5454          {
   \                     f_putc: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x0002             MOVS     R2,R0
   \   00000004   0x0008             MOVS     R0,R1
   5455          	uint32_t bw, btw;
   5456          	uint8_t s[3];
   5457          
   5458          
   5459          #if _USE_STRFUNC >= 2
   5460          	if (c == '\n') f_putc ('\r', fp);	/* LF -> CRLF conversion */
   5461          #endif
   5462          
   5463          #if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
   5464          	if (c < 0x80) {			/* 7-bit */
   5465          		s[0] = (uint8_t)c;
   5466          		btw = 1;
   5467          	} else {
   5468          		if (c < 0x800) {	/* 11-bit */
   5469          			s[0] = (uint8_t)(0xC0 | (c >> 6));
   5470          			s[1] = (uint8_t)(0x80 | (c & 0x3F));
   5471          			btw = 2;
   5472          		} else {			/* 16-bit */
   5473          			s[0] = (uint8_t)(0xE0 | (c >> 12));
   5474          			s[1] = (uint8_t)(0x80 | ((c >> 6) & 0x3F));
   5475          			s[2] = (uint8_t)(0x80 | (c & 0x3F));
   5476          			btw = 3;
   5477          		}
   5478          	}
   5479          #else				/* Write the character without conversion */
   5480          	s[0] = (uint8_t)c;
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x700A             STRB     R2,[R1, #+0]
   5481          	btw = 1;
   \   0000000A   0x2401             MOVS     R4,#+1
   5482          #endif
   5483          	f_write(fp, s, btw, &bw);		/* Write the char to the file */
   \   0000000C   0xAB01             ADD      R3,SP,#+4
   \   0000000E   0x0022             MOVS     R2,R4
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x.... 0x....      BL       f_write
   5484          	return (bw == btw) ? 1 : EOF;	/* Return the result */
   \   00000016   0x9801             LDR      R0,[SP, #+4]
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xD101             BNE      ??f_putc_0
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE001             B        ??f_putc_1
   \                     ??f_putc_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x43C0             MVNS     R0,R0            ;; #-1
   \                     ??f_putc_1: (+1)
   \   00000024   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   5485          }
   5486          
   5487          /*FUNCTION*-------------------------------------------------------------------
   5488          *
   5489          * Function Name    : f_puts
   5490          * Returned Value   : if suceesful, return number of characters written 
   5491          *                    -1: failed
   5492          *                    
   5493          * Comments         : Put a string to the file
   5494          *   
   5495          *END*----------------------------------------------------------------------*/
   5496          

   \                                 In section .text, align 2, keep-with-next
   5497          int f_puts 
   5498            (
   5499              /* [IN] Pointer to the string to be output */
   5500            	const TCHAR* str,
   5501            	/* [IN] Pointer to the file object */	
   5502            	FIL* fp			
   5503            )
   5504          {
   \                     f_puts: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   5505          	int n;
   5506          
   5507          
   5508          	for (n = 0; *str; str++, n++) {
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0xE001             B        ??f_puts_0
   \                     ??f_puts_1: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \   0000000C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_puts_0: (+1)
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD00A             BEQ      ??f_puts_2
   5509          		if (f_putc(*str, fp) == EOF) return EOF;
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       f_putc
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000020   0x4288             CMP      R0,R1
   \   00000022   0xD1F2             BNE      ??f_puts_1
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000028   0xE000             B        ??f_puts_3
   5510          	}
   5511          	return n;
   \                     ??f_puts_2: (+1)
   \   0000002A   0x0028             MOVS     R0,R5
   \                     ??f_puts_3: (+1)
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
   5512          }
   5513          
   5514          
   5515          /*FUNCTION*-------------------------------------------------------------------
   5516          *
   5517          * Function Name    : f_printf
   5518          * Returned Value   : if suceesful, return number of characters written 
   5519          *                    -1: failed
   5520          *
   5521          * Comments         : Put a formatted string to the file 
   5522          *   
   5523          *END*----------------------------------------------------------------------*/
   5524          

   \                                 In section .text, align 2, keep-with-next
   5525          int f_printf 
   5526            (
   5527              /* [IN] Pointer to the file object */
   5528            	FIL* fp,			
   5529            	/* [IN] Pointer to the format string */
   5530            	const TCHAR* str,	
   5531            	/* [IN] Optional arguments... */
   5532            	...					
   5533            )
   5534          {
   \                     f_printf: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB5F0             PUSH     {R4-R7,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   5535          	va_list arp;
   5536          	uint8_t f, r;
   5537          	uint32_t i, j, w;
   5538          	uint32_t v;
   5539          	TCHAR c, d, s[16], *p;
   5540          	int res, chc, cc;
   5541          
   5542          
   5543          	va_start(arp, str);
   \   00000006   0xAE10             ADD      R6,SP,#+64
   5544          
   5545          	for (cc = res = 0; cc != EOF; res += cc) {
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0x9803             LDR      R0,[SP, #+12]
   \   0000000E   0xE007             B        ??f_printf_0
   5546          		c = *str++;
   5547          		if (c == 0) break;			/* End of string */
   5548          		if (c != '%') {				/* Non escape character */
   5549          			cc = f_putc(c, fp);
   5550          			if (cc != EOF) cc = 1;
   5551          			continue;
   5552          		}
   5553          		w = f = 0;
   5554          		c = *str++;
   5555          		if (c == '0') {				/* Flag: '0' padding */
   5556          			f = 1; c = *str++;
   5557          		} else {
   5558          			if (c == '-') {			/* Flag: left justified */
   5559          				f = 2; c = *str++;
   5560          			}
   5561          		}
   5562          		while (IsDigit(c)) {		/* Precision */
   5563          			w = w * 10 + c - '0';
   5564          			c = *str++;
   5565          		}
   5566          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   5567          			f |= 4; c = *str++;
   5568          		}
   5569          		if (!c) break;
   5570          		d = c;
   5571          		if (IsLower(d)) d -= 0x20;
   5572          		switch (d) {				/* Type is... */
   5573          		case 'S' :					/* String */
   5574          			p = va_arg(arp, TCHAR*);
   5575          			for (j = 0; p[j]; j++) ;
   5576          			chc = 0;
   5577          			if (!(f & 2)) {
   5578          				while (j++ < w) chc += (cc = f_putc(' ', fp));
   5579          			}
   5580          			chc += (cc = f_puts(p, fp));
   5581          			while (j++ < w) chc += (cc = f_putc(' ', fp));
   5582          			if (cc != EOF) cc = chc;
   5583          			continue;
   5584          		case 'C' :					/* Character */
   5585          			cc = f_putc((TCHAR)va_arg(arp, int), fp); continue;
   5586          		case 'B' :					/* Binary */
   5587          			r = 2; break;
   5588          		case 'O' :					/* Octal */
   5589          			r = 8; break;
   5590          		case 'D' :					/* Signed decimal */
   5591          		case 'U' :					/* Unsigned decimal */
   5592          			r = 10; break;
   5593          		case 'X' :					/* Hexdecimal */
   5594          			r = 16; break;
   5595          		default:					/* Unknown type (pass-through) */
   5596          			cc = f_putc(c, fp); continue;
   5597          		}
   5598          
   5599          		/* Get an argument and put it in numeral */
   5600          		v = (f & 4) ? (uint32_t)va_arg(arp, long) : ((d == 'D') ? (uint32_t)(long)va_arg(arp, int) : (uint32_t)va_arg(arp, unsigned int));
   5601          		if (d == 'D' && (v & 0x80000000)) {
   5602          			v = 0 - v;
   5603          			f |= 8;
   5604          		}
   5605          		i = 0;
   5606          		do {
   5607          			d = (TCHAR)(v % r); v /= r;
   5608          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   5609          			s[i++] = d + '0';
   5610          		} while (v && i < sizeof s / sizeof s[0]);
   5611          		if (f & 8) s[i++] = '-';
   5612          		j = i; d = (f & 1) ? '0' : ' ';
   5613          		chc = 0;
   5614          		while (!(f & 2) && j++ < w) chc += (cc = f_putc(d, fp));
   5615          		do chc += (cc = f_putc(s[--i], fp)); while(i);
   5616          		while (j++ < w) chc += (cc = f_putc(' ', fp));
   5617          		if (cc != EOF) cc = chc;
   \                     ??f_printf_1: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD000             BEQ      ??f_printf_2
   \   00000018   0x0020             MOVS     R0,R4
   \                     ??f_printf_2: (+1)
   \   0000001A   0x9903             LDR      R1,[SP, #+12]
   \   0000001C   0x1809             ADDS     R1,R1,R0
   \   0000001E   0x9103             STR      R1,[SP, #+12]
   \                     ??f_printf_0: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD007             BEQ      ??f_printf_3
   \   00000028   0x990F             LDR      R1,[SP, #+60]
   \   0000002A   0x780C             LDRB     R4,[R1, #+0]
   \   0000002C   0x990F             LDR      R1,[SP, #+60]
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \   00000030   0x910F             STR      R1,[SP, #+60]
   \   00000032   0xB2E4             UXTB     R4,R4
   \   00000034   0x2C00             CMP      R4,#+0
   \   00000036   0xD105             BNE      ??f_printf_4
   5618          	}
   5619          
   5620          	va_end(arp);
   5621          	return (cc == EOF) ? cc : res;
   \                     ??f_printf_3: (+1)
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xD000             BEQ      .+4
   \   00000040   0xE139             B        ??f_printf_5
   \   00000042   0xE139             B        ??f_printf_6
   \                     ??f_printf_4: (+1)
   \   00000044   0xB2E4             UXTB     R4,R4
   \   00000046   0x2C25             CMP      R4,#+37
   \   00000048   0xD00A             BEQ      ??f_printf_7
   \   0000004A   0x990E             LDR      R1,[SP, #+56]
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0xB2C0             UXTB     R0,R0
   \   00000050   0x.... 0x....      BL       f_putc
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD000             BEQ      ??f_printf_8
   \   0000005C   0x2001             MOVS     R0,#+1
   \                     ??f_printf_8: (+1)
   \   0000005E   0xE7DC             B        ??f_printf_2
   \                     ??f_printf_7: (+1)
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x466A             MOV      R2,SP
   \   00000064   0x7011             STRB     R1,[R2, #+0]
   \   00000066   0x4669             MOV      R1,SP
   \   00000068   0x7809             LDRB     R1,[R1, #+0]
   \   0000006A   0x9102             STR      R1,[SP, #+8]
   \   0000006C   0x990F             LDR      R1,[SP, #+60]
   \   0000006E   0x780C             LDRB     R4,[R1, #+0]
   \   00000070   0x990F             LDR      R1,[SP, #+60]
   \   00000072   0x1C49             ADDS     R1,R1,#+1
   \   00000074   0x910F             STR      R1,[SP, #+60]
   \   00000076   0xB2E4             UXTB     R4,R4
   \   00000078   0x2C30             CMP      R4,#+48
   \   0000007A   0xD108             BNE      ??f_printf_9
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x466A             MOV      R2,SP
   \   00000080   0x7011             STRB     R1,[R2, #+0]
   \   00000082   0x990F             LDR      R1,[SP, #+60]
   \   00000084   0x780C             LDRB     R4,[R1, #+0]
   \   00000086   0x990F             LDR      R1,[SP, #+60]
   \   00000088   0x1C49             ADDS     R1,R1,#+1
   \   0000008A   0x910F             STR      R1,[SP, #+60]
   \   0000008C   0xE017             B        ??f_printf_10
   \                     ??f_printf_9: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4
   \   00000090   0x2C2D             CMP      R4,#+45
   \   00000092   0xD114             BNE      ??f_printf_10
   \   00000094   0x2102             MOVS     R1,#+2
   \   00000096   0x466A             MOV      R2,SP
   \   00000098   0x7011             STRB     R1,[R2, #+0]
   \   0000009A   0x990F             LDR      R1,[SP, #+60]
   \   0000009C   0x780C             LDRB     R4,[R1, #+0]
   \   0000009E   0x990F             LDR      R1,[SP, #+60]
   \   000000A0   0x1C49             ADDS     R1,R1,#+1
   \   000000A2   0x910F             STR      R1,[SP, #+60]
   \   000000A4   0xE00B             B        ??f_printf_10
   \                     ??f_printf_11: (+1)
   \   000000A6   0x9902             LDR      R1,[SP, #+8]
   \   000000A8   0x220A             MOVS     R2,#+10
   \   000000AA   0x4351             MULS     R1,R2,R1
   \   000000AC   0xB2E4             UXTB     R4,R4
   \   000000AE   0x1909             ADDS     R1,R1,R4
   \   000000B0   0x3930             SUBS     R1,R1,#+48
   \   000000B2   0x9102             STR      R1,[SP, #+8]
   \   000000B4   0x990F             LDR      R1,[SP, #+60]
   \   000000B6   0x780C             LDRB     R4,[R1, #+0]
   \   000000B8   0x990F             LDR      R1,[SP, #+60]
   \   000000BA   0x1C49             ADDS     R1,R1,#+1
   \   000000BC   0x910F             STR      R1,[SP, #+60]
   \                     ??f_printf_10: (+1)
   \   000000BE   0xB2E4             UXTB     R4,R4
   \   000000C0   0x0021             MOVS     R1,R4
   \   000000C2   0x3930             SUBS     R1,R1,#+48
   \   000000C4   0x290A             CMP      R1,#+10
   \   000000C6   0xD3EE             BCC      ??f_printf_11
   \   000000C8   0xB2E4             UXTB     R4,R4
   \   000000CA   0x2C6C             CMP      R4,#+108
   \   000000CC   0xD002             BEQ      ??f_printf_12
   \   000000CE   0xB2E4             UXTB     R4,R4
   \   000000D0   0x2C4C             CMP      R4,#+76
   \   000000D2   0xD10A             BNE      ??f_printf_13
   \                     ??f_printf_12: (+1)
   \   000000D4   0x4669             MOV      R1,SP
   \   000000D6   0x466A             MOV      R2,SP
   \   000000D8   0x7812             LDRB     R2,[R2, #+0]
   \   000000DA   0x2304             MOVS     R3,#+4
   \   000000DC   0x4313             ORRS     R3,R3,R2
   \   000000DE   0x700B             STRB     R3,[R1, #+0]
   \   000000E0   0x990F             LDR      R1,[SP, #+60]
   \   000000E2   0x780C             LDRB     R4,[R1, #+0]
   \   000000E4   0x990F             LDR      R1,[SP, #+60]
   \   000000E6   0x1C49             ADDS     R1,R1,#+1
   \   000000E8   0x910F             STR      R1,[SP, #+60]
   \                     ??f_printf_13: (+1)
   \   000000EA   0xB2E4             UXTB     R4,R4
   \   000000EC   0x2C00             CMP      R4,#+0
   \   000000EE   0xD0A3             BEQ      ??f_printf_3
   \                     ??f_printf_14: (+1)
   \   000000F0   0x0027             MOVS     R7,R4
   \   000000F2   0xB2FF             UXTB     R7,R7
   \   000000F4   0x0038             MOVS     R0,R7
   \   000000F6   0x3861             SUBS     R0,R0,#+97
   \   000000F8   0x281A             CMP      R0,#+26
   \   000000FA   0xD200             BCS      ??f_printf_15
   \   000000FC   0x3F20             SUBS     R7,R7,#+32
   \                     ??f_printf_15: (+1)
   \   000000FE   0xB2FF             UXTB     R7,R7
   \   00000100   0x0038             MOVS     R0,R7
   \   00000102   0x2842             CMP      R0,#+66
   \   00000104   0xD043             BEQ      ??f_printf_16
   \   00000106   0x2843             CMP      R0,#+67
   \   00000108   0xD03A             BEQ      ??f_printf_17
   \   0000010A   0x2844             CMP      R0,#+68
   \   0000010C   0xD04D             BEQ      ??f_printf_18
   \   0000010E   0x284F             CMP      R0,#+79
   \   00000110   0xD047             BEQ      ??f_printf_19
   \   00000112   0x2853             CMP      R0,#+83
   \   00000114   0xD004             BEQ      ??f_printf_20
   \   00000116   0x2855             CMP      R0,#+85
   \   00000118   0xD047             BEQ      ??f_printf_18
   \   0000011A   0x2858             CMP      R0,#+88
   \   0000011C   0xD049             BEQ      ??f_printf_21
   \   0000011E   0xE04C             B        ??f_printf_22
   \                     ??f_printf_20: (+1)
   \   00000120   0x6837             LDR      R7,[R6, #+0]
   \   00000122   0x1D36             ADDS     R6,R6,#+4
   \   00000124   0x2500             MOVS     R5,#+0
   \   00000126   0xE000             B        ??f_printf_23
   \                     ??f_printf_24: (+1)
   \   00000128   0x1C6D             ADDS     R5,R5,#+1
   \                     ??f_printf_23: (+1)
   \   0000012A   0x5D78             LDRB     R0,[R7, R5]
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD1FB             BNE      ??f_printf_24
   \   00000130   0x2400             MOVS     R4,#+0
   \   00000132   0x4668             MOV      R0,SP
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x0780             LSLS     R0,R0,#+30
   \   00000138   0xD40B             BMI      ??f_printf_25
   \   0000013A   0xE004             B        ??f_printf_26
   \                     ??f_printf_27: (+1)
   \   0000013C   0x990E             LDR      R1,[SP, #+56]
   \   0000013E   0x2020             MOVS     R0,#+32
   \   00000140   0x.... 0x....      BL       f_putc
   \   00000144   0x1824             ADDS     R4,R4,R0
   \                     ??f_printf_26: (+1)
   \   00000146   0x0028             MOVS     R0,R5
   \   00000148   0x0005             MOVS     R5,R0
   \   0000014A   0x1C6D             ADDS     R5,R5,#+1
   \   0000014C   0x9902             LDR      R1,[SP, #+8]
   \   0000014E   0x4288             CMP      R0,R1
   \   00000150   0xD3F4             BCC      ??f_printf_27
   \                     ??f_printf_25: (+1)
   \   00000152   0x990E             LDR      R1,[SP, #+56]
   \   00000154   0x0038             MOVS     R0,R7
   \   00000156   0x.... 0x....      BL       f_puts
   \   0000015A   0x1824             ADDS     R4,R4,R0
   \   0000015C   0xE004             B        ??f_printf_28
   \                     ??f_printf_29: (+1)
   \   0000015E   0x990E             LDR      R1,[SP, #+56]
   \   00000160   0x2020             MOVS     R0,#+32
   \   00000162   0x.... 0x....      BL       f_putc
   \   00000166   0x1824             ADDS     R4,R4,R0
   \                     ??f_printf_28: (+1)
   \   00000168   0x0029             MOVS     R1,R5
   \   0000016A   0x000D             MOVS     R5,R1
   \   0000016C   0x1C6D             ADDS     R5,R5,#+1
   \   0000016E   0x9A02             LDR      R2,[SP, #+8]
   \   00000170   0x4291             CMP      R1,R2
   \   00000172   0xD3F4             BCC      ??f_printf_29
   \   00000174   0x2100             MOVS     R1,#+0
   \   00000176   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000178   0x4288             CMP      R0,R1
   \   0000017A   0xD000             BEQ      ??f_printf_30
   \   0000017C   0x0020             MOVS     R0,R4
   \                     ??f_printf_30: (+1)
   \   0000017E   0xE74C             B        ??f_printf_2
   \                     ??f_printf_17: (+1)
   \   00000180   0x6830             LDR      R0,[R6, #+0]
   \   00000182   0x1D36             ADDS     R6,R6,#+4
   \   00000184   0x990E             LDR      R1,[SP, #+56]
   \   00000186   0xB2C0             UXTB     R0,R0
   \   00000188   0x.... 0x....      BL       f_putc
   \   0000018C   0xE745             B        ??f_printf_2
   \                     ??f_printf_16: (+1)
   \   0000018E   0x2002             MOVS     R0,#+2
   \   00000190   0x4669             MOV      R1,SP
   \   00000192   0x7048             STRB     R0,[R1, #+1]
   \                     ??f_printf_31: (+1)
   \   00000194   0x4668             MOV      R0,SP
   \   00000196   0x7800             LDRB     R0,[R0, #+0]
   \   00000198   0x0740             LSLS     R0,R0,#+29
   \   0000019A   0xD514             BPL      ??f_printf_32
   \   0000019C   0x6835             LDR      R5,[R6, #+0]
   \   0000019E   0x1D36             ADDS     R6,R6,#+4
   \   000001A0   0xE019             B        ??f_printf_33
   \                     ??f_printf_19: (+1)
   \   000001A2   0x2008             MOVS     R0,#+8
   \   000001A4   0x4669             MOV      R1,SP
   \   000001A6   0x7048             STRB     R0,[R1, #+1]
   \   000001A8   0xE7F4             B        ??f_printf_31
   \                     ??f_printf_18: (+1)
   \   000001AA   0x200A             MOVS     R0,#+10
   \   000001AC   0x4669             MOV      R1,SP
   \   000001AE   0x7048             STRB     R0,[R1, #+1]
   \   000001B0   0xE7F0             B        ??f_printf_31
   \                     ??f_printf_21: (+1)
   \   000001B2   0x2010             MOVS     R0,#+16
   \   000001B4   0x4669             MOV      R1,SP
   \   000001B6   0x7048             STRB     R0,[R1, #+1]
   \   000001B8   0xE7EC             B        ??f_printf_31
   \                     ??f_printf_22: (+1)
   \   000001BA   0x990E             LDR      R1,[SP, #+56]
   \   000001BC   0x0020             MOVS     R0,R4
   \   000001BE   0xB2C0             UXTB     R0,R0
   \   000001C0   0x.... 0x....      BL       f_putc
   \   000001C4   0xE729             B        ??f_printf_2
   \                     ??f_printf_32: (+1)
   \   000001C6   0xB2FF             UXTB     R7,R7
   \   000001C8   0x2F44             CMP      R7,#+68
   \   000001CA   0xD102             BNE      ??f_printf_34
   \   000001CC   0x6835             LDR      R5,[R6, #+0]
   \   000001CE   0x1D36             ADDS     R6,R6,#+4
   \   000001D0   0xE001             B        ??f_printf_33
   \                     ??f_printf_34: (+1)
   \   000001D2   0x6835             LDR      R5,[R6, #+0]
   \   000001D4   0x1D36             ADDS     R6,R6,#+4
   \                     ??f_printf_33: (+1)
   \   000001D6   0xB2FF             UXTB     R7,R7
   \   000001D8   0x2F44             CMP      R7,#+68
   \   000001DA   0xD109             BNE      ??f_printf_35
   \   000001DC   0x2D00             CMP      R5,#+0
   \   000001DE   0xD507             BPL      ??f_printf_35
   \   000001E0   0x4268             RSBS     R0,R5,#+0
   \   000001E2   0x0005             MOVS     R5,R0
   \   000001E4   0x4668             MOV      R0,SP
   \   000001E6   0x4669             MOV      R1,SP
   \   000001E8   0x7809             LDRB     R1,[R1, #+0]
   \   000001EA   0x2208             MOVS     R2,#+8
   \   000001EC   0x430A             ORRS     R2,R2,R1
   \   000001EE   0x7002             STRB     R2,[R0, #+0]
   \                     ??f_printf_35: (+1)
   \   000001F0   0x2000             MOVS     R0,#+0
   \   000001F2   0x9001             STR      R0,[SP, #+4]
   \                     ??f_printf_36: (+1)
   \   000001F4   0x0028             MOVS     R0,R5
   \   000001F6   0x4669             MOV      R1,SP
   \   000001F8   0x7849             LDRB     R1,[R1, #+1]
   \   000001FA   0x.... 0x....      BL       __aeabi_uidivmod
   \   000001FE   0x000F             MOVS     R7,R1
   \   00000200   0x0028             MOVS     R0,R5
   \   00000202   0x4669             MOV      R1,SP
   \   00000204   0x7849             LDRB     R1,[R1, #+1]
   \   00000206   0x.... 0x....      BL       __aeabi_uidiv
   \   0000020A   0x0005             MOVS     R5,R0
   \   0000020C   0xB2FF             UXTB     R7,R7
   \   0000020E   0x2F0A             CMP      R7,#+10
   \   00000210   0xDB06             BLT      ??f_printf_37
   \   00000212   0xB2E4             UXTB     R4,R4
   \   00000214   0x2C78             CMP      R4,#+120
   \   00000216   0xD101             BNE      ??f_printf_38
   \   00000218   0x2027             MOVS     R0,#+39
   \   0000021A   0xE000             B        ??f_printf_39
   \                     ??f_printf_38: (+1)
   \   0000021C   0x2007             MOVS     R0,#+7
   \                     ??f_printf_39: (+1)
   \   0000021E   0x183F             ADDS     R7,R7,R0
   \                     ??f_printf_37: (+1)
   \   00000220   0x3730             ADDS     R7,R7,#+48
   \   00000222   0xA804             ADD      R0,SP,#+16
   \   00000224   0x9901             LDR      R1,[SP, #+4]
   \   00000226   0x5447             STRB     R7,[R0, R1]
   \   00000228   0x9801             LDR      R0,[SP, #+4]
   \   0000022A   0x1C40             ADDS     R0,R0,#+1
   \   0000022C   0x9001             STR      R0,[SP, #+4]
   \   0000022E   0x2D00             CMP      R5,#+0
   \   00000230   0xD002             BEQ      ??f_printf_40
   \   00000232   0x9801             LDR      R0,[SP, #+4]
   \   00000234   0x2810             CMP      R0,#+16
   \   00000236   0xD3DD             BCC      ??f_printf_36
   \                     ??f_printf_40: (+1)
   \   00000238   0x4668             MOV      R0,SP
   \   0000023A   0x7800             LDRB     R0,[R0, #+0]
   \   0000023C   0x0700             LSLS     R0,R0,#+28
   \   0000023E   0xD506             BPL      ??f_printf_41
   \   00000240   0x202D             MOVS     R0,#+45
   \   00000242   0xA904             ADD      R1,SP,#+16
   \   00000244   0x9A01             LDR      R2,[SP, #+4]
   \   00000246   0x5488             STRB     R0,[R1, R2]
   \   00000248   0x9801             LDR      R0,[SP, #+4]
   \   0000024A   0x1C40             ADDS     R0,R0,#+1
   \   0000024C   0x9001             STR      R0,[SP, #+4]
   \                     ??f_printf_41: (+1)
   \   0000024E   0x9D01             LDR      R5,[SP, #+4]
   \   00000250   0x4668             MOV      R0,SP
   \   00000252   0x7800             LDRB     R0,[R0, #+0]
   \   00000254   0x07C0             LSLS     R0,R0,#+31
   \   00000256   0xD501             BPL      ??f_printf_42
   \   00000258   0x2730             MOVS     R7,#+48
   \   0000025A   0xE000             B        ??f_printf_43
   \                     ??f_printf_42: (+1)
   \   0000025C   0x2720             MOVS     R7,#+32
   \                     ??f_printf_43: (+1)
   \   0000025E   0x2400             MOVS     R4,#+0
   \   00000260   0xE005             B        ??f_printf_44
   \                     ??f_printf_45: (+1)
   \   00000262   0x990E             LDR      R1,[SP, #+56]
   \   00000264   0x0038             MOVS     R0,R7
   \   00000266   0xB2C0             UXTB     R0,R0
   \   00000268   0x.... 0x....      BL       f_putc
   \   0000026C   0x1824             ADDS     R4,R4,R0
   \                     ??f_printf_44: (+1)
   \   0000026E   0x4668             MOV      R0,SP
   \   00000270   0x7800             LDRB     R0,[R0, #+0]
   \   00000272   0x0780             LSLS     R0,R0,#+30
   \   00000274   0xD405             BMI      ??f_printf_46
   \   00000276   0x0028             MOVS     R0,R5
   \   00000278   0x0005             MOVS     R5,R0
   \   0000027A   0x1C6D             ADDS     R5,R5,#+1
   \   0000027C   0x9902             LDR      R1,[SP, #+8]
   \   0000027E   0x4288             CMP      R0,R1
   \   00000280   0xD3EF             BCC      ??f_printf_45
   \                     ??f_printf_46: (+1)
   \   00000282   0x9801             LDR      R0,[SP, #+4]
   \   00000284   0x1E40             SUBS     R0,R0,#+1
   \   00000286   0x9001             STR      R0,[SP, #+4]
   \   00000288   0x990E             LDR      R1,[SP, #+56]
   \   0000028A   0xA804             ADD      R0,SP,#+16
   \   0000028C   0x9A01             LDR      R2,[SP, #+4]
   \   0000028E   0x5C80             LDRB     R0,[R0, R2]
   \   00000290   0x.... 0x....      BL       f_putc
   \   00000294   0x1824             ADDS     R4,R4,R0
   \   00000296   0x9901             LDR      R1,[SP, #+4]
   \   00000298   0x2900             CMP      R1,#+0
   \   0000029A   0xD1F2             BNE      ??f_printf_46
   \                     ??f_printf_47: (+1)
   \   0000029C   0x0029             MOVS     R1,R5
   \   0000029E   0x000D             MOVS     R5,R1
   \   000002A0   0x1C6D             ADDS     R5,R5,#+1
   \   000002A2   0x9A02             LDR      R2,[SP, #+8]
   \   000002A4   0x4291             CMP      R1,R2
   \   000002A6   0xD300             BCC      .+4
   \   000002A8   0xE6B2             B        ??f_printf_1
   \   000002AA   0x990E             LDR      R1,[SP, #+56]
   \   000002AC   0x2020             MOVS     R0,#+32
   \   000002AE   0x.... 0x....      BL       f_putc
   \   000002B2   0x1824             ADDS     R4,R4,R0
   \   000002B4   0xE7F2             B        ??f_printf_47
   \                     ??f_printf_5: (+1)
   \   000002B6   0x9803             LDR      R0,[SP, #+12]
   \                     ??f_printf_6: (+1)
   \   000002B8   0xB009             ADD      SP,SP,#+36
   \   000002BA   0x9904             LDR      R1,[SP, #+16]
   \   000002BC   0xBCF0             POP      {R4-R7}
   \   000002BE   0xB005             ADD      SP,SP,#+20
   \   000002C0   0x4708             BX       R1               ;; return
   5622          }
   5623          
   5624          #endif /* !_FS_READONLY */
   5625          #endif /* _USE_STRFUNC */
   5626          
   5627          #if _USE_LFN == 3
   5628          /*FUNCTION*----------------------------------------------------------------
   5629          *
   5630          * Function Name  : ff_memalloc
   5631          * Returned Value : pointer to allocated area of memory
   5632          * Comments       : allocates a memory block
   5633          *
   5634          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   5635          void* ff_memalloc (uint32_t size){
   \                     ff_memalloc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   5636          	return (void *)malloc(size);
   \   00000002   0x.... 0x....      BL       malloc
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
   5637          }
   5638          
   5639          /*FUNCTION*----------------------------------------------------------------
   5640          *
   5641          * Function Name  : ff_memfree
   5642          * Returned Value : nothing
   5643          * Comments       : frees a memory block
   5644          *
   5645          *END*--------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   5646          void ff_memfree (void *ptr){
   \                     ff_memfree: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   5647          	free(ptr);
   \   00000002   0x.... 0x....      BL       free
   5648          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x0FFFFFFF         DC32     0xfffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     entry_start_clust

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     entry_start_free_index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     LfnOfs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     entry_start_clust

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     entry_start_free_index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ExCvt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x0000AA55         DC32     0xaa55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x00544146         DC32     0x544146

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x00000FF6         DC32     0xff6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x0000FFF6         DC32     0xfff6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x0000AA55         DC32     0xaa55

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x41615252         DC32     0x41615252

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x61417272         DC32     0x61417272

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     Fsid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     FatFs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     entry_start_clust

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     entry_start_free_index

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x0FFFFFFF         DC32     0xfffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x000001FF         DC32     0x1ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     CurrVol

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x0FFFFFFF         DC32     0xfffffff

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x22 0x2A          DC8 "\"*:<>?|\177"
   \              0x3A 0x3C    
   \              0x3E 0x3F    
   \              0x7C 0x7F    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x2B 0x2C          DC8 "+,;=[]"
   \              0x3B 0x3D    
   \              0x5B 0x5D    
   \              0x00         
   \   00000007   0x00               DC8 0
   5649          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   buff_validation
       8   check_fs
         8   -> disk_read
       4   chk_chr
      32   chk_mounted
        32   -> check_fs
        32   -> clear_buff
        32   -> disk_initialize
        32   -> disk_read
        32   -> disk_status
        32 __aeabi_uidiv
        32 __aeabi_uidivmod
       8   clear_buff
         8   -> mem_set
       0   clear_dirty2
       4   clust2sect
      24   cmp_lfn
        24   -> ff_wtoupper
       8   convert_ptr
         8 __aeabi_uidivmod
      24   create_chain
        24   -> get_fat
        24   -> put_fat
      48   create_chain_for_clusts
        48   -> create_chain
        48   -> get_fat
        48   -> put_fat
      40   create_name
        40   -> chk_chr
        40   -> ff_convert
        40   -> mem_set
      24   dir_alloc
        24   -> convert_ptr
        24   -> dir_next
        24   -> dir_sdi
        24   -> move_window
      32   dir_find
        32   -> cmp_lfn
        32   -> convert_ptr
        32   -> dir_next
        32   -> dir_sdi
        32   -> mem_cmp
        32   -> move_window
        32   -> sum_sfn
      24   dir_next
        24   -> clust2sect
        24   -> create_chain
        24   -> get_fat
        24   -> mem_set
        24   -> set_dirty
        24   -> set_sectorprev
        24   -> sync_winindex
        24 __aeabi_uidivmod
      32   dir_read
        32   -> convert_ptr
        32   -> dir_next
        32   -> move_window
        32   -> pick_lfn
        32   -> sum_sfn
      40   dir_register
        40   -> convert_ptr
        40   -> dir_alloc
        40   -> dir_find
        40   -> dir_next
        40   -> dir_sdi
        40   -> fit_lfn
        40   -> gen_numname
        40   -> mem_cpy
        40   -> mem_set
        40   -> move_window
        40   -> set_dirty
        40   -> sum_sfn
        40 __aeabi_idiv
      16   dir_remove
        16   -> convert_ptr
        16   -> dir_next
        16   -> dir_sdi
        16   -> move_window
        16   -> set_dirty
      16   dir_sdi
        16   -> clust2sect
        16   -> get_fat
        16 __aeabi_uidivmod
      64   f_chdir
        64   -> chk_mounted
        64   -> convert_ptr
        64   -> ff_memalloc
        64   -> ff_memfree
        64   -> follow_path
        64   -> ld_clust
       4   f_chdrive
      72   f_chmod
        72   -> chk_mounted
        72   -> convert_ptr
        72   -> ff_memalloc
        72   -> ff_memfree
        72   -> follow_path
        72   -> set_dirty
        72   -> sync_fs
       8   f_close
         8   -> f_sync
      32   f_forward
        32   -- Indirect call
        32   -> clust2sect
        32   -> get_fat
        32   -> move_window
        32   -> validate
        32 __aeabi_uidivmod
     112   f_getcwd
       112   -> chk_mounted
       112   -> convert_ptr
       112   -> dir_next
       112   -> dir_read
       112   -> dir_sdi
       112   -> ff_memalloc
       112   -> ff_memfree
       112   -> get_fileinfo
       112   -> ld_clust
      40   f_getfree
        40   -> chk_mounted
        40   -> get_fat
        40   -> move_window
      32   f_gets
        32   -> f_read
      32   f_lseek
        32   -> clust2sect
        32   -> create_chain
        32   -> get_fat
        32   -> validate
        32 __aeabi_uidiv
        32 __aeabi_uidivmod
      88   f_mkdir
        88   -> chk_mounted
        88   -> clust2sect
        88   -> convert_ptr
        88   -> create_chain
        88   -> dir_register
        88   -> ff_memalloc
        88   -> ff_memfree
        88   -> follow_path
        88   -> get_fattime
        88   -> mem_cpy
        88   -> mem_set
        88   -> remove_chain
        88   -> set_dirty
        88   -> set_sectorprev
        88   -> st_clust
        88   -> sync_fs
        88   -> sync_winindex
      16   f_mount
        16   -> clear_buff
      88   f_open
        88   -> chk_mounted
        88   -> convert_ptr
        88   -> dir_register
        88   -> ff_memalloc
        88   -> ff_memfree
        88   -> follow_path
        88   -> get_fattime
        88   -> ld_clust
        88   -> move_window
        88   -> remove_chain
        88   -> set_dirty
        88   -> st_clust
      40   f_opendir
        40   -> chk_mounted
        40   -> convert_ptr
        40   -> dir_sdi
        40   -> ff_memalloc
        40   -> ff_memfree
        40   -> follow_path
        40   -> ld_clust
      72   f_printf
        72   -> f_putc
        72   -> f_puts
        72 __aeabi_uidiv
        72 __aeabi_uidivmod
      16   f_putc
        16   -> f_write
      16   f_puts
        16   -> f_putc
      40   f_read
        40   -> clust2sect
        40   -> disk_read
        40   -> get_fat
        40   -> get_sectorprev
        40   -> mem_cpy
        40   -> move_window
        40   -> validate
        40 __aeabi_uidiv
        40 __aeabi_uidivmod
      32   f_readdir
        32   -> dir_next
        32   -> dir_read
        32   -> dir_sdi
        32   -> ff_memalloc
        32   -> ff_memfree
        32   -> get_fileinfo
        32   -> validate
     128   f_rename
       128   -> chk_mounted
       128   -> clust2sect
       128   -> convert_ptr
       128   -> dir_register
       128   -> dir_remove
       128   -> ff_memalloc
       128   -> ff_memfree
       128   -> follow_path
       128   -> ld_clust
       128   -> mem_cpy
       128   -> move_window
       128   -> set_dirty
       128   -> st_clust
       128   -> sync_fs
      72   f_stat
        72   -> chk_mounted
        72   -> ff_memalloc
        72   -> ff_memfree
        72   -> follow_path
        72   -> get_fileinfo
      16   f_sync
        16   -> convert_ptr
        16   -> get_fattime
        16   -> move_window
        16   -> set_dirty
        16   -> st_clust
        16   -> sync_fs
        16   -> validate
      16   f_truncate
        16   -> get_fat
        16   -> put_fat
        16   -> remove_chain
        16   -> validate
     112   f_unlink
       112   -> chk_mounted
       112   -> convert_ptr
       112   -> dir_read
       112   -> dir_remove
       112   -> dir_sdi
       112   -> ff_memalloc
       112   -> ff_memfree
       112   -> follow_path
       112   -> ld_clust
       112   -> mem_cpy
       112   -> remove_chain
       112   -> sync_fs
      72   f_utime
        72   -> chk_mounted
        72   -> convert_ptr
        72   -> ff_memalloc
        72   -> ff_memfree
        72   -> follow_path
        72   -> set_dirty
        72   -> sync_fs
      48   f_write
        48   -> clear_dirty2
        48   -> clust2sect
        48   -> create_chain_for_clusts
        48   -> disk_write
        48   -> get_sectorprev
        48   -> mem_cpy
        48   -> move_window
        48   -> set_dirty
        48   -> set_sectorprev
        48   -> sync_winindex
        48   -> validate
        48 __aeabi_uidiv
        48 __aeabi_uidivmod
       8   ff_memalloc
         8   -> malloc
       8   ff_memfree
         8   -> free
      20   fit_lfn
      16   follow_path
        16   -> convert_ptr
        16   -> create_name
        16   -> dir_find
        16   -> dir_sdi
        16   -> ld_clust
      24   gen_numname
        24   -> mem_cpy
        24 __aeabi_idiv
        24 __aeabi_idivmod
      24   get_fat
        24   -> move_window
        24 __aeabi_uidivmod
      24   get_fileinfo
        24   -> convert_ptr
        24   -> ff_convert
       0   get_sectorprev
       4   ld_clust
       8   mem_cmp
       4   mem_cpy
       4   mem_set
      16   move_window
        16   -> buff_validation
        16   -> disk_read
        16   -> sync_winindex
      16   pick_lfn
      32   put_fat
        32   -> move_window
        32   -> set_dirty
        32 __aeabi_uidivmod
      24   remove_chain
        24   -> get_fat
        24   -> put_fat
       4   set_dirty
       0   set_sectorprev
       0   st_clust
       4   sum_sfn
      16   sync_fs
        16   -> clear_buff
        16   -> disk_ioctl
        16   -> disk_write
        16   -> mem_set
        16   -> sync_winindex
      32   sync_winindex
        32   -> disk_write
       8   validate
         8   -> disk_status


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable10
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable2
       4  ??DataTable20
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable9
      12  ?_0
       8  ?_1
       1  CurrVol
     128  ExCvt
       8  FatFs
       2  Fsid
      16  LfnOfs
      72  buff_validation
     130  check_fs
      22  chk_chr
     988  chk_mounted
      34  clear_buff
      12  clear_dirty2
      26  clust2sect
     136  cmp_lfn
      28  convert_ptr
     182  create_chain
     490  create_chain_for_clusts
     800  create_name
     124  dir_alloc
     322  dir_find
     382  dir_next
     214  dir_read
     378  dir_register
     108  dir_remove
     180  dir_sdi
       4  entry_start_clust
       2  entry_start_free_index
     136  f_chdir
      20  f_chdrive
     142  f_chmod
      24  f_close
     312  f_forward
     346  f_getcwd
     244  f_getfree
      70  f_gets
     384  f_lseek
     488  f_mkdir
      62  f_mount
     458  f_open
     174  f_opendir
     706  f_printf
      38  f_putc
      46  f_puts
     672  f_read
     130  f_readdir
     348  f_rename
      96  f_stat
     144  f_sync
     164  f_truncate
     270  f_unlink
     148  f_utime
     810  f_write
       8  ff_memalloc
       8  ff_memfree
     114  fit_lfn
     158  follow_path
     140  gen_numname
     248  get_fat
     262  get_fileinfo
      12  get_sectorprev
      36  ld_clust
      30  mem_cmp
      22  mem_cpy
      20  mem_set
     138  move_window
     104  pick_lfn
     352  put_fat
     110  remove_chain
      28  set_dirty
      24  set_sectorprev
      28  st_clust
      34  sum_sfn
     290  sync_fs
     384  sync_winindex
      54  validate

 
     17 bytes in section .bss
    164 bytes in section .rodata
 13 788 bytes in section .text
 
 13 788 bytes of CODE  memory
    164 bytes of CONST memory
     17 bytes of DATA  memory

Errors: none
Warnings: 4
