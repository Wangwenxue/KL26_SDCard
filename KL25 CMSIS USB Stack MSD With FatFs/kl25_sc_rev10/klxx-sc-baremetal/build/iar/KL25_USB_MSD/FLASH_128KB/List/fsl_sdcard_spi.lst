###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        18/Feb/2016  23:08:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\SPI_SDCard\fsl_sdcard_spi.c
#    Command line =  
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\SPI_SDCard\fsl_sdcard_spi.c"
#        -D IAR -D FREEDOM -D SD_DISK_ENABLE -lCN "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -lB "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\"
#        -o "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.2\arm\INC\c\DLib_Config_Normal.h" -I "D:\My
#        Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\common\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\cpu\headers\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\i2c\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\llwu\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\lptmr\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\mcg\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\pmc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rcm\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\rtc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\smc\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\uart\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\wdog\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\drivers\cmp\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\platforms\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\" -I
#        "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\inc\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack
#        MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\CMSIS
#        USB Stack\Porting use\" -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB
#        Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\SPI_SDCard\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\"
#        -I "D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\..\..\..\src\projects\KL25_USB_MSD\FATFS\fsl_sd_disk\"
#        -Ol
#    List file    =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\List\fsl_sdcard_spi.lst
#    Object file  =  
#        D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With
#        FatFs\kl25_sc_rev10\klxx-sc-baremetal\build\iar\KL25_USB_MSD\FLASH_128KB\Obj\fsl_sdcard_spi.o
#
###############################################################################

D:\My Project\SDCardJicheng\KL25 CMSIS USB Stack MSD With FatFs\kl25_sc_rev10\klxx-sc-baremetal\src\projects\KL25_USB_MSD\SPI_SDCard\fsl_sdcard_spi.c
      1          #include "SPI_kinetis.h"
      2          #include "fsl_sdmmc_card.h"
      3          #include "fsl_sdcard_spi.h"
      4          
      5          /* rate unit is divided by 1000 */

   \                                 In section .rodata, align 4
      6          static const uint32_t g_transpeedru[] =
   \                     g_transpeedru:
   \   00000000   0x00000064         DC32 100, 1000, 10000, 100000
   \              0x000003E8   
   \              0x00002710   
   \              0x000186A0   
      7          {
      8            /* 100Kbps, 1Mbps, 10Mbps, 100Mbps*/
      9              100, 1000, 10000, 100000,
     10          };
     11          
     12          /* time value multiplied by 1000 */

   \                                 In section .rodata, align 4
     13          static const uint32_t g_transpeedtv[] =
   \                     g_transpeedtv:
   \   00000000   0x00000000         DC32 0, 1000, 1200, 1300, 1500, 2000, 2500, 3000, 3500, 4000, 4500
   \              0x000003E8   
   \              0x000004B0   
   \              0x00000514   
   \              0x000005DC   
   \              0x000007D0   
   \              0x000009C4   
   \              0x00000BB8   
   \              0x00000DAC   
   \              0x00000FA0   
   \              0x00001194   
   \   0000002C   0x00001388         DC32 5000, 5500, 6000, 7000, 8000
   \              0x0000157C   
   \              0x00001770   
   \              0x00001B58   
   \              0x00001F40   
     14          {
     15                 0, 1000, 1200, 1300,
     16              1500, 2000, 2500, 3000,
     17              3500, 4000, 4500, 5000,
     18              5500, 6000, 7000, 8000,
     19          };
     20          

   \                                 In section .bss, align 4
     21          sdspi_card_t g_card = {0};
   \                     g_card:
   \   00000000                      DS8 68
     22          /*FUNCTION****************************************************************
     23           *
     24           * Function Name: SDCardInit
     25           * Description: Initialize the SD card
     26           *
     27           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     28          uint8_t SDCardInit(void)
     29          {
   \                     SDCardInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     30            /* Begin test SD card. */
     31            memset(&g_card, 0, sizeof(g_card));
   \   00000002   0x2244             MOVS     R2,#+68
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR      R0,??DataTable3
   \   00000008   0x.... 0x....      BL       memset
     32              
     33            if(kStatus_SDSPI_NoError==SDSPI_DRV_Init(&g_card))
   \   0000000C   0x....             LDR      R0,??DataTable3
   \   0000000E   0x.... 0x....      BL       SDSPI_DRV_Init
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE      ??SDCardInit_0
     34              return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE000             B        ??SDCardInit_1
     35            else
     36              return 1;
   \                     ??SDCardInit_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \                     ??SDCardInit_1: (+1)
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
     37          }
     38          
     39          /*FUNCTION****************************************************************
     40           *
     41           * Function Name: SDGetCapacity
     42           * Description: check card capacity of the card in Bytes
     43           *
     44           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     45          uint32_t SDGetCapacity(void)
     46          {
   \                     SDGetCapacity: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     47            SDSPI_DRV_CheckCapacity(&g_card);
   \   00000002   0x....             LDR      R0,??DataTable3
   \   00000004   0x.... 0x....      BL       SDSPI_DRV_CheckCapacity
     48            
     49            return (g_card.blockCount);
   \   00000008   0x....             LDR      R0,??DataTable3
   \   0000000A   0x6BC0             LDR      R0,[R0, #+60]
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
     50          }
     51          
     52          /*FUNCTION****************************************************************
     53           *
     54           * Function Name: SDSPI_DRV_GenerateCRC7
     55           * Description: calculate CRC7
     56           *
     57           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     58          static uint32_t SDSPI_DRV_GenerateCRC7(uint8_t *buffer,
     59                                                uint32_t length,
     60                                                uint32_t crc)
     61          {
   \                     SDSPI_DRV_GenerateCRC7: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xE01A             B        ??SDSPI_DRV_GenerateCRC7_0
     62              uint32_t index;
     63          
     64              static const uint8_t crcTable[] = {
     65                  0x00, 0x09, 0x12, 0x1B, 0x24, 0x2D, 0x36, 0x3F,
     66                  0x48, 0x41, 0x5A, 0x53, 0x6C, 0x65, 0x7E, 0x77
     67              };
     68          
     69              while (length)
     70              {
     71                  index = ((crc >> 3) & 0x0F) ^ ((*buffer) >> 4);
   \                     ??SDSPI_DRV_GenerateCRC7_1: (+1)
   \   00000004   0x0013             MOVS     R3,R2
   \   00000006   0x08DB             LSRS     R3,R3,#+3
   \   00000008   0x071C             LSLS     R4,R3,#+28       ;; ZeroExtS R4,R3,#+28,#+28
   \   0000000A   0x0F24             LSRS     R4,R4,#+28
   \   0000000C   0x7803             LDRB     R3,[R0, #+0]
   \   0000000E   0xB2DB             UXTB     R3,R3
   \   00000010   0x091B             LSRS     R3,R3,#+4
   \   00000012   0xB2DB             UXTB     R3,R3
   \   00000014   0x4063             EORS     R3,R3,R4
     72                  crc = (crc << 4) ^ crcTable[index];
   \   00000016   0x0114             LSLS     R4,R2,#+4
   \   00000018   0x....             LDR      R2,??DataTable3_1
   \   0000001A   0x5CD2             LDRB     R2,[R2, R3]
   \   0000001C   0x4062             EORS     R2,R2,R4
     73          
     74                  index = ((crc >> 3) & 0x0F) ^ ((*buffer) & 0x0F);
   \   0000001E   0x0013             MOVS     R3,R2
   \   00000020   0x08DB             LSRS     R3,R3,#+3
   \   00000022   0x071C             LSLS     R4,R3,#+28       ;; ZeroExtS R4,R3,#+28,#+28
   \   00000024   0x0F24             LSRS     R4,R4,#+28
   \   00000026   0x7803             LDRB     R3,[R0, #+0]
   \   00000028   0x071B             LSLS     R3,R3,#+28       ;; ZeroExtS R3,R3,#+28,#+28
   \   0000002A   0x0F1B             LSRS     R3,R3,#+28
   \   0000002C   0x4063             EORS     R3,R3,R4
     75                  crc = (crc << 4) ^ crcTable[index];
   \   0000002E   0x0114             LSLS     R4,R2,#+4
   \   00000030   0x....             LDR      R2,??DataTable3_1
   \   00000032   0x5CD2             LDRB     R2,[R2, R3]
   \   00000034   0x4062             EORS     R2,R2,R4
     76          
     77                  buffer++;
   \   00000036   0x1C40             ADDS     R0,R0,#+1
     78                  length--;
   \   00000038   0x1E49             SUBS     R1,R1,#+1
     79              }
   \                     ??SDSPI_DRV_GenerateCRC7_0: (+1)
   \   0000003A   0x2900             CMP      R1,#+0
   \   0000003C   0xD1E2             BNE      ??SDSPI_DRV_GenerateCRC7_1
     80          
     81              return (crc & 0x7F);
   \   0000003E   0x0650             LSLS     R0,R2,#+25       ;; ZeroExtS R0,R2,#+25,#+25
   \   00000040   0x0E40             LSRS     R0,R0,#+25
   \   00000042   0xBD10             POP      {R4,PC}          ;; return
     82          }

   \                                 In section .rodata, align 4
   \                     ??crcTable:
   \   00000000   0x00 0x09          DC8 0, 9, 18, 27, 36, 45, 54, 63, 72, 65, 90, 83, 108, 101, 126, 119
   \              0x12 0x1B    
   \              0x24 0x2D    
   \              0x36 0x3F    
   \              0x48 0x41    
   \              0x5A 0x53    
   \              0x6C 0x65    
   \              0x7E 0x77    
     83          
     84          /*FUNCTION****************************************************************
     85           *
     86           * Function Name: SDSPI_DRV_WaitReady
     87           * Description: wait ready 
     88           *
     89           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     90          static sdspi_status_t SDSPI_DRV_WaitReady(void)
     91          {
   \                     SDSPI_DRV_WaitReady: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     92              uint8_t response;
     93              uint16_t timeout=0;
   \   00000002   0x2400             MOVS     R4,#+0
     94              
     95              do
     96              {
     97                  response = SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_WaitReady_0: (+1)
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0x.... 0x....      BL       SpiSendByte
     98              } while ((response != 0xFF) && timeout++ < 60000);
   \   0000000A   0xB2C0             UXTB     R0,R0
   \   0000000C   0x28FF             CMP      R0,#+255
   \   0000000E   0xD006             BEQ      ??SDSPI_DRV_WaitReady_1
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0x000C             MOVS     R4,R1
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \   00000016   0xB289             UXTH     R1,R1
   \   00000018   0x....             LDR      R2,??DataTable3_2  ;; 0xea60
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xDBF2             BLT      ??SDSPI_DRV_WaitReady_0
     99          
    100              if (response != 0xFF)
   \                     ??SDSPI_DRV_WaitReady_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x28FF             CMP      R0,#+255
   \   00000022   0xD001             BEQ      ??SDSPI_DRV_WaitReady_2
    101              {
    102                  return kStatus_SDSPI_CardIsBusyError;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xE000             B        ??SDSPI_DRV_WaitReady_3
    103              }
    104          
    105              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_WaitReady_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_WaitReady_3: (+1)
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    106          }
    107          
    108          /*FUNCTION****************************************************************
    109           *
    110           * Function Name: SDSPI_DRV_SendCommand
    111           * Description: send command
    112           *
    113           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    114          static sdspi_status_t SDSPI_DRV_SendCommand(sdspi_request_t *req,
    115                                                      uint32_t timeout)
    116          {
   \                     SDSPI_DRV_SendCommand: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
    117              uint8_t buffer[6];
    118              uint8_t response;
    119              uint8_t i;
    120              sdspi_status_t result = kStatus_SDSPI_NoError;
   \   00000008   0x2600             MOVS     R6,#+0
    121          
    122              SpiCsLow(); // Assert the CS to select the SD Card
   \   0000000A   0x.... 0x....      BL       SpiCsLow
    123              
    124              result = SDSPI_DRV_WaitReady();
   \   0000000E   0x.... 0x....      BL       SDSPI_DRV_WaitReady
   \   00000012   0x0006             MOVS     R6,R0
    125              if ((result == kStatus_SDSPI_CardIsBusyError)
    126                      && (req->cmdIndex != kGoIdleState))
   \   00000014   0xB2F6             UXTB     R6,R6
   \   00000016   0x2E03             CMP      R6,#+3
   \   00000018   0xD107             BNE      ??SDSPI_DRV_SendCommand_0
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ      ??SDSPI_DRV_SendCommand_0
    127              {
    128                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   00000020   0x.... 0x....      BL       SpiCsHigh
    129                  return result;
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0xE071             B        ??SDSPI_DRV_SendCommand_1
    130              }
    131          
    132              buffer[0] = SDSPI_MAKE_CMD(req->cmdIndex);
   \                     ??SDSPI_DRV_SendCommand_0: (+1)
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2140             MOVS     R1,#+64
   \   0000002E   0x4301             ORRS     R1,R1,R0
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x7001             STRB     R1,[R0, #+0]
    133              buffer[1] = req->argument >> 24 & 0xFF;
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0x0E00             LSRS     R0,R0,#+24
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x7048             STRB     R0,[R1, #+1]
    134              buffer[2] = req->argument >> 16 & 0xFF;
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x0C00             LSRS     R0,R0,#+16
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7088             STRB     R0,[R1, #+2]
    135              buffer[3] = req->argument >> 8 & 0xFF;
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x70C8             STRB     R0,[R1, #+3]
    136              buffer[4] = req->argument & 0xFF;
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x7108             STRB     R0,[R1, #+4]
    137              buffer[5] = (SDSPI_DRV_GenerateCRC7(buffer, 5, 0) << 1) | 1;
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x2105             MOVS     R1,#+5
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x.... 0x....      BL       SDSPI_DRV_GenerateCRC7
   \   0000005C   0x0040             LSLS     R0,R0,#+1
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x4301             ORRS     R1,R1,R0
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x7141             STRB     R1,[R0, #+5]
    138          
    139              if (SpiSendFrame(buffer, NULL, sizeof(buffer)))
   \   00000066   0x2206             MOVS     R2,#+6
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x.... 0x....      BL       SpiSendFrame
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD003             BEQ      ??SDSPI_DRV_SendCommand_2
    140              {
    141                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   00000074   0x.... 0x....      BL       SpiCsHigh
    142                  return kStatus_SDSPI_TransferFailed;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0xE048             B        ??SDSPI_DRV_SendCommand_1
    143              }
    144          
    145              if (req->cmdIndex == kStopTransmission)
   \                     ??SDSPI_DRV_SendCommand_2: (+1)
   \   0000007C   0x7820             LDRB     R0,[R4, #+0]
   \   0000007E   0x280C             CMP      R0,#+12
   \   00000080   0xD102             BNE      ??SDSPI_DRV_SendCommand_3
    146              {
    147                  SpiSendByte(0xFF);
   \   00000082   0x20FF             MOVS     R0,#+255
   \   00000084   0x.... 0x....      BL       SpiSendByte
    148              }
    149              /* Wait for the response coming, the left most bit which is transfered first in response is 0 */
    150              for (i = 0; i < 9; i++)
   \                     ??SDSPI_DRV_SendCommand_3: (+1)
   \   00000088   0x2600             MOVS     R6,#+0
   \   0000008A   0xE000             B        ??SDSPI_DRV_SendCommand_4
   \                     ??SDSPI_DRV_SendCommand_5: (+1)
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   \                     ??SDSPI_DRV_SendCommand_4: (+1)
   \   0000008E   0xB2F6             UXTB     R6,R6
   \   00000090   0x2E09             CMP      R6,#+9
   \   00000092   0xDA05             BGE      ??SDSPI_DRV_SendCommand_6
    151              {
    152                  response = SpiSendByte(0xFF);
   \   00000094   0x20FF             MOVS     R0,#+255
   \   00000096   0x.... 0x....      BL       SpiSendByte
   \   0000009A   0x0005             MOVS     R5,R0
    153                  if (!(response & 0x80))
   \   0000009C   0x0628             LSLS     R0,R5,#+24
   \   0000009E   0xD4F5             BMI      ??SDSPI_DRV_SendCommand_5
    154                  {
    155                      break;
    156                  }
    157              }
    158          
    159              if ((response & 0x80))
   \                     ??SDSPI_DRV_SendCommand_6: (+1)
   \   000000A0   0x0628             LSLS     R0,R5,#+24
   \   000000A2   0xD503             BPL      ??SDSPI_DRV_SendCommand_7
    160              {
    161                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   000000A4   0x.... 0x....      BL       SpiCsHigh
    162                  return kStatus_SDSPI_Failed;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE030             B        ??SDSPI_DRV_SendCommand_1
    163              }
    164          
    165              req->response[0] = response;
   \                     ??SDSPI_DRV_SendCommand_7: (+1)
   \   000000AC   0x7265             STRB     R5,[R4, #+9]
    166              switch(req->respType)
   \   000000AE   0x7A20             LDRB     R0,[R4, #+8]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD003             BEQ      ??SDSPI_DRV_SendCommand_8
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xD016             BEQ      ??SDSPI_DRV_SendCommand_9
   \   000000B8   0xD301             BCC      ??SDSPI_DRV_SendCommand_10
   \   000000BA   0xE019             B        ??SDSPI_DRV_SendCommand_11
    167              {
    168                  case kSdSpiRespTypeR1:
    169                      break;
   \                     ??SDSPI_DRV_SendCommand_8: (+1)
   \   000000BC   0xE024             B        ??SDSPI_DRV_SendCommand_12
    170                  case kSdSpiRespTypeR1b:
    171                  {
    172                      uint8_t busy = 0;
   \                     ??SDSPI_DRV_SendCommand_10: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
    173                      uint32_t time=0;
   \   000000C0   0x2400             MOVS     R4,#+0
    174                      while (busy != 0xFF)
   \                     ??SDSPI_DRV_SendCommand_13: (+1)
   \   000000C2   0xB2C0             UXTB     R0,R0
   \   000000C4   0x28FF             CMP      R0,#+255
   \   000000C6   0xD007             BEQ      ??SDSPI_DRV_SendCommand_14
    175                      {
    176                          busy = SpiSendByte(0xFF);
   \   000000C8   0x20FF             MOVS     R0,#+255
   \   000000CA   0x.... 0x....      BL       SpiSendByte
    177                          if (time++ > timeout)
   \   000000CE   0x0021             MOVS     R1,R4
   \   000000D0   0x000C             MOVS     R4,R1
   \   000000D2   0x1C64             ADDS     R4,R4,#+1
   \   000000D4   0x428F             CMP      R7,R1
   \   000000D6   0xD2F4             BCS      ??SDSPI_DRV_SendCommand_13
    178                          {
    179                              break;
    180                          }
    181                      }
    182                      if (busy != 0xFF)
   \                     ??SDSPI_DRV_SendCommand_14: (+1)
   \   000000D8   0xB2C0             UXTB     R0,R0
   \   000000DA   0x28FF             CMP      R0,#+255
   \   000000DC   0xD002             BEQ      ??SDSPI_DRV_SendCommand_15
    183                      {
    184                          SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   000000DE   0x.... 0x....      BL       SpiCsHigh
    185                          result = kStatus_SDSPI_CardIsBusyError;
   \   000000E2   0x2603             MOVS     R6,#+3
    186                      }
    187                      break;
   \                     ??SDSPI_DRV_SendCommand_15: (+1)
   \   000000E4   0xE010             B        ??SDSPI_DRV_SendCommand_12
    188                  }
    189                  case kSdSpiRespTypeR2:
    190                      req->response[1] = SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_SendCommand_9: (+1)
   \   000000E6   0x20FF             MOVS     R0,#+255
   \   000000E8   0x.... 0x....      BL       SpiSendByte
   \   000000EC   0x72A0             STRB     R0,[R4, #+10]
    191                      break;
   \   000000EE   0xE00B             B        ??SDSPI_DRV_SendCommand_12
    192                  case kSdSpiRespTypeR3:
    193                  case kSdSpiRespTypeR7:
    194                  default:
    195                      for (i = 1; i <= 4; i++)/* R7 has total 5 bytes in SPI mode. */
   \                     ??SDSPI_DRV_SendCommand_11: (+1)
   \   000000F0   0x2601             MOVS     R6,#+1
   \   000000F2   0xE006             B        ??SDSPI_DRV_SendCommand_16
    196                      {
    197                          req->response[i] = SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_SendCommand_17: (+1)
   \   000000F4   0x20FF             MOVS     R0,#+255
   \   000000F6   0x.... 0x....      BL       SpiSendByte
   \   000000FA   0xB2F6             UXTB     R6,R6
   \   000000FC   0x19A1             ADDS     R1,R4,R6
   \   000000FE   0x7248             STRB     R0,[R1, #+9]
    198                      }
   \   00000100   0x1C76             ADDS     R6,R6,#+1
   \                     ??SDSPI_DRV_SendCommand_16: (+1)
   \   00000102   0xB2F6             UXTB     R6,R6
   \   00000104   0x2E05             CMP      R6,#+5
   \   00000106   0xDBF5             BLT      ??SDSPI_DRV_SendCommand_17
    199                      break;
    200              }
    201          
    202              SpiCsHigh();// Deassert the CS to deselect the SD Card
   \                     ??SDSPI_DRV_SendCommand_12: (+1)
   \   00000108   0x.... 0x....      BL       SpiCsHigh
    203          
    204              return kStatus_SDSPI_NoError;
   \   0000010C   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_SendCommand_1: (+1)
   \   0000010E   0xBDFE             POP      {R1-R7,PC}       ;; return
    205          }
    206          
    207          // wenxue add 20160218
    208          /*FUNCTION****************************************************************
    209           *
    210           * Function Name: SDSPI_DRV_SendCommand
    211           * Description: send command
    212           *
    213           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          static sdspi_status_t SDSPI_DRV_SendCommand_NoDeassert(sdspi_request_t *req,
    215                                                      uint32_t timeout)
    216          {
   \                     SDSPI_DRV_SendCommand_NoDeassert: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
    217              uint8_t buffer[6];
    218              uint8_t response;
    219              uint8_t i;
    220              sdspi_status_t result = kStatus_SDSPI_NoError;
   \   00000008   0x2600             MOVS     R6,#+0
    221          
    222              SpiCsLow(); // Assert the CS to select the SD Card
   \   0000000A   0x.... 0x....      BL       SpiCsLow
    223              
    224              result = SDSPI_DRV_WaitReady();
   \   0000000E   0x.... 0x....      BL       SDSPI_DRV_WaitReady
   \   00000012   0x0006             MOVS     R6,R0
    225              if ((result == kStatus_SDSPI_CardIsBusyError)
    226                      && (req->cmdIndex != kGoIdleState))
   \   00000014   0xB2F6             UXTB     R6,R6
   \   00000016   0x2E03             CMP      R6,#+3
   \   00000018   0xD107             BNE      ??SDSPI_DRV_SendCommand_NoDeassert_0
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD004             BEQ      ??SDSPI_DRV_SendCommand_NoDeassert_0
    227              {
    228                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   00000020   0x.... 0x....      BL       SpiCsHigh
    229                  return result;
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0xE06F             B        ??SDSPI_DRV_SendCommand_NoDeassert_1
    230              }
    231          
    232              buffer[0] = SDSPI_MAKE_CMD(req->cmdIndex);
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_0: (+1)
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x2140             MOVS     R1,#+64
   \   0000002E   0x4301             ORRS     R1,R1,R0
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x7001             STRB     R1,[R0, #+0]
    233              buffer[1] = req->argument >> 24 & 0xFF;
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0x0E00             LSRS     R0,R0,#+24
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0x7048             STRB     R0,[R1, #+1]
    234              buffer[2] = req->argument >> 16 & 0xFF;
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0x0C00             LSRS     R0,R0,#+16
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7088             STRB     R0,[R1, #+2]
    235              buffer[3] = req->argument >> 8 & 0xFF;
   \   00000044   0x6860             LDR      R0,[R4, #+4]
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x70C8             STRB     R0,[R1, #+3]
    236              buffer[4] = req->argument & 0xFF;
   \   0000004C   0x6860             LDR      R0,[R4, #+4]
   \   0000004E   0x4669             MOV      R1,SP
   \   00000050   0x7108             STRB     R0,[R1, #+4]
    237              buffer[5] = (SDSPI_DRV_GenerateCRC7(buffer, 5, 0) << 1) | 1;
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x2105             MOVS     R1,#+5
   \   00000056   0x4668             MOV      R0,SP
   \   00000058   0x.... 0x....      BL       SDSPI_DRV_GenerateCRC7
   \   0000005C   0x0040             LSLS     R0,R0,#+1
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x4301             ORRS     R1,R1,R0
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x7141             STRB     R1,[R0, #+5]
    238          
    239              if (SpiSendFrame(buffer, NULL, sizeof(buffer)))
   \   00000066   0x2206             MOVS     R2,#+6
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x.... 0x....      BL       SpiSendFrame
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD003             BEQ      ??SDSPI_DRV_SendCommand_NoDeassert_2
    240              {
    241                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   00000074   0x.... 0x....      BL       SpiCsHigh
    242                  return kStatus_SDSPI_TransferFailed;
   \   00000078   0x2002             MOVS     R0,#+2
   \   0000007A   0xE046             B        ??SDSPI_DRV_SendCommand_NoDeassert_1
    243              }
    244          
    245              if (req->cmdIndex == kStopTransmission) //  豕?1?那?CMD12??芍?㏒??迄﹞⊿?赤0xFF ???
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_2: (+1)
   \   0000007C   0x7820             LDRB     R0,[R4, #+0]
   \   0000007E   0x280C             CMP      R0,#+12
   \   00000080   0xD102             BNE      ??SDSPI_DRV_SendCommand_NoDeassert_3
    246              {
    247                  SpiSendByte(0xFF);
   \   00000082   0x20FF             MOVS     R0,#+255
   \   00000084   0x.... 0x....      BL       SpiSendByte
    248              }
    249              /* Wait for the response coming, the left most bit which is transfered first in response is 0 */
    250              for (i = 0; i < 9; i++)
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_3: (+1)
   \   00000088   0x2600             MOVS     R6,#+0
   \   0000008A   0xE000             B        ??SDSPI_DRV_SendCommand_NoDeassert_4
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_5: (+1)
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_4: (+1)
   \   0000008E   0xB2F6             UXTB     R6,R6
   \   00000090   0x2E09             CMP      R6,#+9
   \   00000092   0xDA05             BGE      ??SDSPI_DRV_SendCommand_NoDeassert_6
    251              {
    252                  response = SpiSendByte(0xFF);
   \   00000094   0x20FF             MOVS     R0,#+255
   \   00000096   0x.... 0x....      BL       SpiSendByte
   \   0000009A   0x0005             MOVS     R5,R0
    253                  if (!(response & 0x80)) // 足?3?米?足??t那?那?℅????a0
   \   0000009C   0x0628             LSLS     R0,R5,#+24
   \   0000009E   0xD4F5             BMI      ??SDSPI_DRV_SendCommand_NoDeassert_5
    254                  {
    255                      break;
    256                  }
    257              }
    258          
    259              if ((response & 0x80))
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_6: (+1)
   \   000000A0   0x0628             LSLS     R0,R5,#+24
   \   000000A2   0xD503             BPL      ??SDSPI_DRV_SendCommand_NoDeassert_7
    260              {
    261                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   000000A4   0x.... 0x....      BL       SpiCsHigh
    262                  return kStatus_SDSPI_Failed;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE02E             B        ??SDSPI_DRV_SendCommand_NoDeassert_1
    263              }
    264          
    265              req->response[0] = response;
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_7: (+1)
   \   000000AC   0x7265             STRB     R5,[R4, #+9]
    266              switch(req->respType)
   \   000000AE   0x7A20             LDRB     R0,[R4, #+8]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD003             BEQ      ??SDSPI_DRV_SendCommand_NoDeassert_8
   \   000000B4   0x2802             CMP      R0,#+2
   \   000000B6   0xD016             BEQ      ??SDSPI_DRV_SendCommand_NoDeassert_9
   \   000000B8   0xD301             BCC      ??SDSPI_DRV_SendCommand_NoDeassert_10
   \   000000BA   0xE019             B        ??SDSPI_DRV_SendCommand_NoDeassert_11
    267              {
    268                  case kSdSpiRespTypeR1:
    269                      break; // R1 那?辰???℅??迆
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_8: (+1)
   \   000000BC   0xE024             B        ??SDSPI_DRV_SendCommand_NoDeassert_12
    270                  case kSdSpiRespTypeR1b:
    271                  {
    272                      uint8_t busy = 0;
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_10: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
    273                      uint32_t time=0;
   \   000000C0   0x2400             MOVS     R4,#+0
    274                      while (busy != 0xFF) //?芍那?米?足??t那?㏒o1)3?那㊣ 2㏒?busy=0xFF
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_13: (+1)
   \   000000C2   0xB2C0             UXTB     R0,R0
   \   000000C4   0x28FF             CMP      R0,#+255
   \   000000C6   0xD007             BEQ      ??SDSPI_DRV_SendCommand_NoDeassert_14
    275                      {
    276                          busy = SpiSendByte(0xFF);
   \   000000C8   0x20FF             MOVS     R0,#+255
   \   000000CA   0x.... 0x....      BL       SpiSendByte
    277                          if (time++ > timeout)
   \   000000CE   0x0021             MOVS     R1,R4
   \   000000D0   0x000C             MOVS     R4,R1
   \   000000D2   0x1C64             ADDS     R4,R4,#+1
   \   000000D4   0x428F             CMP      R7,R1
   \   000000D6   0xD2F4             BCS      ??SDSPI_DRV_SendCommand_NoDeassert_13
    278                          {
    279                              break;
    280                          }
    281                      }
    282                      if (busy != 0xFF)
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_14: (+1)
   \   000000D8   0xB2C0             UXTB     R0,R0
   \   000000DA   0x28FF             CMP      R0,#+255
   \   000000DC   0xD002             BEQ      ??SDSPI_DRV_SendCommand_NoDeassert_15
    283                      {
    284                          SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   000000DE   0x.... 0x....      BL       SpiCsHigh
    285                          result = kStatus_SDSPI_CardIsBusyError;
   \   000000E2   0x2603             MOVS     R6,#+3
    286                      }
    287                      break;
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_15: (+1)
   \   000000E4   0xE010             B        ??SDSPI_DRV_SendCommand_NoDeassert_12
    288                  }
    289                  case kSdSpiRespTypeR2:
    290                      req->response[1] = SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_9: (+1)
   \   000000E6   0x20FF             MOVS     R0,#+255
   \   000000E8   0x.... 0x....      BL       SpiSendByte
   \   000000EC   0x72A0             STRB     R0,[R4, #+10]
    291                      break;
   \   000000EE   0xE00B             B        ??SDSPI_DRV_SendCommand_NoDeassert_12
    292                  case kSdSpiRespTypeR3:
    293                  case kSdSpiRespTypeR7:
    294                  default:
    295                      for (i = 1; i <= 4; i++)/* R7 has total 5 bytes in SPI mode. */
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_11: (+1)
   \   000000F0   0x2601             MOVS     R6,#+1
   \   000000F2   0xE006             B        ??SDSPI_DRV_SendCommand_NoDeassert_16
    296                      {
    297                          req->response[i] = SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_17: (+1)
   \   000000F4   0x20FF             MOVS     R0,#+255
   \   000000F6   0x.... 0x....      BL       SpiSendByte
   \   000000FA   0xB2F6             UXTB     R6,R6
   \   000000FC   0x19A1             ADDS     R1,R4,R6
   \   000000FE   0x7248             STRB     R0,[R1, #+9]
    298                      }
   \   00000100   0x1C76             ADDS     R6,R6,#+1
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_16: (+1)
   \   00000102   0xB2F6             UXTB     R6,R6
   \   00000104   0x2E05             CMP      R6,#+5
   \   00000106   0xDBF5             BLT      ??SDSPI_DRV_SendCommand_NoDeassert_17
    299                      break;
    300              }
    301          
    302            //  SpiCsHigh();// Deassert the CS to deselect the SD Card  // wenxue
    303          
    304              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_12: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_SendCommand_NoDeassert_1: (+1)
   \   0000010A   0xBDFE             POP      {R1-R7,PC}       ;; return
    305          }
    306          
    307          /*FUNCTION****************************************************************
    308           *
    309           * Function Name: SDSPI_DRV_GoIdle
    310           * Description: send CMD0
    311           *
    312           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    313          static sdspi_status_t SDSPI_DRV_GoIdle(sdspi_card_t *card)
    314          {
   \                     SDSPI_DRV_GoIdle: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    315              uint32_t i, j;
    316              sdspi_request_t req;
    317          
    318              /*
    319               * SD card will enter SPI mode if the CS is asserted (negative) during the
    320               * reception of the reset command (CMD0) and the card is in IDLE state.
    321               */
    322              for (i = 0; i < 2; i++)
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE000             B        ??SDSPI_DRV_GoIdle_0
   \                     ??SDSPI_DRV_GoIdle_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??SDSPI_DRV_GoIdle_0: (+1)
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD21A             BCS      ??SDSPI_DRV_GoIdle_2
    323              {
    324                  for (j = 0; j < 10; j++)
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xE003             B        ??SDSPI_DRV_GoIdle_3
    325                  {
    326                      SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_GoIdle_4: (+1)
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0x.... 0x....      BL       SpiSendByte
    327                  }
   \   00000018   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SDSPI_DRV_GoIdle_3: (+1)
   \   0000001A   0x2D0A             CMP      R5,#+10
   \   0000001C   0xD3F9             BCC      ??SDSPI_DRV_GoIdle_4
    328          
    329                  req.cmdIndex = kGoIdleState;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    330                  req.respType = kSdSpiRespTypeR1;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x7208             STRB     R0,[R1, #+8]
    331                  if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   0000002A   0x21FA             MOVS     R1,#+250
   \   0000002C   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD001             BEQ      ??SDSPI_DRV_GoIdle_5
    332                  {
    333                      return kStatus_SDSPI_Failed;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xE00A             B        ??SDSPI_DRV_GoIdle_6
    334                  }
    335          
    336                  if (req.response[0] == SDMMC_SPI_R1_IN_IDLE_STATE)
   \                     ??SDSPI_DRV_GoIdle_5: (+1)
   \   0000003C   0x4668             MOV      R0,SP
   \   0000003E   0x7A40             LDRB     R0,[R0, #+9]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD1E1             BNE      ??SDSPI_DRV_GoIdle_1
    337                  {
    338                      break;
    339                  }
    340              }
    341          
    342              if (req.response[0] != SDMMC_SPI_R1_IN_IDLE_STATE)
   \                     ??SDSPI_DRV_GoIdle_2: (+1)
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x7A40             LDRB     R0,[R0, #+9]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xD001             BEQ      ??SDSPI_DRV_GoIdle_7
    343              {
    344                  return kStatus_SDSPI_Failed;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE000             B        ??SDSPI_DRV_GoIdle_6
    345              }
    346          
    347              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_GoIdle_7: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_GoIdle_6: (+1)
   \   00000052   0xB007             ADD      SP,SP,#+28
   \   00000054   0xBD30             POP      {R4,R5,PC}       ;; return
    348          }
    349          
    350          /*FUNCTION****************************************************************
    351           *
    352           * Function Name: SDSPI_DRV_SendApplicationCmd
    353           * Description: send application command to card
    354           *
    355           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    356          static sdspi_status_t SDSPI_DRV_SendApplicationCmd(void)
    357          {
   \                     SDSPI_DRV_SendApplicationCmd: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    358              sdspi_request_t req;
    359          
    360              req.cmdIndex = kAppCmd;
   \   00000004   0x2037             MOVS     R0,#+55
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    361              req.respType = kSdSpiRespTypeR1;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7208             STRB     R0,[R1, #+8]
    362              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000010   0x21FA             MOVS     R1,#+250
   \   00000012   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ      ??SDSPI_DRV_SendApplicationCmd_0
    363              {
    364                  return kStatus_SDSPI_Failed;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE00A             B        ??SDSPI_DRV_SendApplicationCmd_1
    365              }
    366          
    367              if (req.response[0] && !(req.response[0] & SDMMC_SPI_R1_IN_IDLE_STATE))
   \                     ??SDSPI_DRV_SendApplicationCmd_0: (+1)
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x7A40             LDRB     R0,[R0, #+9]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD005             BEQ      ??SDSPI_DRV_SendApplicationCmd_2
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x7A40             LDRB     R0,[R0, #+9]
   \   0000002E   0x07C0             LSLS     R0,R0,#+31
   \   00000030   0xD401             BMI      ??SDSPI_DRV_SendApplicationCmd_2
    368              {
    369          
    370                  return kStatus_SDSPI_Failed;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE000             B        ??SDSPI_DRV_SendApplicationCmd_1
    371              }
    372          
    373              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_SendApplicationCmd_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_SendApplicationCmd_1: (+1)
   \   00000038   0xB007             ADD      SP,SP,#+28
   \   0000003A   0xBD00             POP      {PC}             ;; return
    374          }
    375          
    376          /*FUNCTION****************************************************************
    377           *
    378           * Function Name: SDSPI_DRV_AppSendOpCond
    379           * Description: Get the card to send its operating condition.
    380           *
    381           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    382          static sdspi_status_t SDSPI_DRV_AppSendOpCond(sdspi_card_t *card,
    383                                                        uint32_t argument,
    384                                                        uint8_t *response)
    385          {
   \                     SDSPI_DRV_AppSendOpCond: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0014             MOVS     R4,R2
    386              sdspi_request_t req;
    387              uint16_t timeout = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    388              uint8_t i=0;
   \   00000008   0x2000             MOVS     R0,#+0
    389          
    390          
    391              req.cmdIndex = kSdAppSendOpCond;
   \   0000000A   0x2029             MOVS     R0,#+41
   \   0000000C   0x466A             MOV      R2,SP
   \   0000000E   0x7010             STRB     R0,[R2, #+0]
    392              req.argument = argument;
   \   00000010   0x9101             STR      R1,[SP, #+4]
    393              req.respType = kSdSpiRespTypeR1;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x7208             STRB     R0,[R1, #+8]
    394          
    395              timeout = 0;
   \   00000018   0x2500             MOVS     R5,#+0
    396              do
    397              {
    398                  if (kStatus_SDSPI_NoError == SDSPI_DRV_SendApplicationCmd())
   \                     ??SDSPI_DRV_AppSendOpCond_0: (+1)
   \   0000001A   0x.... 0x....      BL       SDSPI_DRV_SendApplicationCmd
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10A             BNE      ??SDSPI_DRV_AppSendOpCond_1
    399                  {
    400                      if (kStatus_SDSPI_NoError == SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000022   0x21FA             MOVS     R1,#+250
   \   00000024   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000026   0x4668             MOV      R0,SP
   \   00000028   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE      ??SDSPI_DRV_AppSendOpCond_1
    401                      {
    402                          if (!req.response[0])
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x7A40             LDRB     R0,[R0, #+9]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD005             BEQ      ??SDSPI_DRV_AppSendOpCond_2
    403                          {
    404                              break;
    405                          }
    406                      }
    407                  }
    408                  timeout++;
   \                     ??SDSPI_DRV_AppSendOpCond_1: (+1)
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
    409              } while (timeout < 2000);
   \   0000003A   0xB2AD             UXTH     R5,R5
   \   0000003C   0x20FA             MOVS     R0,#+250
   \   0000003E   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xDBEA             BLT      ??SDSPI_DRV_AppSendOpCond_0
    410          
    411              if (response)
   \                     ??SDSPI_DRV_AppSendOpCond_2: (+1)
   \   00000044   0x2C00             CMP      R4,#+0
   \   00000046   0xD00B             BEQ      ??SDSPI_DRV_AppSendOpCond_3
    412              {
    413                  //memcpy(response, req.response, sizeof(req.response));
    414                for(i=0;i<sizeof(req.response);i++)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE006             B        ??SDSPI_DRV_AppSendOpCond_4
    415                {
    416                  response[i] = req.response[i];
   \                     ??SDSPI_DRV_AppSendOpCond_5: (+1)
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0xB2C0             UXTB     R0,R0
   \   00000050   0x1809             ADDS     R1,R1,R0
   \   00000052   0x7A49             LDRB     R1,[R1, #+9]
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x5421             STRB     R1,[R4, R0]
    417                }
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \                     ??SDSPI_DRV_AppSendOpCond_4: (+1)
   \   0000005A   0xB2C0             UXTB     R0,R0
   \   0000005C   0x2805             CMP      R0,#+5
   \   0000005E   0xD3F5             BCC      ??SDSPI_DRV_AppSendOpCond_5
    418              }
    419          
    420              if (timeout < 2000)
   \                     ??SDSPI_DRV_AppSendOpCond_3: (+1)
   \   00000060   0xB2AD             UXTH     R5,R5
   \   00000062   0x20FA             MOVS     R0,#+250
   \   00000064   0x00C0             LSLS     R0,R0,#+3        ;; #+2000
   \   00000066   0x4285             CMP      R5,R0
   \   00000068   0xDA01             BGE      ??SDSPI_DRV_AppSendOpCond_6
    421              {
    422                  return kStatus_SDSPI_NoError;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE000             B        ??SDSPI_DRV_AppSendOpCond_7
    423              }
    424              return kStatus_SDSPI_TimeoutError;
   \                     ??SDSPI_DRV_AppSendOpCond_6: (+1)
   \   0000006E   0x2005             MOVS     R0,#+5
   \                     ??SDSPI_DRV_AppSendOpCond_7: (+1)
   \   00000070   0xB007             ADD      SP,SP,#+28
   \   00000072   0xBD30             POP      {R4,R5,PC}       ;; return
    425          }
    426          
    427          /*FUNCTION****************************************************************
    428           *
    429           * Function Name: SDSPI_DRV_SendIfCond
    430           * Description: check card interface condition, which includes host supply
    431           * voltage information and asks the card whether card supports voltage.
    432           *
    433           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    434          static sdspi_status_t SDSPI_DRV_SendIfCond(sdspi_card_t *card,
    435                                                     uint8_t pattern,
    436                                                     uint8_t *response1)
    437          {
   \                     SDSPI_DRV_SendIfCond: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0014             MOVS     R4,R2
    438              sdspi_request_t req;
    439              uint8_t i=0;
   \   00000006   0x2000             MOVS     R0,#+0
    440              
    441              req.cmdIndex = kSdSendIfCond;
   \   00000008   0x2008             MOVS     R0,#+8
   \   0000000A   0x466A             MOV      R2,SP
   \   0000000C   0x7010             STRB     R0,[R2, #+0]
    442              req.argument = 0x100 | (pattern & 0xFF);
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \   00000014   0x4308             ORRS     R0,R0,R1
   \   00000016   0x9001             STR      R0,[SP, #+4]
    443              req.respType = kSdSpiRespTypeR7;
   \   00000018   0x2004             MOVS     R0,#+4
   \   0000001A   0x4669             MOV      R1,SP
   \   0000001C   0x7208             STRB     R0,[R1, #+8]
    444              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   0000001E   0x21FA             MOVS     R1,#+250
   \   00000020   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000022   0x4668             MOV      R0,SP
   \   00000024   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ      ??SDSPI_DRV_SendIfCond_0
    445              {
    446                  return kStatus_SDSPI_Failed;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE00C             B        ??SDSPI_DRV_SendIfCond_1
    447              }
    448              
    449              for(i=0;i<sizeof(req.response);i++)
   \                     ??SDSPI_DRV_SendIfCond_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE006             B        ??SDSPI_DRV_SendIfCond_2
    450              {
    451                response1[i] = req.response[i];
   \                     ??SDSPI_DRV_SendIfCond_3: (+1)
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0xB2C0             UXTB     R0,R0
   \   00000038   0x1809             ADDS     R1,R1,R0
   \   0000003A   0x7A49             LDRB     R1,[R1, #+9]
   \   0000003C   0xB2C0             UXTB     R0,R0
   \   0000003E   0x5421             STRB     R1,[R4, R0]
    452              }
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \                     ??SDSPI_DRV_SendIfCond_2: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0
   \   00000044   0x2805             CMP      R0,#+5
   \   00000046   0xD3F5             BCC      ??SDSPI_DRV_SendIfCond_3
    453              //memcpy(response1, (uint8_t *)req.response, sizeof(req.response));
    454          
    455              return kStatus_SDSPI_NoError;
   \   00000048   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_SendIfCond_1: (+1)
   \   0000004A   0xB006             ADD      SP,SP,#+24
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
    456          }
    457          
    458          /*FUNCTION****************************************************************
    459           *
    460           * Function Name: SDSPI_DRV_ReadOcr
    461           * Description: Get OCR register from card
    462           *
    463           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    464          static sdspi_status_t SDSPI_DRV_ReadOcr(sdspi_card_t *card)
    465          {
   \                     SDSPI_DRV_ReadOcr: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0004             MOVS     R4,R0
    466              uint32_t i;
    467              sdspi_request_t req;
    468          
    469              req.cmdIndex = kReadOcr;
   \   00000006   0x203A             MOVS     R0,#+58
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    470              req.respType = kSdSpiRespTypeR3;
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x7208             STRB     R0,[R1, #+8]
    471              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000012   0x21FA             MOVS     R1,#+250
   \   00000014   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ      ??SDSPI_DRV_ReadOcr_0
    472              {
    473                  return kStatus_SDSPI_Failed;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE019             B        ??SDSPI_DRV_ReadOcr_1
    474              }
    475              if (req.response[0])
   \                     ??SDSPI_DRV_ReadOcr_0: (+1)
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x7A40             LDRB     R0,[R0, #+9]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD001             BEQ      ??SDSPI_DRV_ReadOcr_2
    476              {
    477                  return kStatus_SDSPI_Failed;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE013             B        ??SDSPI_DRV_ReadOcr_1
    478              }
    479          
    480              card->ocr = 0;
   \                     ??SDSPI_DRV_ReadOcr_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x63A0             STR      R0,[R4, #+56]
    481              for (i = 4; i > 0; i--)
   \   00000034   0x2004             MOVS     R0,#+4
   \   00000036   0xE00C             B        ??SDSPI_DRV_ReadOcr_3
    482              {
    483                  card->ocr |= (uint32_t) req.response[i] << ((4 - i) * 8);
   \                     ??SDSPI_DRV_ReadOcr_4: (+1)
   \   00000038   0x6BA1             LDR      R1,[R4, #+56]
   \   0000003A   0x466A             MOV      R2,SP
   \   0000003C   0x1812             ADDS     R2,R2,R0
   \   0000003E   0x7A52             LDRB     R2,[R2, #+9]
   \   00000040   0x2304             MOVS     R3,#+4
   \   00000042   0x0005             MOVS     R5,R0
   \   00000044   0x1B5B             SUBS     R3,R3,R5
   \   00000046   0x2508             MOVS     R5,#+8
   \   00000048   0x436B             MULS     R3,R5,R3
   \   0000004A   0x409A             LSLS     R2,R2,R3
   \   0000004C   0x430A             ORRS     R2,R2,R1
   \   0000004E   0x63A2             STR      R2,[R4, #+56]
    484              }
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \                     ??SDSPI_DRV_ReadOcr_3: (+1)
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1F0             BNE      ??SDSPI_DRV_ReadOcr_4
    485          
    486              return kStatus_SDSPI_NoError;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_ReadOcr_1: (+1)
   \   00000058   0xB007             ADD      SP,SP,#+28
   \   0000005A   0xBD30             POP      {R4,R5,PC}       ;; return
    487          }
    488          
    489          /*FUNCTION****************************************************************
    490           *
    491           * Function Name: SDSPI_DRV_Write
    492           * Description: write data to card
    493           *
    494           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    495          static uint32_t SDSPI_DRV_Write(uint8_t *buffer, uint32_t size, uint8_t token)
    496          {
   \                     SDSPI_DRV_Write: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0007             MOVS     R7,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    497              uint8_t     response = 0;
   \   00000008   0x2000             MOVS     R0,#+0
    498              uint16_t    timeout = 0;
   \   0000000A   0x2400             MOVS     R4,#+0
    499              
    500              SpiCsLow(); // Assert the CS to select the SD Card
   \   0000000C   0x.... 0x....      BL       SpiCsLow
    501              
    502              if (SDSPI_DRV_WaitReady() != kStatus_SDSPI_NoError)
   \   00000010   0x.... 0x....      BL       SDSPI_DRV_WaitReady
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ      ??SDSPI_DRV_Write_0
    503              {
    504                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   00000018   0x.... 0x....      BL       SpiCsHigh
    505                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE02F             B        ??SDSPI_DRV_Write_1
    506              }
    507          
    508              SpiSendByte(token);
   \                     ??SDSPI_DRV_Write_0: (+1)
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x.... 0x....      BL       SpiSendByte
    509          
    510              if (token == SDMMC_SPI_DT_STOP_TRANSFER)
   \   00000028   0xB2F6             UXTB     R6,R6
   \   0000002A   0x2EFD             CMP      R6,#+253
   \   0000002C   0xD103             BNE      ??SDSPI_DRV_Write_2
    511              {
    512                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   0000002E   0x.... 0x....      BL       SpiCsHigh
    513                  return size;
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0xE024             B        ??SDSPI_DRV_Write_1
    514              }
    515          
    516              if (SpiSendFrame(buffer, NULL, size))
   \                     ??SDSPI_DRV_Write_2: (+1)
   \   00000036   0x002A             MOVS     R2,R5
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       SpiSendFrame
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD003             BEQ      ??SDSPI_DRV_Write_3
    517              {
    518                  SpiCsHigh();// Deassert the CS to deselect the SD Card
   \   00000044   0x.... 0x....      BL       SpiCsHigh
    519                  return 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE019             B        ??SDSPI_DRV_Write_1
    520              }
    521          
    522              /* Send CRC */
    523              SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_Write_3: (+1)
   \   0000004C   0x20FF             MOVS     R0,#+255
   \   0000004E   0x.... 0x....      BL       SpiSendByte
    524              SpiSendByte(0xFF);
   \   00000052   0x20FF             MOVS     R0,#+255
   \   00000054   0x.... 0x....      BL       SpiSendByte
    525          
    526              do{
    527                  //read response  
    528                  response = SpiSendByte(0xFF);  
   \                     ??SDSPI_DRV_Write_4: (+1)
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0x.... 0x....      BL       SpiSendByte
    529                  timeout ++;  
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
    530                  //if time out,set CS high and return r1  
    531                  if(timeout > 3000)  
   \   00000060   0xB2A4             UXTH     R4,R4
   \   00000062   0x....             LDR      R1,??DataTable7  ;; 0xbb9
   \   00000064   0x428C             CMP      R4,R1
   \   00000066   0xDB03             BLT      ??SDSPI_DRV_Write_5
    532                  {  
    533                      //set CS high and send 8 clocks  
    534                      SpiCsHigh();  
   \   00000068   0x.... 0x....      BL       SpiCsHigh
    535                      return 0;  
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE007             B        ??SDSPI_DRV_Write_1
    536                  }  
    537              }while((response & SDMMC_SPI_DR_MASK)!= SDMMC_SPI_DR_ACCEPTED);  
   \                     ??SDSPI_DRV_Write_5: (+1)
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   00000074   0x0EC0             LSRS     R0,R0,#+27
   \   00000076   0x2805             CMP      R0,#+5
   \   00000078   0xD1EE             BNE      ??SDSPI_DRV_Write_4
    538              
    539              SpiCsHigh(); // Deassert the CS to deselect the SD Card
   \   0000007A   0x.... 0x....      BL       SpiCsHigh
    540              
    541              return size;
   \   0000007E   0x0028             MOVS     R0,R5
   \                     ??SDSPI_DRV_Write_1: (+1)
   \   00000080   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    542          }
    543          
    544          /*FUNCTION****************************************************************
    545           *
    546           * Function Name: SDSPI_DRV_Read
    547           * Description: read data from card
    548           *
    549           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    550          static uint32_t SDSPI_DRV_Read(uint8_t *buffer, uint32_t size)
    551          {
   \                     SDSPI_DRV_Read: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
    552              uint32_t timeout=0,i=0;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2600             MOVS     R6,#+0
    553              uint8_t response;
    554              
    555              SpiCsLow();
   \   0000000A   0x.... 0x....      BL       SpiCsLow
    556              //continually read till get the start unsigned char 0xfe  
    557              do{  
    558                  response = SpiSendByte(0xFF);  
   \                     ??SDSPI_DRV_Read_0: (+1)
   \   0000000E   0x20FF             MOVS     R0,#+255
   \   00000010   0x.... 0x....      BL       SpiSendByte
   \   00000014   0x0006             MOVS     R6,R0
    559                  timeout ++;  
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
    560                  //if time out,set CS high and return r1  
    561                  if(timeout > 30000)  
   \   00000018   0x....             LDR      R0,??DataTable7_1  ;; 0x7531
   \   0000001A   0x4285             CMP      R5,R0
   \   0000001C   0xD304             BCC      ??SDSPI_DRV_Read_1
    562                  {  
    563                      //set CS high and send 8 clocks  
    564                      SpiCsHigh();  
   \   0000001E   0x.... 0x....      BL       SpiCsHigh
    565                      return response;  
   \   00000022   0xB2F6             UXTB     R6,R6
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xE015             B        ??SDSPI_DRV_Read_2
    566                  }  
    567              }while(response != SDMMC_SPI_DT_START_SINGLE_BLK);  
   \                     ??SDSPI_DRV_Read_1: (+1)
   \   00000028   0xB2F6             UXTB     R6,R6
   \   0000002A   0x2EFE             CMP      R6,#+254
   \   0000002C   0xD1EF             BNE      ??SDSPI_DRV_Read_0
    568              
    569              for(i = 0;i < size;i ++)  
   \   0000002E   0x2600             MOVS     R6,#+0
   \   00000030   0xE005             B        ??SDSPI_DRV_Read_3
    570              *buffer++ = SpiSendByte(0xFF);
   \                     ??SDSPI_DRV_Read_4: (+1)
   \   00000032   0x20FF             MOVS     R0,#+255
   \   00000034   0x.... 0x....      BL       SpiSendByte
   \   00000038   0x7020             STRB     R0,[R4, #+0]
   \   0000003A   0x1C64             ADDS     R4,R4,#+1
   \   0000003C   0x1C76             ADDS     R6,R6,#+1
   \                     ??SDSPI_DRV_Read_3: (+1)
   \   0000003E   0x42BE             CMP      R6,R7
   \   00000040   0xD3F7             BCC      ??SDSPI_DRV_Read_4
    571              
    572              SpiSendByte(0xFF);  
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0x.... 0x....      BL       SpiSendByte
    573              SpiSendByte(0xFF); 
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0x.... 0x....      BL       SpiSendByte
    574              
    575              SpiCsHigh();  
   \   0000004E   0x.... 0x....      BL       SpiCsHigh
    576              
    577              return size;
   \   00000052   0x0038             MOVS     R0,R7
   \                     ??SDSPI_DRV_Read_2: (+1)
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    578          }
    579          
    580          /*FUNCTION****************************************************************
    581           *
    582           * Function Name: SDSPI_DRV_SendCsd
    583           * Description: get CSD register from card
    584           *
    585           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    586          static sdspi_status_t SDSPI_DRV_SendCsd(sdspi_card_t *card)
    587          {
   \                     SDSPI_DRV_SendCsd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    588              sdspi_request_t req;
    589          
    590              req.cmdIndex = kSendCsd;
   \   00000006   0x2009             MOVS     R0,#+9
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    591              req.respType = kSdSpiRespTypeR1;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x7208             STRB     R0,[R1, #+8]
    592             // if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))  // wenxue
    593              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand_NoDeassert(&req, SDSPI_TIMEOUT))
   \   00000012   0x21FA             MOVS     R1,#+250
   \   00000014   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       SDSPI_DRV_SendCommand_NoDeassert
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ      ??SDSPI_DRV_SendCsd_0
    594              {
    595          
    596                  return kStatus_SDSPI_Failed;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE009             B        ??SDSPI_DRV_SendCsd_1
    597              }
    598          
    599              if (sizeof(card->rawCsd) !=
    600                      (SDSPI_DRV_Read(card->rawCsd, sizeof(card->rawCsd))))
   \                     ??SDSPI_DRV_SendCsd_0: (+1)
   \   00000024   0x2110             MOVS     R1,#+16
   \   00000026   0x340D             ADDS     R4,R4,#+13
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       SDSPI_DRV_Read
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD001             BEQ      ??SDSPI_DRV_SendCsd_2
    601              {
    602                  return kStatus_SDSPI_Failed;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE000             B        ??SDSPI_DRV_SendCsd_1
    603              }
    604          
    605              /* No start single block token if found */
    606              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_SendCsd_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_SendCsd_1: (+1)
   \   00000038   0xB006             ADD      SP,SP,#+24
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    607          }
    608          
    609          /*FUNCTION****************************************************************
    610           *
    611           * Function Name: SDSPI_DRV_SetBlockSize
    612           * Description:  set the block length in bytes for SDSC cards. For SDHC cards,
    613           * it does not affect memory read or write commands, always 512 bytes fixed
    614           * block length is used.
    615           *
    616           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    617          static sdspi_status_t SDSPI_DRV_SetBlockSize(uint32_t blockSize)
    618          {
   \                     SDSPI_DRV_SetBlockSize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    619              sdspi_request_t req;
    620          
    621              req.cmdIndex = kSetBlockLen;
   \   00000004   0x2110             MOVS     R1,#+16
   \   00000006   0x466A             MOV      R2,SP
   \   00000008   0x7011             STRB     R1,[R2, #+0]
    622              req.argument = blockSize;
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    623              req.respType = kSdSpiRespTypeR1;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x7208             STRB     R0,[R1, #+8]
    624          
    625              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000012   0x21FA             MOVS     R1,#+250
   \   00000014   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ      ??SDSPI_DRV_SetBlockSize_0
    626              {
    627                  return kStatus_SDSPI_Failed;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE000             B        ??SDSPI_DRV_SetBlockSize_1
    628              }
    629          
    630              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_SetBlockSize_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_SetBlockSize_1: (+1)
   \   00000026   0xB007             ADD      SP,SP,#+28
   \   00000028   0xBD00             POP      {PC}             ;; return
    631          }
    632          
    633          /*FUNCTION****************************************************************
    634           *
    635           * Function Name: SDSPI_DRV_CheckCapacity
    636           * Description: check card capacity of the card
    637           *
    638           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    639          void SDSPI_DRV_CheckCapacity(sdspi_card_t *card)
    640          {
   \                     SDSPI_DRV_CheckCapacity: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    641              uint32_t cSize, cSizeMult, readBlkLen;
    642          
    643              if (SDMMC_CSD_CSDSTRUCTURE_VERSION(card->rawCsd))
   \   00000002   0x7B41             LDRB     R1,[R0, #+13]
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x0989             LSRS     R1,R1,#+6
   \   00000008   0xB2C9             UXTB     R1,R1
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD018             BEQ      ??SDSPI_DRV_CheckCapacity_0
    644              {
    645                  /* SD CSD structure v2.xx */
    646                  cSize = SDV20_CSD_CSIZE(card->rawCsd);
   \   0000000E   0x7D01             LDRB     R1,[R0, #+20]
   \   00000010   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000012   0x0E89             LSRS     R1,R1,#+26
   \   00000014   0x0409             LSLS     R1,R1,#+16
   \   00000016   0x7D42             LDRB     R2,[R0, #+21]
   \   00000018   0x0212             LSLS     R2,R2,#+8
   \   0000001A   0x430A             ORRS     R2,R2,R1
   \   0000001C   0x7D81             LDRB     R1,[R0, #+22]
   \   0000001E   0x4311             ORRS     R1,R1,R2
    647                  if (cSize >= 0xFFFF)
   \   00000020   0x....             LDR      R2,??DataTable7_2  ;; 0xffff
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xD304             BCC      ??SDSPI_DRV_CheckCapacity_1
    648                  {
    649                      /* extended capacity */
    650                      card->caps |= SDSPI_CAPS_SDXC;
   \   00000026   0x6842             LDR      R2,[R0, #+4]
   \   00000028   0x2302             MOVS     R3,#+2
   \   0000002A   0x4313             ORRS     R3,R3,R2
   \   0000002C   0x6043             STR      R3,[R0, #+4]
   \   0000002E   0xE003             B        ??SDSPI_DRV_CheckCapacity_2
    651                  }
    652                  else
    653                  {
    654                      card->caps |= SDSPI_CAPS_SDHC;
   \                     ??SDSPI_DRV_CheckCapacity_1: (+1)
   \   00000030   0x6842             LDR      R2,[R0, #+4]
   \   00000032   0x2301             MOVS     R3,#+1
   \   00000034   0x4313             ORRS     R3,R3,R2
   \   00000036   0x6043             STR      R3,[R0, #+4]
    655                  }
    656                  cSizeMult = 10;
   \                     ??SDSPI_DRV_CheckCapacity_2: (+1)
   \   00000038   0x220A             MOVS     R2,#+10
    657                  cSize += 1;
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
    658                  readBlkLen = 9;
   \   0000003C   0x2309             MOVS     R3,#+9
   \   0000003E   0xE019             B        ??SDSPI_DRV_CheckCapacity_3
    659              }
    660              else
    661              {
    662                  /* SD CSD structure v1.xx */
    663                  cSize = SDMMC_CSD_CSIZE(card->rawCsd) + 1;
   \                     ??SDSPI_DRV_CheckCapacity_0: (+1)
   \   00000040   0x7CC1             LDRB     R1,[R0, #+19]
   \   00000042   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000044   0x0F89             LSRS     R1,R1,#+30
   \   00000046   0x0289             LSLS     R1,R1,#+10
   \   00000048   0x7D02             LDRB     R2,[R0, #+20]
   \   0000004A   0x0092             LSLS     R2,R2,#+2
   \   0000004C   0x430A             ORRS     R2,R2,R1
   \   0000004E   0x7D41             LDRB     R1,[R0, #+21]
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x0989             LSRS     R1,R1,#+6
   \   00000054   0xB2C9             UXTB     R1,R1
   \   00000056   0x4311             ORRS     R1,R1,R2
   \   00000058   0x1C49             ADDS     R1,R1,#+1
    664                  cSizeMult = SDMMC_CSD_CSIZEMULT(card->rawCsd) + 2;
   \   0000005A   0x7D82             LDRB     R2,[R0, #+22]
   \   0000005C   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000005E   0x0F92             LSRS     R2,R2,#+30
   \   00000060   0x0053             LSLS     R3,R2,#+1
   \   00000062   0x7DC2             LDRB     R2,[R0, #+23]
   \   00000064   0xB2D2             UXTB     R2,R2
   \   00000066   0x09D2             LSRS     R2,R2,#+7
   \   00000068   0xB2D2             UXTB     R2,R2
   \   0000006A   0x431A             ORRS     R2,R2,R3
   \   0000006C   0x1C92             ADDS     R2,R2,#+2
    665                  readBlkLen = SDMMC_CSD_READBLK_LEN(card->rawCsd);
   \   0000006E   0x7C83             LDRB     R3,[R0, #+18]
   \   00000070   0x071B             LSLS     R3,R3,#+28       ;; ZeroExtS R3,R3,#+28,#+28
   \   00000072   0x0F1B             LSRS     R3,R3,#+28
    666              }
    667          
    668              if (readBlkLen != 9)
   \                     ??SDSPI_DRV_CheckCapacity_3: (+1)
   \   00000074   0x2B09             CMP      R3,#+9
   \   00000076   0xD002             BEQ      ??SDSPI_DRV_CheckCapacity_4
    669              {
    670                  /* Force to use 512-byte length block */
    671                  cSizeMult += (readBlkLen - 9);
   \   00000078   0x3B09             SUBS     R3,R3,#+9
   \   0000007A   0x18D2             ADDS     R2,R2,R3
    672                  readBlkLen = 9;
   \   0000007C   0x2309             MOVS     R3,#+9
    673              }
    674          
    675              card->blockSize = 1 << readBlkLen;
   \                     ??SDSPI_DRV_CheckCapacity_4: (+1)
   \   0000007E   0x2401             MOVS     R4,#+1
   \   00000080   0x409C             LSLS     R4,R4,R3
   \   00000082   0x6404             STR      R4,[R0, #+64]
    676              card->blockCount = cSize << cSizeMult;
   \   00000084   0x4091             LSLS     R1,R1,R2
   \   00000086   0x63C1             STR      R1,[R0, #+60]
    677          }
   \   00000088   0xBD10             POP      {R4,PC}          ;; return
    678          
    679          /*FUNCTION****************************************************************
    680           *
    681           * Function Name: SDSPI_DRV_SendCid
    682           * Description: get CID information from card
    683           *
    684           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    685          static sdspi_status_t SDSPI_DRV_SendCid(sdspi_card_t *card)
    686          {
   \                     SDSPI_DRV_SendCid: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x0004             MOVS     R4,R0
    687              sdspi_request_t req;
    688          
    689              
    690              req.cmdIndex = kSendCid;
   \   00000006   0x200A             MOVS     R0,#+10
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
    691              req.respType = kSdSpiRespTypeR1;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4669             MOV      R1,SP
   \   00000010   0x7208             STRB     R0,[R1, #+8]
    692          
    693             // if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))  // wenxue
    694              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand_NoDeassert(&req, SDSPI_TIMEOUT)) 
   \   00000012   0x21FA             MOVS     R1,#+250
   \   00000014   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x.... 0x....      BL       SDSPI_DRV_SendCommand_NoDeassert
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ      ??SDSPI_DRV_SendCid_0
    695              {
    696                  return kStatus_SDSPI_Failed;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xE009             B        ??SDSPI_DRV_SendCid_1
    697              }
    698          
    699              if (sizeof(card->rawCid) !=
    700                      (SDSPI_DRV_Read(card->rawCid, sizeof(card->rawCid))))
   \                     ??SDSPI_DRV_SendCid_0: (+1)
   \   00000024   0x2110             MOVS     R1,#+16
   \   00000026   0x341D             ADDS     R4,R4,#+29
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       SDSPI_DRV_Read
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD001             BEQ      ??SDSPI_DRV_SendCid_2
    701              {
    702                  return kStatus_SDSPI_Failed;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xE000             B        ??SDSPI_DRV_SendCid_1
    703              }
    704          
    705              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_SendCid_2: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_SendCid_1: (+1)
   \   00000038   0xB006             ADD      SP,SP,#+24
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
    706          }
    707          
    708          /*FUNCTION****************************************************************
    709           *
    710           * Function Name: SDSPI_DRV_InitSd
    711           * Description: initialize SD card
    712           *
    713           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    714          static sdspi_status_t SDSPI_DRV_InitSd(sdspi_card_t *card)
    715          {
   \                     SDSPI_DRV_InitSd: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    716              uint32_t maxFrequency;
    717          
    718              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCsd(card))
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       SDSPI_DRV_SendCsd
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ      ??SDSPI_DRV_InitSd_0
    719              {
    720                  return kStatus_SDSPI_Failed;  
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE01F             B        ??SDSPI_DRV_InitSd_1
    721              }
    722          
    723              /* Calculate frequency */
    724              maxFrequency = g_transpeedtv[SDMMC_CSD_TRANSPEED_TV(card->rawCsd)] *
    725                          g_transpeedru[SDMMC_CSD_TRANSPEED_RU(card->rawCsd)];
   \                     ??SDSPI_DRV_InitSd_0: (+1)
   \   00000012   0x....             LDR      R0,??DataTable7_3
   \   00000014   0x7C21             LDRB     R1,[R4, #+16]
   \   00000016   0x10C9             ASRS     R1,R1,#+3
   \   00000018   0x0709             LSLS     R1,R1,#+28       ;; ZeroExtS R1,R1,#+28,#+28
   \   0000001A   0x0F09             LSRS     R1,R1,#+28
   \   0000001C   0x2204             MOVS     R2,#+4
   \   0000001E   0x4351             MULS     R1,R2,R1
   \   00000020   0x5840             LDR      R0,[R0, R1]
   \   00000022   0x....             LDR      R1,??DataTable7_4
   \   00000024   0x7C22             LDRB     R2,[R4, #+16]
   \   00000026   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000028   0x0F52             LSRS     R2,R2,#+29
   \   0000002A   0x2304             MOVS     R3,#+4
   \   0000002C   0x435A             MULS     R2,R3,R2
   \   0000002E   0x5889             LDR      R1,[R1, R2]
   \   00000030   0x4348             MULS     R0,R1,R0
    726              
    727              SpiHighRate();
   \   00000032   0x.... 0x....      BL       SpiHighRate
    728          
    729              SDSPI_DRV_CheckCapacity(card);
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       SDSPI_DRV_CheckCapacity
    730              SDSPI_DRV_CheckReadOnly(card);
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       SDSPI_DRV_CheckReadOnly
    731          
    732              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCid(card))
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       SDSPI_DRV_SendCid
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD001             BEQ      ??SDSPI_DRV_InitSd_2
    733              {
    734                  return kStatus_SDSPI_Failed; 
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE000             B        ??SDSPI_DRV_InitSd_1
    735              }
    736          
    737              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_InitSd_2: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_InitSd_1: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    738          }
    739          
    740          /*FUNCTION****************************************************************
    741           *
    742           * Function Name: SDSPI_DRV_Init
    743           * Description: initialize card on the given host controller
    744           *
    745           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    746          sdspi_status_t SDSPI_DRV_Init(sdspi_card_t *card)
    747          {
   \                     SDSPI_DRV_Init: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0006             MOVS     R6,R0
    748              uint32_t timeout, acmd41Arg;
    749              uint8_t response[5], acmd41resp[5];
    750              unsigned int likelyMmc = FALSE, likelySdV1 = FALSE;
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x2700             MOVS     R7,#+0
    751          
    752              card->cardType = kCardTypeUnknown;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7330             STRB     R0,[R6, #+12]
    753              
    754              SPI_Init();
   \   0000000E   0x.... 0x....      BL       SPI_Init
    755          
    756              if (kStatus_SDSPI_NoError != SDSPI_DRV_GoIdle(card))
   \   00000012   0x0030             MOVS     R0,R6
   \   00000014   0x.... 0x....      BL       SDSPI_DRV_GoIdle
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ      ??SDSPI_DRV_Init_0
    757              {
    758                  return kStatus_SDSPI_Failed;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE065             B        ??SDSPI_DRV_Init_1
    759              }
    760          
    761              acmd41Arg = 0;
   \                     ??SDSPI_DRV_Init_0: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x9000             STR      R0,[SP, #+0]
    762              if (kStatus_SDSPI_NoError !=
    763                      SDSPI_DRV_SendIfCond(card, 0xAA, response))
   \   00000024   0xAA03             ADD      R2,SP,#+12
   \   00000026   0x21AA             MOVS     R1,#+170
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       SDSPI_DRV_SendIfCond
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00C             BEQ      ??SDSPI_DRV_Init_2
    764              {
    765                  likelySdV1 = TRUE;
   \   00000032   0x2701             MOVS     R7,#+1
    766              }
    767              else if ((response[3] == 0x1) || (response[4] == 0xAA))
    768              {
    769                  acmd41Arg |= SD_OCR_HCS;
    770              }
    771              else
    772              {
    773                  return kStatus_SDSPI_Failed;
    774              }
    775          
    776              timeout = 0;
   \                     ??SDSPI_DRV_Init_3: (+1)
   \   00000034   0x2400             MOVS     R4,#+0
    777              do
    778              {
    779                  if (kStatus_SDSPI_NoError !=
    780                          SDSPI_DRV_AppSendOpCond(card, acmd41Arg, acmd41resp))
   \                     ??SDSPI_DRV_Init_4: (+1)
   \   00000036   0xAA01             ADD      R2,SP,#+4
   \   00000038   0x9900             LDR      R1,[SP, #+0]
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0x.... 0x....      BL       SDSPI_DRV_AppSendOpCond
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD015             BEQ      ??SDSPI_DRV_Init_5
    781                  {
    782                      if (likelySdV1)
   \   00000044   0x2F00             CMP      R7,#+0
   \   00000046   0xD011             BEQ      ??SDSPI_DRV_Init_6
    783                      {
    784                          likelyMmc = TRUE;
   \   00000048   0x2501             MOVS     R5,#+1
    785                          break;
   \   0000004A   0xE024             B        ??SDSPI_DRV_Init_7
    786                      }
   \                     ??SDSPI_DRV_Init_2: (+1)
   \   0000004C   0xA803             ADD      R0,SP,#+12
   \   0000004E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD003             BEQ      ??SDSPI_DRV_Init_8
   \   00000054   0xA803             ADD      R0,SP,#+12
   \   00000056   0x7900             LDRB     R0,[R0, #+4]
   \   00000058   0x28AA             CMP      R0,#+170
   \   0000005A   0xD105             BNE      ??SDSPI_DRV_Init_9
   \                     ??SDSPI_DRV_Init_8: (+1)
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x2180             MOVS     R1,#+128
   \   00000060   0x05C9             LSLS     R1,R1,#+23       ;; #+1073741824
   \   00000062   0x4301             ORRS     R1,R1,R0
   \   00000064   0x9100             STR      R1,[SP, #+0]
   \   00000066   0xE7E5             B        ??SDSPI_DRV_Init_3
   \                     ??SDSPI_DRV_Init_9: (+1)
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0xE03F             B        ??SDSPI_DRV_Init_1
    787                      return kStatus_SDSPI_Failed;
   \                     ??SDSPI_DRV_Init_6: (+1)
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE03D             B        ??SDSPI_DRV_Init_1
    788                  }
    789                  if (!acmd41resp[0])
   \                     ??SDSPI_DRV_Init_5: (+1)
   \   00000070   0x4668             MOV      R0,SP
   \   00000072   0x7900             LDRB     R0,[R0, #+4]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD00E             BEQ      ??SDSPI_DRV_Init_7
    790                  {
    791                      break;
    792                  }
    793                  if (timeout++ > 500)
   \                     ??SDSPI_DRV_Init_10: (+1)
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x0004             MOVS     R4,R0
   \   0000007C   0x1C64             ADDS     R4,R4,#+1
   \   0000007E   0x21FF             MOVS     R1,#+255
   \   00000080   0x31F6             ADDS     R1,R1,#+246      ;; #+501
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD303             BCC      ??SDSPI_DRV_Init_11
    794                  {
    795                      if (likelySdV1)
   \   00000086   0x2F00             CMP      R7,#+0
   \   00000088   0xD001             BEQ      ??SDSPI_DRV_Init_11
    796                      {
    797                          likelyMmc = TRUE;
   \   0000008A   0x2501             MOVS     R5,#+1
    798                          break;
   \   0000008C   0xE003             B        ??SDSPI_DRV_Init_7
    799                      }
    800                  }
    801              } while(acmd41resp[0] == SDMMC_SPI_R1_IN_IDLE_STATE);
   \                     ??SDSPI_DRV_Init_11: (+1)
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x7900             LDRB     R0,[R0, #+4]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD0CF             BEQ      ??SDSPI_DRV_Init_4
    802          
    803              if (likelyMmc)
   \                     ??SDSPI_DRV_Init_7: (+1)
   \   00000096   0x2D00             CMP      R5,#+0
   \   00000098   0xD003             BEQ      ??SDSPI_DRV_Init_12
    804              {
    805                  card->cardType = kCardTypeMmc;
   \   0000009A   0x2003             MOVS     R0,#+3
   \   0000009C   0x7330             STRB     R0,[R6, #+12]
    806                  return kStatus_SDSPI_NotSupportYet;
   \   0000009E   0x2007             MOVS     R0,#+7
   \   000000A0   0xE024             B        ??SDSPI_DRV_Init_1
    807              }
    808              else
    809              {
    810                  card->cardType = kCardTypeSd;
   \                     ??SDSPI_DRV_Init_12: (+1)
   \   000000A2   0x2002             MOVS     R0,#+2
   \   000000A4   0x7330             STRB     R0,[R6, #+12]
    811              }
    812          
    813              if (!likelySdV1)
   \   000000A6   0x2F00             CMP      R7,#+0
   \   000000A8   0xD10E             BNE      ??SDSPI_DRV_Init_13
    814              {
    815                  card->version = kSdCardVersion_2_x;
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x7030             STRB     R0,[R6, #+0]
    816                  if (kStatus_SDSPI_NoError != SDSPI_DRV_ReadOcr(card))
   \   000000AE   0x0030             MOVS     R0,R6
   \   000000B0   0x.... 0x....      BL       SDSPI_DRV_ReadOcr
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD001             BEQ      ??SDSPI_DRV_Init_14
    817                  {
    818                      return kStatus_SDSPI_Failed;
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xE017             B        ??SDSPI_DRV_Init_1
    819                  }
    820                  if (card->ocr & SD_OCR_CCS)
   \                     ??SDSPI_DRV_Init_14: (+1)
   \   000000BC   0x6BB0             LDR      R0,[R6, #+56]
   \   000000BE   0x0040             LSLS     R0,R0,#+1
   \   000000C0   0xD504             BPL      ??SDSPI_DRV_Init_15
    821                  {
    822                      card->caps = SDSPI_CAPS_ACCESS_IN_BLOCK;
   \   000000C2   0x2004             MOVS     R0,#+4
   \   000000C4   0x6070             STR      R0,[R6, #+4]
   \   000000C6   0xE001             B        ??SDSPI_DRV_Init_15
    823                  }
    824              }
    825              else
    826              {
    827                  card->version = kSdCardVersion_1_x;
   \                     ??SDSPI_DRV_Init_13: (+1)
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x7030             STRB     R0,[R6, #+0]
    828              }
    829          
    830              /* Force to use 512-byte length block, no matter which version  */
    831              if (kStatus_SDSPI_NoError != SDSPI_DRV_SetBlockSize(512))
   \                     ??SDSPI_DRV_Init_15: (+1)
   \   000000CC   0x2080             MOVS     R0,#+128
   \   000000CE   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   000000D0   0x.... 0x....      BL       SDSPI_DRV_SetBlockSize
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD001             BEQ      ??SDSPI_DRV_Init_16
    832              {
    833                  return kStatus_SDSPI_Failed;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xE007             B        ??SDSPI_DRV_Init_1
    834              }
    835          
    836              if (kStatus_SDSPI_NoError != SDSPI_DRV_InitSd(card))
   \                     ??SDSPI_DRV_Init_16: (+1)
   \   000000DC   0x0030             MOVS     R0,R6
   \   000000DE   0x.... 0x....      BL       SDSPI_DRV_InitSd
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD001             BEQ      ??SDSPI_DRV_Init_17
    837              {
    838                  return kStatus_SDSPI_Failed;
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0xE000             B        ??SDSPI_DRV_Init_1
    839              }
    840          
    841              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_Init_17: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_Init_1: (+1)
   \   000000EC   0xB005             ADD      SP,SP,#+20
   \   000000EE   0xBDF0             POP      {R4-R7,PC}       ;; return
    842          }
    843          
    844          /*FUNCTION****************************************************************
    845           *
    846           * Function Name: SDSPI_DRV_StopTransmission
    847           * Description:  Send stop transmission command to card to stop ongoing
    848           * data transferring.
    849           *
    850           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    851          static sdspi_status_t SDSPI_DRV_StopTransmission(void)
    852          {
   \                     SDSPI_DRV_StopTransmission: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    853              sdspi_request_t req;
    854          
    855              req.cmdIndex = kStopTransmission;
   \   00000004   0x200C             MOVS     R0,#+12
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x7008             STRB     R0,[R1, #+0]
    856              req.respType = kSdSpiRespTypeR1b;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7208             STRB     R0,[R1, #+8]
    857              if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000010   0x21FA             MOVS     R1,#+250
   \   00000012   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000014   0x4668             MOV      R0,SP
   \   00000016   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ      ??SDSPI_DRV_StopTransmission_0
    858              {
    859                  return kStatus_SDSPI_Failed;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xE000             B        ??SDSPI_DRV_StopTransmission_1
    860              }
    861          
    862              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_StopTransmission_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_StopTransmission_1: (+1)
   \   00000024   0xB007             ADD      SP,SP,#+28
   \   00000026   0xBD00             POP      {PC}             ;; return
    863          }
    864          
    865          /*FUNCTION****************************************************************
    866           *
    867           * Function Name: SDSPI_DRV_ReadBlocks
    868           * Description: read blocks from card 
    869           *
    870           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    871          sdspi_status_t SDSPI_DRV_ReadBlocks(sdspi_card_t *card, uint8_t *buffer,
    872                                              uint32_t startBlock, uint32_t blockCount)
    873          {
   \                     SDSPI_DRV_ReadBlocks: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x001F             MOVS     R7,R3
    874              uint32_t offset, i;
    875              sdspi_request_t req;
    876          
    877              offset = startBlock;
    878              if (!IS_BLOCK_ACCESS(card))
   \   0000000A   0x7930             LDRB     R0,[R6, #+4]
   \   0000000C   0x0740             LSLS     R0,R0,#+29
   \   0000000E   0xD401             BMI      ??SDSPI_DRV_ReadBlocks_0
    879              {
    880                  offset *= card->blockSize;
   \   00000010   0x6C30             LDR      R0,[R6, #+64]
   \   00000012   0x4342             MULS     R2,R0,R2
    881              }
    882              
    883              req.argument = offset;
   \                     ??SDSPI_DRV_ReadBlocks_0: (+1)
   \   00000014   0x9201             STR      R2,[SP, #+4]
    884              req.respType = kSdSpiRespTypeR1;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x7208             STRB     R0,[R1, #+8]
    885              if (blockCount == 1)
   \   0000001C   0x2F01             CMP      R7,#+1
   \   0000001E   0xD114             BNE      ??SDSPI_DRV_ReadBlocks_1
    886              {
    887                  req.cmdIndex = kReadSingleBlock;
   \   00000020   0x2011             MOVS     R0,#+17
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x7008             STRB     R0,[R1, #+0]
    888          
    889                  if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000026   0x21FA             MOVS     R1,#+250
   \   00000028   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   0000002A   0x4668             MOV      R0,SP
   \   0000002C   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ      ??SDSPI_DRV_ReadBlocks_2
    890                  {
    891                      return kStatus_SDSPI_Failed;
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE027             B        ??SDSPI_DRV_ReadBlocks_3
    892                  }
    893          
    894                  if (SDSPI_DRV_Read(buffer, card->blockSize) != card->blockSize)
   \                     ??SDSPI_DRV_ReadBlocks_2: (+1)
   \   00000038   0x6C31             LDR      R1,[R6, #+64]
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       SDSPI_DRV_Read
   \   00000040   0x6C31             LDR      R1,[R6, #+64]
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xD01F             BEQ      ??SDSPI_DRV_ReadBlocks_4
    895                  {
    896                      return kStatus_SDSPI_Failed;
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE01E             B        ??SDSPI_DRV_ReadBlocks_3
    897                  }
    898              }
    899              else
    900              {
    901                  req.cmdIndex = kReadMultipleBlock;
   \                     ??SDSPI_DRV_ReadBlocks_1: (+1)
   \   0000004A   0x2012             MOVS     R0,#+18
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    902          
    903                  if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000050   0x21FA             MOVS     R1,#+250
   \   00000052   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000054   0x4668             MOV      R0,SP
   \   00000056   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD001             BEQ      ??SDSPI_DRV_ReadBlocks_5
    904                  {
    905                      return kStatus_SDSPI_Failed;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xE012             B        ??SDSPI_DRV_ReadBlocks_3
    906                  }
    907          
    908                  for (i = 0; i < blockCount; i++)
   \                     ??SDSPI_DRV_ReadBlocks_5: (+1)
   \   00000062   0x2500             MOVS     R5,#+0
   \   00000064   0xE002             B        ??SDSPI_DRV_ReadBlocks_6
    909                  {
    910                      if (SDSPI_DRV_Read(buffer, card->blockSize) != card->blockSize)
    911                      {
    912                          return kStatus_SDSPI_Failed;
    913                      }
    914                      buffer += card->blockSize;
   \                     ??SDSPI_DRV_ReadBlocks_7: (+1)
   \   00000066   0x6C30             LDR      R0,[R6, #+64]
   \   00000068   0x1824             ADDS     R4,R4,R0
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SDSPI_DRV_ReadBlocks_6: (+1)
   \   0000006C   0x42BD             CMP      R5,R7
   \   0000006E   0xD208             BCS      ??SDSPI_DRV_ReadBlocks_8
   \   00000070   0x6C31             LDR      R1,[R6, #+64]
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       SDSPI_DRV_Read
   \   00000078   0x6C31             LDR      R1,[R6, #+64]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD0F3             BEQ      ??SDSPI_DRV_ReadBlocks_7
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE002             B        ??SDSPI_DRV_ReadBlocks_3
    915                  }
    916                  SDSPI_DRV_StopTransmission();
   \                     ??SDSPI_DRV_ReadBlocks_8: (+1)
   \   00000082   0x.... 0x....      BL       SDSPI_DRV_StopTransmission
    917              }
    918          
    919              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_ReadBlocks_4: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_ReadBlocks_3: (+1)
   \   00000088   0xB007             ADD      SP,SP,#+28
   \   0000008A   0xBDF0             POP      {R4-R7,PC}       ;; return
    920          }
    921          
    922          /*FUNCTION****************************************************************
    923           *
    924           * Function Name: SDSPI_DRV_WriteBlocks
    925           * Description: write blocks to card 
    926           *
    927           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    928          sdspi_status_t SDSPI_DRV_WriteBlocks(sdspi_card_t *card, uint8_t *buffer,
    929                                               uint32_t startBlock, uint32_t blockCount)
    930          {
   \                     SDSPI_DRV_WriteBlocks: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x001F             MOVS     R7,R3
    931              uint32_t offset, i;
    932              sdspi_request_t req;
    933          
    934              if (card->state & SDSPI_STATE_WRITE_PROTECTED)
   \   0000000A   0x7A30             LDRB     R0,[R6, #+8]
   \   0000000C   0x07C0             LSLS     R0,R0,#+31
   \   0000000E   0xD501             BPL      ??SDSPI_DRV_WriteBlocks_0
    935              {
    936                  return kStatus_SDSPI_WriteProtected;
   \   00000010   0x2006             MOVS     R0,#+6
   \   00000012   0xE059             B        ??SDSPI_DRV_WriteBlocks_1
    937              }
    938          
    939              offset = startBlock;
   \                     ??SDSPI_DRV_WriteBlocks_0: (+1)
   \   00000014   0x0014             MOVS     R4,R2
    940              if (!IS_BLOCK_ACCESS(card))
   \   00000016   0x7930             LDRB     R0,[R6, #+4]
   \   00000018   0x0740             LSLS     R0,R0,#+29
   \   0000001A   0xD401             BMI      ??SDSPI_DRV_WriteBlocks_2
    941              {
    942                  offset *= card->blockSize;
   \   0000001C   0x6C30             LDR      R0,[R6, #+64]
   \   0000001E   0x4344             MULS     R4,R0,R4
    943              }
    944          
    945              if (blockCount == 1)
   \                     ??SDSPI_DRV_WriteBlocks_2: (+1)
   \   00000020   0x2F01             CMP      R7,#+1
   \   00000022   0xD11F             BNE      ??SDSPI_DRV_WriteBlocks_3
    946              {
    947                  req.cmdIndex = kWriteBlock;
   \   00000024   0x2018             MOVS     R0,#+24
   \   00000026   0x4669             MOV      R1,SP
   \   00000028   0x7008             STRB     R0,[R1, #+0]
    948                  req.argument = offset;
   \   0000002A   0x9401             STR      R4,[SP, #+4]
    949                  req.respType = kSdSpiRespTypeR1;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x7208             STRB     R0,[R1, #+8]
    950                  if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   00000032   0x21FA             MOVS     R1,#+250
   \   00000034   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000036   0x4668             MOV      R0,SP
   \   00000038   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ      ??SDSPI_DRV_WriteBlocks_4
    951                  {
    952                      return kStatus_SDSPI_Failed;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE041             B        ??SDSPI_DRV_WriteBlocks_1
    953                  }
    954                  if (req.response[0])
   \                     ??SDSPI_DRV_WriteBlocks_4: (+1)
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x7A40             LDRB     R0,[R0, #+9]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD001             BEQ      ??SDSPI_DRV_WriteBlocks_5
    955                  {
    956                      return kStatus_SDSPI_Failed;
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xE03B             B        ??SDSPI_DRV_WriteBlocks_1
    957                  }
    958          
    959                  if (SDSPI_DRV_Write(buffer, card->blockSize, SDMMC_SPI_DT_START_SINGLE_BLK) != card->blockSize)
   \                     ??SDSPI_DRV_WriteBlocks_5: (+1)
   \   00000050   0x22FE             MOVS     R2,#+254
   \   00000052   0x6C31             LDR      R1,[R6, #+64]
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       SDSPI_DRV_Write
   \   0000005A   0x6C31             LDR      R1,[R6, #+64]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD032             BEQ      ??SDSPI_DRV_WriteBlocks_6
    960                  {
    961                      return kStatus_SDSPI_Failed;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xE031             B        ??SDSPI_DRV_WriteBlocks_1
    962                  }
    963              }
    964              else
    965              {
    966                  memset(&req, 0, sizeof(sdspi_request_t));
   \                     ??SDSPI_DRV_WriteBlocks_3: (+1)
   \   00000064   0x2218             MOVS     R2,#+24
   \   00000066   0x2100             MOVS     R1,#+0
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x.... 0x....      BL       memset
    967                  req.cmdIndex = kWriteMultipleBlock;
   \   0000006E   0x2019             MOVS     R0,#+25
   \   00000070   0x4669             MOV      R1,SP
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    968                  req.argument = offset;
   \   00000074   0x9401             STR      R4,[SP, #+4]
    969                  req.respType = kSdSpiRespTypeR1;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x4669             MOV      R1,SP
   \   0000007A   0x7208             STRB     R0,[R1, #+8]
    970          
    971                  if (kStatus_SDSPI_NoError != SDSPI_DRV_SendCommand(&req, SDSPI_TIMEOUT))
   \   0000007C   0x21FA             MOVS     R1,#+250
   \   0000007E   0x00C9             LSLS     R1,R1,#+3        ;; #+2000
   \   00000080   0x4668             MOV      R0,SP
   \   00000082   0x.... 0x....      BL       SDSPI_DRV_SendCommand
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD001             BEQ      ??SDSPI_DRV_WriteBlocks_7
    972                  {
    973                      return kStatus_SDSPI_Failed;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0xE01C             B        ??SDSPI_DRV_WriteBlocks_1
    974                  }
    975                  if (req.response[0])
   \                     ??SDSPI_DRV_WriteBlocks_7: (+1)
   \   0000008E   0x4668             MOV      R0,SP
   \   00000090   0x7A40             LDRB     R0,[R0, #+9]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD001             BEQ      ??SDSPI_DRV_WriteBlocks_8
    976                  {
    977                      return kStatus_SDSPI_Failed;
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0xE016             B        ??SDSPI_DRV_WriteBlocks_1
    978                  }
    979          
    980                  for (i = 0; i < blockCount; i++)
   \                     ??SDSPI_DRV_WriteBlocks_8: (+1)
   \   0000009A   0x2400             MOVS     R4,#+0
   \   0000009C   0xE002             B        ??SDSPI_DRV_WriteBlocks_9
    981                  {
    982                      if (SDSPI_DRV_Write(buffer, card->blockSize, SDMMC_SPI_DT_START_MULTI_BLK) != card->blockSize)
    983                      {
    984                          return kStatus_SDSPI_Failed;
    985                      }
    986                      buffer += card->blockSize;
   \                     ??SDSPI_DRV_WriteBlocks_10: (+1)
   \   0000009E   0x6C30             LDR      R0,[R6, #+64]
   \   000000A0   0x182D             ADDS     R5,R5,R0
   \   000000A2   0x1C64             ADDS     R4,R4,#+1
   \                     ??SDSPI_DRV_WriteBlocks_9: (+1)
   \   000000A4   0x42BC             CMP      R4,R7
   \   000000A6   0xD209             BCS      ??SDSPI_DRV_WriteBlocks_11
   \   000000A8   0x22FC             MOVS     R2,#+252
   \   000000AA   0x6C31             LDR      R1,[R6, #+64]
   \   000000AC   0x0028             MOVS     R0,R5
   \   000000AE   0x.... 0x....      BL       SDSPI_DRV_Write
   \   000000B2   0x6C31             LDR      R1,[R6, #+64]
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD0F2             BEQ      ??SDSPI_DRV_WriteBlocks_10
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0xE005             B        ??SDSPI_DRV_WriteBlocks_1
    987                  }
    988          
    989                  SDSPI_DRV_Write(0, 0, SDMMC_SPI_DT_STOP_TRANSFER);
   \                     ??SDSPI_DRV_WriteBlocks_11: (+1)
   \   000000BC   0x22FD             MOVS     R2,#+253
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       SDSPI_DRV_Write
    990          
    991              }
    992          
    993              return kStatus_SDSPI_NoError;
   \                     ??SDSPI_DRV_WriteBlocks_6: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_WriteBlocks_1: (+1)
   \   000000C8   0xB007             ADD      SP,SP,#+28
   \   000000CA   0xBDF0             POP      {R4-R7,PC}       ;; return
    994          }
    995          
    996          /*FUNCTION****************************************************************
    997           *
    998           * Function Name: SDSPI_DRV_CheckReadOnly
    999           * Description: check if card is read only
   1000           *
   1001           *END*********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1002          unsigned int SDSPI_DRV_CheckReadOnly( sdspi_card_t *card)
   1003          {
   \                     SDSPI_DRV_CheckReadOnly: (+1)
   \   00000000   0xB500             PUSH     {LR}
   1004              card->state &= ~SDSPI_STATE_WRITE_PROTECTED;
   \   00000002   0x6881             LDR      R1,[R0, #+8]
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x4391             BICS     R1,R1,R2
   \   00000008   0x6081             STR      R1,[R0, #+8]
   1005              if (card->cardType != kCardTypeSd)
   \   0000000A   0x7B01             LDRB     R1,[R0, #+12]
   \   0000000C   0x2902             CMP      R1,#+2
   \   0000000E   0xD001             BEQ      ??SDSPI_DRV_CheckReadOnly_0
   1006              {
   1007                  return FALSE;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE00A             B        ??SDSPI_DRV_CheckReadOnly_1
   1008              }
   1009          
   1010              if (SD_CSD_PERM_WRITEPROTECT(card->rawCsd) || SD_CSD_TEMP_WRITEPROTECT(card->rawCsd))
   \                     ??SDSPI_DRV_CheckReadOnly_0: (+1)
   \   00000014   0x7EC1             LDRB     R1,[R0, #+27]
   \   00000016   0x2230             MOVS     R2,#+48
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD005             BEQ      ??SDSPI_DRV_CheckReadOnly_2
   1011              {
   1012                  card->state |= SDSPI_STATE_WRITE_PROTECTED;
   \   0000001C   0x6881             LDR      R1,[R0, #+8]
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x430A             ORRS     R2,R2,R1
   \   00000022   0x6082             STR      R2,[R0, #+8]
   1013                  return TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE000             B        ??SDSPI_DRV_CheckReadOnly_1
   1014              }
   1015          
   1016              return FALSE;
   \                     ??SDSPI_DRV_CheckReadOnly_2: (+1)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??SDSPI_DRV_CheckReadOnly_1: (+1)
   \   0000002A   0xBD00             POP      {PC}             ;; return
   1017          }
   1018          

   \                                 In section .text, align 2, keep-with-next
   1019          void SDSPI_DRV_Shutdown(sdspi_card_t *card)
   1020          {
   \                     SDSPI_DRV_Shutdown: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1021          
   1022              memset(card, 0, sizeof(sdspi_card_t));
   \   00000002   0x2244             MOVS     R2,#+68
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       memset
   1023              return;
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   1024          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     g_card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ??crcTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x0000EA60         DC32     0xea60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x00000BB9         DC32     0xbb9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x00007531         DC32     0x7531

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     g_transpeedtv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     g_transpeedru

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   SDCardInit
         8   -> SDSPI_DRV_Init
         8   -> memset
       8   SDGetCapacity
         8   -> SDSPI_DRV_CheckCapacity
      40   SDSPI_DRV_AppSendOpCond
        40   -> SDSPI_DRV_SendApplicationCmd
        40   -> SDSPI_DRV_SendCommand
       8   SDSPI_DRV_CheckCapacity
       4   SDSPI_DRV_CheckReadOnly
       8   SDSPI_DRV_GenerateCRC7
      40   SDSPI_DRV_GoIdle
        40   -> SDSPI_DRV_SendCommand
        40   -> SpiSendByte
      40   SDSPI_DRV_Init
        40   -> SDSPI_DRV_AppSendOpCond
        40   -> SDSPI_DRV_GoIdle
        40   -> SDSPI_DRV_InitSd
        40   -> SDSPI_DRV_ReadOcr
        40   -> SDSPI_DRV_SendIfCond
        40   -> SDSPI_DRV_SetBlockSize
        40   -> SPI_Init
       8   SDSPI_DRV_InitSd
         8   -> SDSPI_DRV_CheckCapacity
         8   -> SDSPI_DRV_CheckReadOnly
         8   -> SDSPI_DRV_SendCid
         8   -> SDSPI_DRV_SendCsd
         8   -> SpiHighRate
      24   SDSPI_DRV_Read
        24   -> SpiCsHigh
        24   -> SpiCsLow
        24   -> SpiSendByte
      48   SDSPI_DRV_ReadBlocks
        48   -> SDSPI_DRV_Read
        48   -> SDSPI_DRV_SendCommand
        48   -> SDSPI_DRV_StopTransmission
      40   SDSPI_DRV_ReadOcr
        40   -> SDSPI_DRV_SendCommand
      32   SDSPI_DRV_SendApplicationCmd
        32   -> SDSPI_DRV_SendCommand
      32   SDSPI_DRV_SendCid
        32   -> SDSPI_DRV_Read
        32   -> SDSPI_DRV_SendCommand_NoDeassert
      32   SDSPI_DRV_SendCommand
        32   -> SDSPI_DRV_GenerateCRC7
        32   -> SDSPI_DRV_WaitReady
        32   -> SpiCsHigh
        32   -> SpiCsLow
        32   -> SpiSendByte
        32   -> SpiSendFrame
      32   SDSPI_DRV_SendCommand_NoDeassert
        32   -> SDSPI_DRV_GenerateCRC7
        32   -> SDSPI_DRV_WaitReady
        32   -> SpiCsHigh
        32   -> SpiCsLow
        32   -> SpiSendByte
        32   -> SpiSendFrame
      32   SDSPI_DRV_SendCsd
        32   -> SDSPI_DRV_Read
        32   -> SDSPI_DRV_SendCommand_NoDeassert
      32   SDSPI_DRV_SendIfCond
        32   -> SDSPI_DRV_SendCommand
      32   SDSPI_DRV_SetBlockSize
        32   -> SDSPI_DRV_SendCommand
       8   SDSPI_DRV_Shutdown
         8   -> memset
      32   SDSPI_DRV_StopTransmission
        32   -> SDSPI_DRV_SendCommand
       8   SDSPI_DRV_WaitReady
         8   -> SpiSendByte
      24   SDSPI_DRV_Write
        24   -> SDSPI_DRV_WaitReady
        24   -> SpiCsHigh
        24   -> SpiCsLow
        24   -> SpiSendByte
        24   -> SpiSendFrame
      48   SDSPI_DRV_WriteBlocks
        48   -> SDSPI_DRV_SendCommand
        48   -> SDSPI_DRV_Write
        48   -> memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
      30  SDCardInit
      14  SDGetCapacity
     116  SDSPI_DRV_AppSendOpCond
     138  SDSPI_DRV_CheckCapacity
      44  SDSPI_DRV_CheckReadOnly
      68  SDSPI_DRV_GenerateCRC7
      86  SDSPI_DRV_GoIdle
     240  SDSPI_DRV_Init
      84  SDSPI_DRV_InitSd
      86  SDSPI_DRV_Read
     140  SDSPI_DRV_ReadBlocks
      92  SDSPI_DRV_ReadOcr
      60  SDSPI_DRV_SendApplicationCmd
      60  SDSPI_DRV_SendCid
     272  SDSPI_DRV_SendCommand
     268  SDSPI_DRV_SendCommand_NoDeassert
      60  SDSPI_DRV_SendCsd
      78  SDSPI_DRV_SendIfCond
      42  SDSPI_DRV_SetBlockSize
      12  SDSPI_DRV_Shutdown
      40  SDSPI_DRV_StopTransmission
      44  SDSPI_DRV_WaitReady
     130  SDSPI_DRV_Write
     204  SDSPI_DRV_WriteBlocks
      16  crcTable
      68  g_card
      16  g_transpeedru
      64  g_transpeedtv

 
    68 bytes in section .bss
    96 bytes in section .rodata
 2 440 bytes in section .text
 
 2 440 bytes of CODE  memory
    96 bytes of CONST memory
    68 bytes of DATA  memory

Errors: none
Warnings: 2
